#  Stripe API
#
# The Stripe REST API. Please see https://stripe.com/docs/api for more details.
#
# The version of the OpenAPI document: 2020-08-27
# Contact: dev-platform@stripe.com
# Generated by: https://openapi-generator.tech
#

require "nason"
require "time"
require "log"

module Stripe
  # You can store multiple cards on a customer in order to charge the customer later. You can also store multiple debit cards on a recipient in order to transfer to those cards later.  Related guide: [Card Payments with Sources](https://stripe.com/docs/sources/cards).
  class Card
    include NASON::Serializable

    # Required properties
    # Card brand. Can be `American Express`, `Diners Club`, `Discover`, `JCB`, `MasterCard`, `UnionPay`, `Visa`, or `Unknown`.
    @[NASON::Field(key: "brand", type: String)]
    property brand : String

    # Two-digit number representing the card's expiration month.
    @[NASON::Field(key: "exp_month", type: Int64)]
    property exp_month : Int64

    # Four-digit number representing the card's expiration year.
    @[NASON::Field(key: "exp_year", type: Int64)]
    property exp_year : Int64

    # Card funding type. Can be `credit`, `debit`, `prepaid`, or `unknown`.
    @[NASON::Field(key: "funding", type: String)]
    property funding : String

    # Unique identifier for the object.
    @[NASON::Field(key: "id", type: String)]
    property id : String

    # The last four digits of the card.
    @[NASON::Field(key: "last4", type: String)]
    property last4 : String

    # String representing the object's type. Objects of the same type share the same value.
    @[NASON::Field(key: "object", type: String)]
    property object : String

    # Optional properties
    # The account this card belongs to. This attribute will not be in the card object if the card belongs to a customer or recipient instead.
    @[NASON::Field(key: "account", type: String | Account? | Null, nillable: true)]
    property account : String | Account? | Null

    # City/District/Suburb/Town/Village.
    @[NASON::Field(key: "address_city", type: String? | Null, nillable: true)]
    property address_city : String? | Null

    # Billing address country, if provided when creating card.
    @[NASON::Field(key: "address_country", type: String? | Null, nillable: true)]
    property address_country : String? | Null

    # Address line 1 (Street address/PO Box/Company name).
    @[NASON::Field(key: "address_line1", type: String? | Null, nillable: true)]
    property address_line1 : String? | Null

    # If `address_line1` was provided, results of the check: `pass`, `fail`, `unavailable`, or `unchecked`.
    @[NASON::Field(key: "address_line1_check", type: String? | Null, nillable: true)]
    property address_line1_check : String? | Null

    # Address line 2 (Apartment/Suite/Unit/Building).
    @[NASON::Field(key: "address_line2", type: String? | Null, nillable: true)]
    property address_line2 : String? | Null

    # State/County/Province/Region.
    @[NASON::Field(key: "address_state", type: String? | Null, nillable: true)]
    property address_state : String? | Null

    # ZIP or postal code.
    @[NASON::Field(key: "address_zip", type: String? | Null, nillable: true)]
    property address_zip : String? | Null

    # If `address_zip` was provided, results of the check: `pass`, `fail`, `unavailable`, or `unchecked`.
    @[NASON::Field(key: "address_zip_check", type: String? | Null, nillable: true)]
    property address_zip_check : String? | Null

    # A set of available payout methods for this card. Only values from this set should be passed as the `method` when creating a payout.
    @[NASON::Field(key: "available_payout_methods", type: Array(String)? | Null, nillable: true)]
    property available_payout_methods : Array(String)? | Null

    # Two-letter ISO code representing the country of the card. You could use this attribute to get a sense of the international breakdown of cards you've collected.
    @[NASON::Field(key: "country", type: String? | Null, nillable: true)]
    property country : String? | Null

    # Three-letter [ISO code for currency](https://stripe.com/docs/payouts). Only applicable on accounts (not customers or recipients). The card can be used as a transfer destination for funds in this currency.
    @[NASON::Field(key: "currency", type: String? | Null, nillable: true)]
    property currency : String? | Null

    # The customer that this card belongs to. This attribute will not be in the card object if the card belongs to an account or recipient instead.
    @[NASON::Field(key: "customer", type: String | Customer | Nil | Null, nillable: true)]
    property customer : String | Customer | Nil | Null

    # If a CVC was provided, results of the check: `pass`, `fail`, `unavailable`, or `unchecked`. A result of unchecked indicates that CVC was provided but hasn't been checked yet. Checks are typically performed when attaching a card to a Customer object, or when creating a charge. For more details, see [Check if a card is valid without a charge](https://support.stripe.com/questions/check-if-a-card-is-valid-without-a-charge).
    @[NASON::Field(key: "cvc_check", type: String? | Null, nillable: true)]
    property cvc_check : String? | Null

    # Whether this card is the default external account for its currency.
    @[NASON::Field(key: "default_for_currency", type: Bool? | Null, nillable: true)]
    property default_for_currency : Bool? | Null

    # (For tokenized numbers only.) The last four digits of the device account number.
    @[NASON::Field(key: "dynamic_last4", type: String? | Null, nillable: true)]
    property dynamic_last4 : String? | Null

    # Uniquely identifies this particular card number. You can use this attribute to check whether two customers whoâ€™ve signed up with you are using the same card number, for example. For payment methods that tokenize card information (Apple Pay, Google Pay), the tokenized number might be provided instead of the underlying card number.  *Starting May 1, 2021, card fingerprint in India for Connect will change to allow two fingerprints for the same card --- one for India and one for the rest of the world.*
    @[NASON::Field(key: "fingerprint", type: String? | Null, nillable: true)]
    property fingerprint : String? | Null

    # Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    @[NASON::Field(key: "metadata", type: Hash(String, String)? | Null, nillable: true)]
    property metadata : Hash(String, String)? | Null

    # Cardholder name.
    @[NASON::Field(key: "name", type: String? | Null, nillable: true)]
    property name : String? | Null

    # The recipient that this card belongs to. This attribute will not be in the card object if the card belongs to a customer or account instead.
    @[NASON::Field(key: "recipient", type: String | Recipient? | Null, nillable: true)]
    property recipient : String | Recipient? | Null

    # If the card number is tokenized, this is the method that was used. Can be `android_pay` (includes Google Pay), `apple_pay`, `masterpass`, `visa_checkout`, or null.
    @[NASON::Field(key: "tokenization_method", type: String? | Null, nillable: true)]
    property tokenization_method : String? | Null

    class EnumAttributeValidator
      getter datatype : String
      getter allowable_values : Array(String | Int64 | Float64)

      def initialize(datatype, allowable_values)
        @datatype = datatype
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        value.nil? || value.null? || allowable_values.includes?(value)
      end
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(*, @brand : String, @exp_month : Int64, @exp_year : Int64, @funding : String, @id : String, @last4 : String, @object : String, @account : String | Account? | Null = nil, @address_city : String? | Null = nil, @address_country : String? | Null = nil, @address_line1 : String? | Null = nil, @address_line1_check : String? | Null = nil, @address_line2 : String? | Null = nil, @address_state : String? | Null = nil, @address_zip : String? | Null = nil, @address_zip_check : String? | Null = nil, @available_payout_methods : Array(String)? | Null = nil, @country : String? | Null = nil, @currency : String? | Null = nil, @customer : String | Customer | Nil | Null = nil, @cvc_check : String? | Null = nil, @default_for_currency : Bool? | Null = nil, @dynamic_last4 : String? | Null = nil, @fingerprint : String? | Null = nil, @metadata : Hash(String, String)? | Null = nil, @name : String? | Null = nil, @recipient : String | Recipient? | Null = nil, @tokenization_method : String? | Null = nil)
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array(String).new
      if !@address_city.nil? && !@address_city.null? && @address_city.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_city\", the character length must be smaller than or equal to 5000.")
      end

      if !@address_country.nil? && !@address_country.null? && @address_country.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_country\", the character length must be smaller than or equal to 5000.")
      end

      if !@address_line1.nil? && !@address_line1.null? && @address_line1.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_line1\", the character length must be smaller than or equal to 5000.")
      end

      if !@address_line1_check.nil? && !@address_line1_check.null? && @address_line1_check.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_line1_check\", the character length must be smaller than or equal to 5000.")
      end

      if !@address_line2.nil? && !@address_line2.null? && @address_line2.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_line2\", the character length must be smaller than or equal to 5000.")
      end

      if !@address_state.nil? && !@address_state.null? && @address_state.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_state\", the character length must be smaller than or equal to 5000.")
      end

      if !@address_zip.nil? && !@address_zip.null? && @address_zip.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_zip\", the character length must be smaller than or equal to 5000.")
      end

      if !@address_zip_check.nil? && !@address_zip_check.null? && @address_zip_check.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_zip_check\", the character length must be smaller than or equal to 5000.")
      end

      if @brand.to_s.size > 5000
        invalid_properties.push("invalid value for \"brand\", the character length must be smaller than or equal to 5000.")
      end

      if !@country.nil? && !@country.null? && @country.to_s.size > 5000
        invalid_properties.push("invalid value for \"country\", the character length must be smaller than or equal to 5000.")
      end

      if !@cvc_check.nil? && !@cvc_check.null? && @cvc_check.to_s.size > 5000
        invalid_properties.push("invalid value for \"cvc_check\", the character length must be smaller than or equal to 5000.")
      end

      if !@dynamic_last4.nil? && !@dynamic_last4.null? && @dynamic_last4.to_s.size > 5000
        invalid_properties.push("invalid value for \"dynamic_last4\", the character length must be smaller than or equal to 5000.")
      end

      if !@fingerprint.nil? && !@fingerprint.null? && @fingerprint.to_s.size > 5000
        invalid_properties.push("invalid value for \"fingerprint\", the character length must be smaller than or equal to 5000.")
      end

      if @funding.to_s.size > 5000
        invalid_properties.push("invalid value for \"funding\", the character length must be smaller than or equal to 5000.")
      end

      if @id.to_s.size > 5000
        invalid_properties.push("invalid value for \"id\", the character length must be smaller than or equal to 5000.")
      end

      if @last4.to_s.size > 5000
        invalid_properties.push("invalid value for \"last4\", the character length must be smaller than or equal to 5000.")
      end

      if !@name.nil? && !@name.null? && @name.to_s.size > 5000
        invalid_properties.push("invalid value for \"name\", the character length must be smaller than or equal to 5000.")
      end

      if !@tokenization_method.nil? && !@tokenization_method.null? && @tokenization_method.to_s.size > 5000
        invalid_properties.push("invalid value for \"tokenization_method\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if !@address_city.nil? && !@address_city.null? && @address_city.to_s.size > 5000
      return false if !@address_country.nil? && !@address_country.null? && @address_country.to_s.size > 5000
      return false if !@address_line1.nil? && !@address_line1.null? && @address_line1.to_s.size > 5000
      return false if !@address_line1_check.nil? && !@address_line1_check.null? && @address_line1_check.to_s.size > 5000
      return false if !@address_line2.nil? && !@address_line2.null? && @address_line2.to_s.size > 5000
      return false if !@address_state.nil? && !@address_state.null? && @address_state.to_s.size > 5000
      return false if !@address_zip.nil? && !@address_zip.null? && @address_zip.to_s.size > 5000
      return false if !@address_zip_check.nil? && !@address_zip_check.null? && @address_zip_check.to_s.size > 5000
      return false if @brand.to_s.size > 5000
      return false if !@country.nil? && !@country.null? && @country.to_s.size > 5000
      return false if !@cvc_check.nil? && !@cvc_check.null? && @cvc_check.to_s.size > 5000
      return false if !@dynamic_last4.nil? && !@dynamic_last4.null? && @dynamic_last4.to_s.size > 5000
      return false if !@fingerprint.nil? && !@fingerprint.null? && @fingerprint.to_s.size > 5000
      return false if @funding.to_s.size > 5000
      return false if @id.to_s.size > 5000
      return false if @last4.to_s.size > 5000
      return false if !@name.nil? && !@name.null? && @name.to_s.size > 5000
      object_validator = EnumAttributeValidator.new("String", ["card"])
      return false unless object_validator.valid?(@object)
      return false if !@tokenization_method.nil? && !@tokenization_method.null? && @tokenization_method.to_s.size > 5000
      true
    end

    # Custom attribute writer method with validation
    # @param [Object] address_city Value to be assigned
    def address_city=(address_city)
      if !address_city.nil? && !@address_city.null? && address_city.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_city\", the character length must be smaller than or equal to 5000.")
      end

      @address_city = address_city
    end

    # Custom attribute writer method with validation
    # @param [Object] address_country Value to be assigned
    def address_country=(address_country)
      if !address_country.nil? && !@address_country.null? && address_country.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_country\", the character length must be smaller than or equal to 5000.")
      end

      @address_country = address_country
    end

    # Custom attribute writer method with validation
    # @param [Object] address_line1 Value to be assigned
    def address_line1=(address_line1)
      if !address_line1.nil? && !@address_line1.null? && address_line1.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_line1\", the character length must be smaller than or equal to 5000.")
      end

      @address_line1 = address_line1
    end

    # Custom attribute writer method with validation
    # @param [Object] address_line1_check Value to be assigned
    def address_line1_check=(address_line1_check)
      if !address_line1_check.nil? && !@address_line1_check.null? && address_line1_check.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_line1_check\", the character length must be smaller than or equal to 5000.")
      end

      @address_line1_check = address_line1_check
    end

    # Custom attribute writer method with validation
    # @param [Object] address_line2 Value to be assigned
    def address_line2=(address_line2)
      if !address_line2.nil? && !@address_line2.null? && address_line2.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_line2\", the character length must be smaller than or equal to 5000.")
      end

      @address_line2 = address_line2
    end

    # Custom attribute writer method with validation
    # @param [Object] address_state Value to be assigned
    def address_state=(address_state)
      if !address_state.nil? && !@address_state.null? && address_state.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_state\", the character length must be smaller than or equal to 5000.")
      end

      @address_state = address_state
    end

    # Custom attribute writer method with validation
    # @param [Object] address_zip Value to be assigned
    def address_zip=(address_zip)
      if !address_zip.nil? && !@address_zip.null? && address_zip.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_zip\", the character length must be smaller than or equal to 5000.")
      end

      @address_zip = address_zip
    end

    # Custom attribute writer method with validation
    # @param [Object] address_zip_check Value to be assigned
    def address_zip_check=(address_zip_check)
      if !address_zip_check.nil? && !@address_zip_check.null? && address_zip_check.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_zip_check\", the character length must be smaller than or equal to 5000.")
      end

      @address_zip_check = address_zip_check
    end

    # Custom attribute writer method with validation
    # @param [Object] brand Value to be assigned
    def brand=(brand)
      if brand.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"brand\", the character length must be smaller than or equal to 5000.")
      end

      @brand = brand
    end

    # Custom attribute writer method with validation
    # @param [Object] country Value to be assigned
    def country=(country)
      if !country.nil? && !@country.null? && country.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"country\", the character length must be smaller than or equal to 5000.")
      end

      @country = country
    end

    # Custom attribute writer method with validation
    # @param [Object] cvc_check Value to be assigned
    def cvc_check=(cvc_check)
      if !cvc_check.nil? && !@cvc_check.null? && cvc_check.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"cvc_check\", the character length must be smaller than or equal to 5000.")
      end

      @cvc_check = cvc_check
    end

    # Custom attribute writer method with validation
    # @param [Object] dynamic_last4 Value to be assigned
    def dynamic_last4=(dynamic_last4)
      if !dynamic_last4.nil? && !@dynamic_last4.null? && dynamic_last4.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"dynamic_last4\", the character length must be smaller than or equal to 5000.")
      end

      @dynamic_last4 = dynamic_last4
    end

    # Custom attribute writer method with validation
    # @param [Object] fingerprint Value to be assigned
    def fingerprint=(fingerprint)
      if !fingerprint.nil? && !@fingerprint.null? && fingerprint.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"fingerprint\", the character length must be smaller than or equal to 5000.")
      end

      @fingerprint = fingerprint
    end

    # Custom attribute writer method with validation
    # @param [Object] funding Value to be assigned
    def funding=(funding)
      if funding.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"funding\", the character length must be smaller than or equal to 5000.")
      end

      @funding = funding
    end

    # Custom attribute writer method with validation
    # @param [Object] id Value to be assigned
    def id=(id)
      if id.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"id\", the character length must be smaller than or equal to 5000.")
      end

      @id = id
    end

    # Custom attribute writer method with validation
    # @param [Object] last4 Value to be assigned
    def last4=(last4)
      if last4.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"last4\", the character length must be smaller than or equal to 5000.")
      end

      @last4 = last4
    end

    # Custom attribute writer method with validation
    # @param [Object] name Value to be assigned
    def name=(name)
      if !name.nil? && !@name.null? && name.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"name\", the character length must be smaller than or equal to 5000.")
      end

      @name = name
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] object Object to be assigned
    def object=(object)
      validator = EnumAttributeValidator.new("String", ["card"])
      unless validator.valid?(object)
        raise ArgumentError.new("invalid value for \"object\", must be one of #{validator.allowable_values}.")
      end
      @object = object
    end

    # Custom attribute writer method with validation
    # @param [Object] tokenization_method Value to be assigned
    def tokenization_method=(tokenization_method)
      if !tokenization_method.nil? && !@tokenization_method.null? && tokenization_method.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"tokenization_method\", the character length must be smaller than or equal to 5000.")
      end

      @tokenization_method = tokenization_method
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.same?(o)
      self.class == o.class &&
        account == o.account &&
        address_city == o.address_city &&
        address_country == o.address_country &&
        address_line1 == o.address_line1 &&
        address_line1_check == o.address_line1_check &&
        address_line2 == o.address_line2 &&
        address_state == o.address_state &&
        address_zip == o.address_zip &&
        address_zip_check == o.address_zip_check &&
        available_payout_methods == o.available_payout_methods &&
        brand == o.brand &&
        country == o.country &&
        currency == o.currency &&
        customer == o.customer &&
        cvc_check == o.cvc_check &&
        default_for_currency == o.default_for_currency &&
        dynamic_last4 == o.dynamic_last4 &&
        exp_month == o.exp_month &&
        exp_year == o.exp_year &&
        fingerprint == o.fingerprint &&
        funding == o.funding &&
        id == o.id &&
        last4 == o.last4 &&
        metadata == o.metadata &&
        name == o.name &&
        object == o.object &&
        recipient == o.recipient &&
        tokenization_method == o.tokenization_method
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [account, address_city, address_country, address_line1, address_line1_check, address_line2, address_state, address_zip, address_zip_check, available_payout_methods, brand, country, currency, customer, cvc_check, default_for_currency, dynamic_last4, exp_month, exp_year, fingerprint, funding, id, last4, metadata, name, object, recipient, tokenization_method].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      new.build_from_hash(attributes)
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.openapi_types.each_pair do |key, type|
        if !attributes[self.class.attribute_map[key]]? && self.class.openapi_nullable.includes?(key)
          self.send("#{key}=", nil)
        elsif type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :Time
        Time.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        ({} of String => String).tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        # models (e.g. Pet) or oneOf
        klass = Stripe.const_get(type)
        klass.respond_to?(:openapi_one_of) ? klass.build(value) : klass.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {} of String => String
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.includes?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end

        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        ({} of String => String).tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
