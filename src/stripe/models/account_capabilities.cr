#  Stripe API
#
# The Stripe REST API. Please see https://stripe.com/docs/api for more details.
#
# The version of the OpenAPI document: 2020-08-27
# Contact: dev-platform@stripe.com
# Generated by: https://openapi-generator.tech
#

require "nason"
require "time"
require "log"

module Stripe
  class AccountCapabilities
    include NASON::Serializable

    # Optional properties
    # The status of the Canadian pre-authorized debits payments capability of the account, or whether the account can directly process Canadian pre-authorized debits charges.
    @[NASON::Field(key: "acss_debit_payments", type: String?, nillable: true)]
    property acss_debit_payments : String?

    # The status of the Afterpay Clearpay capability of the account, or whether the account can directly process Afterpay Clearpay charges.
    @[NASON::Field(key: "afterpay_clearpay_payments", type: String?, nillable: true)]
    property afterpay_clearpay_payments : String?

    # The status of the BECS Direct Debit (AU) payments capability of the account, or whether the account can directly process BECS Direct Debit (AU) charges.
    @[NASON::Field(key: "au_becs_debit_payments", type: String?, nillable: true)]
    property au_becs_debit_payments : String?

    # The status of the Bacs Direct Debits payments capability of the account, or whether the account can directly process Bacs Direct Debits charges.
    @[NASON::Field(key: "bacs_debit_payments", type: String?, nillable: true)]
    property bacs_debit_payments : String?

    # The status of the Bancontact payments capability of the account, or whether the account can directly process Bancontact charges.
    @[NASON::Field(key: "bancontact_payments", type: String?, nillable: true)]
    property bancontact_payments : String?

    # The status of the boleto payments capability of the account, or whether the account can directly process boleto charges.
    @[NASON::Field(key: "boleto_payments", type: String?, nillable: true)]
    property boleto_payments : String?

    # The status of the card issuing capability of the account, or whether you can use Issuing to distribute funds on cards
    @[NASON::Field(key: "card_issuing", type: String?, nillable: true)]
    property card_issuing : String?

    # The status of the card payments capability of the account, or whether the account can directly process credit and debit card charges.
    @[NASON::Field(key: "card_payments", type: String?, nillable: true)]
    property card_payments : String?

    # The status of the Cartes Bancaires payments capability of the account, or whether the account can directly process Cartes Bancaires card charges in EUR currency.
    @[NASON::Field(key: "cartes_bancaires_payments", type: String?, nillable: true)]
    property cartes_bancaires_payments : String?

    # The status of the EPS payments capability of the account, or whether the account can directly process EPS charges.
    @[NASON::Field(key: "eps_payments", type: String?, nillable: true)]
    property eps_payments : String?

    # The status of the FPX payments capability of the account, or whether the account can directly process FPX charges.
    @[NASON::Field(key: "fpx_payments", type: String?, nillable: true)]
    property fpx_payments : String?

    # The status of the giropay payments capability of the account, or whether the account can directly process giropay charges.
    @[NASON::Field(key: "giropay_payments", type: String?, nillable: true)]
    property giropay_payments : String?

    # The status of the GrabPay payments capability of the account, or whether the account can directly process GrabPay charges.
    @[NASON::Field(key: "grabpay_payments", type: String?, nillable: true)]
    property grabpay_payments : String?

    # The status of the iDEAL payments capability of the account, or whether the account can directly process iDEAL charges.
    @[NASON::Field(key: "ideal_payments", type: String?, nillable: true)]
    property ideal_payments : String?

    # The status of the JCB payments capability of the account, or whether the account (Japan only) can directly process JCB credit card charges in JPY currency.
    @[NASON::Field(key: "jcb_payments", type: String?, nillable: true)]
    property jcb_payments : String?

    # The status of the Klarna payments capability of the account, or whether the account can directly process Klarna charges.
    @[NASON::Field(key: "klarna_payments", type: String?, nillable: true)]
    property klarna_payments : String?

    # The status of the legacy payments capability of the account.
    @[NASON::Field(key: "legacy_payments", type: String?, nillable: true)]
    property legacy_payments : String?

    # The status of the OXXO payments capability of the account, or whether the account can directly process OXXO charges.
    @[NASON::Field(key: "oxxo_payments", type: String?, nillable: true)]
    property oxxo_payments : String?

    # The status of the P24 payments capability of the account, or whether the account can directly process P24 charges.
    @[NASON::Field(key: "p24_payments", type: String?, nillable: true)]
    property p24_payments : String?

    # The status of the SEPA Direct Debits payments capability of the account, or whether the account can directly process SEPA Direct Debits charges.
    @[NASON::Field(key: "sepa_debit_payments", type: String?, nillable: true)]
    property sepa_debit_payments : String?

    # The status of the Sofort payments capability of the account, or whether the account can directly process Sofort charges.
    @[NASON::Field(key: "sofort_payments", type: String?, nillable: true)]
    property sofort_payments : String?

    # The status of the tax reporting 1099-K (US) capability of the account.
    @[NASON::Field(key: "tax_reporting_us_1099_k", type: String?, nillable: true)]
    property tax_reporting_us_1099_k : String?

    # The status of the tax reporting 1099-MISC (US) capability of the account.
    @[NASON::Field(key: "tax_reporting_us_1099_misc", type: String?, nillable: true)]
    property tax_reporting_us_1099_misc : String?

    # The status of the transfers capability of the account, or whether your platform can transfer funds to the account.
    @[NASON::Field(key: "transfers", type: String?, nillable: true)]
    property transfers : String?

    class EnumAttributeValidator
      getter datatype : String
      getter allowable_values : Array(String | Int64 | Float64)

      def initialize(datatype, allowable_values)
        @datatype = datatype
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        value.nil? || value.null? || allowable_values.includes?(value)
      end
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(*, @acss_debit_payments : String? = nil, @afterpay_clearpay_payments : String? = nil, @au_becs_debit_payments : String? = nil, @bacs_debit_payments : String? = nil, @bancontact_payments : String? = nil, @boleto_payments : String? = nil, @card_issuing : String? = nil, @card_payments : String? = nil, @cartes_bancaires_payments : String? = nil, @eps_payments : String? = nil, @fpx_payments : String? = nil, @giropay_payments : String? = nil, @grabpay_payments : String? = nil, @ideal_payments : String? = nil, @jcb_payments : String? = nil, @klarna_payments : String? = nil, @legacy_payments : String? = nil, @oxxo_payments : String? = nil, @p24_payments : String? = nil, @sepa_debit_payments : String? = nil, @sofort_payments : String? = nil, @tax_reporting_us_1099_k : String? = nil, @tax_reporting_us_1099_misc : String? = nil, @transfers : String? = nil)
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array(String).new
      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      acss_debit_payments_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless acss_debit_payments_validator.valid?(@acss_debit_payments)
      afterpay_clearpay_payments_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless afterpay_clearpay_payments_validator.valid?(@afterpay_clearpay_payments)
      au_becs_debit_payments_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless au_becs_debit_payments_validator.valid?(@au_becs_debit_payments)
      bacs_debit_payments_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless bacs_debit_payments_validator.valid?(@bacs_debit_payments)
      bancontact_payments_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless bancontact_payments_validator.valid?(@bancontact_payments)
      boleto_payments_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless boleto_payments_validator.valid?(@boleto_payments)
      card_issuing_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless card_issuing_validator.valid?(@card_issuing)
      card_payments_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless card_payments_validator.valid?(@card_payments)
      cartes_bancaires_payments_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless cartes_bancaires_payments_validator.valid?(@cartes_bancaires_payments)
      eps_payments_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless eps_payments_validator.valid?(@eps_payments)
      fpx_payments_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless fpx_payments_validator.valid?(@fpx_payments)
      giropay_payments_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless giropay_payments_validator.valid?(@giropay_payments)
      grabpay_payments_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless grabpay_payments_validator.valid?(@grabpay_payments)
      ideal_payments_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless ideal_payments_validator.valid?(@ideal_payments)
      jcb_payments_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless jcb_payments_validator.valid?(@jcb_payments)
      klarna_payments_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless klarna_payments_validator.valid?(@klarna_payments)
      legacy_payments_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless legacy_payments_validator.valid?(@legacy_payments)
      oxxo_payments_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless oxxo_payments_validator.valid?(@oxxo_payments)
      p24_payments_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless p24_payments_validator.valid?(@p24_payments)
      sepa_debit_payments_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless sepa_debit_payments_validator.valid?(@sepa_debit_payments)
      sofort_payments_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless sofort_payments_validator.valid?(@sofort_payments)
      tax_reporting_us_1099_k_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless tax_reporting_us_1099_k_validator.valid?(@tax_reporting_us_1099_k)
      tax_reporting_us_1099_misc_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless tax_reporting_us_1099_misc_validator.valid?(@tax_reporting_us_1099_misc)
      transfers_validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      return false unless transfers_validator.valid?(@transfers)
      true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] acss_debit_payments Object to be assigned
    def acss_debit_payments=(acss_debit_payments)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(acss_debit_payments)
        raise ArgumentError.new("invalid value for \"acss_debit_payments\", must be one of #{validator.allowable_values}.")
      end
      @acss_debit_payments = acss_debit_payments
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] afterpay_clearpay_payments Object to be assigned
    def afterpay_clearpay_payments=(afterpay_clearpay_payments)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(afterpay_clearpay_payments)
        raise ArgumentError.new("invalid value for \"afterpay_clearpay_payments\", must be one of #{validator.allowable_values}.")
      end
      @afterpay_clearpay_payments = afterpay_clearpay_payments
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] au_becs_debit_payments Object to be assigned
    def au_becs_debit_payments=(au_becs_debit_payments)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(au_becs_debit_payments)
        raise ArgumentError.new("invalid value for \"au_becs_debit_payments\", must be one of #{validator.allowable_values}.")
      end
      @au_becs_debit_payments = au_becs_debit_payments
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] bacs_debit_payments Object to be assigned
    def bacs_debit_payments=(bacs_debit_payments)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(bacs_debit_payments)
        raise ArgumentError.new("invalid value for \"bacs_debit_payments\", must be one of #{validator.allowable_values}.")
      end
      @bacs_debit_payments = bacs_debit_payments
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] bancontact_payments Object to be assigned
    def bancontact_payments=(bancontact_payments)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(bancontact_payments)
        raise ArgumentError.new("invalid value for \"bancontact_payments\", must be one of #{validator.allowable_values}.")
      end
      @bancontact_payments = bancontact_payments
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] boleto_payments Object to be assigned
    def boleto_payments=(boleto_payments)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(boleto_payments)
        raise ArgumentError.new("invalid value for \"boleto_payments\", must be one of #{validator.allowable_values}.")
      end
      @boleto_payments = boleto_payments
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] card_issuing Object to be assigned
    def card_issuing=(card_issuing)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(card_issuing)
        raise ArgumentError.new("invalid value for \"card_issuing\", must be one of #{validator.allowable_values}.")
      end
      @card_issuing = card_issuing
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] card_payments Object to be assigned
    def card_payments=(card_payments)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(card_payments)
        raise ArgumentError.new("invalid value for \"card_payments\", must be one of #{validator.allowable_values}.")
      end
      @card_payments = card_payments
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] cartes_bancaires_payments Object to be assigned
    def cartes_bancaires_payments=(cartes_bancaires_payments)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(cartes_bancaires_payments)
        raise ArgumentError.new("invalid value for \"cartes_bancaires_payments\", must be one of #{validator.allowable_values}.")
      end
      @cartes_bancaires_payments = cartes_bancaires_payments
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] eps_payments Object to be assigned
    def eps_payments=(eps_payments)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(eps_payments)
        raise ArgumentError.new("invalid value for \"eps_payments\", must be one of #{validator.allowable_values}.")
      end
      @eps_payments = eps_payments
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] fpx_payments Object to be assigned
    def fpx_payments=(fpx_payments)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(fpx_payments)
        raise ArgumentError.new("invalid value for \"fpx_payments\", must be one of #{validator.allowable_values}.")
      end
      @fpx_payments = fpx_payments
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] giropay_payments Object to be assigned
    def giropay_payments=(giropay_payments)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(giropay_payments)
        raise ArgumentError.new("invalid value for \"giropay_payments\", must be one of #{validator.allowable_values}.")
      end
      @giropay_payments = giropay_payments
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] grabpay_payments Object to be assigned
    def grabpay_payments=(grabpay_payments)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(grabpay_payments)
        raise ArgumentError.new("invalid value for \"grabpay_payments\", must be one of #{validator.allowable_values}.")
      end
      @grabpay_payments = grabpay_payments
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] ideal_payments Object to be assigned
    def ideal_payments=(ideal_payments)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(ideal_payments)
        raise ArgumentError.new("invalid value for \"ideal_payments\", must be one of #{validator.allowable_values}.")
      end
      @ideal_payments = ideal_payments
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] jcb_payments Object to be assigned
    def jcb_payments=(jcb_payments)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(jcb_payments)
        raise ArgumentError.new("invalid value for \"jcb_payments\", must be one of #{validator.allowable_values}.")
      end
      @jcb_payments = jcb_payments
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] klarna_payments Object to be assigned
    def klarna_payments=(klarna_payments)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(klarna_payments)
        raise ArgumentError.new("invalid value for \"klarna_payments\", must be one of #{validator.allowable_values}.")
      end
      @klarna_payments = klarna_payments
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] legacy_payments Object to be assigned
    def legacy_payments=(legacy_payments)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(legacy_payments)
        raise ArgumentError.new("invalid value for \"legacy_payments\", must be one of #{validator.allowable_values}.")
      end
      @legacy_payments = legacy_payments
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] oxxo_payments Object to be assigned
    def oxxo_payments=(oxxo_payments)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(oxxo_payments)
        raise ArgumentError.new("invalid value for \"oxxo_payments\", must be one of #{validator.allowable_values}.")
      end
      @oxxo_payments = oxxo_payments
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] p24_payments Object to be assigned
    def p24_payments=(p24_payments)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(p24_payments)
        raise ArgumentError.new("invalid value for \"p24_payments\", must be one of #{validator.allowable_values}.")
      end
      @p24_payments = p24_payments
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] sepa_debit_payments Object to be assigned
    def sepa_debit_payments=(sepa_debit_payments)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(sepa_debit_payments)
        raise ArgumentError.new("invalid value for \"sepa_debit_payments\", must be one of #{validator.allowable_values}.")
      end
      @sepa_debit_payments = sepa_debit_payments
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] sofort_payments Object to be assigned
    def sofort_payments=(sofort_payments)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(sofort_payments)
        raise ArgumentError.new("invalid value for \"sofort_payments\", must be one of #{validator.allowable_values}.")
      end
      @sofort_payments = sofort_payments
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] tax_reporting_us_1099_k Object to be assigned
    def tax_reporting_us_1099_k=(tax_reporting_us_1099_k)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(tax_reporting_us_1099_k)
        raise ArgumentError.new("invalid value for \"tax_reporting_us_1099_k\", must be one of #{validator.allowable_values}.")
      end
      @tax_reporting_us_1099_k = tax_reporting_us_1099_k
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] tax_reporting_us_1099_misc Object to be assigned
    def tax_reporting_us_1099_misc=(tax_reporting_us_1099_misc)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(tax_reporting_us_1099_misc)
        raise ArgumentError.new("invalid value for \"tax_reporting_us_1099_misc\", must be one of #{validator.allowable_values}.")
      end
      @tax_reporting_us_1099_misc = tax_reporting_us_1099_misc
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] transfers Object to be assigned
    def transfers=(transfers)
      validator = EnumAttributeValidator.new("String", ["active", "inactive", "pending"])
      unless validator.valid?(transfers)
        raise ArgumentError.new("invalid value for \"transfers\", must be one of #{validator.allowable_values}.")
      end
      @transfers = transfers
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.same?(o)
      self.class == o.class &&
        acss_debit_payments == o.acss_debit_payments &&
        afterpay_clearpay_payments == o.afterpay_clearpay_payments &&
        au_becs_debit_payments == o.au_becs_debit_payments &&
        bacs_debit_payments == o.bacs_debit_payments &&
        bancontact_payments == o.bancontact_payments &&
        boleto_payments == o.boleto_payments &&
        card_issuing == o.card_issuing &&
        card_payments == o.card_payments &&
        cartes_bancaires_payments == o.cartes_bancaires_payments &&
        eps_payments == o.eps_payments &&
        fpx_payments == o.fpx_payments &&
        giropay_payments == o.giropay_payments &&
        grabpay_payments == o.grabpay_payments &&
        ideal_payments == o.ideal_payments &&
        jcb_payments == o.jcb_payments &&
        klarna_payments == o.klarna_payments &&
        legacy_payments == o.legacy_payments &&
        oxxo_payments == o.oxxo_payments &&
        p24_payments == o.p24_payments &&
        sepa_debit_payments == o.sepa_debit_payments &&
        sofort_payments == o.sofort_payments &&
        tax_reporting_us_1099_k == o.tax_reporting_us_1099_k &&
        tax_reporting_us_1099_misc == o.tax_reporting_us_1099_misc &&
        transfers == o.transfers
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [acss_debit_payments, afterpay_clearpay_payments, au_becs_debit_payments, bacs_debit_payments, bancontact_payments, boleto_payments, card_issuing, card_payments, cartes_bancaires_payments, eps_payments, fpx_payments, giropay_payments, grabpay_payments, ideal_payments, jcb_payments, klarna_payments, legacy_payments, oxxo_payments, p24_payments, sepa_debit_payments, sofort_payments, tax_reporting_us_1099_k, tax_reporting_us_1099_misc, transfers].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      new.build_from_hash(attributes)
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.openapi_types.each_pair do |key, type|
        if !attributes[self.class.attribute_map[key]]? && self.class.openapi_nullable.includes?(key)
          self.send("#{key}=", nil)
        elsif type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :Time
        Time.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        ({} of String => String).tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        # models (e.g. Pet) or oneOf
        klass = Stripe.const_get(type)
        klass.respond_to?(:openapi_one_of) ? klass.build(value) : klass.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {} of String => String
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.includes?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end

        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        ({} of String => String).tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
