#  Stripe API
#
# The Stripe REST API. Please see https://stripe.com/docs/api for more details.
#
# The version of the OpenAPI document: 2020-08-27
# Contact: dev-platform@stripe.com
# Generated by: https://openapi-generator.tech
#

require "json"
require "time"
require "log"

module Stripe
  @[JSON::Serializable::Options(emit_nulls: true)]
  class PostCustomersCustomerSourcesId200Response
    include JSON::Serializable
    include JSON::Serializable::Unmapped

    # Required properties
    # City/District/Suburb/Town/Village.
    @[JSON::Field(key: "address_city", type: String, presence: true, ignore_serialize: address_city.nil? && !address_city_present?)]
    getter address_city : String

    @[JSON::Field(ignore: true)]
    property? address_city_present : Bool = false

    # Billing address country, if provided when creating card.
    @[JSON::Field(key: "address_country", type: String, presence: true, ignore_serialize: address_country.nil? && !address_country_present?)]
    getter address_country : String

    @[JSON::Field(ignore: true)]
    property? address_country_present : Bool = false

    # Address line 1 (Street address/PO Box/Company name).
    @[JSON::Field(key: "address_line1", type: String, presence: true, ignore_serialize: address_line1.nil? && !address_line1_present?)]
    getter address_line1 : String

    @[JSON::Field(ignore: true)]
    property? address_line1_present : Bool = false

    # If `address_line1` was provided, results of the check: `pass`, `fail`, `unavailable`, or `unchecked`.
    @[JSON::Field(key: "address_line1_check", type: String, presence: true, ignore_serialize: address_line1_check.nil? && !address_line1_check_present?)]
    getter address_line1_check : String

    @[JSON::Field(ignore: true)]
    property? address_line1_check_present : Bool = false

    # Address line 2 (Apartment/Suite/Unit/Building).
    @[JSON::Field(key: "address_line2", type: String, presence: true, ignore_serialize: address_line2.nil? && !address_line2_present?)]
    getter address_line2 : String

    @[JSON::Field(ignore: true)]
    property? address_line2_present : Bool = false

    # State/County/Province/Region.
    @[JSON::Field(key: "address_state", type: String, presence: true, ignore_serialize: address_state.nil? && !address_state_present?)]
    getter address_state : String

    @[JSON::Field(ignore: true)]
    property? address_state_present : Bool = false

    # ZIP or postal code.
    @[JSON::Field(key: "address_zip", type: String, presence: true, ignore_serialize: address_zip.nil? && !address_zip_present?)]
    getter address_zip : String

    @[JSON::Field(ignore: true)]
    property? address_zip_present : Bool = false

    # If `address_zip` was provided, results of the check: `pass`, `fail`, `unavailable`, or `unchecked`.
    @[JSON::Field(key: "address_zip_check", type: String, presence: true, ignore_serialize: address_zip_check.nil? && !address_zip_check_present?)]
    getter address_zip_check : String

    @[JSON::Field(ignore: true)]
    property? address_zip_check_present : Bool = false

    # Card brand. Can be `American Express`, `Diners Club`, `Discover`, `JCB`, `MasterCard`, `UnionPay`, `Visa`, or `Unknown`.
    @[JSON::Field(key: "brand", type: String?)]
    getter brand : String?

    # Two-letter ISO code representing the country the bank account is located in.
    @[JSON::Field(key: "country", type: String?)]
    getter country : String?

    # Three-letter [ISO code for the currency](https://stripe.com/docs/currencies) associated with the source. This is the currency for which the source will be chargeable once ready. Required for `single_use` sources.
    @[JSON::Field(key: "currency", type: String, presence: true, ignore_serialize: currency.nil? && !currency_present?)]
    property currency : String

    @[JSON::Field(ignore: true)]
    property? currency_present : Bool = false

    # If a CVC was provided, results of the check: `pass`, `fail`, `unavailable`, or `unchecked`. A result of unchecked indicates that CVC was provided but hasn't been checked yet. Checks are typically performed when attaching a card to a Customer object, or when creating a charge. For more details, see [Check if a card is valid without a charge](https://support.stripe.com/questions/check-if-a-card-is-valid-without-a-charge).
    @[JSON::Field(key: "cvc_check", type: String, presence: true, ignore_serialize: cvc_check.nil? && !cvc_check_present?)]
    getter cvc_check : String

    @[JSON::Field(ignore: true)]
    property? cvc_check_present : Bool = false

    # (For tokenized numbers only.) The last four digits of the device account number.
    @[JSON::Field(key: "dynamic_last4", type: String, presence: true, ignore_serialize: dynamic_last4.nil? && !dynamic_last4_present?)]
    getter dynamic_last4 : String

    @[JSON::Field(ignore: true)]
    property? dynamic_last4_present : Bool = false

    # Two-digit number representing the card's expiration month.
    @[JSON::Field(key: "exp_month", type: Int64?)]
    property exp_month : Int64?

    # Four-digit number representing the card's expiration year.
    @[JSON::Field(key: "exp_year", type: Int64?)]
    property exp_year : Int64?

    # Uniquely identifies this particular bank account. You can use this attribute to check whether two bank accounts are the same.
    @[JSON::Field(key: "fingerprint", type: String, presence: true, ignore_serialize: fingerprint.nil? && !fingerprint_present?)]
    getter fingerprint : String

    @[JSON::Field(ignore: true)]
    property? fingerprint_present : Bool = false

    # Card funding type. Can be `credit`, `debit`, `prepaid`, or `unknown`.
    @[JSON::Field(key: "funding", type: String?)]
    getter funding : String?

    # Unique identifier for the object.
    @[JSON::Field(key: "id", type: String?)]
    getter id : String?

    # The last four digits of the bank account number.
    @[JSON::Field(key: "last4", type: String?)]
    getter last4 : String?

    # Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    @[JSON::Field(key: "metadata", type: Hash(String, String), presence: true, ignore_serialize: metadata.nil? && !metadata_present?)]
    property metadata : Hash(String, String)

    @[JSON::Field(ignore: true)]
    property? metadata_present : Bool = false

    # Cardholder name.
    @[JSON::Field(key: "name", type: String, presence: true, ignore_serialize: name.nil? && !name_present?)]
    getter name : String

    @[JSON::Field(ignore: true)]
    property? name_present : Bool = false

    # String representing the object's type. Objects of the same type share the same value.
    @[JSON::Field(key: "object", type: String?)]
    getter object : String?

    ENUM_VALIDATOR_FOR_OBJECT = EnumValidator.new("object", "String", ["source"])

    # The status of the source, one of `canceled`, `chargeable`, `consumed`, `failed`, or `pending`. Only `chargeable` sources can be used to create a charge.
    @[JSON::Field(key: "status", type: String?)]
    getter status : String?

    # If the card number is tokenized, this is the method that was used. Can be `android_pay` (includes Google Pay), `apple_pay`, `masterpass`, `visa_checkout`, or null.
    @[JSON::Field(key: "tokenization_method", type: String, presence: true, ignore_serialize: tokenization_method.nil? && !tokenization_method_present?)]
    getter tokenization_method : String

    @[JSON::Field(ignore: true)]
    property? tokenization_method_present : Bool = false

    # The name of the person or business that owns the bank account.
    @[JSON::Field(key: "account_holder_name", type: String, presence: true, ignore_serialize: account_holder_name.nil? && !account_holder_name_present?)]
    getter account_holder_name : String

    @[JSON::Field(ignore: true)]
    property? account_holder_name_present : Bool = false

    # The type of entity that holds the account. This can be either `individual` or `company`.
    @[JSON::Field(key: "account_holder_type", type: String, presence: true, ignore_serialize: account_holder_type.nil? && !account_holder_type_present?)]
    getter account_holder_type : String

    @[JSON::Field(ignore: true)]
    property? account_holder_type_present : Bool = false

    # The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
    @[JSON::Field(key: "account_type", type: String, presence: true, ignore_serialize: account_type.nil? && !account_type_present?)]
    getter account_type : String

    @[JSON::Field(ignore: true)]
    property? account_type_present : Bool = false

    # Name of the bank associated with the routing number (e.g., `WELLS FARGO`).
    @[JSON::Field(key: "bank_name", type: String, presence: true, ignore_serialize: bank_name.nil? && !bank_name_present?)]
    getter bank_name : String

    @[JSON::Field(ignore: true)]
    property? bank_name_present : Bool = false

    # The routing transit number for the bank account.
    @[JSON::Field(key: "routing_number", type: String, presence: true, ignore_serialize: routing_number.nil? && !routing_number_present?)]
    getter routing_number : String

    @[JSON::Field(ignore: true)]
    property? routing_number_present : Bool = false

    # A positive integer in the smallest currency unit (that is, 100 cents for $1.00, or 1 for Â¥1, Japanese Yen being a zero-decimal currency) representing the total amount associated with the source. This is the amount for which the source will be chargeable once ready. Required for `single_use` sources.
    @[JSON::Field(key: "amount", type: Int64, presence: true, ignore_serialize: amount.nil? && !amount_present?)]
    property amount : Int64

    @[JSON::Field(ignore: true)]
    property? amount_present : Bool = false

    # The client secret of the source. Used for client-side retrieval using a publishable key.
    @[JSON::Field(key: "client_secret", type: String?)]
    getter client_secret : String?

    # Time at which the object was created. Measured in seconds since the Unix epoch.
    @[JSON::Field(key: "created", type: Int64?)]
    property created : Int64?

    # The authentication `flow` of the source. `flow` is one of `redirect`, `receiver`, `code_verification`, `none`.
    @[JSON::Field(key: "flow", type: String?)]
    getter flow : String?

    # Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    @[JSON::Field(key: "livemode", type: Bool?)]
    property livemode : Bool?

    @[JSON::Field(key: "owner", type: SourceOwner1, presence: true, ignore_serialize: owner.nil? && !owner_present?)]
    property owner : SourceOwner1

    @[JSON::Field(ignore: true)]
    property? owner_present : Bool = false

    # Extra information about a source. This will appear on your customer's statement every time you charge the source.
    @[JSON::Field(key: "statement_descriptor", type: String, presence: true, ignore_serialize: statement_descriptor.nil? && !statement_descriptor_present?)]
    getter statement_descriptor : String

    @[JSON::Field(ignore: true)]
    property? statement_descriptor_present : Bool = false

    # The `type` of the source. The `type` is a payment method, one of `ach_credit_transfer`, `ach_debit`, `alipay`, `bancontact`, `card`, `card_present`, `eps`, `giropay`, `ideal`, `multibanco`, `klarna`, `p24`, `sepa_debit`, `sofort`, `three_d_secure`, or `wechat`. An additional hash is included on the source with a name matching this value. It contains additional information specific to the [payment method](https://stripe.com/docs/sources) used.
    @[JSON::Field(key: "type", type: String?)]
    getter _type : String?

    ENUM_VALIDATOR_FOR__TYPE = EnumValidator.new("_type", "String", ["ach_credit_transfer", "ach_debit", "acss_debit", "alipay", "au_becs_debit", "bancontact", "card", "card_present", "eps", "giropay", "ideal", "klarna", "multibanco", "p24", "sepa_credit_transfer", "sepa_debit", "sofort", "three_d_secure", "wechat"])

    # Either `reusable` or `single_use`. Whether this source should be reusable or not. Some source types may or may not be reusable by construction, while others may leave the option at creation. If an incompatible value is passed, an error will be returned.
    @[JSON::Field(key: "usage", type: String, presence: true, ignore_serialize: usage.nil? && !usage_present?)]
    getter usage : String

    @[JSON::Field(ignore: true)]
    property? usage_present : Bool = false

    # Optional properties
    @[JSON::Field(key: "account", type: BankAccountAccount?, presence: true, ignore_serialize: account.nil? && !account_present?)]
    property account : BankAccountAccount?

    @[JSON::Field(ignore: true)]
    property? account_present : Bool = false

    # A set of available payout methods for this bank account. Only values from this set should be passed as the `method` when creating a payout.
    @[JSON::Field(key: "available_payout_methods", type: Array(String)?, presence: true, ignore_serialize: available_payout_methods.nil? && !available_payout_methods_present?)]
    getter available_payout_methods : Array(String)?

    @[JSON::Field(ignore: true)]
    property? available_payout_methods_present : Bool = false

    ENUM_VALIDATOR_FOR_AVAILABLE_PAYOUT_METHODS = EnumValidator.new("available_payout_methods", "String", ["instant", "standard"])

    # The ID of the customer to which this source is attached. This will not be present when the source has not been attached to a customer.
    @[JSON::Field(key: "customer", type: String?, presence: true, ignore_serialize: customer.nil? && !customer_present?)]
    getter customer : String?

    @[JSON::Field(ignore: true)]
    property? customer_present : Bool = false

    # Whether this bank account is the default external account for its currency.
    @[JSON::Field(key: "default_for_currency", type: Bool?, presence: true, ignore_serialize: default_for_currency.nil? && !default_for_currency_present?)]
    property default_for_currency : Bool?

    @[JSON::Field(ignore: true)]
    property? default_for_currency_present : Bool = false

    # A high-level description of the type of cards issued in this range. (For internal use only and not typically available in standard API requests.)
    @[JSON::Field(key: "description", type: String?, presence: true, ignore_serialize: description.nil? && !description_present?)]
    getter description : String?

    @[JSON::Field(ignore: true)]
    property? description_present : Bool = false

    # Issuer identification number of the card. (For internal use only and not typically available in standard API requests.)
    @[JSON::Field(key: "iin", type: String?, presence: true, ignore_serialize: iin.nil? && !iin_present?)]
    getter iin : String?

    @[JSON::Field(ignore: true)]
    property? iin_present : Bool = false

    # The name of the card's issuing bank. (For internal use only and not typically available in standard API requests.)
    @[JSON::Field(key: "issuer", type: String?, presence: true, ignore_serialize: issuer.nil? && !issuer_present?)]
    getter issuer : String?

    @[JSON::Field(ignore: true)]
    property? issuer_present : Bool = false

    @[JSON::Field(key: "recipient", type: CardRecipient?, presence: true, ignore_serialize: recipient.nil? && !recipient_present?)]
    property recipient : CardRecipient?

    @[JSON::Field(ignore: true)]
    property? recipient_present : Bool = false

    @[JSON::Field(key: "ach_credit_transfer", type: SourceTypeAchCreditTransfer?, presence: true, ignore_serialize: ach_credit_transfer.nil? && !ach_credit_transfer_present?)]
    property ach_credit_transfer : SourceTypeAchCreditTransfer?

    @[JSON::Field(ignore: true)]
    property? ach_credit_transfer_present : Bool = false

    @[JSON::Field(key: "ach_debit", type: SourceTypeAchDebit?, presence: true, ignore_serialize: ach_debit.nil? && !ach_debit_present?)]
    property ach_debit : SourceTypeAchDebit?

    @[JSON::Field(ignore: true)]
    property? ach_debit_present : Bool = false

    @[JSON::Field(key: "acss_debit", type: SourceTypeAcssDebit?, presence: true, ignore_serialize: acss_debit.nil? && !acss_debit_present?)]
    property acss_debit : SourceTypeAcssDebit?

    @[JSON::Field(ignore: true)]
    property? acss_debit_present : Bool = false

    @[JSON::Field(key: "alipay", type: SourceTypeAlipay?, presence: true, ignore_serialize: alipay.nil? && !alipay_present?)]
    property alipay : SourceTypeAlipay?

    @[JSON::Field(ignore: true)]
    property? alipay_present : Bool = false

    @[JSON::Field(key: "au_becs_debit", type: SourceTypeAuBecsDebit?, presence: true, ignore_serialize: au_becs_debit.nil? && !au_becs_debit_present?)]
    property au_becs_debit : SourceTypeAuBecsDebit?

    @[JSON::Field(ignore: true)]
    property? au_becs_debit_present : Bool = false

    @[JSON::Field(key: "bancontact", type: SourceTypeBancontact?, presence: true, ignore_serialize: bancontact.nil? && !bancontact_present?)]
    property bancontact : SourceTypeBancontact?

    @[JSON::Field(ignore: true)]
    property? bancontact_present : Bool = false

    @[JSON::Field(key: "card", type: SourceTypeCard?, presence: true, ignore_serialize: card.nil? && !card_present?)]
    property card : SourceTypeCard?

    @[JSON::Field(ignore: true)]
    property? card_present : Bool = false

    @[JSON::Field(key: "card_present", type: SourceTypeCardPresent?, presence: true, ignore_serialize: card_present.nil? && !card_present_present?)]
    property card_present2 : SourceTypeCardPresent?

    @[JSON::Field(ignore: true)]
    property? card_present2_present : Bool = false

    @[JSON::Field(key: "code_verification", type: SourceCodeVerificationFlow?, presence: true, ignore_serialize: code_verification.nil? && !code_verification_present?)]
    property code_verification : SourceCodeVerificationFlow?

    @[JSON::Field(ignore: true)]
    property? code_verification_present : Bool = false

    @[JSON::Field(key: "eps", type: SourceTypeEps?, presence: true, ignore_serialize: eps.nil? && !eps_present?)]
    property eps : SourceTypeEps?

    @[JSON::Field(ignore: true)]
    property? eps_present : Bool = false

    @[JSON::Field(key: "giropay", type: SourceTypeGiropay?, presence: true, ignore_serialize: giropay.nil? && !giropay_present?)]
    property giropay : SourceTypeGiropay?

    @[JSON::Field(ignore: true)]
    property? giropay_present : Bool = false

    @[JSON::Field(key: "ideal", type: SourceTypeIdeal?, presence: true, ignore_serialize: ideal.nil? && !ideal_present?)]
    property ideal : SourceTypeIdeal?

    @[JSON::Field(ignore: true)]
    property? ideal_present : Bool = false

    @[JSON::Field(key: "klarna", type: SourceTypeKlarna?, presence: true, ignore_serialize: klarna.nil? && !klarna_present?)]
    property klarna : SourceTypeKlarna?

    @[JSON::Field(ignore: true)]
    property? klarna_present : Bool = false

    @[JSON::Field(key: "multibanco", type: SourceTypeMultibanco?, presence: true, ignore_serialize: multibanco.nil? && !multibanco_present?)]
    property multibanco : SourceTypeMultibanco?

    @[JSON::Field(ignore: true)]
    property? multibanco_present : Bool = false

    @[JSON::Field(key: "p24", type: SourceTypeP24?, presence: true, ignore_serialize: p24.nil? && !p24_present?)]
    property p24 : SourceTypeP24?

    @[JSON::Field(ignore: true)]
    property? p24_present : Bool = false

    @[JSON::Field(key: "receiver", type: SourceReceiverFlow?, presence: true, ignore_serialize: receiver.nil? && !receiver_present?)]
    property receiver : SourceReceiverFlow?

    @[JSON::Field(ignore: true)]
    property? receiver_present : Bool = false

    @[JSON::Field(key: "redirect", type: SourceRedirectFlow?, presence: true, ignore_serialize: redirect.nil? && !redirect_present?)]
    property redirect : SourceRedirectFlow?

    @[JSON::Field(ignore: true)]
    property? redirect_present : Bool = false

    @[JSON::Field(key: "sepa_credit_transfer", type: SourceTypeSepaCreditTransfer?, presence: true, ignore_serialize: sepa_credit_transfer.nil? && !sepa_credit_transfer_present?)]
    property sepa_credit_transfer : SourceTypeSepaCreditTransfer?

    @[JSON::Field(ignore: true)]
    property? sepa_credit_transfer_present : Bool = false

    @[JSON::Field(key: "sepa_debit", type: SourceTypeSepaDebit?, presence: true, ignore_serialize: sepa_debit.nil? && !sepa_debit_present?)]
    property sepa_debit : SourceTypeSepaDebit?

    @[JSON::Field(ignore: true)]
    property? sepa_debit_present : Bool = false

    @[JSON::Field(key: "sofort", type: SourceTypeSofort?, presence: true, ignore_serialize: sofort.nil? && !sofort_present?)]
    property sofort : SourceTypeSofort?

    @[JSON::Field(ignore: true)]
    property? sofort_present : Bool = false

    @[JSON::Field(key: "source_order", type: SourceOrder?, presence: true, ignore_serialize: source_order.nil? && !source_order_present?)]
    property source_order : SourceOrder?

    @[JSON::Field(ignore: true)]
    property? source_order_present : Bool = false

    @[JSON::Field(key: "three_d_secure", type: SourceTypeThreeDSecure?, presence: true, ignore_serialize: three_d_secure.nil? && !three_d_secure_present?)]
    property three_d_secure : SourceTypeThreeDSecure?

    @[JSON::Field(ignore: true)]
    property? three_d_secure_present : Bool = false

    @[JSON::Field(key: "wechat", type: SourceTypeWechat?, presence: true, ignore_serialize: wechat.nil? && !wechat_present?)]
    property wechat : SourceTypeWechat?

    @[JSON::Field(ignore: true)]
    property? wechat_present : Bool = false

    # List of class defined in anyOf (OpenAPI v3)
    def self.openapi_any_of
      [
        Stripe::BankAccount,
        Stripe::Card,
        Stripe::Source,
      ]
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(*, @address_city : String?, @address_country : String?, @address_line1 : String?, @address_line1_check : String?, @address_line2 : String?, @address_state : String?, @address_zip : String?, @address_zip_check : String?, @brand : String, @country : String, @currency : String?, @cvc_check : String?, @dynamic_last4 : String?, @exp_month : Int64, @exp_year : Int64, @fingerprint : String?, @funding : String, @id : String, @last4 : String, @metadata : Hash(String, String)?, @name : String?, @object : String, @status : String, @tokenization_method : String?, @account_holder_name : String?, @account_holder_type : String?, @account_type : String?, @bank_name : String?, @routing_number : String?, @amount : Int64?, @client_secret : String, @created : Int64, @flow : String, @livemode : Bool, @owner : SourceOwner1?, @statement_descriptor : String?, @_type : String, @usage : String?, @account : BankAccountAccount? = nil, @available_payout_methods : Array(String)? = nil, @customer : String? = nil, @default_for_currency : Bool? = nil, @description : String? = nil, @iin : String? = nil, @issuer : String? = nil, @recipient : CardRecipient? = nil, @ach_credit_transfer : SourceTypeAchCreditTransfer? = nil, @ach_debit : SourceTypeAchDebit? = nil, @acss_debit : SourceTypeAcssDebit? = nil, @alipay : SourceTypeAlipay? = nil, @au_becs_debit : SourceTypeAuBecsDebit? = nil, @bancontact : SourceTypeBancontact? = nil, @card : SourceTypeCard? = nil, @card_present2 : SourceTypeCardPresent? = nil, @code_verification : SourceCodeVerificationFlow? = nil, @eps : SourceTypeEps? = nil, @giropay : SourceTypeGiropay? = nil, @ideal : SourceTypeIdeal? = nil, @klarna : SourceTypeKlarna? = nil, @multibanco : SourceTypeMultibanco? = nil, @p24 : SourceTypeP24? = nil, @receiver : SourceReceiverFlow? = nil, @redirect : SourceRedirectFlow? = nil, @sepa_credit_transfer : SourceTypeSepaCreditTransfer? = nil, @sepa_debit : SourceTypeSepaDebit? = nil, @sofort : SourceTypeSofort? = nil, @source_order : SourceOrder? = nil, @three_d_secure : SourceTypeThreeDSecure? = nil, @wechat : SourceTypeWechat? = nil)
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array(String).new

      if @address_city.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_city\", the character length must be smaller than or equal to 5000.")
      end

      if @address_country.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_country\", the character length must be smaller than or equal to 5000.")
      end

      if @address_line1.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_line1\", the character length must be smaller than or equal to 5000.")
      end

      if @address_line1_check.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_line1_check\", the character length must be smaller than or equal to 5000.")
      end

      if @address_line2.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_line2\", the character length must be smaller than or equal to 5000.")
      end

      if @address_state.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_state\", the character length must be smaller than or equal to 5000.")
      end

      if @address_zip.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_zip\", the character length must be smaller than or equal to 5000.")
      end

      if @address_zip_check.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_zip_check\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties.push(ENUM_VALIDATOR_FOR_AVAILABLE_PAYOUT_METHODS.error_message) unless ENUM_VALIDATOR_FOR_AVAILABLE_PAYOUT_METHODS.all_valid?(@available_payout_methods)

      if @brand.to_s.size > 5000
        invalid_properties.push("invalid value for \"brand\", the character length must be smaller than or equal to 5000.")
      end

      if @country.to_s.size > 5000
        invalid_properties.push("invalid value for \"country\", the character length must be smaller than or equal to 5000.")
      end

      if !@customer.nil? && @customer.to_s.size > 5000
        invalid_properties.push("invalid value for \"customer\", the character length must be smaller than or equal to 5000.")
      end

      if @cvc_check.to_s.size > 5000
        invalid_properties.push("invalid value for \"cvc_check\", the character length must be smaller than or equal to 5000.")
      end

      if !@description.nil? && @description.to_s.size > 5000
        invalid_properties.push("invalid value for \"description\", the character length must be smaller than or equal to 5000.")
      end

      if @dynamic_last4.to_s.size > 5000
        invalid_properties.push("invalid value for \"dynamic_last4\", the character length must be smaller than or equal to 5000.")
      end

      if @fingerprint.to_s.size > 5000
        invalid_properties.push("invalid value for \"fingerprint\", the character length must be smaller than or equal to 5000.")
      end

      if @funding.to_s.size > 5000
        invalid_properties.push("invalid value for \"funding\", the character length must be smaller than or equal to 5000.")
      end

      if @id.to_s.size > 5000
        invalid_properties.push("invalid value for \"id\", the character length must be smaller than or equal to 5000.")
      end

      if !@iin.nil? && @iin.to_s.size > 5000
        invalid_properties.push("invalid value for \"iin\", the character length must be smaller than or equal to 5000.")
      end

      if !@issuer.nil? && @issuer.to_s.size > 5000
        invalid_properties.push("invalid value for \"issuer\", the character length must be smaller than or equal to 5000.")
      end

      if @last4.to_s.size > 5000
        invalid_properties.push("invalid value for \"last4\", the character length must be smaller than or equal to 5000.")
      end

      if @name.to_s.size > 5000
        invalid_properties.push("invalid value for \"name\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties.push(ENUM_VALIDATOR_FOR_OBJECT.error_message) unless ENUM_VALIDATOR_FOR_OBJECT.valid?(@object, false)

      if @status.to_s.size > 5000
        invalid_properties.push("invalid value for \"status\", the character length must be smaller than or equal to 5000.")
      end

      if @tokenization_method.to_s.size > 5000
        invalid_properties.push("invalid value for \"tokenization_method\", the character length must be smaller than or equal to 5000.")
      end

      if @account_holder_name.to_s.size > 5000
        invalid_properties.push("invalid value for \"account_holder_name\", the character length must be smaller than or equal to 5000.")
      end

      if @account_holder_type.to_s.size > 5000
        invalid_properties.push("invalid value for \"account_holder_type\", the character length must be smaller than or equal to 5000.")
      end

      if @account_type.to_s.size > 5000
        invalid_properties.push("invalid value for \"account_type\", the character length must be smaller than or equal to 5000.")
      end

      if @bank_name.to_s.size > 5000
        invalid_properties.push("invalid value for \"bank_name\", the character length must be smaller than or equal to 5000.")
      end

      if @routing_number.to_s.size > 5000
        invalid_properties.push("invalid value for \"routing_number\", the character length must be smaller than or equal to 5000.")
      end

      if @client_secret.to_s.size > 5000
        invalid_properties.push("invalid value for \"client_secret\", the character length must be smaller than or equal to 5000.")
      end

      if @flow.to_s.size > 5000
        invalid_properties.push("invalid value for \"flow\", the character length must be smaller than or equal to 5000.")
      end

      if @statement_descriptor.to_s.size > 5000
        invalid_properties.push("invalid value for \"statement_descriptor\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties.push(ENUM_VALIDATOR_FOR__TYPE.error_message) unless ENUM_VALIDATOR_FOR__TYPE.valid?(@_type, false)

      if @usage.to_s.size > 5000
        invalid_properties.push("invalid value for \"usage\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if @address_city.to_s.size > 5000
      return false if @address_country.to_s.size > 5000
      return false if @address_line1.to_s.size > 5000
      return false if @address_line1_check.to_s.size > 5000
      return false if @address_line2.to_s.size > 5000
      return false if @address_state.to_s.size > 5000
      return false if @address_zip.to_s.size > 5000
      return false if @address_zip_check.to_s.size > 5000
      return false unless ENUM_VALIDATOR_FOR_AVAILABLE_PAYOUT_METHODS.all_valid?(@available_payout_methods)
      return false if @brand.to_s.size > 5000
      return false if @country.to_s.size > 5000
      return false if !@customer.nil? && @customer.to_s.size > 5000
      return false if @cvc_check.to_s.size > 5000
      return false if !@description.nil? && @description.to_s.size > 5000
      return false if @dynamic_last4.to_s.size > 5000
      return false if @fingerprint.to_s.size > 5000
      return false if @funding.to_s.size > 5000
      return false if @id.to_s.size > 5000
      return false if !@iin.nil? && @iin.to_s.size > 5000
      return false if !@issuer.nil? && @issuer.to_s.size > 5000
      return false if @last4.to_s.size > 5000
      return false if @name.to_s.size > 5000
      return false unless ENUM_VALIDATOR_FOR_OBJECT.valid?(@object, false)
      return false if @status.to_s.size > 5000
      return false if @tokenization_method.to_s.size > 5000
      return false if @account_holder_name.to_s.size > 5000
      return false if @account_holder_type.to_s.size > 5000
      return false if @account_type.to_s.size > 5000
      return false if @bank_name.to_s.size > 5000
      return false if @routing_number.to_s.size > 5000
      return false if @client_secret.to_s.size > 5000
      return false if @flow.to_s.size > 5000
      return false if @statement_descriptor.to_s.size > 5000
      return false unless ENUM_VALIDATOR_FOR__TYPE.valid?(@_type, false)
      return false if @usage.to_s.size > 5000
      _any_of_found = false
      json_string : String = self.to_json
      _any_of_found = self.class.openapi_any_of.any? do |_class|
        _any_of = begin
          _class.from_json(json_string)
        rescue
          nil
        end

        !_any_of.nil? && _any_of.not_nil!.valid?
      end

      if !_any_of_found
        return false
      end

      true
    end

    # Custom attribute writer method with validation
    # @param [Object] address_city Value to be assigned
    def address_city=(address_city)
      if address_city.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_city\", the character length must be smaller than or equal to 5000.")
      end

      @address_city = address_city
    end

    # Custom attribute writer method with validation
    # @param [Object] address_country Value to be assigned
    def address_country=(address_country)
      if address_country.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_country\", the character length must be smaller than or equal to 5000.")
      end

      @address_country = address_country
    end

    # Custom attribute writer method with validation
    # @param [Object] address_line1 Value to be assigned
    def address_line1=(address_line1)
      if address_line1.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_line1\", the character length must be smaller than or equal to 5000.")
      end

      @address_line1 = address_line1
    end

    # Custom attribute writer method with validation
    # @param [Object] address_line1_check Value to be assigned
    def address_line1_check=(address_line1_check)
      if address_line1_check.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_line1_check\", the character length must be smaller than or equal to 5000.")
      end

      @address_line1_check = address_line1_check
    end

    # Custom attribute writer method with validation
    # @param [Object] address_line2 Value to be assigned
    def address_line2=(address_line2)
      if address_line2.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_line2\", the character length must be smaller than or equal to 5000.")
      end

      @address_line2 = address_line2
    end

    # Custom attribute writer method with validation
    # @param [Object] address_state Value to be assigned
    def address_state=(address_state)
      if address_state.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_state\", the character length must be smaller than or equal to 5000.")
      end

      @address_state = address_state
    end

    # Custom attribute writer method with validation
    # @param [Object] address_zip Value to be assigned
    def address_zip=(address_zip)
      if address_zip.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_zip\", the character length must be smaller than or equal to 5000.")
      end

      @address_zip = address_zip
    end

    # Custom attribute writer method with validation
    # @param [Object] address_zip_check Value to be assigned
    def address_zip_check=(address_zip_check)
      if address_zip_check.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_zip_check\", the character length must be smaller than or equal to 5000.")
      end

      @address_zip_check = address_zip_check
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] available_payout_methods Object to be assigned
    def available_payout_methods=(available_payout_methods)
      ENUM_VALIDATOR_FOR_AVAILABLE_PAYOUT_METHODS.all_valid!(available_payout_methods)
      @available_payout_methods = available_payout_methods
    end

    # Custom attribute writer method with validation
    # @param [Object] brand Value to be assigned
    def brand=(brand)
      if brand.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"brand\", the character length must be smaller than or equal to 5000.")
      end

      @brand = brand
    end

    # Custom attribute writer method with validation
    # @param [Object] country Value to be assigned
    def country=(country)
      if country.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"country\", the character length must be smaller than or equal to 5000.")
      end

      @country = country
    end

    # Custom attribute writer method with validation
    # @param [Object] customer Value to be assigned
    def customer=(customer)
      if !customer.nil? && customer.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"customer\", the character length must be smaller than or equal to 5000.")
      end

      @customer = customer
    end

    # Custom attribute writer method with validation
    # @param [Object] cvc_check Value to be assigned
    def cvc_check=(cvc_check)
      if cvc_check.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"cvc_check\", the character length must be smaller than or equal to 5000.")
      end

      @cvc_check = cvc_check
    end

    # Custom attribute writer method with validation
    # @param [Object] description Value to be assigned
    def description=(description)
      if !description.nil? && description.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"description\", the character length must be smaller than or equal to 5000.")
      end

      @description = description
    end

    # Custom attribute writer method with validation
    # @param [Object] dynamic_last4 Value to be assigned
    def dynamic_last4=(dynamic_last4)
      if dynamic_last4.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"dynamic_last4\", the character length must be smaller than or equal to 5000.")
      end

      @dynamic_last4 = dynamic_last4
    end

    # Custom attribute writer method with validation
    # @param [Object] fingerprint Value to be assigned
    def fingerprint=(fingerprint)
      if fingerprint.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"fingerprint\", the character length must be smaller than or equal to 5000.")
      end

      @fingerprint = fingerprint
    end

    # Custom attribute writer method with validation
    # @param [Object] funding Value to be assigned
    def funding=(funding)
      if funding.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"funding\", the character length must be smaller than or equal to 5000.")
      end

      @funding = funding
    end

    # Custom attribute writer method with validation
    # @param [Object] id Value to be assigned
    def id=(id)
      if id.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"id\", the character length must be smaller than or equal to 5000.")
      end

      @id = id
    end

    # Custom attribute writer method with validation
    # @param [Object] iin Value to be assigned
    def iin=(iin)
      if !iin.nil? && iin.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"iin\", the character length must be smaller than or equal to 5000.")
      end

      @iin = iin
    end

    # Custom attribute writer method with validation
    # @param [Object] issuer Value to be assigned
    def issuer=(issuer)
      if !issuer.nil? && issuer.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"issuer\", the character length must be smaller than or equal to 5000.")
      end

      @issuer = issuer
    end

    # Custom attribute writer method with validation
    # @param [Object] last4 Value to be assigned
    def last4=(last4)
      if last4.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"last4\", the character length must be smaller than or equal to 5000.")
      end

      @last4 = last4
    end

    # Custom attribute writer method with validation
    # @param [Object] name Value to be assigned
    def name=(name)
      if name.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"name\", the character length must be smaller than or equal to 5000.")
      end

      @name = name
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] object Object to be assigned
    def object=(object)
      ENUM_VALIDATOR_FOR_OBJECT.valid!(object, false)
      @object = object
    end

    # Custom attribute writer method with validation
    # @param [Object] status Value to be assigned
    def status=(status)
      if status.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"status\", the character length must be smaller than or equal to 5000.")
      end

      @status = status
    end

    # Custom attribute writer method with validation
    # @param [Object] tokenization_method Value to be assigned
    def tokenization_method=(tokenization_method)
      if tokenization_method.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"tokenization_method\", the character length must be smaller than or equal to 5000.")
      end

      @tokenization_method = tokenization_method
    end

    # Custom attribute writer method with validation
    # @param [Object] account_holder_name Value to be assigned
    def account_holder_name=(account_holder_name)
      if account_holder_name.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"account_holder_name\", the character length must be smaller than or equal to 5000.")
      end

      @account_holder_name = account_holder_name
    end

    # Custom attribute writer method with validation
    # @param [Object] account_holder_type Value to be assigned
    def account_holder_type=(account_holder_type)
      if account_holder_type.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"account_holder_type\", the character length must be smaller than or equal to 5000.")
      end

      @account_holder_type = account_holder_type
    end

    # Custom attribute writer method with validation
    # @param [Object] account_type Value to be assigned
    def account_type=(account_type)
      if account_type.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"account_type\", the character length must be smaller than or equal to 5000.")
      end

      @account_type = account_type
    end

    # Custom attribute writer method with validation
    # @param [Object] bank_name Value to be assigned
    def bank_name=(bank_name)
      if bank_name.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"bank_name\", the character length must be smaller than or equal to 5000.")
      end

      @bank_name = bank_name
    end

    # Custom attribute writer method with validation
    # @param [Object] routing_number Value to be assigned
    def routing_number=(routing_number)
      if routing_number.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"routing_number\", the character length must be smaller than or equal to 5000.")
      end

      @routing_number = routing_number
    end

    # Custom attribute writer method with validation
    # @param [Object] client_secret Value to be assigned
    def client_secret=(client_secret)
      if client_secret.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"client_secret\", the character length must be smaller than or equal to 5000.")
      end

      @client_secret = client_secret
    end

    # Custom attribute writer method with validation
    # @param [Object] flow Value to be assigned
    def flow=(flow)
      if flow.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"flow\", the character length must be smaller than or equal to 5000.")
      end

      @flow = flow
    end

    # Custom attribute writer method with validation
    # @param [Object] statement_descriptor Value to be assigned
    def statement_descriptor=(statement_descriptor)
      if statement_descriptor.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"statement_descriptor\", the character length must be smaller than or equal to 5000.")
      end

      @statement_descriptor = statement_descriptor
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] _type Object to be assigned
    def _type=(_type)
      ENUM_VALIDATOR_FOR__TYPE.valid!(_type, false)
      @_type = _type
    end

    # Custom attribute writer method with validation
    # @param [Object] usage Value to be assigned
    def usage=(usage)
      if usage.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"usage\", the character length must be smaller than or equal to 5000.")
      end

      @usage = usage
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.same?(o)
      self.class == o.class &&
        account == o.account &&
        address_city == o.address_city &&
        address_country == o.address_country &&
        address_line1 == o.address_line1 &&
        address_line1_check == o.address_line1_check &&
        address_line2 == o.address_line2 &&
        address_state == o.address_state &&
        address_zip == o.address_zip &&
        address_zip_check == o.address_zip_check &&
        available_payout_methods == o.available_payout_methods &&
        brand == o.brand &&
        country == o.country &&
        currency == o.currency &&
        customer == o.customer &&
        cvc_check == o.cvc_check &&
        default_for_currency == o.default_for_currency &&
        description == o.description &&
        dynamic_last4 == o.dynamic_last4 &&
        exp_month == o.exp_month &&
        exp_year == o.exp_year &&
        fingerprint == o.fingerprint &&
        funding == o.funding &&
        id == o.id &&
        iin == o.iin &&
        issuer == o.issuer &&
        last4 == o.last4 &&
        metadata == o.metadata &&
        name == o.name &&
        object == o.object &&
        recipient == o.recipient &&
        status == o.status &&
        tokenization_method == o.tokenization_method &&
        account_holder_name == o.account_holder_name &&
        account_holder_type == o.account_holder_type &&
        account_type == o.account_type &&
        bank_name == o.bank_name &&
        routing_number == o.routing_number &&
        ach_credit_transfer == o.ach_credit_transfer &&
        ach_debit == o.ach_debit &&
        acss_debit == o.acss_debit &&
        alipay == o.alipay &&
        amount == o.amount &&
        au_becs_debit == o.au_becs_debit &&
        bancontact == o.bancontact &&
        card == o.card &&
        card_present2 == o.card_present2 &&
        client_secret == o.client_secret &&
        code_verification == o.code_verification &&
        created == o.created &&
        eps == o.eps &&
        flow == o.flow &&
        giropay == o.giropay &&
        ideal == o.ideal &&
        klarna == o.klarna &&
        livemode == o.livemode &&
        multibanco == o.multibanco &&
        owner == o.owner &&
        p24 == o.p24 &&
        receiver == o.receiver &&
        redirect == o.redirect &&
        sepa_credit_transfer == o.sepa_credit_transfer &&
        sepa_debit == o.sepa_debit &&
        sofort == o.sofort &&
        source_order == o.source_order &&
        statement_descriptor == o.statement_descriptor &&
        three_d_secure == o.three_d_secure &&
        _type == o._type &&
        usage == o.usage &&
        wechat == o.wechat
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [UInt64] Hash code
    def_hash(@account, @address_city, @address_country, @address_line1, @address_line1_check, @address_line2, @address_state, @address_zip, @address_zip_check, @available_payout_methods, @brand, @country, @currency, @customer, @cvc_check, @default_for_currency, @description, @dynamic_last4, @exp_month, @exp_year, @fingerprint, @funding, @id, @iin, @issuer, @last4, @metadata, @name, @object, @recipient, @status, @tokenization_method, @account_holder_name, @account_holder_type, @account_type, @bank_name, @routing_number, @ach_credit_transfer, @ach_debit, @acss_debit, @alipay, @amount, @au_becs_debit, @bancontact, @card, @card_present2, @client_secret, @code_verification, @created, @eps, @flow, @giropay, @ideal, @klarna, @livemode, @multibanco, @owner, @p24, @receiver, @redirect, @sepa_credit_transfer, @sepa_debit, @sofort, @source_order, @statement_descriptor, @three_d_secure, @_type, @usage, @wechat)
  end
end
