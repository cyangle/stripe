#  Stripe API
#
# The Stripe REST API. Please see https://stripe.com/docs/api for more details.
#
# The version of the OpenAPI document: 2020-08-27
# Contact: dev-platform@stripe.com
# Generated by: https://openapi-generator.tech
#

require "json"
require "time"
require "log"

module Stripe
  @[JSON::Serializable::Options(emit_nulls: true)]
  class PostInvoiceitemsRequest
    include JSON::Serializable
    include JSON::Serializable::Unmapped

    # Required properties

    # The ID of the customer who will be billed when this invoice item is billed.
    @[JSON::Field(key: "customer", type: String)]
    getter customer : String

    # Optional properties

    # The integer amount in cents (or local equivalent) of the charge to be applied to the upcoming invoice. Passing in a negative `amount` will reduce the `amount_due` on the invoice.
    @[JSON::Field(key: "amount", type: Int64?, presence: true, ignore_serialize: amount.nil? && !amount_present?)]
    property amount : Int64?

    @[JSON::Field(ignore: true)]
    property? amount_present : Bool = false

    # Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    @[JSON::Field(key: "currency", type: String?, presence: true, ignore_serialize: currency.nil? && !currency_present?)]
    property currency : String?

    @[JSON::Field(ignore: true)]
    property? currency_present : Bool = false

    # An arbitrary string which you can attach to the invoice item. The description is displayed in the invoice for easy tracking.
    @[JSON::Field(key: "description", type: String?, presence: true, ignore_serialize: description.nil? && !description_present?)]
    getter description : String?

    @[JSON::Field(ignore: true)]
    property? description_present : Bool = false

    # Controls whether discounts apply to this invoice item. Defaults to false for prorations or negative invoice items, and true for all other invoice items.
    @[JSON::Field(key: "discountable", type: Bool?, presence: true, ignore_serialize: discountable.nil? && !discountable_present?)]
    property discountable : Bool?

    @[JSON::Field(ignore: true)]
    property? discountable_present : Bool = false

    @[JSON::Field(key: "discounts", type: PostInvoiceitemsRequestDiscounts?, presence: true, ignore_serialize: discounts.nil? && !discounts_present?)]
    property discounts : PostInvoiceitemsRequestDiscounts?

    @[JSON::Field(ignore: true)]
    property? discounts_present : Bool = false

    # Specifies which fields in the response should be expanded.
    @[JSON::Field(key: "expand", type: Array(String)?, presence: true, ignore_serialize: expand.nil? && !expand_present?)]
    property expand : Array(String)?

    @[JSON::Field(ignore: true)]
    property? expand_present : Bool = false

    # The ID of an existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming scheduled invoice. This is useful when adding invoice items in response to an invoice.created webhook. You can only add invoice items to draft invoices and there is a maximum of 250 items per invoice.
    @[JSON::Field(key: "invoice", type: String?, presence: true, ignore_serialize: invoice.nil? && !invoice_present?)]
    getter invoice : String?

    @[JSON::Field(ignore: true)]
    property? invoice_present : Bool = false

    @[JSON::Field(key: "metadata", type: PostAccountRequestMetadata?, presence: true, ignore_serialize: metadata.nil? && !metadata_present?)]
    property metadata : PostAccountRequestMetadata?

    @[JSON::Field(ignore: true)]
    property? metadata_present : Bool = false

    @[JSON::Field(key: "period", type: Period1?, presence: true, ignore_serialize: period.nil? && !period_present?)]
    property period : Period1?

    @[JSON::Field(ignore: true)]
    property? period_present : Bool = false

    # The ID of the price object.
    @[JSON::Field(key: "price", type: String?, presence: true, ignore_serialize: price.nil? && !price_present?)]
    getter price : String?

    @[JSON::Field(ignore: true)]
    property? price_present : Bool = false

    @[JSON::Field(key: "price_data", type: OneTimePriceData1?, presence: true, ignore_serialize: price_data.nil? && !price_data_present?)]
    property price_data : OneTimePriceData1?

    @[JSON::Field(ignore: true)]
    property? price_data_present : Bool = false

    # Non-negative integer. The quantity of units for the invoice item.
    @[JSON::Field(key: "quantity", type: Int64?, presence: true, ignore_serialize: quantity.nil? && !quantity_present?)]
    property quantity : Int64?

    @[JSON::Field(ignore: true)]
    property? quantity_present : Bool = false

    # The ID of a subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming scheduled invoice. When set, scheduled invoices for subscriptions other than the specified subscription will ignore the invoice item. Use this when you want to express that an invoice item has been accrued within the context of a particular subscription.
    @[JSON::Field(key: "subscription", type: String?, presence: true, ignore_serialize: subscription.nil? && !subscription_present?)]
    getter subscription : String?

    @[JSON::Field(ignore: true)]
    property? subscription_present : Bool = false

    # The tax rates which apply to the invoice item. When set, the `default_tax_rates` on the invoice do not apply to this invoice item.
    @[JSON::Field(key: "tax_rates", type: Array(String)?, presence: true, ignore_serialize: tax_rates.nil? && !tax_rates_present?)]
    property tax_rates : Array(String)?

    @[JSON::Field(ignore: true)]
    property? tax_rates_present : Bool = false

    # The integer unit amount in cents (or local equivalent) of the charge to be applied to the upcoming invoice. This `unit_amount` will be multiplied by the quantity to get the full amount. Passing in a negative `unit_amount` will reduce the `amount_due` on the invoice.
    @[JSON::Field(key: "unit_amount", type: Int64?, presence: true, ignore_serialize: unit_amount.nil? && !unit_amount_present?)]
    property unit_amount : Int64?

    @[JSON::Field(ignore: true)]
    property? unit_amount_present : Bool = false

    # Same as `unit_amount`, but accepts a decimal value in cents (or local equivalent) with at most 12 decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
    @[JSON::Field(key: "unit_amount_decimal", type: String?, presence: true, ignore_serialize: unit_amount_decimal.nil? && !unit_amount_decimal_present?)]
    property unit_amount_decimal : String?

    @[JSON::Field(ignore: true)]
    property? unit_amount_decimal_present : Bool = false

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(
      *,
      # Required properties
      @customer : String,
      # Optional properties
      @amount : Int64? = nil,
      @currency : String? = nil,
      @description : String? = nil,
      @discountable : Bool? = nil,
      @discounts : PostInvoiceitemsRequestDiscounts? = nil,
      @expand : Array(String)? = nil,
      @invoice : String? = nil,
      @metadata : PostAccountRequestMetadata? = nil,
      @period : Period1? = nil,
      @price : String? = nil,
      @price_data : OneTimePriceData1? = nil,
      @quantity : Int64? = nil,
      @subscription : String? = nil,
      @tax_rates : Array(String)? = nil,
      @unit_amount : Int64? = nil,
      @unit_amount_decimal : String? = nil
    )
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array(String).new

      if @customer.to_s.size > 5000
        invalid_properties.push("invalid value for \"customer\", the character length must be smaller than or equal to 5000.")
      end

      if !@description.nil? && @description.to_s.size > 5000
        invalid_properties.push("invalid value for \"description\", the character length must be smaller than or equal to 5000.")
      end

      if !@invoice.nil? && @invoice.to_s.size > 5000
        invalid_properties.push("invalid value for \"invoice\", the character length must be smaller than or equal to 5000.")
      end

      if !@price.nil? && @price.to_s.size > 5000
        invalid_properties.push("invalid value for \"price\", the character length must be smaller than or equal to 5000.")
      end

      if !@subscription.nil? && @subscription.to_s.size > 5000
        invalid_properties.push("invalid value for \"subscription\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if @customer.to_s.size > 5000
      return false if !@description.nil? && @description.to_s.size > 5000
      return false if !@invoice.nil? && @invoice.to_s.size > 5000
      return false if !@price.nil? && @price.to_s.size > 5000
      return false if !@subscription.nil? && @subscription.to_s.size > 5000

      true
    end

    # Custom attribute writer method with validation
    # @param [Object] customer Value to be assigned
    def customer=(customer)
      if customer.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"customer\", the character length must be smaller than or equal to 5000.")
      end

      @customer = customer
    end

    # Custom attribute writer method with validation
    # @param [Object] description Value to be assigned
    def description=(description)
      if !description.nil? && description.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"description\", the character length must be smaller than or equal to 5000.")
      end

      @description = description
    end

    # Custom attribute writer method with validation
    # @param [Object] invoice Value to be assigned
    def invoice=(invoice)
      if !invoice.nil? && invoice.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"invoice\", the character length must be smaller than or equal to 5000.")
      end

      @invoice = invoice
    end

    # Custom attribute writer method with validation
    # @param [Object] price Value to be assigned
    def price=(price)
      if !price.nil? && price.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"price\", the character length must be smaller than or equal to 5000.")
      end

      @price = price
    end

    # Custom attribute writer method with validation
    # @param [Object] subscription Value to be assigned
    def subscription=(subscription)
      if !subscription.nil? && subscription.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"subscription\", the character length must be smaller than or equal to 5000.")
      end

      @subscription = subscription
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Generates #hash and #== methods from all fields
    # #== @return [Bool]
    # #hash calculates hash code according to all attributes.
    # #hash @return [UInt64] Hash code
    def_equals_and_hash(@customer, @amount, @currency, @description, @discountable, @discounts, @expand, @invoice, @metadata, @period, @price, @price_data, @quantity, @subscription, @tax_rates, @unit_amount, @unit_amount_decimal)
  end
end
