#  Stripe API
#
# The Stripe REST API. Please see https://stripe.com/docs/api for more details.
#
# The version of the OpenAPI document: 2020-08-27
# Contact: dev-platform@stripe.com
# Generated by: https://openapi-generator.tech
#

require "nason"
require "time"
require "log"

module Stripe
  class PaymentSource
    include NASON::Serializable

    # Required properties
    # Two-letter ISO code representing the country of the card. You could use this attribute to get a sense of the international breakdown of cards you've collected.
    @[NASON::Field(key: "country", type: String | Null, nillable: false)]
    property country : String | Null

    # Time at which the object was created. Measured in seconds since the Unix epoch.
    @[NASON::Field(key: "created", type: Int64)]
    property created : Int64

    # Unique identifier for the object.
    @[NASON::Field(key: "id", type: String)]
    property id : String

    # String representing the object's type. Objects of the same type share the same value.
    @[NASON::Field(key: "object", type: String)]
    property object : String

    # The `type` of the source. The `type` is a payment method, one of `ach_credit_transfer`, `ach_debit`, `alipay`, `bancontact`, `card`, `card_present`, `eps`, `giropay`, `ideal`, `multibanco`, `klarna`, `p24`, `sepa_debit`, `sofort`, `three_d_secure`, or `wechat`. An additional hash is included on the source with a name matching this value. It contains additional information specific to the [payment method](https://stripe.com/docs/sources) used.
    @[NASON::Field(key: "type", type: String)]
    property _type : String

    # Uniquely identifies this particular card number. You can use this attribute to check whether two customers who’ve signed up with you are using the same card number, for example. For payment methods that tokenize card information (Apple Pay, Google Pay), the tokenized number might be provided instead of the underlying card number.  *Starting May 1, 2021, card fingerprint in India for Connect will change to allow two fingerprints for the same card --- one for India and one for the rest of the world.*
    @[NASON::Field(key: "fingerprint", type: String | Null, nillable: false)]
    property fingerprint : String | Null

    # Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    @[NASON::Field(key: "livemode", type: Bool)]
    property livemode : Bool

    # True if you can create multiple payments using this account. If the account is reusable, then you can freely choose the amount of each payment.
    @[NASON::Field(key: "reusable", type: Bool)]
    property reusable : Bool

    # Whether this Alipay account object has ever been used for a payment.
    @[NASON::Field(key: "used", type: Bool)]
    property used : Bool

    # The username for the Alipay account.
    @[NASON::Field(key: "username", type: String)]
    property username : String

    # Three-letter [ISO code for the currency](https://stripe.com/docs/currencies) associated with the source. This is the currency for which the source will be chargeable once ready. Required for `single_use` sources.
    @[NASON::Field(key: "currency", type: String | Null, nillable: false)]
    property currency : String | Null

    # The last four digits of the card.
    @[NASON::Field(key: "last4", type: String)]
    property last4 : String

    # The status of the source, one of `canceled`, `chargeable`, `consumed`, `failed`, or `pending`. Only `chargeable` sources can be used to create a charge.
    @[NASON::Field(key: "status", type: String)]
    property status : String

    # True when this bitcoin receiver has received a non-zero amount of bitcoin.
    @[NASON::Field(key: "active", type: Bool)]
    property active : Bool

    # A positive integer in the smallest currency unit (that is, 100 cents for $1.00, or 1 for ¥1, Japanese Yen being a zero-decimal currency) representing the total amount associated with the source. This is the amount for which the source will be chargeable once ready. Required for `single_use` sources.
    @[NASON::Field(key: "amount", type: Int64 | Null, nillable: false)]
    property amount : Int64 | Null

    # The amount of `currency` to which `bitcoin_amount_received` has been converted.
    @[NASON::Field(key: "amount_received", type: Int64)]
    property amount_received : Int64

    # The amount of bitcoin that the customer should send to fill the receiver. The `bitcoin_amount` is denominated in Satoshi: there are 10^8 Satoshi in one bitcoin.
    @[NASON::Field(key: "bitcoin_amount", type: Int64)]
    property bitcoin_amount : Int64

    # The amount of bitcoin that has been sent by the customer to this receiver.
    @[NASON::Field(key: "bitcoin_amount_received", type: Int64)]
    property bitcoin_amount_received : Int64

    # This URI can be displayed to the customer as a clickable link (to activate their bitcoin client) or as a QR code (for mobile wallets).
    @[NASON::Field(key: "bitcoin_uri", type: String)]
    property bitcoin_uri : String

    # This flag is initially false and updates to true when the customer sends the `bitcoin_amount` to this receiver.
    @[NASON::Field(key: "filled", type: Bool)]
    property filled : Bool

    # A bitcoin address that is specific to this receiver. The customer can send bitcoin to this address to fill the receiver.
    @[NASON::Field(key: "inbound_address", type: String)]
    property inbound_address : String

    # This receiver contains uncaptured funds that can be used for a payment or refunded.
    @[NASON::Field(key: "uncaptured_funds", type: Bool)]
    property uncaptured_funds : Bool

    # Card brand. Can be `American Express`, `Diners Club`, `Discover`, `JCB`, `MasterCard`, `UnionPay`, `Visa`, or `Unknown`.
    @[NASON::Field(key: "brand", type: String)]
    property brand : String

    # Two-digit number representing the card's expiration month.
    @[NASON::Field(key: "exp_month", type: Int64)]
    property exp_month : Int64

    # Four-digit number representing the card's expiration year.
    @[NASON::Field(key: "exp_year", type: Int64)]
    property exp_year : Int64

    # Card funding type. Can be `credit`, `debit`, `prepaid`, or `unknown`.
    @[NASON::Field(key: "funding", type: String)]
    property funding : String

    # The client secret of the source. Used for client-side retrieval using a publishable key.
    @[NASON::Field(key: "client_secret", type: String)]
    property client_secret : String

    # The authentication `flow` of the source. `flow` is one of `redirect`, `receiver`, `code_verification`, `none`.
    @[NASON::Field(key: "flow", type: String)]
    property flow : String

    # Optional properties
    # Business information about the account.
    @[NASON::Field(key: "business_profile", type: AccountBusinessProfile? | Null, nillable: true)]
    property business_profile : AccountBusinessProfile? | Null

    # The business type.
    @[NASON::Field(key: "business_type", type: String? | Null, nillable: true)]
    property business_type : String? | Null

    @[NASON::Field(key: "capabilities", type: AccountCapabilities?, nillable: true)]
    property capabilities : AccountCapabilities?

    # Whether the account can create live charges.
    @[NASON::Field(key: "charges_enabled", type: Bool?, nillable: true)]
    property charges_enabled : Bool?

    @[NASON::Field(key: "company", type: LegalEntityCompany?, nillable: true)]
    property company : LegalEntityCompany?

    @[NASON::Field(key: "controller", type: AccountUnificationAccountController?, nillable: true)]
    property controller : AccountUnificationAccountController?

    # Three-letter ISO currency code representing the default currency for the account. This must be a currency that [Stripe supports in the account's country](https://stripe.com/docs/payouts).
    @[NASON::Field(key: "default_currency", type: String?, nillable: true)]
    property default_currency : String?

    # Whether account details have been submitted. Standard accounts cannot receive payouts before this is true.
    @[NASON::Field(key: "details_submitted", type: Bool?, nillable: true)]
    property details_submitted : Bool?

    # The customer's email address, set by the API call that creates the receiver.
    @[NASON::Field(key: "email", type: String? | Null, nillable: true)]
    property email : String? | Null

    @[NASON::Field(key: "external_accounts", type: ExternalAccountList1?, nillable: true)]
    property external_accounts : ExternalAccountList1?

    @[NASON::Field(key: "future_requirements", type: AccountFutureRequirements?, nillable: true)]
    property future_requirements : AccountFutureRequirements?

    @[NASON::Field(key: "individual", type: Person?, nillable: true)]
    property individual : Person?

    # Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    @[NASON::Field(key: "metadata", type: Hash(String, String)? | Null, nillable: true)]
    property metadata : Hash(String, String)? | Null

    # Whether Stripe can send payouts to this account.
    @[NASON::Field(key: "payouts_enabled", type: Bool?, nillable: true)]
    property payouts_enabled : Bool?

    @[NASON::Field(key: "requirements", type: AccountRequirements?, nillable: true)]
    property requirements : AccountRequirements?

    # Options for customizing how the account functions within Stripe.
    @[NASON::Field(key: "settings", type: AccountSettings? | Null, nillable: true)]
    property settings : AccountSettings? | Null

    @[NASON::Field(key: "tos_acceptance", type: AccountTosAcceptance?, nillable: true)]
    property tos_acceptance : AccountTosAcceptance?

    # The ID of the customer to which this source is attached. This will not be present when the source has not been attached to a customer.
    @[NASON::Field(key: "customer", type: String?, nillable: true)]
    property customer : String?

    # If the Alipay account object is not reusable, the exact amount that you can create a charge for.
    @[NASON::Field(key: "payment_amount", type: Int64? | Null, nillable: true)]
    property payment_amount : Int64? | Null

    # If the Alipay account object is not reusable, the exact currency that you can create a charge for.
    @[NASON::Field(key: "payment_currency", type: String? | Null, nillable: true)]
    property payment_currency : String? | Null

    # The account this card belongs to. This attribute will not be in the card object if the card belongs to a customer or recipient instead.
    @[NASON::Field(key: "account", type: String | Account? | Null, nillable: true)]
    property account : String | Account? | Null

    # The name of the person or business that owns the bank account.
    @[NASON::Field(key: "account_holder_name", type: String? | Null, nillable: true)]
    property account_holder_name : String? | Null

    # The type of entity that holds the account. This can be either `individual` or `company`.
    @[NASON::Field(key: "account_holder_type", type: String? | Null, nillable: true)]
    property account_holder_type : String? | Null

    # The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
    @[NASON::Field(key: "account_type", type: String? | Null, nillable: true)]
    property account_type : String? | Null

    # A set of available payout methods for this card. Only values from this set should be passed as the `method` when creating a payout.
    @[NASON::Field(key: "available_payout_methods", type: Array(String)? | Null, nillable: true)]
    property available_payout_methods : Array(String)? | Null

    # Name of the bank associated with the routing number (e.g., `WELLS FARGO`).
    @[NASON::Field(key: "bank_name", type: String? | Null, nillable: true)]
    property bank_name : String? | Null

    # Whether this card is the default external account for its currency.
    @[NASON::Field(key: "default_for_currency", type: Bool? | Null, nillable: true)]
    property default_for_currency : Bool? | Null

    # The routing transit number for the bank account.
    @[NASON::Field(key: "routing_number", type: String? | Null, nillable: true)]
    property routing_number : String? | Null

    # An arbitrary string attached to the object. Often useful for displaying to users.
    @[NASON::Field(key: "description", type: String? | Null, nillable: true)]
    property description : String? | Null

    # The ID of the payment created from the receiver, if any. Hidden when viewing the receiver with a publishable key.
    @[NASON::Field(key: "payment", type: String? | Null, nillable: true)]
    property payment : String? | Null

    # The refund address of this bitcoin receiver.
    @[NASON::Field(key: "refund_address", type: String? | Null, nillable: true)]
    property refund_address : String? | Null

    @[NASON::Field(key: "transactions", type: BitcoinTransactionList1?, nillable: true)]
    property transactions : BitcoinTransactionList1?

    # Indicate if this source is used for payment.
    @[NASON::Field(key: "used_for_payment", type: Bool? | Null, nillable: true)]
    property used_for_payment : Bool? | Null

    # City/District/Suburb/Town/Village.
    @[NASON::Field(key: "address_city", type: String? | Null, nillable: true)]
    property address_city : String? | Null

    # Billing address country, if provided when creating card.
    @[NASON::Field(key: "address_country", type: String? | Null, nillable: true)]
    property address_country : String? | Null

    # Address line 1 (Street address/PO Box/Company name).
    @[NASON::Field(key: "address_line1", type: String? | Null, nillable: true)]
    property address_line1 : String? | Null

    # If `address_line1` was provided, results of the check: `pass`, `fail`, `unavailable`, or `unchecked`.
    @[NASON::Field(key: "address_line1_check", type: String? | Null, nillable: true)]
    property address_line1_check : String? | Null

    # Address line 2 (Apartment/Suite/Unit/Building).
    @[NASON::Field(key: "address_line2", type: String? | Null, nillable: true)]
    property address_line2 : String? | Null

    # State/County/Province/Region.
    @[NASON::Field(key: "address_state", type: String? | Null, nillable: true)]
    property address_state : String? | Null

    # ZIP or postal code.
    @[NASON::Field(key: "address_zip", type: String? | Null, nillable: true)]
    property address_zip : String? | Null

    # If `address_zip` was provided, results of the check: `pass`, `fail`, `unavailable`, or `unchecked`.
    @[NASON::Field(key: "address_zip_check", type: String? | Null, nillable: true)]
    property address_zip_check : String? | Null

    # If a CVC was provided, results of the check: `pass`, `fail`, `unavailable`, or `unchecked`. A result of unchecked indicates that CVC was provided but hasn't been checked yet. Checks are typically performed when attaching a card to a Customer object, or when creating a charge. For more details, see [Check if a card is valid without a charge](https://support.stripe.com/questions/check-if-a-card-is-valid-without-a-charge).
    @[NASON::Field(key: "cvc_check", type: String? | Null, nillable: true)]
    property cvc_check : String? | Null

    # (For tokenized numbers only.) The last four digits of the device account number.
    @[NASON::Field(key: "dynamic_last4", type: String? | Null, nillable: true)]
    property dynamic_last4 : String? | Null

    # Cardholder name.
    @[NASON::Field(key: "name", type: String? | Null, nillable: true)]
    property name : String? | Null

    # The recipient that this card belongs to. This attribute will not be in the card object if the card belongs to a customer or account instead.
    @[NASON::Field(key: "recipient", type: String | Recipient? | Null, nillable: true)]
    property recipient : String | Recipient? | Null

    # If the card number is tokenized, this is the method that was used. Can be `android_pay` (includes Google Pay), `apple_pay`, `masterpass`, `visa_checkout`, or null.
    @[NASON::Field(key: "tokenization_method", type: String? | Null, nillable: true)]
    property tokenization_method : String? | Null

    @[NASON::Field(key: "ach_credit_transfer", type: SourceTypeAchCreditTransfer?, nillable: true)]
    property ach_credit_transfer : SourceTypeAchCreditTransfer?

    @[NASON::Field(key: "ach_debit", type: SourceTypeAchDebit?, nillable: true)]
    property ach_debit : SourceTypeAchDebit?

    @[NASON::Field(key: "acss_debit", type: SourceTypeAcssDebit?, nillable: true)]
    property acss_debit : SourceTypeAcssDebit?

    @[NASON::Field(key: "alipay", type: SourceTypeAlipay?, nillable: true)]
    property alipay : SourceTypeAlipay?

    @[NASON::Field(key: "au_becs_debit", type: SourceTypeAuBecsDebit?, nillable: true)]
    property au_becs_debit : SourceTypeAuBecsDebit?

    @[NASON::Field(key: "bancontact", type: SourceTypeBancontact?, nillable: true)]
    property bancontact : SourceTypeBancontact?

    @[NASON::Field(key: "card", type: SourceTypeCard?, nillable: true)]
    property card : SourceTypeCard?

    @[NASON::Field(key: "card_present", type: SourceTypeCardPresent?, nillable: true)]
    property card_present : SourceTypeCardPresent?

    @[NASON::Field(key: "code_verification", type: SourceCodeVerificationFlow?, nillable: true)]
    property code_verification : SourceCodeVerificationFlow?

    @[NASON::Field(key: "eps", type: SourceTypeEps?, nillable: true)]
    property eps : SourceTypeEps?

    @[NASON::Field(key: "giropay", type: SourceTypeGiropay?, nillable: true)]
    property giropay : SourceTypeGiropay?

    @[NASON::Field(key: "ideal", type: SourceTypeIdeal?, nillable: true)]
    property ideal : SourceTypeIdeal?

    @[NASON::Field(key: "klarna", type: SourceTypeKlarna?, nillable: true)]
    property klarna : SourceTypeKlarna?

    @[NASON::Field(key: "multibanco", type: SourceTypeMultibanco?, nillable: true)]
    property multibanco : SourceTypeMultibanco?

    # Information about the owner of the payment instrument that may be used or required by particular source types.
    @[NASON::Field(key: "owner", type: SourceOwner? | Null, nillable: true)]
    property owner : SourceOwner? | Null

    @[NASON::Field(key: "p24", type: SourceTypeP24?, nillable: true)]
    property p24 : SourceTypeP24?

    @[NASON::Field(key: "receiver", type: SourceReceiverFlow?, nillable: true)]
    property receiver : SourceReceiverFlow?

    @[NASON::Field(key: "redirect", type: SourceRedirectFlow?, nillable: true)]
    property redirect : SourceRedirectFlow?

    @[NASON::Field(key: "sepa_debit", type: SourceTypeSepaDebit?, nillable: true)]
    property sepa_debit : SourceTypeSepaDebit?

    @[NASON::Field(key: "sofort", type: SourceTypeSofort?, nillable: true)]
    property sofort : SourceTypeSofort?

    @[NASON::Field(key: "source_order", type: SourceOrder?, nillable: true)]
    property source_order : SourceOrder?

    # Extra information about a source. This will appear on your customer's statement every time you charge the source.
    @[NASON::Field(key: "statement_descriptor", type: String? | Null, nillable: true)]
    property statement_descriptor : String? | Null

    @[NASON::Field(key: "three_d_secure", type: SourceTypeThreeDSecure?, nillable: true)]
    property three_d_secure : SourceTypeThreeDSecure?

    # Either `reusable` or `single_use`. Whether this source should be reusable or not. Some source types may or may not be reusable by construction, while others may leave the option at creation. If an incompatible value is passed, an error will be returned.
    @[NASON::Field(key: "usage", type: String? | Null, nillable: true)]
    property usage : String? | Null

    @[NASON::Field(key: "wechat", type: SourceTypeWechat?, nillable: true)]
    property wechat : SourceTypeWechat?

    class EnumAttributeValidator
      getter datatype : String
      getter allowable_values : Array(String | Int64 | Float64)

      def initialize(datatype, allowable_values)
        @datatype = datatype
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        value.nil? || value.null? || allowable_values.includes?(value)
      end
    end

    # List of class defined in anyOf (OpenAPI v3)
    def self.openapi_any_of
      [
      Account,
      AlipayAccount,
      BankAccount,
      BitcoinReceiver,
      Card,
      Source
      ]
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(*, @country : String | Null, @created : Int64, @id : String, @object : String, @_type : String, @fingerprint : String | Null, @livemode : Bool, @reusable : Bool, @used : Bool, @username : String, @currency : String | Null, @last4 : String, @status : String, @active : Bool, @amount : Int64 | Null, @amount_received : Int64, @bitcoin_amount : Int64, @bitcoin_amount_received : Int64, @bitcoin_uri : String, @filled : Bool, @inbound_address : String, @uncaptured_funds : Bool, @brand : String, @exp_month : Int64, @exp_year : Int64, @funding : String, @client_secret : String, @flow : String, @business_profile : AccountBusinessProfile? | Null = nil, @business_type : String? | Null = nil, @capabilities : AccountCapabilities? = nil, @charges_enabled : Bool? = nil, @company : LegalEntityCompany? = nil, @controller : AccountUnificationAccountController? = nil, @default_currency : String? = nil, @details_submitted : Bool? = nil, @email : String? | Null = nil, @external_accounts : ExternalAccountList1? = nil, @future_requirements : AccountFutureRequirements? = nil, @individual : Person? = nil, @metadata : Hash(String, String)? | Null = nil, @payouts_enabled : Bool? = nil, @requirements : AccountRequirements? = nil, @settings : AccountSettings? | Null = nil, @tos_acceptance : AccountTosAcceptance? = nil, @customer : String? = nil, @payment_amount : Int64? | Null = nil, @payment_currency : String? | Null = nil, @account : String | Account? | Null = nil, @account_holder_name : String? | Null = nil, @account_holder_type : String? | Null = nil, @account_type : String? | Null = nil, @available_payout_methods : Array(String)? | Null = nil, @bank_name : String? | Null = nil, @default_for_currency : Bool? | Null = nil, @routing_number : String? | Null = nil, @description : String? | Null = nil, @payment : String? | Null = nil, @refund_address : String? | Null = nil, @transactions : BitcoinTransactionList1? = nil, @used_for_payment : Bool? | Null = nil, @address_city : String? | Null = nil, @address_country : String? | Null = nil, @address_line1 : String? | Null = nil, @address_line1_check : String? | Null = nil, @address_line2 : String? | Null = nil, @address_state : String? | Null = nil, @address_zip : String? | Null = nil, @address_zip_check : String? | Null = nil, @cvc_check : String? | Null = nil, @dynamic_last4 : String? | Null = nil, @name : String? | Null = nil, @recipient : String | Recipient? | Null = nil, @tokenization_method : String? | Null = nil, @ach_credit_transfer : SourceTypeAchCreditTransfer? = nil, @ach_debit : SourceTypeAchDebit? = nil, @acss_debit : SourceTypeAcssDebit? = nil, @alipay : SourceTypeAlipay? = nil, @au_becs_debit : SourceTypeAuBecsDebit? = nil, @bancontact : SourceTypeBancontact? = nil, @card : SourceTypeCard? = nil, @card_present : SourceTypeCardPresent? = nil, @code_verification : SourceCodeVerificationFlow? = nil, @eps : SourceTypeEps? = nil, @giropay : SourceTypeGiropay? = nil, @ideal : SourceTypeIdeal? = nil, @klarna : SourceTypeKlarna? = nil, @multibanco : SourceTypeMultibanco? = nil, @owner : SourceOwner? | Null = nil, @p24 : SourceTypeP24? = nil, @receiver : SourceReceiverFlow? = nil, @redirect : SourceRedirectFlow? = nil, @sepa_debit : SourceTypeSepaDebit? = nil, @sofort : SourceTypeSofort? = nil, @source_order : SourceOrder? = nil, @statement_descriptor : String? | Null = nil, @three_d_secure : SourceTypeThreeDSecure? = nil, @usage : String? | Null = nil, @wechat : SourceTypeWechat? = nil)
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array(String).new
      if !@country.null? && @country.to_s.size > 5000
        invalid_properties.push("invalid value for \"country\", the character length must be smaller than or equal to 5000.")
      end

      if !@default_currency.nil? && @default_currency.to_s.size > 5000
        invalid_properties.push("invalid value for \"default_currency\", the character length must be smaller than or equal to 5000.")
      end

      if !@email.nil? && !@email.null? && @email.to_s.size > 5000
        invalid_properties.push("invalid value for \"email\", the character length must be smaller than or equal to 5000.")
      end

      if @id.to_s.size > 5000
        invalid_properties.push("invalid value for \"id\", the character length must be smaller than or equal to 5000.")
      end

      if !@customer.nil? && @customer.to_s.size > 5000
        invalid_properties.push("invalid value for \"customer\", the character length must be smaller than or equal to 5000.")
      end

      if !@fingerprint.null? && @fingerprint.to_s.size > 5000
        invalid_properties.push("invalid value for \"fingerprint\", the character length must be smaller than or equal to 5000.")
      end

      if @username.to_s.size > 5000
        invalid_properties.push("invalid value for \"username\", the character length must be smaller than or equal to 5000.")
      end

      if !@account_holder_name.nil? && !@account_holder_name.null? && @account_holder_name.to_s.size > 5000
        invalid_properties.push("invalid value for \"account_holder_name\", the character length must be smaller than or equal to 5000.")
      end

      if !@account_holder_type.nil? && !@account_holder_type.null? && @account_holder_type.to_s.size > 5000
        invalid_properties.push("invalid value for \"account_holder_type\", the character length must be smaller than or equal to 5000.")
      end

      if !@account_type.nil? && !@account_type.null? && @account_type.to_s.size > 5000
        invalid_properties.push("invalid value for \"account_type\", the character length must be smaller than or equal to 5000.")
      end

      if !@bank_name.nil? && !@bank_name.null? && @bank_name.to_s.size > 5000
        invalid_properties.push("invalid value for \"bank_name\", the character length must be smaller than or equal to 5000.")
      end

      if @last4.to_s.size > 5000
        invalid_properties.push("invalid value for \"last4\", the character length must be smaller than or equal to 5000.")
      end

      if !@routing_number.nil? && !@routing_number.null? && @routing_number.to_s.size > 5000
        invalid_properties.push("invalid value for \"routing_number\", the character length must be smaller than or equal to 5000.")
      end

      if @status.to_s.size > 5000
        invalid_properties.push("invalid value for \"status\", the character length must be smaller than or equal to 5000.")
      end

      if @bitcoin_uri.to_s.size > 5000
        invalid_properties.push("invalid value for \"bitcoin_uri\", the character length must be smaller than or equal to 5000.")
      end

      if !@description.nil? && !@description.null? && @description.to_s.size > 5000
        invalid_properties.push("invalid value for \"description\", the character length must be smaller than or equal to 5000.")
      end

      if @inbound_address.to_s.size > 5000
        invalid_properties.push("invalid value for \"inbound_address\", the character length must be smaller than or equal to 5000.")
      end

      if !@payment.nil? && !@payment.null? && @payment.to_s.size > 5000
        invalid_properties.push("invalid value for \"payment\", the character length must be smaller than or equal to 5000.")
      end

      if !@refund_address.nil? && !@refund_address.null? && @refund_address.to_s.size > 5000
        invalid_properties.push("invalid value for \"refund_address\", the character length must be smaller than or equal to 5000.")
      end

      if !@address_city.nil? && !@address_city.null? && @address_city.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_city\", the character length must be smaller than or equal to 5000.")
      end

      if !@address_country.nil? && !@address_country.null? && @address_country.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_country\", the character length must be smaller than or equal to 5000.")
      end

      if !@address_line1.nil? && !@address_line1.null? && @address_line1.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_line1\", the character length must be smaller than or equal to 5000.")
      end

      if !@address_line1_check.nil? && !@address_line1_check.null? && @address_line1_check.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_line1_check\", the character length must be smaller than or equal to 5000.")
      end

      if !@address_line2.nil? && !@address_line2.null? && @address_line2.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_line2\", the character length must be smaller than or equal to 5000.")
      end

      if !@address_state.nil? && !@address_state.null? && @address_state.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_state\", the character length must be smaller than or equal to 5000.")
      end

      if !@address_zip.nil? && !@address_zip.null? && @address_zip.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_zip\", the character length must be smaller than or equal to 5000.")
      end

      if !@address_zip_check.nil? && !@address_zip_check.null? && @address_zip_check.to_s.size > 5000
        invalid_properties.push("invalid value for \"address_zip_check\", the character length must be smaller than or equal to 5000.")
      end

      if @brand.to_s.size > 5000
        invalid_properties.push("invalid value for \"brand\", the character length must be smaller than or equal to 5000.")
      end

      if !@cvc_check.nil? && !@cvc_check.null? && @cvc_check.to_s.size > 5000
        invalid_properties.push("invalid value for \"cvc_check\", the character length must be smaller than or equal to 5000.")
      end

      if !@dynamic_last4.nil? && !@dynamic_last4.null? && @dynamic_last4.to_s.size > 5000
        invalid_properties.push("invalid value for \"dynamic_last4\", the character length must be smaller than or equal to 5000.")
      end

      if @funding.to_s.size > 5000
        invalid_properties.push("invalid value for \"funding\", the character length must be smaller than or equal to 5000.")
      end

      if !@name.nil? && !@name.null? && @name.to_s.size > 5000
        invalid_properties.push("invalid value for \"name\", the character length must be smaller than or equal to 5000.")
      end

      if !@tokenization_method.nil? && !@tokenization_method.null? && @tokenization_method.to_s.size > 5000
        invalid_properties.push("invalid value for \"tokenization_method\", the character length must be smaller than or equal to 5000.")
      end

      if @client_secret.to_s.size > 5000
        invalid_properties.push("invalid value for \"client_secret\", the character length must be smaller than or equal to 5000.")
      end

      if @flow.to_s.size > 5000
        invalid_properties.push("invalid value for \"flow\", the character length must be smaller than or equal to 5000.")
      end

      if !@statement_descriptor.nil? && !@statement_descriptor.null? && @statement_descriptor.to_s.size > 5000
        invalid_properties.push("invalid value for \"statement_descriptor\", the character length must be smaller than or equal to 5000.")
      end

      if !@usage.nil? && !@usage.null? && @usage.to_s.size > 5000
        invalid_properties.push("invalid value for \"usage\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      business_type_validator = EnumAttributeValidator.new("String", ["company", "government_entity", "individual", "non_profit"])
      return false unless business_type_validator.valid?(@business_type)
      return false if !@country.null? && @country.to_s.size > 5000
      return false if !@default_currency.nil? && @default_currency.to_s.size > 5000
      return false if !@email.nil? && !@email.null? && @email.to_s.size > 5000
      return false if @id.to_s.size > 5000
      object_validator = EnumAttributeValidator.new("String", ["source"])
      return false unless object_validator.valid?(@object)
      _type_validator = EnumAttributeValidator.new("String", ["ach_credit_transfer", "ach_debit", "acss_debit", "alipay", "au_becs_debit", "bancontact", "card", "card_present", "eps", "giropay", "ideal", "klarna", "multibanco", "p24", "sepa_debit", "sofort", "three_d_secure", "wechat"])
      return false unless _type_validator.valid?(@_type)
      return false if !@customer.nil? && @customer.to_s.size > 5000
      return false if !@fingerprint.null? && @fingerprint.to_s.size > 5000
      return false if @username.to_s.size > 5000
      return false if !@account_holder_name.nil? && !@account_holder_name.null? && @account_holder_name.to_s.size > 5000
      return false if !@account_holder_type.nil? && !@account_holder_type.null? && @account_holder_type.to_s.size > 5000
      return false if !@account_type.nil? && !@account_type.null? && @account_type.to_s.size > 5000
      return false if !@bank_name.nil? && !@bank_name.null? && @bank_name.to_s.size > 5000
      return false if @last4.to_s.size > 5000
      return false if !@routing_number.nil? && !@routing_number.null? && @routing_number.to_s.size > 5000
      return false if @status.to_s.size > 5000
      return false if @bitcoin_uri.to_s.size > 5000
      return false if !@description.nil? && !@description.null? && @description.to_s.size > 5000
      return false if @inbound_address.to_s.size > 5000
      return false if !@payment.nil? && !@payment.null? && @payment.to_s.size > 5000
      return false if !@refund_address.nil? && !@refund_address.null? && @refund_address.to_s.size > 5000
      return false if !@address_city.nil? && !@address_city.null? && @address_city.to_s.size > 5000
      return false if !@address_country.nil? && !@address_country.null? && @address_country.to_s.size > 5000
      return false if !@address_line1.nil? && !@address_line1.null? && @address_line1.to_s.size > 5000
      return false if !@address_line1_check.nil? && !@address_line1_check.null? && @address_line1_check.to_s.size > 5000
      return false if !@address_line2.nil? && !@address_line2.null? && @address_line2.to_s.size > 5000
      return false if !@address_state.nil? && !@address_state.null? && @address_state.to_s.size > 5000
      return false if !@address_zip.nil? && !@address_zip.null? && @address_zip.to_s.size > 5000
      return false if !@address_zip_check.nil? && !@address_zip_check.null? && @address_zip_check.to_s.size > 5000
      return false if @brand.to_s.size > 5000
      return false if !@cvc_check.nil? && !@cvc_check.null? && @cvc_check.to_s.size > 5000
      return false if !@dynamic_last4.nil? && !@dynamic_last4.null? && @dynamic_last4.to_s.size > 5000
      return false if @funding.to_s.size > 5000
      return false if !@name.nil? && !@name.null? && @name.to_s.size > 5000
      return false if !@tokenization_method.nil? && !@tokenization_method.null? && @tokenization_method.to_s.size > 5000
      return false if @client_secret.to_s.size > 5000
      return false if @flow.to_s.size > 5000
      return false if !@statement_descriptor.nil? && !@statement_descriptor.null? && @statement_descriptor.to_s.size > 5000
      return false if !@usage.nil? && !@usage.null? && @usage.to_s.size > 5000
      _any_of_found = false
      self.class.openapi_any_of.each do |_class|
        _any_of = Stripe.const_get(_class).build_from_hash(self.to_hash)
        if _any_of.valid?
          _any_of_found = true
        end
      end

      if !_any_of_found
        return false
      end

      true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] business_type Object to be assigned
    def business_type=(business_type)
      validator = EnumAttributeValidator.new("String", ["company", "government_entity", "individual", "non_profit"])
      unless validator.valid?(business_type)
        raise ArgumentError.new("invalid value for \"business_type\", must be one of #{validator.allowable_values}.")
      end
      @business_type = business_type
    end

    # Custom attribute writer method with validation
    # @param [Object] country Value to be assigned
    def country=(country)
      if !@country.null? && country.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"country\", the character length must be smaller than or equal to 5000.")
      end

      @country = country
    end

    # Custom attribute writer method with validation
    # @param [Object] default_currency Value to be assigned
    def default_currency=(default_currency)
      if !default_currency.nil? && default_currency.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"default_currency\", the character length must be smaller than or equal to 5000.")
      end

      @default_currency = default_currency
    end

    # Custom attribute writer method with validation
    # @param [Object] email Value to be assigned
    def email=(email)
      if !email.nil? && !@email.null? && email.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"email\", the character length must be smaller than or equal to 5000.")
      end

      @email = email
    end

    # Custom attribute writer method with validation
    # @param [Object] id Value to be assigned
    def id=(id)
      if id.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"id\", the character length must be smaller than or equal to 5000.")
      end

      @id = id
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] object Object to be assigned
    def object=(object)
      validator = EnumAttributeValidator.new("String", ["source"])
      unless validator.valid?(object)
        raise ArgumentError.new("invalid value for \"object\", must be one of #{validator.allowable_values}.")
      end
      @object = object
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] _type Object to be assigned
    def _type=(_type)
      validator = EnumAttributeValidator.new("String", ["ach_credit_transfer", "ach_debit", "acss_debit", "alipay", "au_becs_debit", "bancontact", "card", "card_present", "eps", "giropay", "ideal", "klarna", "multibanco", "p24", "sepa_debit", "sofort", "three_d_secure", "wechat"])
      unless validator.valid?(_type)
        raise ArgumentError.new("invalid value for \"_type\", must be one of #{validator.allowable_values}.")
      end
      @_type = _type
    end

    # Custom attribute writer method with validation
    # @param [Object] customer Value to be assigned
    def customer=(customer)
      if !customer.nil? && customer.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"customer\", the character length must be smaller than or equal to 5000.")
      end

      @customer = customer
    end

    # Custom attribute writer method with validation
    # @param [Object] fingerprint Value to be assigned
    def fingerprint=(fingerprint)
      if !@fingerprint.null? && fingerprint.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"fingerprint\", the character length must be smaller than or equal to 5000.")
      end

      @fingerprint = fingerprint
    end

    # Custom attribute writer method with validation
    # @param [Object] username Value to be assigned
    def username=(username)
      if username.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"username\", the character length must be smaller than or equal to 5000.")
      end

      @username = username
    end

    # Custom attribute writer method with validation
    # @param [Object] account_holder_name Value to be assigned
    def account_holder_name=(account_holder_name)
      if !account_holder_name.nil? && !@account_holder_name.null? && account_holder_name.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"account_holder_name\", the character length must be smaller than or equal to 5000.")
      end

      @account_holder_name = account_holder_name
    end

    # Custom attribute writer method with validation
    # @param [Object] account_holder_type Value to be assigned
    def account_holder_type=(account_holder_type)
      if !account_holder_type.nil? && !@account_holder_type.null? && account_holder_type.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"account_holder_type\", the character length must be smaller than or equal to 5000.")
      end

      @account_holder_type = account_holder_type
    end

    # Custom attribute writer method with validation
    # @param [Object] account_type Value to be assigned
    def account_type=(account_type)
      if !account_type.nil? && !@account_type.null? && account_type.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"account_type\", the character length must be smaller than or equal to 5000.")
      end

      @account_type = account_type
    end

    # Custom attribute writer method with validation
    # @param [Object] bank_name Value to be assigned
    def bank_name=(bank_name)
      if !bank_name.nil? && !@bank_name.null? && bank_name.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"bank_name\", the character length must be smaller than or equal to 5000.")
      end

      @bank_name = bank_name
    end

    # Custom attribute writer method with validation
    # @param [Object] last4 Value to be assigned
    def last4=(last4)
      if last4.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"last4\", the character length must be smaller than or equal to 5000.")
      end

      @last4 = last4
    end

    # Custom attribute writer method with validation
    # @param [Object] routing_number Value to be assigned
    def routing_number=(routing_number)
      if !routing_number.nil? && !@routing_number.null? && routing_number.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"routing_number\", the character length must be smaller than or equal to 5000.")
      end

      @routing_number = routing_number
    end

    # Custom attribute writer method with validation
    # @param [Object] status Value to be assigned
    def status=(status)
      if status.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"status\", the character length must be smaller than or equal to 5000.")
      end

      @status = status
    end

    # Custom attribute writer method with validation
    # @param [Object] bitcoin_uri Value to be assigned
    def bitcoin_uri=(bitcoin_uri)
      if bitcoin_uri.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"bitcoin_uri\", the character length must be smaller than or equal to 5000.")
      end

      @bitcoin_uri = bitcoin_uri
    end

    # Custom attribute writer method with validation
    # @param [Object] description Value to be assigned
    def description=(description)
      if !description.nil? && !@description.null? && description.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"description\", the character length must be smaller than or equal to 5000.")
      end

      @description = description
    end

    # Custom attribute writer method with validation
    # @param [Object] inbound_address Value to be assigned
    def inbound_address=(inbound_address)
      if inbound_address.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"inbound_address\", the character length must be smaller than or equal to 5000.")
      end

      @inbound_address = inbound_address
    end

    # Custom attribute writer method with validation
    # @param [Object] payment Value to be assigned
    def payment=(payment)
      if !payment.nil? && !@payment.null? && payment.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"payment\", the character length must be smaller than or equal to 5000.")
      end

      @payment = payment
    end

    # Custom attribute writer method with validation
    # @param [Object] refund_address Value to be assigned
    def refund_address=(refund_address)
      if !refund_address.nil? && !@refund_address.null? && refund_address.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"refund_address\", the character length must be smaller than or equal to 5000.")
      end

      @refund_address = refund_address
    end

    # Custom attribute writer method with validation
    # @param [Object] address_city Value to be assigned
    def address_city=(address_city)
      if !address_city.nil? && !@address_city.null? && address_city.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_city\", the character length must be smaller than or equal to 5000.")
      end

      @address_city = address_city
    end

    # Custom attribute writer method with validation
    # @param [Object] address_country Value to be assigned
    def address_country=(address_country)
      if !address_country.nil? && !@address_country.null? && address_country.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_country\", the character length must be smaller than or equal to 5000.")
      end

      @address_country = address_country
    end

    # Custom attribute writer method with validation
    # @param [Object] address_line1 Value to be assigned
    def address_line1=(address_line1)
      if !address_line1.nil? && !@address_line1.null? && address_line1.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_line1\", the character length must be smaller than or equal to 5000.")
      end

      @address_line1 = address_line1
    end

    # Custom attribute writer method with validation
    # @param [Object] address_line1_check Value to be assigned
    def address_line1_check=(address_line1_check)
      if !address_line1_check.nil? && !@address_line1_check.null? && address_line1_check.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_line1_check\", the character length must be smaller than or equal to 5000.")
      end

      @address_line1_check = address_line1_check
    end

    # Custom attribute writer method with validation
    # @param [Object] address_line2 Value to be assigned
    def address_line2=(address_line2)
      if !address_line2.nil? && !@address_line2.null? && address_line2.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_line2\", the character length must be smaller than or equal to 5000.")
      end

      @address_line2 = address_line2
    end

    # Custom attribute writer method with validation
    # @param [Object] address_state Value to be assigned
    def address_state=(address_state)
      if !address_state.nil? && !@address_state.null? && address_state.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_state\", the character length must be smaller than or equal to 5000.")
      end

      @address_state = address_state
    end

    # Custom attribute writer method with validation
    # @param [Object] address_zip Value to be assigned
    def address_zip=(address_zip)
      if !address_zip.nil? && !@address_zip.null? && address_zip.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_zip\", the character length must be smaller than or equal to 5000.")
      end

      @address_zip = address_zip
    end

    # Custom attribute writer method with validation
    # @param [Object] address_zip_check Value to be assigned
    def address_zip_check=(address_zip_check)
      if !address_zip_check.nil? && !@address_zip_check.null? && address_zip_check.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"address_zip_check\", the character length must be smaller than or equal to 5000.")
      end

      @address_zip_check = address_zip_check
    end

    # Custom attribute writer method with validation
    # @param [Object] brand Value to be assigned
    def brand=(brand)
      if brand.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"brand\", the character length must be smaller than or equal to 5000.")
      end

      @brand = brand
    end

    # Custom attribute writer method with validation
    # @param [Object] cvc_check Value to be assigned
    def cvc_check=(cvc_check)
      if !cvc_check.nil? && !@cvc_check.null? && cvc_check.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"cvc_check\", the character length must be smaller than or equal to 5000.")
      end

      @cvc_check = cvc_check
    end

    # Custom attribute writer method with validation
    # @param [Object] dynamic_last4 Value to be assigned
    def dynamic_last4=(dynamic_last4)
      if !dynamic_last4.nil? && !@dynamic_last4.null? && dynamic_last4.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"dynamic_last4\", the character length must be smaller than or equal to 5000.")
      end

      @dynamic_last4 = dynamic_last4
    end

    # Custom attribute writer method with validation
    # @param [Object] funding Value to be assigned
    def funding=(funding)
      if funding.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"funding\", the character length must be smaller than or equal to 5000.")
      end

      @funding = funding
    end

    # Custom attribute writer method with validation
    # @param [Object] name Value to be assigned
    def name=(name)
      if !name.nil? && !@name.null? && name.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"name\", the character length must be smaller than or equal to 5000.")
      end

      @name = name
    end

    # Custom attribute writer method with validation
    # @param [Object] tokenization_method Value to be assigned
    def tokenization_method=(tokenization_method)
      if !tokenization_method.nil? && !@tokenization_method.null? && tokenization_method.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"tokenization_method\", the character length must be smaller than or equal to 5000.")
      end

      @tokenization_method = tokenization_method
    end

    # Custom attribute writer method with validation
    # @param [Object] client_secret Value to be assigned
    def client_secret=(client_secret)
      if client_secret.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"client_secret\", the character length must be smaller than or equal to 5000.")
      end

      @client_secret = client_secret
    end

    # Custom attribute writer method with validation
    # @param [Object] flow Value to be assigned
    def flow=(flow)
      if flow.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"flow\", the character length must be smaller than or equal to 5000.")
      end

      @flow = flow
    end

    # Custom attribute writer method with validation
    # @param [Object] statement_descriptor Value to be assigned
    def statement_descriptor=(statement_descriptor)
      if !statement_descriptor.nil? && !@statement_descriptor.null? && statement_descriptor.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"statement_descriptor\", the character length must be smaller than or equal to 5000.")
      end

      @statement_descriptor = statement_descriptor
    end

    # Custom attribute writer method with validation
    # @param [Object] usage Value to be assigned
    def usage=(usage)
      if !usage.nil? && !@usage.null? && usage.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"usage\", the character length must be smaller than or equal to 5000.")
      end

      @usage = usage
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.same?(o)
      self.class == o.class &&
        business_profile == o.business_profile &&
        business_type == o.business_type &&
        capabilities == o.capabilities &&
        charges_enabled == o.charges_enabled &&
        company == o.company &&
        controller == o.controller &&
        country == o.country &&
        created == o.created &&
        default_currency == o.default_currency &&
        details_submitted == o.details_submitted &&
        email == o.email &&
        external_accounts == o.external_accounts &&
        future_requirements == o.future_requirements &&
        id == o.id &&
        individual == o.individual &&
        metadata == o.metadata &&
        object == o.object &&
        payouts_enabled == o.payouts_enabled &&
        requirements == o.requirements &&
        settings == o.settings &&
        tos_acceptance == o.tos_acceptance &&
        _type == o._type &&
        customer == o.customer &&
        fingerprint == o.fingerprint &&
        livemode == o.livemode &&
        payment_amount == o.payment_amount &&
        payment_currency == o.payment_currency &&
        reusable == o.reusable &&
        used == o.used &&
        username == o.username &&
        account == o.account &&
        account_holder_name == o.account_holder_name &&
        account_holder_type == o.account_holder_type &&
        account_type == o.account_type &&
        available_payout_methods == o.available_payout_methods &&
        bank_name == o.bank_name &&
        currency == o.currency &&
        default_for_currency == o.default_for_currency &&
        last4 == o.last4 &&
        routing_number == o.routing_number &&
        status == o.status &&
        active == o.active &&
        amount == o.amount &&
        amount_received == o.amount_received &&
        bitcoin_amount == o.bitcoin_amount &&
        bitcoin_amount_received == o.bitcoin_amount_received &&
        bitcoin_uri == o.bitcoin_uri &&
        description == o.description &&
        filled == o.filled &&
        inbound_address == o.inbound_address &&
        payment == o.payment &&
        refund_address == o.refund_address &&
        transactions == o.transactions &&
        uncaptured_funds == o.uncaptured_funds &&
        used_for_payment == o.used_for_payment &&
        address_city == o.address_city &&
        address_country == o.address_country &&
        address_line1 == o.address_line1 &&
        address_line1_check == o.address_line1_check &&
        address_line2 == o.address_line2 &&
        address_state == o.address_state &&
        address_zip == o.address_zip &&
        address_zip_check == o.address_zip_check &&
        brand == o.brand &&
        cvc_check == o.cvc_check &&
        dynamic_last4 == o.dynamic_last4 &&
        exp_month == o.exp_month &&
        exp_year == o.exp_year &&
        funding == o.funding &&
        name == o.name &&
        recipient == o.recipient &&
        tokenization_method == o.tokenization_method &&
        ach_credit_transfer == o.ach_credit_transfer &&
        ach_debit == o.ach_debit &&
        acss_debit == o.acss_debit &&
        alipay == o.alipay &&
        au_becs_debit == o.au_becs_debit &&
        bancontact == o.bancontact &&
        card == o.card &&
        card_present == o.card_present &&
        client_secret == o.client_secret &&
        code_verification == o.code_verification &&
        eps == o.eps &&
        flow == o.flow &&
        giropay == o.giropay &&
        ideal == o.ideal &&
        klarna == o.klarna &&
        multibanco == o.multibanco &&
        owner == o.owner &&
        p24 == o.p24 &&
        receiver == o.receiver &&
        redirect == o.redirect &&
        sepa_debit == o.sepa_debit &&
        sofort == o.sofort &&
        source_order == o.source_order &&
        statement_descriptor == o.statement_descriptor &&
        three_d_secure == o.three_d_secure &&
        usage == o.usage &&
        wechat == o.wechat
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [business_profile, business_type, capabilities, charges_enabled, company, controller, country, created, default_currency, details_submitted, email, external_accounts, future_requirements, id, individual, metadata, object, payouts_enabled, requirements, settings, tos_acceptance, _type, customer, fingerprint, livemode, payment_amount, payment_currency, reusable, used, username, account, account_holder_name, account_holder_type, account_type, available_payout_methods, bank_name, currency, default_for_currency, last4, routing_number, status, active, amount, amount_received, bitcoin_amount, bitcoin_amount_received, bitcoin_uri, description, filled, inbound_address, payment, refund_address, transactions, uncaptured_funds, used_for_payment, address_city, address_country, address_line1, address_line1_check, address_line2, address_state, address_zip, address_zip_check, brand, cvc_check, dynamic_last4, exp_month, exp_year, funding, name, recipient, tokenization_method, ach_credit_transfer, ach_debit, acss_debit, alipay, au_becs_debit, bancontact, card, card_present, client_secret, code_verification, eps, flow, giropay, ideal, klarna, multibanco, owner, p24, receiver, redirect, sepa_debit, sofort, source_order, statement_descriptor, three_d_secure, usage, wechat].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      new.build_from_hash(attributes)
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.openapi_types.each_pair do |key, type|
        if !attributes[self.class.attribute_map[key]]? && self.class.openapi_nullable.includes?(key)
          self.send("#{key}=", nil)
        elsif type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :Time
        Time.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        ({} of String => String).tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        # models (e.g. Pet) or oneOf
        klass = Stripe.const_get(type)
        klass.respond_to?(:openapi_one_of) ? klass.build(value) : klass.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {} of String => String
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.includes?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end

        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        ({} of String => String).tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
