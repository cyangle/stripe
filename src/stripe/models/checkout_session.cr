#  Stripe API
#
# The Stripe REST API. Please see https://stripe.com/docs/api for more details.
#
# The version of the OpenAPI document: 2020-08-27
# Contact: dev-platform@stripe.com
# Generated by: https://openapi-generator.tech
#

require "json"
require "time"
require "log"

module Stripe
  # A Checkout Session represents your customer's session as they pay for one-time purchases or subscriptions through [Checkout](https://stripe.com/docs/payments/checkout) or [Payment Links](https://stripe.com/docs/payments/payment-links). We recommend creating a new Session each time your customer attempts to pay.  Once payment is successful, the Checkout Session will contain a reference to the [Customer](https://stripe.com/docs/api/customers), and either the successful [PaymentIntent](https://stripe.com/docs/api/payment_intents) or an active [Subscription](https://stripe.com/docs/api/subscriptions).  You can create a Checkout Session on your server and pass its ID to the client to begin Checkout.  Related guide: [Checkout Server Quickstart](https://stripe.com/docs/payments/checkout/api).
  @[JSON::Serializable::Options(emit_nulls: true)]
  class CheckoutSession
    include JSON::Serializable
    include JSON::Serializable::Unmapped

    # Required properties
    @[JSON::Field(key: "after_expiration", type: CheckoutSessionAfterExpiration?, presence: true, ignore_serialize: after_expiration.nil? && !after_expiration_present?)]
    property after_expiration : CheckoutSessionAfterExpiration?

    @[JSON::Field(ignore: true)]
    property? after_expiration_present : Bool = false

    # Enables user redeemable promotion codes.
    @[JSON::Field(key: "allow_promotion_codes", type: Bool?, presence: true, ignore_serialize: allow_promotion_codes.nil? && !allow_promotion_codes_present?)]
    property allow_promotion_codes : Bool?

    @[JSON::Field(ignore: true)]
    property? allow_promotion_codes_present : Bool = false

    # Total of all items before discounts or taxes are applied.
    @[JSON::Field(key: "amount_subtotal", type: Int64?, presence: true, ignore_serialize: amount_subtotal.nil? && !amount_subtotal_present?)]
    property amount_subtotal : Int64?

    @[JSON::Field(ignore: true)]
    property? amount_subtotal_present : Bool = false

    # Total of all items after discounts and taxes are applied.
    @[JSON::Field(key: "amount_total", type: Int64?, presence: true, ignore_serialize: amount_total.nil? && !amount_total_present?)]
    property amount_total : Int64?

    @[JSON::Field(ignore: true)]
    property? amount_total_present : Bool = false

    @[JSON::Field(key: "automatic_tax", type: PaymentPagesCheckoutSessionAutomaticTax)]
    property automatic_tax : PaymentPagesCheckoutSessionAutomaticTax

    # Describes whether Checkout should collect the customer's billing address.
    @[JSON::Field(key: "billing_address_collection", type: String?, presence: true, ignore_serialize: billing_address_collection.nil? && !billing_address_collection_present?)]
    getter billing_address_collection : String?

    @[JSON::Field(ignore: true)]
    property? billing_address_collection_present : Bool = false

    ENUM_VALIDATOR_FOR_BILLING_ADDRESS_COLLECTION = EnumValidator.new("billing_address_collection", "String", ["auto", "required", "null"])

    # The URL the customer will be directed to if they decide to cancel payment and return to your website.
    @[JSON::Field(key: "cancel_url", type: String)]
    getter cancel_url : String

    # A unique string to reference the Checkout Session. This can be a customer ID, a cart ID, or similar, and can be used to reconcile the Session with your internal systems.
    @[JSON::Field(key: "client_reference_id", type: String?, presence: true, ignore_serialize: client_reference_id.nil? && !client_reference_id_present?)]
    getter client_reference_id : String?

    @[JSON::Field(ignore: true)]
    property? client_reference_id_present : Bool = false

    @[JSON::Field(key: "consent", type: CheckoutSessionConsent?, presence: true, ignore_serialize: consent.nil? && !consent_present?)]
    property consent : CheckoutSessionConsent?

    @[JSON::Field(ignore: true)]
    property? consent_present : Bool = false

    @[JSON::Field(key: "consent_collection", type: CheckoutSessionConsentCollection?, presence: true, ignore_serialize: consent_collection.nil? && !consent_collection_present?)]
    property consent_collection : CheckoutSessionConsentCollection?

    @[JSON::Field(ignore: true)]
    property? consent_collection_present : Bool = false

    # Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    @[JSON::Field(key: "currency", type: String?, presence: true, ignore_serialize: currency.nil? && !currency_present?)]
    property currency : String?

    @[JSON::Field(ignore: true)]
    property? currency_present : Bool = false

    @[JSON::Field(key: "customer", type: CheckoutSessionCustomer?, presence: true, ignore_serialize: customer.nil? && !customer_present?)]
    property customer : CheckoutSessionCustomer?

    @[JSON::Field(ignore: true)]
    property? customer_present : Bool = false

    # Configure whether a Checkout Session creates a Customer when the Checkout Session completes.
    @[JSON::Field(key: "customer_creation", type: String?, presence: true, ignore_serialize: customer_creation.nil? && !customer_creation_present?)]
    getter customer_creation : String?

    @[JSON::Field(ignore: true)]
    property? customer_creation_present : Bool = false

    ENUM_VALIDATOR_FOR_CUSTOMER_CREATION = EnumValidator.new("customer_creation", "String", ["always", "if_required", "null"])

    @[JSON::Field(key: "customer_details", type: CheckoutSessionCustomerDetails?, presence: true, ignore_serialize: customer_details.nil? && !customer_details_present?)]
    property customer_details : CheckoutSessionCustomerDetails?

    @[JSON::Field(ignore: true)]
    property? customer_details_present : Bool = false

    # If provided, this value will be used when the Customer object is created. If not provided, customers will be asked to enter their email address. Use this parameter to prefill customer data if you already have an email on file. To access information about the customer once the payment flow is complete, use the `customer` attribute.
    @[JSON::Field(key: "customer_email", type: String?, presence: true, ignore_serialize: customer_email.nil? && !customer_email_present?)]
    getter customer_email : String?

    @[JSON::Field(ignore: true)]
    property? customer_email_present : Bool = false

    # The timestamp at which the Checkout Session will expire.
    @[JSON::Field(key: "expires_at", type: Int64)]
    property expires_at : Int64

    # Unique identifier for the object. Used to pass to `redirectToCheckout` in Stripe.js.
    @[JSON::Field(key: "id", type: String)]
    getter id : String

    # Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    @[JSON::Field(key: "livemode", type: Bool)]
    property livemode : Bool

    # The IETF language tag of the locale Checkout is displayed in. If blank or `auto`, the browser's locale is used.
    @[JSON::Field(key: "locale", type: String?, presence: true, ignore_serialize: locale.nil? && !locale_present?)]
    getter locale : String?

    @[JSON::Field(ignore: true)]
    property? locale_present : Bool = false

    ENUM_VALIDATOR_FOR_LOCALE = EnumValidator.new("locale", "String", ["auto", "bg", "cs", "da", "de", "el", "en", "en-GB", "es", "es-419", "et", "fi", "fil", "fr", "fr-CA", "hr", "hu", "id", "it", "ja", "ko", "lt", "lv", "ms", "mt", "nb", "nl", "pl", "pt", "pt-BR", "ro", "ru", "sk", "sl", "sv", "th", "tr", "vi", "zh", "zh-HK", "zh-TW", "null"])

    # Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    @[JSON::Field(key: "metadata", type: Hash(String, String)?, presence: true, ignore_serialize: metadata.nil? && !metadata_present?)]
    property metadata : Hash(String, String)?

    @[JSON::Field(ignore: true)]
    property? metadata_present : Bool = false

    # The mode of the Checkout Session.
    @[JSON::Field(key: "mode", type: String)]
    getter mode : String

    ENUM_VALIDATOR_FOR_MODE = EnumValidator.new("mode", "String", ["payment", "setup", "subscription"])

    # String representing the object's type. Objects of the same type share the same value.
    @[JSON::Field(key: "object", type: String)]
    getter object : String

    ENUM_VALIDATOR_FOR_OBJECT = EnumValidator.new("object", "String", ["checkout.session"])

    @[JSON::Field(key: "payment_intent", type: CheckoutSessionPaymentIntent?, presence: true, ignore_serialize: payment_intent.nil? && !payment_intent_present?)]
    property payment_intent : CheckoutSessionPaymentIntent?

    @[JSON::Field(ignore: true)]
    property? payment_intent_present : Bool = false

    @[JSON::Field(key: "payment_link", type: CheckoutSessionPaymentLink?, presence: true, ignore_serialize: payment_link.nil? && !payment_link_present?)]
    property payment_link : CheckoutSessionPaymentLink?

    @[JSON::Field(ignore: true)]
    property? payment_link_present : Bool = false

    @[JSON::Field(key: "payment_method_options", type: CheckoutSessionPaymentMethodOptions1?, presence: true, ignore_serialize: payment_method_options.nil? && !payment_method_options_present?)]
    property payment_method_options : CheckoutSessionPaymentMethodOptions1?

    @[JSON::Field(ignore: true)]
    property? payment_method_options_present : Bool = false

    @[JSON::Field(key: "payment_method_types", type: Array(String))]
    property payment_method_types : Array(String)

    # The payment status of the Checkout Session, one of `paid`, `unpaid`, or `no_payment_required`. You can use this value to decide when to fulfill your customer's order.
    @[JSON::Field(key: "payment_status", type: String)]
    getter payment_status : String

    ENUM_VALIDATOR_FOR_PAYMENT_STATUS = EnumValidator.new("payment_status", "String", ["no_payment_required", "paid", "unpaid"])

    # The ID of the original expired Checkout Session that triggered the recovery flow.
    @[JSON::Field(key: "recovered_from", type: String?, presence: true, ignore_serialize: recovered_from.nil? && !recovered_from_present?)]
    getter recovered_from : String?

    @[JSON::Field(ignore: true)]
    property? recovered_from_present : Bool = false

    @[JSON::Field(key: "setup_intent", type: CheckoutSessionSetupIntent?, presence: true, ignore_serialize: setup_intent.nil? && !setup_intent_present?)]
    property setup_intent : CheckoutSessionSetupIntent?

    @[JSON::Field(ignore: true)]
    property? setup_intent_present : Bool = false

    @[JSON::Field(key: "shipping", type: CheckoutSessionShipping?, presence: true, ignore_serialize: shipping.nil? && !shipping_present?)]
    property shipping : CheckoutSessionShipping?

    @[JSON::Field(ignore: true)]
    property? shipping_present : Bool = false

    @[JSON::Field(key: "shipping_address_collection", type: CheckoutSessionShippingAddressCollection?, presence: true, ignore_serialize: shipping_address_collection.nil? && !shipping_address_collection_present?)]
    property shipping_address_collection : CheckoutSessionShippingAddressCollection?

    @[JSON::Field(ignore: true)]
    property? shipping_address_collection_present : Bool = false

    # The shipping rate options applied to this Session.
    @[JSON::Field(key: "shipping_options", type: Array(PaymentPagesCheckoutSessionShippingOption))]
    property shipping_options : Array(PaymentPagesCheckoutSessionShippingOption)

    @[JSON::Field(key: "shipping_rate", type: CheckoutSessionShippingRate?, presence: true, ignore_serialize: shipping_rate.nil? && !shipping_rate_present?)]
    property shipping_rate : CheckoutSessionShippingRate?

    @[JSON::Field(ignore: true)]
    property? shipping_rate_present : Bool = false

    # The status of the Checkout Session, one of `open`, `complete`, or `expired`.
    @[JSON::Field(key: "status", type: String?, presence: true, ignore_serialize: status.nil? && !status_present?)]
    getter status : String?

    @[JSON::Field(ignore: true)]
    property? status_present : Bool = false

    ENUM_VALIDATOR_FOR_STATUS = EnumValidator.new("status", "String", ["complete", "expired", "open", "null"])

    # Describes the type of transaction being performed by Checkout in order to customize relevant text on the page, such as the submit button. `submit_type` can only be specified on Checkout Sessions in `payment` mode, but not Checkout Sessions in `subscription` or `setup` mode.
    @[JSON::Field(key: "submit_type", type: String?, presence: true, ignore_serialize: submit_type.nil? && !submit_type_present?)]
    getter submit_type : String?

    @[JSON::Field(ignore: true)]
    property? submit_type_present : Bool = false

    ENUM_VALIDATOR_FOR_SUBMIT_TYPE = EnumValidator.new("submit_type", "String", ["auto", "book", "donate", "pay", "null"])

    @[JSON::Field(key: "subscription", type: CheckoutSessionSubscription?, presence: true, ignore_serialize: subscription.nil? && !subscription_present?)]
    property subscription : CheckoutSessionSubscription?

    @[JSON::Field(ignore: true)]
    property? subscription_present : Bool = false

    # The URL the customer will be directed to after the payment or subscription creation is successful.
    @[JSON::Field(key: "success_url", type: String)]
    getter success_url : String

    @[JSON::Field(key: "total_details", type: CheckoutSessionTotalDetails?, presence: true, ignore_serialize: total_details.nil? && !total_details_present?)]
    property total_details : CheckoutSessionTotalDetails?

    @[JSON::Field(ignore: true)]
    property? total_details_present : Bool = false

    # The URL to the Checkout Session. Redirect customers to this URL to take them to Checkout. If you’re using [Custom Domains](https://stripe.com/docs/payments/checkout/custom-domains), the URL will use your subdomain. Otherwise, it’ll use `checkout.stripe.com.`
    @[JSON::Field(key: "url", type: String?, presence: true, ignore_serialize: url.nil? && !url_present?)]
    getter url : String?

    @[JSON::Field(ignore: true)]
    property? url_present : Bool = false

    # Optional properties
    @[JSON::Field(key: "line_items", type: PaymentPagesCheckoutSessionListLineItems1?, presence: true, ignore_serialize: line_items.nil? && !line_items_present?)]
    property line_items : PaymentPagesCheckoutSessionListLineItems1?

    @[JSON::Field(ignore: true)]
    property? line_items_present : Bool = false

    @[JSON::Field(key: "phone_number_collection", type: PaymentPagesCheckoutSessionPhoneNumberCollection?, presence: true, ignore_serialize: phone_number_collection.nil? && !phone_number_collection_present?)]
    property phone_number_collection : PaymentPagesCheckoutSessionPhoneNumberCollection?

    @[JSON::Field(ignore: true)]
    property? phone_number_collection_present : Bool = false

    @[JSON::Field(key: "tax_id_collection", type: PaymentPagesCheckoutSessionTaxIdCollection?, presence: true, ignore_serialize: tax_id_collection.nil? && !tax_id_collection_present?)]
    property tax_id_collection : PaymentPagesCheckoutSessionTaxIdCollection?

    @[JSON::Field(ignore: true)]
    property? tax_id_collection_present : Bool = false

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(*, @after_expiration : CheckoutSessionAfterExpiration?, @allow_promotion_codes : Bool?, @amount_subtotal : Int64?, @amount_total : Int64?, @automatic_tax : PaymentPagesCheckoutSessionAutomaticTax, @billing_address_collection : String?, @cancel_url : String, @client_reference_id : String?, @consent : CheckoutSessionConsent?, @consent_collection : CheckoutSessionConsentCollection?, @currency : String?, @customer : CheckoutSessionCustomer?, @customer_creation : String?, @customer_details : CheckoutSessionCustomerDetails?, @customer_email : String?, @expires_at : Int64, @id : String, @livemode : Bool, @locale : String?, @metadata : Hash(String, String)?, @mode : String, @object : String, @payment_intent : CheckoutSessionPaymentIntent?, @payment_link : CheckoutSessionPaymentLink?, @payment_method_options : CheckoutSessionPaymentMethodOptions1?, @payment_method_types : Array(String), @payment_status : String, @recovered_from : String?, @setup_intent : CheckoutSessionSetupIntent?, @shipping : CheckoutSessionShipping?, @shipping_address_collection : CheckoutSessionShippingAddressCollection?, @shipping_options : Array(PaymentPagesCheckoutSessionShippingOption), @shipping_rate : CheckoutSessionShippingRate?, @status : String?, @submit_type : String?, @subscription : CheckoutSessionSubscription?, @success_url : String, @total_details : CheckoutSessionTotalDetails?, @url : String?, @line_items : PaymentPagesCheckoutSessionListLineItems1? = nil, @phone_number_collection : PaymentPagesCheckoutSessionPhoneNumberCollection? = nil, @tax_id_collection : PaymentPagesCheckoutSessionTaxIdCollection? = nil)
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array(String).new

      invalid_properties.push(ENUM_VALIDATOR_FOR_BILLING_ADDRESS_COLLECTION.error_message) unless ENUM_VALIDATOR_FOR_BILLING_ADDRESS_COLLECTION.valid?(@billing_address_collection)

      if @cancel_url.to_s.size > 5000
        invalid_properties.push("invalid value for \"cancel_url\", the character length must be smaller than or equal to 5000.")
      end

      if @client_reference_id.to_s.size > 5000
        invalid_properties.push("invalid value for \"client_reference_id\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties.push(ENUM_VALIDATOR_FOR_CUSTOMER_CREATION.error_message) unless ENUM_VALIDATOR_FOR_CUSTOMER_CREATION.valid?(@customer_creation)

      if @customer_email.to_s.size > 5000
        invalid_properties.push("invalid value for \"customer_email\", the character length must be smaller than or equal to 5000.")
      end

      if @id.to_s.size > 5000
        invalid_properties.push("invalid value for \"id\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties.push(ENUM_VALIDATOR_FOR_LOCALE.error_message) unless ENUM_VALIDATOR_FOR_LOCALE.valid?(@locale)

      invalid_properties.push(ENUM_VALIDATOR_FOR_MODE.error_message) unless ENUM_VALIDATOR_FOR_MODE.valid?(@mode, false)

      invalid_properties.push(ENUM_VALIDATOR_FOR_OBJECT.error_message) unless ENUM_VALIDATOR_FOR_OBJECT.valid?(@object, false)

      invalid_properties.push(ENUM_VALIDATOR_FOR_PAYMENT_STATUS.error_message) unless ENUM_VALIDATOR_FOR_PAYMENT_STATUS.valid?(@payment_status, false)

      if @recovered_from.to_s.size > 5000
        invalid_properties.push("invalid value for \"recovered_from\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties.push(ENUM_VALIDATOR_FOR_STATUS.error_message) unless ENUM_VALIDATOR_FOR_STATUS.valid?(@status)

      invalid_properties.push(ENUM_VALIDATOR_FOR_SUBMIT_TYPE.error_message) unless ENUM_VALIDATOR_FOR_SUBMIT_TYPE.valid?(@submit_type)

      if @success_url.to_s.size > 5000
        invalid_properties.push("invalid value for \"success_url\", the character length must be smaller than or equal to 5000.")
      end

      if @url.to_s.size > 5000
        invalid_properties.push("invalid value for \"url\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false unless ENUM_VALIDATOR_FOR_BILLING_ADDRESS_COLLECTION.valid?(@billing_address_collection)
      return false if @cancel_url.to_s.size > 5000
      return false if @client_reference_id.to_s.size > 5000
      return false unless ENUM_VALIDATOR_FOR_CUSTOMER_CREATION.valid?(@customer_creation)
      return false if @customer_email.to_s.size > 5000
      return false if @id.to_s.size > 5000
      return false unless ENUM_VALIDATOR_FOR_LOCALE.valid?(@locale)
      return false unless ENUM_VALIDATOR_FOR_MODE.valid?(@mode, false)
      return false unless ENUM_VALIDATOR_FOR_OBJECT.valid?(@object, false)
      return false unless ENUM_VALIDATOR_FOR_PAYMENT_STATUS.valid?(@payment_status, false)
      return false if @recovered_from.to_s.size > 5000
      return false unless ENUM_VALIDATOR_FOR_STATUS.valid?(@status)
      return false unless ENUM_VALIDATOR_FOR_SUBMIT_TYPE.valid?(@submit_type)
      return false if @success_url.to_s.size > 5000
      return false if @url.to_s.size > 5000
      true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] billing_address_collection Object to be assigned
    def billing_address_collection=(billing_address_collection)
      ENUM_VALIDATOR_FOR_BILLING_ADDRESS_COLLECTION.valid!(billing_address_collection)
      @billing_address_collection = billing_address_collection
    end

    # Custom attribute writer method with validation
    # @param [Object] cancel_url Value to be assigned
    def cancel_url=(cancel_url)
      if cancel_url.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"cancel_url\", the character length must be smaller than or equal to 5000.")
      end

      @cancel_url = cancel_url
    end

    # Custom attribute writer method with validation
    # @param [Object] client_reference_id Value to be assigned
    def client_reference_id=(client_reference_id)
      if client_reference_id.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"client_reference_id\", the character length must be smaller than or equal to 5000.")
      end

      @client_reference_id = client_reference_id
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] customer_creation Object to be assigned
    def customer_creation=(customer_creation)
      ENUM_VALIDATOR_FOR_CUSTOMER_CREATION.valid!(customer_creation)
      @customer_creation = customer_creation
    end

    # Custom attribute writer method with validation
    # @param [Object] customer_email Value to be assigned
    def customer_email=(customer_email)
      if customer_email.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"customer_email\", the character length must be smaller than or equal to 5000.")
      end

      @customer_email = customer_email
    end

    # Custom attribute writer method with validation
    # @param [Object] id Value to be assigned
    def id=(id)
      if id.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"id\", the character length must be smaller than or equal to 5000.")
      end

      @id = id
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] locale Object to be assigned
    def locale=(locale)
      ENUM_VALIDATOR_FOR_LOCALE.valid!(locale)
      @locale = locale
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] mode Object to be assigned
    def mode=(mode)
      ENUM_VALIDATOR_FOR_MODE.valid!(mode, false)
      @mode = mode
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] object Object to be assigned
    def object=(object)
      ENUM_VALIDATOR_FOR_OBJECT.valid!(object, false)
      @object = object
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] payment_status Object to be assigned
    def payment_status=(payment_status)
      ENUM_VALIDATOR_FOR_PAYMENT_STATUS.valid!(payment_status, false)
      @payment_status = payment_status
    end

    # Custom attribute writer method with validation
    # @param [Object] recovered_from Value to be assigned
    def recovered_from=(recovered_from)
      if recovered_from.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"recovered_from\", the character length must be smaller than or equal to 5000.")
      end

      @recovered_from = recovered_from
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] status Object to be assigned
    def status=(status)
      ENUM_VALIDATOR_FOR_STATUS.valid!(status)
      @status = status
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] submit_type Object to be assigned
    def submit_type=(submit_type)
      ENUM_VALIDATOR_FOR_SUBMIT_TYPE.valid!(submit_type)
      @submit_type = submit_type
    end

    # Custom attribute writer method with validation
    # @param [Object] success_url Value to be assigned
    def success_url=(success_url)
      if success_url.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"success_url\", the character length must be smaller than or equal to 5000.")
      end

      @success_url = success_url
    end

    # Custom attribute writer method with validation
    # @param [Object] url Value to be assigned
    def url=(url)
      if url.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"url\", the character length must be smaller than or equal to 5000.")
      end

      @url = url
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.same?(o)
      self.class == o.class &&
        after_expiration == o.after_expiration &&
        allow_promotion_codes == o.allow_promotion_codes &&
        amount_subtotal == o.amount_subtotal &&
        amount_total == o.amount_total &&
        automatic_tax == o.automatic_tax &&
        billing_address_collection == o.billing_address_collection &&
        cancel_url == o.cancel_url &&
        client_reference_id == o.client_reference_id &&
        consent == o.consent &&
        consent_collection == o.consent_collection &&
        currency == o.currency &&
        customer == o.customer &&
        customer_creation == o.customer_creation &&
        customer_details == o.customer_details &&
        customer_email == o.customer_email &&
        expires_at == o.expires_at &&
        id == o.id &&
        line_items == o.line_items &&
        livemode == o.livemode &&
        locale == o.locale &&
        metadata == o.metadata &&
        mode == o.mode &&
        object == o.object &&
        payment_intent == o.payment_intent &&
        payment_link == o.payment_link &&
        payment_method_options == o.payment_method_options &&
        payment_method_types == o.payment_method_types &&
        payment_status == o.payment_status &&
        phone_number_collection == o.phone_number_collection &&
        recovered_from == o.recovered_from &&
        setup_intent == o.setup_intent &&
        shipping == o.shipping &&
        shipping_address_collection == o.shipping_address_collection &&
        shipping_options == o.shipping_options &&
        shipping_rate == o.shipping_rate &&
        status == o.status &&
        submit_type == o.submit_type &&
        subscription == o.subscription &&
        success_url == o.success_url &&
        tax_id_collection == o.tax_id_collection &&
        total_details == o.total_details &&
        url == o.url
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [UInt64] Hash code
    def_hash(@after_expiration, @allow_promotion_codes, @amount_subtotal, @amount_total, @automatic_tax, @billing_address_collection, @cancel_url, @client_reference_id, @consent, @consent_collection, @currency, @customer, @customer_creation, @customer_details, @customer_email, @expires_at, @id, @line_items, @livemode, @locale, @metadata, @mode, @object, @payment_intent, @payment_link, @payment_method_options, @payment_method_types, @payment_status, @phone_number_collection, @recovered_from, @setup_intent, @shipping, @shipping_address_collection, @shipping_options, @shipping_rate, @status, @submit_type, @subscription, @success_url, @tax_id_collection, @total_details, @url)
  end
end
