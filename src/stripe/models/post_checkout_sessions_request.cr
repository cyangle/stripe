#  Stripe API
#
# The Stripe REST API. Please see https://stripe.com/docs/api for more details.
#
# The version of the OpenAPI document: 2020-08-27
# Contact: dev-platform@stripe.com
# Generated by: https://openapi-generator.tech
#

require "json"
require "time"
require "log"

module Stripe
  @[JSON::Serializable::Options(emit_nulls: true)]
  class PostCheckoutSessionsRequest
    include JSON::Serializable
    include JSON::Serializable::Unmapped

    # Required properties

    # The URL the customer will be directed to if they decide to cancel payment and return to your website.
    @[JSON::Field(key: "cancel_url", type: String)]
    getter cancel_url : String

    # The URL to which Stripe should send customers when payment or setup is complete. If you’d like to use information from the successful Checkout Session on your page, read the guide on [customizing your success page](https://stripe.com/docs/payments/checkout/custom-success-page).
    @[JSON::Field(key: "success_url", type: String)]
    getter success_url : String

    # Optional properties

    @[JSON::Field(key: "after_expiration", type: AfterExpirationParams?, presence: true, ignore_serialize: after_expiration.nil? && !after_expiration_present?)]
    property after_expiration : AfterExpirationParams?

    @[JSON::Field(ignore: true)]
    property? after_expiration_present : Bool = false

    # Enables user redeemable promotion codes.
    @[JSON::Field(key: "allow_promotion_codes", type: Bool?, presence: true, ignore_serialize: allow_promotion_codes.nil? && !allow_promotion_codes_present?)]
    property allow_promotion_codes : Bool?

    @[JSON::Field(ignore: true)]
    property? allow_promotion_codes_present : Bool = false

    @[JSON::Field(key: "automatic_tax", type: AutomaticTaxParams?, presence: true, ignore_serialize: automatic_tax.nil? && !automatic_tax_present?)]
    property automatic_tax : AutomaticTaxParams?

    @[JSON::Field(ignore: true)]
    property? automatic_tax_present : Bool = false

    # Specify whether Checkout should collect the customer's billing address.
    @[JSON::Field(key: "billing_address_collection", type: String?, presence: true, ignore_serialize: billing_address_collection.nil? && !billing_address_collection_present?)]
    getter billing_address_collection : String?

    @[JSON::Field(ignore: true)]
    property? billing_address_collection_present : Bool = false

    ENUM_VALIDATOR_FOR_BILLING_ADDRESS_COLLECTION = EnumValidator.new("billing_address_collection", "String", ["auto", "required"])

    # A unique string to reference the Checkout Session. This can be a customer ID, a cart ID, or similar, and can be used to reconcile the session with your internal systems.
    @[JSON::Field(key: "client_reference_id", type: String?, presence: true, ignore_serialize: client_reference_id.nil? && !client_reference_id_present?)]
    getter client_reference_id : String?

    @[JSON::Field(ignore: true)]
    property? client_reference_id_present : Bool = false

    @[JSON::Field(key: "consent_collection", type: ConsentCollectionParams?, presence: true, ignore_serialize: consent_collection.nil? && !consent_collection_present?)]
    property consent_collection : ConsentCollectionParams?

    @[JSON::Field(ignore: true)]
    property? consent_collection_present : Bool = false

    # ID of an existing Customer, if one exists. In `payment` mode, the customer’s most recent card payment method will be used to prefill the email, name, card details, and billing address on the Checkout page. In `subscription` mode, the customer’s [default payment method](https://stripe.com/docs/api/customers/update#update_customer-invoice_settings-default_payment_method) will be used if it’s a card, and otherwise the most recent card will be used. A valid billing address, billing name and billing email are required on the payment method for Checkout to prefill the customer's card details.  If the Customer already has a valid [email](https://stripe.com/docs/api/customers/object#customer_object-email) set, the email will be prefilled and not editable in Checkout. If the Customer does not have a valid `email`, Checkout will set the email entered during the session on the Customer.  If blank for Checkout Sessions in `payment` or `subscription` mode, Checkout will create a new Customer object based on information provided during the payment flow.  You can set [`payment_intent_data.setup_future_usage`](https://stripe.com/docs/api/checkout/sessions/create#create_checkout_session-payment_intent_data-setup_future_usage) to have Checkout automatically attach the payment method to the Customer you pass in for future reuse.
    @[JSON::Field(key: "customer", type: String?, presence: true, ignore_serialize: customer.nil? && !customer_present?)]
    getter customer : String?

    @[JSON::Field(ignore: true)]
    property? customer_present : Bool = false

    # Configure whether a Checkout Session creates a [Customer](https://stripe.com/docs/api/customers) during Session confirmation.  When a Customer is not created, you can still retrieve email, address, and other customer data entered in Checkout with [customer_details](https://stripe.com/docs/api/checkout/sessions/object#checkout_session_object-customer_details).  Sessions that don't create Customers instead create [Guest Customers](https://support.stripe.com/questions/guest-customer-faq) in the Dashboard. Promotion codes limited to first time customers will return invalid for these Sessions.  Can only be set in `payment` and `setup` mode.
    @[JSON::Field(key: "customer_creation", type: String?, presence: true, ignore_serialize: customer_creation.nil? && !customer_creation_present?)]
    getter customer_creation : String?

    @[JSON::Field(ignore: true)]
    property? customer_creation_present : Bool = false

    ENUM_VALIDATOR_FOR_CUSTOMER_CREATION = EnumValidator.new("customer_creation", "String", ["always", "if_required"])

    # If provided, this value will be used when the Customer object is created. If not provided, customers will be asked to enter their email address. Use this parameter to prefill customer data if you already have an email on file. To access information about the customer once a session is complete, use the `customer` field.
    @[JSON::Field(key: "customer_email", type: String?, presence: true, ignore_serialize: customer_email.nil? && !customer_email_present?)]
    property customer_email : String?

    @[JSON::Field(ignore: true)]
    property? customer_email_present : Bool = false

    @[JSON::Field(key: "customer_update", type: CustomerUpdateParams?, presence: true, ignore_serialize: customer_update.nil? && !customer_update_present?)]
    property customer_update : CustomerUpdateParams?

    @[JSON::Field(ignore: true)]
    property? customer_update_present : Bool = false

    # The coupon or promotion code to apply to this Session. Currently, only up to one may be specified.
    @[JSON::Field(key: "discounts", type: Array(DiscountParams)?, presence: true, ignore_serialize: discounts.nil? && !discounts_present?)]
    property discounts : Array(DiscountParams)?

    @[JSON::Field(ignore: true)]
    property? discounts_present : Bool = false

    # Specifies which fields in the response should be expanded.
    @[JSON::Field(key: "expand", type: Array(String)?, presence: true, ignore_serialize: expand.nil? && !expand_present?)]
    property expand : Array(String)?

    @[JSON::Field(ignore: true)]
    property? expand_present : Bool = false

    # The Epoch time in seconds at which the Checkout Session will expire. It can be anywhere from 1 to 24 hours after Checkout Session creation. By default, this value is 24 hours from creation.
    @[JSON::Field(key: "expires_at", type: Int64?, presence: true, ignore_serialize: expires_at.nil? && !expires_at_present?)]
    property expires_at : Int64?

    @[JSON::Field(ignore: true)]
    property? expires_at_present : Bool = false

    # A list of items the customer is purchasing. Use this parameter to pass one-time or recurring [Prices](https://stripe.com/docs/api/prices).  For `payment` mode, there is a maximum of 100 line items, however it is recommended to consolidate line items if there are more than a few dozen.  For `subscription` mode, there is a maximum of 20 line items with recurring Prices and 20 line items with one-time Prices. Line items with one-time Prices in will be on the initial invoice only.
    @[JSON::Field(key: "line_items", type: Array(LineItemParams)?, presence: true, ignore_serialize: line_items.nil? && !line_items_present?)]
    property line_items : Array(LineItemParams)?

    @[JSON::Field(ignore: true)]
    property? line_items_present : Bool = false

    # The IETF language tag of the locale Checkout is displayed in. If blank or `auto`, the browser's locale is used.
    @[JSON::Field(key: "locale", type: String?, presence: true, ignore_serialize: locale.nil? && !locale_present?)]
    getter locale : String?

    @[JSON::Field(ignore: true)]
    property? locale_present : Bool = false

    ENUM_VALIDATOR_FOR_LOCALE = EnumValidator.new("locale", "String", ["auto", "bg", "cs", "da", "de", "el", "en", "en-GB", "es", "es-419", "et", "fi", "fil", "fr", "fr-CA", "hr", "hu", "id", "it", "ja", "ko", "lt", "lv", "ms", "mt", "nb", "nl", "pl", "pt", "pt-BR", "ro", "ru", "sk", "sl", "sv", "th", "tr", "vi", "zh", "zh-HK", "zh-TW"])

    # Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
    @[JSON::Field(key: "metadata", type: Hash(String, String)?, presence: true, ignore_serialize: metadata.nil? && !metadata_present?)]
    property metadata : Hash(String, String)?

    @[JSON::Field(ignore: true)]
    property? metadata_present : Bool = false

    # The mode of the Checkout Session. Required when using prices or `setup` mode. Pass `subscription` if the Checkout Session includes at least one recurring item.
    @[JSON::Field(key: "mode", type: String?, presence: true, ignore_serialize: mode.nil? && !mode_present?)]
    getter mode : String?

    @[JSON::Field(ignore: true)]
    property? mode_present : Bool = false

    ENUM_VALIDATOR_FOR_MODE = EnumValidator.new("mode", "String", ["payment", "setup", "subscription"])

    @[JSON::Field(key: "payment_intent_data", type: PaymentIntentDataParams?, presence: true, ignore_serialize: payment_intent_data.nil? && !payment_intent_data_present?)]
    property payment_intent_data : PaymentIntentDataParams?

    @[JSON::Field(ignore: true)]
    property? payment_intent_data_present : Bool = false

    @[JSON::Field(key: "payment_method_options", type: PaymentMethodOptionsParam?, presence: true, ignore_serialize: payment_method_options.nil? && !payment_method_options_present?)]
    property payment_method_options : PaymentMethodOptionsParam?

    @[JSON::Field(ignore: true)]
    property? payment_method_options_present : Bool = false

    # A list of the types of payment methods (e.g., `card`) this Checkout Session can accept.  Do not include this attribute if you prefer to manage your payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods).  Read more about the supported payment methods and their requirements in our [payment method details guide](/docs/payments/checkout/payment-methods).  If multiple payment methods are passed, Checkout will dynamically reorder them to prioritize the most relevant payment methods based on the customer's location and other characteristics.
    @[JSON::Field(key: "payment_method_types", type: Array(String)?, presence: true, ignore_serialize: payment_method_types.nil? && !payment_method_types_present?)]
    getter payment_method_types : Array(String)?

    @[JSON::Field(ignore: true)]
    property? payment_method_types_present : Bool = false

    ENUM_VALIDATOR_FOR_PAYMENT_METHOD_TYPES = EnumValidator.new("payment_method_types", "String", ["acss_debit", "affirm", "afterpay_clearpay", "alipay", "au_becs_debit", "bacs_debit", "bancontact", "boleto", "card", "eps", "fpx", "giropay", "grabpay", "ideal", "klarna", "konbini", "oxxo", "p24", "paynow", "sepa_debit", "sofort", "us_bank_account", "wechat_pay"])

    @[JSON::Field(key: "phone_number_collection", type: PhoneNumberCollectionParams?, presence: true, ignore_serialize: phone_number_collection.nil? && !phone_number_collection_present?)]
    property phone_number_collection : PhoneNumberCollectionParams?

    @[JSON::Field(ignore: true)]
    property? phone_number_collection_present : Bool = false

    @[JSON::Field(key: "setup_intent_data", type: SetupIntentDataParam?, presence: true, ignore_serialize: setup_intent_data.nil? && !setup_intent_data_present?)]
    property setup_intent_data : SetupIntentDataParam?

    @[JSON::Field(ignore: true)]
    property? setup_intent_data_present : Bool = false

    @[JSON::Field(key: "shipping_address_collection", type: ShippingAddressCollectionParams?, presence: true, ignore_serialize: shipping_address_collection.nil? && !shipping_address_collection_present?)]
    property shipping_address_collection : ShippingAddressCollectionParams?

    @[JSON::Field(ignore: true)]
    property? shipping_address_collection_present : Bool = false

    # The shipping rate options to apply to this Session.
    @[JSON::Field(key: "shipping_options", type: Array(ShippingOptionParams)?, presence: true, ignore_serialize: shipping_options.nil? && !shipping_options_present?)]
    property shipping_options : Array(ShippingOptionParams)?

    @[JSON::Field(ignore: true)]
    property? shipping_options_present : Bool = false

    # Describes the type of transaction being performed by Checkout in order to customize relevant text on the page, such as the submit button. `submit_type` can only be specified on Checkout Sessions in `payment` mode, but not Checkout Sessions in `subscription` or `setup` mode.
    @[JSON::Field(key: "submit_type", type: String?, presence: true, ignore_serialize: submit_type.nil? && !submit_type_present?)]
    getter submit_type : String?

    @[JSON::Field(ignore: true)]
    property? submit_type_present : Bool = false

    ENUM_VALIDATOR_FOR_SUBMIT_TYPE = EnumValidator.new("submit_type", "String", ["auto", "book", "donate", "pay"])

    @[JSON::Field(key: "subscription_data", type: SubscriptionDataParams?, presence: true, ignore_serialize: subscription_data.nil? && !subscription_data_present?)]
    property subscription_data : SubscriptionDataParams?

    @[JSON::Field(ignore: true)]
    property? subscription_data_present : Bool = false

    @[JSON::Field(key: "tax_id_collection", type: TaxIdCollectionParams?, presence: true, ignore_serialize: tax_id_collection.nil? && !tax_id_collection_present?)]
    property tax_id_collection : TaxIdCollectionParams?

    @[JSON::Field(ignore: true)]
    property? tax_id_collection_present : Bool = false

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(
      *,
      # Required properties
      @cancel_url : String,
      @success_url : String,
      # Optional properties
      @after_expiration : AfterExpirationParams? = nil,
      @allow_promotion_codes : Bool? = nil,
      @automatic_tax : AutomaticTaxParams? = nil,
      @billing_address_collection : String? = nil,
      @client_reference_id : String? = nil,
      @consent_collection : ConsentCollectionParams? = nil,
      @customer : String? = nil,
      @customer_creation : String? = nil,
      @customer_email : String? = nil,
      @customer_update : CustomerUpdateParams? = nil,
      @discounts : Array(DiscountParams)? = nil,
      @expand : Array(String)? = nil,
      @expires_at : Int64? = nil,
      @line_items : Array(LineItemParams)? = nil,
      @locale : String? = nil,
      @metadata : Hash(String, String)? = nil,
      @mode : String? = nil,
      @payment_intent_data : PaymentIntentDataParams? = nil,
      @payment_method_options : PaymentMethodOptionsParam? = nil,
      @payment_method_types : Array(String)? = nil,
      @phone_number_collection : PhoneNumberCollectionParams? = nil,
      @setup_intent_data : SetupIntentDataParam? = nil,
      @shipping_address_collection : ShippingAddressCollectionParams? = nil,
      @shipping_options : Array(ShippingOptionParams)? = nil,
      @submit_type : String? = nil,
      @subscription_data : SubscriptionDataParams? = nil,
      @tax_id_collection : TaxIdCollectionParams? = nil
    )
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array(String).new

      if @cancel_url.to_s.size > 5000
        invalid_properties.push("invalid value for \"cancel_url\", the character length must be smaller than or equal to 5000.")
      end

      if @success_url.to_s.size > 5000
        invalid_properties.push("invalid value for \"success_url\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties.push(ENUM_VALIDATOR_FOR_BILLING_ADDRESS_COLLECTION.error_message) unless ENUM_VALIDATOR_FOR_BILLING_ADDRESS_COLLECTION.valid?(@billing_address_collection)

      if !@client_reference_id.nil? && @client_reference_id.to_s.size > 200
        invalid_properties.push("invalid value for \"client_reference_id\", the character length must be smaller than or equal to 200.")
      end

      if !@customer.nil? && @customer.to_s.size > 5000
        invalid_properties.push("invalid value for \"customer\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties.push(ENUM_VALIDATOR_FOR_CUSTOMER_CREATION.error_message) unless ENUM_VALIDATOR_FOR_CUSTOMER_CREATION.valid?(@customer_creation)

      invalid_properties.push(ENUM_VALIDATOR_FOR_LOCALE.error_message) unless ENUM_VALIDATOR_FOR_LOCALE.valid?(@locale)

      invalid_properties.push(ENUM_VALIDATOR_FOR_MODE.error_message) unless ENUM_VALIDATOR_FOR_MODE.valid?(@mode)

      invalid_properties.push(ENUM_VALIDATOR_FOR_PAYMENT_METHOD_TYPES.error_message) unless ENUM_VALIDATOR_FOR_PAYMENT_METHOD_TYPES.all_valid?(@payment_method_types)

      invalid_properties.push(ENUM_VALIDATOR_FOR_SUBMIT_TYPE.error_message) unless ENUM_VALIDATOR_FOR_SUBMIT_TYPE.valid?(@submit_type)

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if @cancel_url.to_s.size > 5000
      return false if @success_url.to_s.size > 5000
      return false unless ENUM_VALIDATOR_FOR_BILLING_ADDRESS_COLLECTION.valid?(@billing_address_collection)
      return false if !@client_reference_id.nil? && @client_reference_id.to_s.size > 200
      return false if !@customer.nil? && @customer.to_s.size > 5000
      return false unless ENUM_VALIDATOR_FOR_CUSTOMER_CREATION.valid?(@customer_creation)
      return false unless ENUM_VALIDATOR_FOR_LOCALE.valid?(@locale)
      return false unless ENUM_VALIDATOR_FOR_MODE.valid?(@mode)
      return false unless ENUM_VALIDATOR_FOR_PAYMENT_METHOD_TYPES.all_valid?(@payment_method_types)
      return false unless ENUM_VALIDATOR_FOR_SUBMIT_TYPE.valid?(@submit_type)

      true
    end

    # Custom attribute writer method with validation
    # @param [Object] cancel_url Value to be assigned
    def cancel_url=(cancel_url)
      if cancel_url.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"cancel_url\", the character length must be smaller than or equal to 5000.")
      end

      @cancel_url = cancel_url
    end

    # Custom attribute writer method with validation
    # @param [Object] success_url Value to be assigned
    def success_url=(success_url)
      if success_url.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"success_url\", the character length must be smaller than or equal to 5000.")
      end

      @success_url = success_url
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] billing_address_collection Object to be assigned
    def billing_address_collection=(billing_address_collection)
      ENUM_VALIDATOR_FOR_BILLING_ADDRESS_COLLECTION.valid!(billing_address_collection)
      @billing_address_collection = billing_address_collection
    end

    # Custom attribute writer method with validation
    # @param [Object] client_reference_id Value to be assigned
    def client_reference_id=(client_reference_id)
      if !client_reference_id.nil? && client_reference_id.to_s.size > 200
        raise ArgumentError.new("invalid value for \"client_reference_id\", the character length must be smaller than or equal to 200.")
      end

      @client_reference_id = client_reference_id
    end

    # Custom attribute writer method with validation
    # @param [Object] customer Value to be assigned
    def customer=(customer)
      if !customer.nil? && customer.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"customer\", the character length must be smaller than or equal to 5000.")
      end

      @customer = customer
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] customer_creation Object to be assigned
    def customer_creation=(customer_creation)
      ENUM_VALIDATOR_FOR_CUSTOMER_CREATION.valid!(customer_creation)
      @customer_creation = customer_creation
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] locale Object to be assigned
    def locale=(locale)
      ENUM_VALIDATOR_FOR_LOCALE.valid!(locale)
      @locale = locale
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] mode Object to be assigned
    def mode=(mode)
      ENUM_VALIDATOR_FOR_MODE.valid!(mode)
      @mode = mode
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] payment_method_types Object to be assigned
    def payment_method_types=(payment_method_types)
      ENUM_VALIDATOR_FOR_PAYMENT_METHOD_TYPES.all_valid!(payment_method_types)
      @payment_method_types = payment_method_types
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] submit_type Object to be assigned
    def submit_type=(submit_type)
      ENUM_VALIDATOR_FOR_SUBMIT_TYPE.valid!(submit_type)
      @submit_type = submit_type
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Generates #hash and #== methods from all fields
    # #== @return [Bool]
    # #hash calculates hash code according to all attributes.
    # #hash @return [UInt64] Hash code
    def_equals_and_hash(@cancel_url, @success_url, @after_expiration, @allow_promotion_codes, @automatic_tax, @billing_address_collection, @client_reference_id, @consent_collection, @customer, @customer_creation, @customer_email, @customer_update, @discounts, @expand, @expires_at, @line_items, @locale, @metadata, @mode, @payment_intent_data, @payment_method_options, @payment_method_types, @phone_number_collection, @setup_intent_data, @shipping_address_collection, @shipping_options, @submit_type, @subscription_data, @tax_id_collection)
  end
end
