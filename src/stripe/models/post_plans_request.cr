#  Stripe API
#
# The Stripe REST API. Please see https://stripe.com/docs/api for more details.
#
# The version of the OpenAPI document: 2020-08-27
# Contact: dev-platform@stripe.com
# Generated by: https://openapi-generator.tech
#

require "json"
require "time"
require "log"

module Stripe
  @[JSON::Serializable::Options(emit_nulls: true)]
  class PostPlansRequest
    include JSON::Serializable
    include JSON::Serializable::Unmapped

    # Required properties
    # Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    @[JSON::Field(key: "currency", type: String)]
    property currency : String

    # Specifies billing frequency. Either `day`, `week`, `month` or `year`.
    @[JSON::Field(key: "interval", type: String)]
    getter interval : String

    ENUM_VALIDATOR_FOR_INTERVAL = EnumValidator.new("interval", "String", ["day", "month", "week", "year"])

    # Optional properties
    # Whether the plan is currently available for new subscriptions. Defaults to `true`.
    @[JSON::Field(key: "active", type: Bool?, presence: true, ignore_serialize: active.nil? && !active_present?)]
    property active : Bool?

    @[JSON::Field(ignore: true)]
    property? active_present : Bool = false

    # Specifies a usage aggregation strategy for plans of `usage_type=metered`. Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max` which uses the usage record with the maximum reported usage during a period. Defaults to `sum`.
    @[JSON::Field(key: "aggregate_usage", type: String?, presence: true, ignore_serialize: aggregate_usage.nil? && !aggregate_usage_present?)]
    getter aggregate_usage : String?

    @[JSON::Field(ignore: true)]
    property? aggregate_usage_present : Bool = false

    ENUM_VALIDATOR_FOR_AGGREGATE_USAGE = EnumValidator.new("aggregate_usage", "String", ["last_during_period", "last_ever", "max", "sum"])

    # A positive integer in cents (or local equivalent) (or 0 for a free plan) representing how much to charge on a recurring basis.
    @[JSON::Field(key: "amount", type: Int64?, presence: true, ignore_serialize: amount.nil? && !amount_present?)]
    property amount : Int64?

    @[JSON::Field(ignore: true)]
    property? amount_present : Bool = false

    # Same as `amount`, but accepts a decimal value with at most 12 decimal places. Only one of `amount` and `amount_decimal` can be set.
    @[JSON::Field(key: "amount_decimal", type: String?, presence: true, ignore_serialize: amount_decimal.nil? && !amount_decimal_present?)]
    property amount_decimal : String?

    @[JSON::Field(ignore: true)]
    property? amount_decimal_present : Bool = false

    # Describes how to compute the price per period. Either `per_unit` or `tiered`. `per_unit` indicates that the fixed amount (specified in `amount`) will be charged per unit in `quantity` (for plans with `usage_type=licensed`), or per unit of total usage (for plans with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as defined using the `tiers` and `tiers_mode` attributes.
    @[JSON::Field(key: "billing_scheme", type: String?, presence: true, ignore_serialize: billing_scheme.nil? && !billing_scheme_present?)]
    getter billing_scheme : String?

    @[JSON::Field(ignore: true)]
    property? billing_scheme_present : Bool = false

    ENUM_VALIDATOR_FOR_BILLING_SCHEME = EnumValidator.new("billing_scheme", "String", ["per_unit", "tiered"])

    @[JSON::Field(key: "expand", type: Array(String)?, presence: true, ignore_serialize: expand.nil? && !expand_present?)]
    property expand : Array(String)?

    @[JSON::Field(ignore: true)]
    property? expand_present : Bool = false

    # An identifier randomly generated by Stripe. Used to identify this plan when subscribing a customer. You can optionally override this ID, but the ID must be unique across all plans in your Stripe account. You can, however, use the same plan ID in both live and test modes.
    @[JSON::Field(key: "id", type: String?, presence: true, ignore_serialize: id.nil? && !id_present?)]
    getter id : String?

    @[JSON::Field(ignore: true)]
    property? id_present : Bool = false

    # The number of intervals between subscription billings. For example, `interval=month` and `interval_count=3` bills every 3 months. Maximum of one year interval allowed (1 year, 12 months, or 52 weeks).
    @[JSON::Field(key: "interval_count", type: Int64?, presence: true, ignore_serialize: interval_count.nil? && !interval_count_present?)]
    property interval_count : Int64?

    @[JSON::Field(ignore: true)]
    property? interval_count_present : Bool = false

    @[JSON::Field(key: "metadata", type: IndividualSpecsMetadata?, presence: true, ignore_serialize: metadata.nil? && !metadata_present?)]
    property metadata : IndividualSpecsMetadata?

    @[JSON::Field(ignore: true)]
    property? metadata_present : Bool = false

    # A brief description of the plan, hidden from customers.
    @[JSON::Field(key: "nickname", type: String?, presence: true, ignore_serialize: nickname.nil? && !nickname_present?)]
    getter nickname : String?

    @[JSON::Field(ignore: true)]
    property? nickname_present : Bool = false

    @[JSON::Field(key: "product", type: PostPlansRequestProduct?, presence: true, ignore_serialize: product.nil? && !product_present?)]
    property product : PostPlansRequestProduct?

    @[JSON::Field(ignore: true)]
    property? product_present : Bool = false

    # Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`. See also the documentation for `billing_scheme`.
    @[JSON::Field(key: "tiers", type: Array(Tier)?, presence: true, ignore_serialize: tiers.nil? && !tiers_present?)]
    property tiers : Array(Tier)?

    @[JSON::Field(ignore: true)]
    property? tiers_present : Bool = false

    # Defines if the tiering price should be `graduated` or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per unit price, in `graduated` tiering pricing can successively change as the quantity grows.
    @[JSON::Field(key: "tiers_mode", type: String?, presence: true, ignore_serialize: tiers_mode.nil? && !tiers_mode_present?)]
    getter tiers_mode : String?

    @[JSON::Field(ignore: true)]
    property? tiers_mode_present : Bool = false

    ENUM_VALIDATOR_FOR_TIERS_MODE = EnumValidator.new("tiers_mode", "String", ["graduated", "volume"])

    @[JSON::Field(key: "transform_usage", type: TransformUsageParam?, presence: true, ignore_serialize: transform_usage.nil? && !transform_usage_present?)]
    property transform_usage : TransformUsageParam?

    @[JSON::Field(ignore: true)]
    property? transform_usage_present : Bool = false

    # Default number of trial days when subscribing a customer to this plan using [`trial_from_plan=true`](https://stripe.com/docs/api#create_subscription-trial_from_plan).
    @[JSON::Field(key: "trial_period_days", type: Int64?, presence: true, ignore_serialize: trial_period_days.nil? && !trial_period_days_present?)]
    property trial_period_days : Int64?

    @[JSON::Field(ignore: true)]
    property? trial_period_days_present : Bool = false

    # Configures how the quantity per period should be determined. Can be either `metered` or `licensed`. `licensed` automatically bills the `quantity` set when adding it to a subscription. `metered` aggregates the total usage based on usage records. Defaults to `licensed`.
    @[JSON::Field(key: "usage_type", type: String?, presence: true, ignore_serialize: usage_type.nil? && !usage_type_present?)]
    getter usage_type : String?

    @[JSON::Field(ignore: true)]
    property? usage_type_present : Bool = false

    ENUM_VALIDATOR_FOR_USAGE_TYPE = EnumValidator.new("usage_type", "String", ["licensed", "metered"])

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(*, @currency : String, @interval : String, @active : Bool? = nil, @aggregate_usage : String? = nil, @amount : Int64? = nil, @amount_decimal : String? = nil, @billing_scheme : String? = nil, @expand : Array(String)? = nil, @id : String? = nil, @interval_count : Int64? = nil, @metadata : IndividualSpecsMetadata? = nil, @nickname : String? = nil, @product : PostPlansRequestProduct? = nil, @tiers : Array(Tier)? = nil, @tiers_mode : String? = nil, @transform_usage : TransformUsageParam? = nil, @trial_period_days : Int64? = nil, @usage_type : String? = nil)
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array(String).new

      invalid_properties.push(ENUM_VALIDATOR_FOR_AGGREGATE_USAGE.error_message) unless ENUM_VALIDATOR_FOR_AGGREGATE_USAGE.valid?(@aggregate_usage)

      invalid_properties.push(ENUM_VALIDATOR_FOR_BILLING_SCHEME.error_message) unless ENUM_VALIDATOR_FOR_BILLING_SCHEME.valid?(@billing_scheme)

      if !@id.nil? && @id.to_s.size > 5000
        invalid_properties.push("invalid value for \"id\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties.push(ENUM_VALIDATOR_FOR_INTERVAL.error_message) unless ENUM_VALIDATOR_FOR_INTERVAL.valid?(@interval, false)

      if !@nickname.nil? && @nickname.to_s.size > 5000
        invalid_properties.push("invalid value for \"nickname\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties.push(ENUM_VALIDATOR_FOR_TIERS_MODE.error_message) unless ENUM_VALIDATOR_FOR_TIERS_MODE.valid?(@tiers_mode)

      invalid_properties.push(ENUM_VALIDATOR_FOR_USAGE_TYPE.error_message) unless ENUM_VALIDATOR_FOR_USAGE_TYPE.valid?(@usage_type)

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false unless ENUM_VALIDATOR_FOR_AGGREGATE_USAGE.valid?(@aggregate_usage)
      return false unless ENUM_VALIDATOR_FOR_BILLING_SCHEME.valid?(@billing_scheme)
      return false if !@id.nil? && @id.to_s.size > 5000
      return false unless ENUM_VALIDATOR_FOR_INTERVAL.valid?(@interval, false)
      return false if !@nickname.nil? && @nickname.to_s.size > 5000
      return false unless ENUM_VALIDATOR_FOR_TIERS_MODE.valid?(@tiers_mode)
      return false unless ENUM_VALIDATOR_FOR_USAGE_TYPE.valid?(@usage_type)
      true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] aggregate_usage Object to be assigned
    def aggregate_usage=(aggregate_usage)
      ENUM_VALIDATOR_FOR_AGGREGATE_USAGE.valid!(aggregate_usage)
      @aggregate_usage = aggregate_usage
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] billing_scheme Object to be assigned
    def billing_scheme=(billing_scheme)
      ENUM_VALIDATOR_FOR_BILLING_SCHEME.valid!(billing_scheme)
      @billing_scheme = billing_scheme
    end

    # Custom attribute writer method with validation
    # @param [Object] id Value to be assigned
    def id=(id)
      if !id.nil? && id.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"id\", the character length must be smaller than or equal to 5000.")
      end

      @id = id
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] interval Object to be assigned
    def interval=(interval)
      ENUM_VALIDATOR_FOR_INTERVAL.valid!(interval, false)
      @interval = interval
    end

    # Custom attribute writer method with validation
    # @param [Object] nickname Value to be assigned
    def nickname=(nickname)
      if !nickname.nil? && nickname.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"nickname\", the character length must be smaller than or equal to 5000.")
      end

      @nickname = nickname
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] tiers_mode Object to be assigned
    def tiers_mode=(tiers_mode)
      ENUM_VALIDATOR_FOR_TIERS_MODE.valid!(tiers_mode)
      @tiers_mode = tiers_mode
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] usage_type Object to be assigned
    def usage_type=(usage_type)
      ENUM_VALIDATOR_FOR_USAGE_TYPE.valid!(usage_type)
      @usage_type = usage_type
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.same?(o)
      self.class == o.class &&
        active == o.active &&
        aggregate_usage == o.aggregate_usage &&
        amount == o.amount &&
        amount_decimal == o.amount_decimal &&
        billing_scheme == o.billing_scheme &&
        currency == o.currency &&
        expand == o.expand &&
        id == o.id &&
        interval == o.interval &&
        interval_count == o.interval_count &&
        metadata == o.metadata &&
        nickname == o.nickname &&
        product == o.product &&
        tiers == o.tiers &&
        tiers_mode == o.tiers_mode &&
        transform_usage == o.transform_usage &&
        trial_period_days == o.trial_period_days &&
        usage_type == o.usage_type
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [UInt64] Hash code
    def_hash(@active, @aggregate_usage, @amount, @amount_decimal, @billing_scheme, @currency, @expand, @id, @interval, @interval_count, @metadata, @nickname, @product, @tiers, @tiers_mode, @transform_usage, @trial_period_days, @usage_type)
  end
end
