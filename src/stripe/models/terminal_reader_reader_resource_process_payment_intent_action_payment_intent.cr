#  Stripe API
#
# The Stripe REST API. Please see https://stripe.com/docs/api for more details.
#
# The version of the OpenAPI document: 2020-08-27
# Contact: dev-platform@stripe.com
# Generated by: https://openapi-generator.tech
#

require "json"
require "time"
require "log"

module Stripe
  # Most recent PaymentIntent processed by the reader.
  @[JSON::Serializable::Options(emit_nulls: true)]
  class TerminalReaderReaderResourceProcessPaymentIntentActionPaymentIntent
    include JSON::Serializable
    include JSON::Serializable::Unmapped

    # Required properties

    # Amount intended to be collected by this PaymentIntent. A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge Â¥100, a zero-decimal currency). The minimum amount is $0.50 US or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
    @[JSON::Field(key: "amount", type: Int64?)]
    property amount : Int64?

    # Controls when the funds will be captured from the customer's account.
    @[JSON::Field(key: "capture_method", type: String?)]
    getter capture_method : String?

    ENUM_VALIDATOR_FOR_CAPTURE_METHOD = EnumValidator.new("capture_method", "String", ["automatic", "manual"])

    @[JSON::Field(key: "confirmation_method", type: String?)]
    getter confirmation_method : String?

    ENUM_VALIDATOR_FOR_CONFIRMATION_METHOD = EnumValidator.new("confirmation_method", "String", ["automatic", "manual"])

    # Time at which the object was created. Measured in seconds since the Unix epoch.
    @[JSON::Field(key: "created", type: Int64?)]
    property created : Int64?

    # Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    @[JSON::Field(key: "currency", type: String?)]
    property currency : String?

    # Unique identifier for the object.
    @[JSON::Field(key: "id", type: String?)]
    getter id : String?

    # Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    @[JSON::Field(key: "livemode", type: Bool?)]
    property livemode : Bool?

    # String representing the object's type. Objects of the same type share the same value.
    @[JSON::Field(key: "object", type: String?)]
    getter object : String?

    ENUM_VALIDATOR_FOR_OBJECT = EnumValidator.new("object", "String", ["payment_intent"])

    # The list of payment method types (e.g. card) that this PaymentIntent is allowed to use.
    @[JSON::Field(key: "payment_method_types", type: Array(String)?)]
    property payment_method_types : Array(String)?

    # Status of this PaymentIntent, one of `requires_payment_method`, `requires_confirmation`, `requires_action`, `processing`, `requires_capture`, `canceled`, or `succeeded`. Read more about each PaymentIntent [status](https://stripe.com/docs/payments/intents#intent-statuses).
    @[JSON::Field(key: "status", type: String?)]
    getter status : String?

    ENUM_VALIDATOR_FOR_STATUS = EnumValidator.new("status", "String", ["canceled", "processing", "requires_action", "requires_capture", "requires_confirmation", "requires_payment_method", "succeeded"])

    # Optional properties

    # Amount that can be captured from this PaymentIntent.
    @[JSON::Field(key: "amount_capturable", type: Int64?, presence: true, ignore_serialize: amount_capturable.nil? && !amount_capturable_present?)]
    property amount_capturable : Int64?

    @[JSON::Field(ignore: true)]
    property? amount_capturable_present : Bool = false

    @[JSON::Field(key: "amount_details", type: PaymentFlowsAmountDetails?, presence: true, ignore_serialize: amount_details.nil? && !amount_details_present?)]
    property amount_details : PaymentFlowsAmountDetails?

    @[JSON::Field(ignore: true)]
    property? amount_details_present : Bool = false

    # Amount that was collected by this PaymentIntent.
    @[JSON::Field(key: "amount_received", type: Int64?, presence: true, ignore_serialize: amount_received.nil? && !amount_received_present?)]
    property amount_received : Int64?

    @[JSON::Field(ignore: true)]
    property? amount_received_present : Bool = false

    @[JSON::Field(key: "application", type: PaymentIntentApplication?, presence: true, ignore_serialize: application.nil? && !application_present?)]
    property application : PaymentIntentApplication?

    @[JSON::Field(ignore: true)]
    property? application_present : Bool = false

    # The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
    @[JSON::Field(key: "application_fee_amount", type: Int64?, presence: true, ignore_serialize: application_fee_amount.nil? && !application_fee_amount_present?)]
    property application_fee_amount : Int64?

    @[JSON::Field(ignore: true)]
    property? application_fee_amount_present : Bool = false

    @[JSON::Field(key: "automatic_payment_methods", type: PaymentIntentAutomaticPaymentMethods?, presence: true, ignore_serialize: automatic_payment_methods.nil? && !automatic_payment_methods_present?)]
    property automatic_payment_methods : PaymentIntentAutomaticPaymentMethods?

    @[JSON::Field(ignore: true)]
    property? automatic_payment_methods_present : Bool = false

    # Populated when `status` is `canceled`, this is the time at which the PaymentIntent was canceled. Measured in seconds since the Unix epoch.
    @[JSON::Field(key: "canceled_at", type: Int64?, presence: true, ignore_serialize: canceled_at.nil? && !canceled_at_present?)]
    property canceled_at : Int64?

    @[JSON::Field(ignore: true)]
    property? canceled_at_present : Bool = false

    # Reason for cancellation of this PaymentIntent, either user-provided (`duplicate`, `fraudulent`, `requested_by_customer`, or `abandoned`) or generated by Stripe internally (`failed_invoice`, `void_invoice`, or `automatic`).
    @[JSON::Field(key: "cancellation_reason", type: String?, presence: true, ignore_serialize: cancellation_reason.nil? && !cancellation_reason_present?)]
    getter cancellation_reason : String?

    @[JSON::Field(ignore: true)]
    property? cancellation_reason_present : Bool = false

    ENUM_VALIDATOR_FOR_CANCELLATION_REASON = EnumValidator.new("cancellation_reason", "String", ["abandoned", "automatic", "duplicate", "failed_invoice", "fraudulent", "requested_by_customer", "void_invoice"])

    @[JSON::Field(key: "charges", type: PaymentFlowsPaymentIntentResourceChargeList?, presence: true, ignore_serialize: charges.nil? && !charges_present?)]
    property charges : PaymentFlowsPaymentIntentResourceChargeList?

    @[JSON::Field(ignore: true)]
    property? charges_present : Bool = false

    # The client secret of this PaymentIntent. Used for client-side retrieval using a publishable key.   The client secret can be used to complete a payment from your frontend. It should not be stored, logged, or exposed to anyone other than the customer. Make sure that you have TLS enabled on any page that includes the client secret.  Refer to our docs to [accept a payment](https://stripe.com/docs/payments/accept-a-payment?ui=elements) and learn about how `client_secret` should be handled.
    @[JSON::Field(key: "client_secret", type: String?, presence: true, ignore_serialize: client_secret.nil? && !client_secret_present?)]
    getter client_secret : String?

    @[JSON::Field(ignore: true)]
    property? client_secret_present : Bool = false

    @[JSON::Field(key: "customer", type: PaymentIntentCustomer?, presence: true, ignore_serialize: customer.nil? && !customer_present?)]
    property customer : PaymentIntentCustomer?

    @[JSON::Field(ignore: true)]
    property? customer_present : Bool = false

    # An arbitrary string attached to the object. Often useful for displaying to users.
    @[JSON::Field(key: "description", type: String?, presence: true, ignore_serialize: description.nil? && !description_present?)]
    getter description : String?

    @[JSON::Field(ignore: true)]
    property? description_present : Bool = false

    @[JSON::Field(key: "invoice", type: PaymentIntentInvoice?, presence: true, ignore_serialize: invoice.nil? && !invoice_present?)]
    property invoice : PaymentIntentInvoice?

    @[JSON::Field(ignore: true)]
    property? invoice_present : Bool = false

    @[JSON::Field(key: "last_payment_error", type: PaymentIntentLastPaymentError?, presence: true, ignore_serialize: last_payment_error.nil? && !last_payment_error_present?)]
    property last_payment_error : PaymentIntentLastPaymentError?

    @[JSON::Field(ignore: true)]
    property? last_payment_error_present : Bool = false

    # Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. For more information, see the [documentation](https://stripe.com/docs/payments/payment-intents/creating-payment-intents#storing-information-in-metadata).
    @[JSON::Field(key: "metadata", type: Hash(String, String)?, presence: true, ignore_serialize: metadata.nil? && !metadata_present?)]
    property metadata : Hash(String, String)?

    @[JSON::Field(ignore: true)]
    property? metadata_present : Bool = false

    @[JSON::Field(key: "next_action", type: PaymentIntentNextAction1?, presence: true, ignore_serialize: next_action.nil? && !next_action_present?)]
    property next_action : PaymentIntentNextAction1?

    @[JSON::Field(ignore: true)]
    property? next_action_present : Bool = false

    @[JSON::Field(key: "on_behalf_of", type: PaymentIntentOnBehalfOf?, presence: true, ignore_serialize: on_behalf_of.nil? && !on_behalf_of_present?)]
    property on_behalf_of : PaymentIntentOnBehalfOf?

    @[JSON::Field(ignore: true)]
    property? on_behalf_of_present : Bool = false

    @[JSON::Field(key: "payment_method", type: PaymentIntentPaymentMethod?, presence: true, ignore_serialize: payment_method.nil? && !payment_method_present?)]
    property payment_method : PaymentIntentPaymentMethod?

    @[JSON::Field(ignore: true)]
    property? payment_method_present : Bool = false

    @[JSON::Field(key: "payment_method_options", type: PaymentIntentPaymentMethodOptions1?, presence: true, ignore_serialize: payment_method_options.nil? && !payment_method_options_present?)]
    property payment_method_options : PaymentIntentPaymentMethodOptions1?

    @[JSON::Field(ignore: true)]
    property? payment_method_options_present : Bool = false

    @[JSON::Field(key: "processing", type: PaymentIntentProcessing1?, presence: true, ignore_serialize: processing.nil? && !processing_present?)]
    property processing : PaymentIntentProcessing1?

    @[JSON::Field(ignore: true)]
    property? processing_present : Bool = false

    # Email address that the receipt for the resulting payment will be sent to. If `receipt_email` is specified for a payment in live mode, a receipt will be sent regardless of your [email settings](https://dashboard.stripe.com/account/emails).
    @[JSON::Field(key: "receipt_email", type: String?, presence: true, ignore_serialize: receipt_email.nil? && !receipt_email_present?)]
    getter receipt_email : String?

    @[JSON::Field(ignore: true)]
    property? receipt_email_present : Bool = false

    @[JSON::Field(key: "review", type: PaymentIntentReview?, presence: true, ignore_serialize: review.nil? && !review_present?)]
    property review : PaymentIntentReview?

    @[JSON::Field(ignore: true)]
    property? review_present : Bool = false

    # Indicates that you intend to make future payments with this PaymentIntent's payment method.  Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.  When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).
    @[JSON::Field(key: "setup_future_usage", type: String?, presence: true, ignore_serialize: setup_future_usage.nil? && !setup_future_usage_present?)]
    getter setup_future_usage : String?

    @[JSON::Field(ignore: true)]
    property? setup_future_usage_present : Bool = false

    ENUM_VALIDATOR_FOR_SETUP_FUTURE_USAGE = EnumValidator.new("setup_future_usage", "String", ["off_session", "on_session"])

    @[JSON::Field(key: "shipping", type: PaymentIntentShipping?, presence: true, ignore_serialize: shipping.nil? && !shipping_present?)]
    property shipping : PaymentIntentShipping?

    @[JSON::Field(ignore: true)]
    property? shipping_present : Bool = false

    # For non-card charges, you can use this value as the complete description that appears on your customersâ statements. Must contain at least one letter, maximum 22 characters.
    @[JSON::Field(key: "statement_descriptor", type: String?, presence: true, ignore_serialize: statement_descriptor.nil? && !statement_descriptor_present?)]
    getter statement_descriptor : String?

    @[JSON::Field(ignore: true)]
    property? statement_descriptor_present : Bool = false

    # Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor thatâs set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
    @[JSON::Field(key: "statement_descriptor_suffix", type: String?, presence: true, ignore_serialize: statement_descriptor_suffix.nil? && !statement_descriptor_suffix_present?)]
    getter statement_descriptor_suffix : String?

    @[JSON::Field(ignore: true)]
    property? statement_descriptor_suffix_present : Bool = false

    @[JSON::Field(key: "transfer_data", type: PaymentIntentTransferData?, presence: true, ignore_serialize: transfer_data.nil? && !transfer_data_present?)]
    property transfer_data : PaymentIntentTransferData?

    @[JSON::Field(ignore: true)]
    property? transfer_data_present : Bool = false

    # A string that identifies the resulting payment as part of a group. See the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts) for details.
    @[JSON::Field(key: "transfer_group", type: String?, presence: true, ignore_serialize: transfer_group.nil? && !transfer_group_present?)]
    getter transfer_group : String?

    @[JSON::Field(ignore: true)]
    property? transfer_group_present : Bool = false

    # List of class defined in anyOf (OpenAPI v3)
    def self.openapi_any_of
      [
        Stripe::PaymentIntent,
        String,
      ]
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(
      *,
      # Required properties
      @amount : Int64? = nil,
      @capture_method : String? = nil,
      @confirmation_method : String? = nil,
      @created : Int64? = nil,
      @currency : String? = nil,
      @id : String? = nil,
      @livemode : Bool? = nil,
      @object : String? = nil,
      @payment_method_types : Array(String)? = nil,
      @status : String? = nil,
      # Optional properties
      @amount_capturable : Int64? = nil,
      @amount_details : PaymentFlowsAmountDetails? = nil,
      @amount_received : Int64? = nil,
      @application : PaymentIntentApplication? = nil,
      @application_fee_amount : Int64? = nil,
      @automatic_payment_methods : PaymentIntentAutomaticPaymentMethods? = nil,
      @canceled_at : Int64? = nil,
      @cancellation_reason : String? = nil,
      @charges : PaymentFlowsPaymentIntentResourceChargeList? = nil,
      @client_secret : String? = nil,
      @customer : PaymentIntentCustomer? = nil,
      @description : String? = nil,
      @invoice : PaymentIntentInvoice? = nil,
      @last_payment_error : PaymentIntentLastPaymentError? = nil,
      @metadata : Hash(String, String)? = nil,
      @next_action : PaymentIntentNextAction1? = nil,
      @on_behalf_of : PaymentIntentOnBehalfOf? = nil,
      @payment_method : PaymentIntentPaymentMethod? = nil,
      @payment_method_options : PaymentIntentPaymentMethodOptions1? = nil,
      @processing : PaymentIntentProcessing1? = nil,
      @receipt_email : String? = nil,
      @review : PaymentIntentReview? = nil,
      @setup_future_usage : String? = nil,
      @shipping : PaymentIntentShipping? = nil,
      @statement_descriptor : String? = nil,
      @statement_descriptor_suffix : String? = nil,
      @transfer_data : PaymentIntentTransferData? = nil,
      @transfer_group : String? = nil
    )
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array(String).new

      invalid_properties.push(ENUM_VALIDATOR_FOR_CAPTURE_METHOD.error_message) unless ENUM_VALIDATOR_FOR_CAPTURE_METHOD.valid?(@capture_method, false)

      invalid_properties.push(ENUM_VALIDATOR_FOR_CONFIRMATION_METHOD.error_message) unless ENUM_VALIDATOR_FOR_CONFIRMATION_METHOD.valid?(@confirmation_method, false)

      if @id.to_s.size > 5000
        invalid_properties.push("invalid value for \"id\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties.push(ENUM_VALIDATOR_FOR_OBJECT.error_message) unless ENUM_VALIDATOR_FOR_OBJECT.valid?(@object, false)

      invalid_properties.push(ENUM_VALIDATOR_FOR_STATUS.error_message) unless ENUM_VALIDATOR_FOR_STATUS.valid?(@status, false)

      invalid_properties.push(ENUM_VALIDATOR_FOR_CANCELLATION_REASON.error_message) unless ENUM_VALIDATOR_FOR_CANCELLATION_REASON.valid?(@cancellation_reason)

      if !@client_secret.nil? && @client_secret.to_s.size > 5000
        invalid_properties.push("invalid value for \"client_secret\", the character length must be smaller than or equal to 5000.")
      end

      if !@description.nil? && @description.to_s.size > 5000
        invalid_properties.push("invalid value for \"description\", the character length must be smaller than or equal to 5000.")
      end

      if !@receipt_email.nil? && @receipt_email.to_s.size > 5000
        invalid_properties.push("invalid value for \"receipt_email\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties.push(ENUM_VALIDATOR_FOR_SETUP_FUTURE_USAGE.error_message) unless ENUM_VALIDATOR_FOR_SETUP_FUTURE_USAGE.valid?(@setup_future_usage)

      if !@statement_descriptor.nil? && @statement_descriptor.to_s.size > 5000
        invalid_properties.push("invalid value for \"statement_descriptor\", the character length must be smaller than or equal to 5000.")
      end

      if !@statement_descriptor_suffix.nil? && @statement_descriptor_suffix.to_s.size > 5000
        invalid_properties.push("invalid value for \"statement_descriptor_suffix\", the character length must be smaller than or equal to 5000.")
      end

      if !@transfer_group.nil? && @transfer_group.to_s.size > 5000
        invalid_properties.push("invalid value for \"transfer_group\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false unless ENUM_VALIDATOR_FOR_CAPTURE_METHOD.valid?(@capture_method, false)
      return false unless ENUM_VALIDATOR_FOR_CONFIRMATION_METHOD.valid?(@confirmation_method, false)
      return false if @id.to_s.size > 5000
      return false unless ENUM_VALIDATOR_FOR_OBJECT.valid?(@object, false)
      return false unless ENUM_VALIDATOR_FOR_STATUS.valid?(@status, false)
      return false unless ENUM_VALIDATOR_FOR_CANCELLATION_REASON.valid?(@cancellation_reason)
      return false if !@client_secret.nil? && @client_secret.to_s.size > 5000
      return false if !@description.nil? && @description.to_s.size > 5000
      return false if !@receipt_email.nil? && @receipt_email.to_s.size > 5000
      return false unless ENUM_VALIDATOR_FOR_SETUP_FUTURE_USAGE.valid?(@setup_future_usage)
      return false if !@statement_descriptor.nil? && @statement_descriptor.to_s.size > 5000
      return false if !@statement_descriptor_suffix.nil? && @statement_descriptor_suffix.to_s.size > 5000
      return false if !@transfer_group.nil? && @transfer_group.to_s.size > 5000

      _any_of_found = false
      json_string : String = self.to_json
      _any_of_found = self.class.openapi_any_of.any? do |_class|
        _any_of = begin
          _class.from_json(json_string)
        rescue
          nil
        end

        !_any_of.nil? && _any_of.not_nil!.valid?
      end
      return false if !_any_of_found

      true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] capture_method Object to be assigned
    def capture_method=(capture_method)
      ENUM_VALIDATOR_FOR_CAPTURE_METHOD.valid!(capture_method, false)
      @capture_method = capture_method
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] confirmation_method Object to be assigned
    def confirmation_method=(confirmation_method)
      ENUM_VALIDATOR_FOR_CONFIRMATION_METHOD.valid!(confirmation_method, false)
      @confirmation_method = confirmation_method
    end

    # Custom attribute writer method with validation
    # @param [Object] id Value to be assigned
    def id=(id)
      if id.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"id\", the character length must be smaller than or equal to 5000.")
      end

      @id = id
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] object Object to be assigned
    def object=(object)
      ENUM_VALIDATOR_FOR_OBJECT.valid!(object, false)
      @object = object
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] status Object to be assigned
    def status=(status)
      ENUM_VALIDATOR_FOR_STATUS.valid!(status, false)
      @status = status
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] cancellation_reason Object to be assigned
    def cancellation_reason=(cancellation_reason)
      ENUM_VALIDATOR_FOR_CANCELLATION_REASON.valid!(cancellation_reason)
      @cancellation_reason = cancellation_reason
    end

    # Custom attribute writer method with validation
    # @param [Object] client_secret Value to be assigned
    def client_secret=(client_secret)
      if !client_secret.nil? && client_secret.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"client_secret\", the character length must be smaller than or equal to 5000.")
      end

      @client_secret = client_secret
    end

    # Custom attribute writer method with validation
    # @param [Object] description Value to be assigned
    def description=(description)
      if !description.nil? && description.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"description\", the character length must be smaller than or equal to 5000.")
      end

      @description = description
    end

    # Custom attribute writer method with validation
    # @param [Object] receipt_email Value to be assigned
    def receipt_email=(receipt_email)
      if !receipt_email.nil? && receipt_email.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"receipt_email\", the character length must be smaller than or equal to 5000.")
      end

      @receipt_email = receipt_email
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] setup_future_usage Object to be assigned
    def setup_future_usage=(setup_future_usage)
      ENUM_VALIDATOR_FOR_SETUP_FUTURE_USAGE.valid!(setup_future_usage)
      @setup_future_usage = setup_future_usage
    end

    # Custom attribute writer method with validation
    # @param [Object] statement_descriptor Value to be assigned
    def statement_descriptor=(statement_descriptor)
      if !statement_descriptor.nil? && statement_descriptor.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"statement_descriptor\", the character length must be smaller than or equal to 5000.")
      end

      @statement_descriptor = statement_descriptor
    end

    # Custom attribute writer method with validation
    # @param [Object] statement_descriptor_suffix Value to be assigned
    def statement_descriptor_suffix=(statement_descriptor_suffix)
      if !statement_descriptor_suffix.nil? && statement_descriptor_suffix.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"statement_descriptor_suffix\", the character length must be smaller than or equal to 5000.")
      end

      @statement_descriptor_suffix = statement_descriptor_suffix
    end

    # Custom attribute writer method with validation
    # @param [Object] transfer_group Value to be assigned
    def transfer_group=(transfer_group)
      if !transfer_group.nil? && transfer_group.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"transfer_group\", the character length must be smaller than or equal to 5000.")
      end

      @transfer_group = transfer_group
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Generates #hash and #== methods from all fields
    # #== @return [Bool]
    # #hash calculates hash code according to all attributes.
    # #hash @return [UInt64] Hash code
    def_equals_and_hash(@amount, @capture_method, @confirmation_method, @created, @currency, @id, @livemode, @object, @payment_method_types, @status, @amount_capturable, @amount_details, @amount_received, @application, @application_fee_amount, @automatic_payment_methods, @canceled_at, @cancellation_reason, @charges, @client_secret, @customer, @description, @invoice, @last_payment_error, @metadata, @next_action, @on_behalf_of, @payment_method, @payment_method_options, @processing, @receipt_email, @review, @setup_future_usage, @shipping, @statement_descriptor, @statement_descriptor_suffix, @transfer_data, @transfer_group)
  end
end
