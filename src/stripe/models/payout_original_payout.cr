#  Stripe API
#
# The Stripe REST API. Please see https://stripe.com/docs/api for more details.
#
# The version of the OpenAPI document: 2020-08-27
# Contact: dev-platform@stripe.com
# Generated by: https://openapi-generator.tech
#

require "json"
require "time"
require "log"

module Stripe
  # If the payout reverses another, this is the ID of the original payout.
  @[JSON::Serializable::Options(emit_nulls: true)]
  class PayoutOriginalPayout
    include JSON::Serializable
    include JSON::Serializable::Unmapped

    # Required properties

    # Amount (in %s) to be transferred to your bank account or debit card.
    @[JSON::Field(key: "amount", type: Int64?)]
    property amount : Int64?

    # Date the payout is expected to arrive in the bank. This factors in delays like weekends or bank holidays.
    @[JSON::Field(key: "arrival_date", type: Int64?)]
    property arrival_date : Int64?

    # Returns `true` if the payout was created by an [automated payout schedule](https://stripe.com/docs/payouts#payout-schedule), and `false` if it was [requested manually](https://stripe.com/docs/payouts#manual-payouts).
    @[JSON::Field(key: "automatic", type: Bool?)]
    property automatic : Bool?

    # Time at which the object was created. Measured in seconds since the Unix epoch.
    @[JSON::Field(key: "created", type: Int64?)]
    property created : Int64?

    # Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    @[JSON::Field(key: "currency", type: String?)]
    property currency : String?

    # Unique identifier for the object.
    @[JSON::Field(key: "id", type: String?)]
    getter id : String?

    # Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.
    @[JSON::Field(key: "livemode", type: Bool?)]
    property livemode : Bool?

    # The method used to send this payout, which can be `standard` or `instant`. `instant` is only supported for payouts to debit cards. (See [Instant payouts for marketplaces](https://stripe.com/blog/instant-payouts-for-marketplaces) for more information.)
    @[JSON::Field(key: "method", type: String?)]
    getter method : String?

    # String representing the object's type. Objects of the same type share the same value.
    @[JSON::Field(key: "object", type: String?)]
    getter object : String?

    ENUM_VALIDATOR_FOR_OBJECT = EnumValidator.new("object", "String", ["payout"])

    # The source balance this payout came from. One of `card`, `fpx`, or `bank_account`.
    @[JSON::Field(key: "source_type", type: String?)]
    getter source_type : String?

    # Current status of the payout: `paid`, `pending`, `in_transit`, `canceled` or `failed`. A payout is `pending` until it is submitted to the bank, when it becomes `in_transit`. The status then changes to `paid` if the transaction goes through, or to `failed` or `canceled` (within 5 business days). Some failed payouts may initially show as `paid` but then change to `failed`.
    @[JSON::Field(key: "status", type: String?)]
    getter status : String?

    # Can be `bank_account` or `card`.
    @[JSON::Field(key: "type", type: String?)]
    getter _type : String?

    ENUM_VALIDATOR_FOR__TYPE = EnumValidator.new("_type", "String", ["bank_account", "card"])

    # Optional properties

    @[JSON::Field(key: "balance_transaction", type: PayoutBalanceTransaction?, presence: true, ignore_serialize: balance_transaction.nil? && !balance_transaction_present?)]
    property balance_transaction : PayoutBalanceTransaction?

    @[JSON::Field(ignore: true)]
    property? balance_transaction_present : Bool = false

    # An arbitrary string attached to the object. Often useful for displaying to users.
    @[JSON::Field(key: "description", type: String?, presence: true, ignore_serialize: description.nil? && !description_present?)]
    getter description : String?

    @[JSON::Field(ignore: true)]
    property? description_present : Bool = false

    @[JSON::Field(key: "destination", type: PayoutDestination?, presence: true, ignore_serialize: destination.nil? && !destination_present?)]
    property destination : PayoutDestination?

    @[JSON::Field(ignore: true)]
    property? destination_present : Bool = false

    @[JSON::Field(key: "failure_balance_transaction", type: PayoutFailureBalanceTransaction?, presence: true, ignore_serialize: failure_balance_transaction.nil? && !failure_balance_transaction_present?)]
    property failure_balance_transaction : PayoutFailureBalanceTransaction?

    @[JSON::Field(ignore: true)]
    property? failure_balance_transaction_present : Bool = false

    # Error code explaining reason for payout failure if available. See [Types of payout failures](https://stripe.com/docs/api#payout_failures) for a list of failure codes.
    @[JSON::Field(key: "failure_code", type: String?, presence: true, ignore_serialize: failure_code.nil? && !failure_code_present?)]
    getter failure_code : String?

    @[JSON::Field(ignore: true)]
    property? failure_code_present : Bool = false

    # Message to user further explaining reason for payout failure if available.
    @[JSON::Field(key: "failure_message", type: String?, presence: true, ignore_serialize: failure_message.nil? && !failure_message_present?)]
    getter failure_message : String?

    @[JSON::Field(ignore: true)]
    property? failure_message_present : Bool = false

    # Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    @[JSON::Field(key: "metadata", type: Hash(String, String)?, presence: true, ignore_serialize: metadata.nil? && !metadata_present?)]
    property metadata : Hash(String, String)?

    @[JSON::Field(ignore: true)]
    property? metadata_present : Bool = false

    @[JSON::Field(key: "original_payout", type: PayoutOriginalPayout?, presence: true, ignore_serialize: original_payout.nil? && !original_payout_present?)]
    property original_payout : PayoutOriginalPayout?

    @[JSON::Field(ignore: true)]
    property? original_payout_present : Bool = false

    @[JSON::Field(key: "reversed_by", type: PayoutReversedBy?, presence: true, ignore_serialize: reversed_by.nil? && !reversed_by_present?)]
    property reversed_by : PayoutReversedBy?

    @[JSON::Field(ignore: true)]
    property? reversed_by_present : Bool = false

    # Extra information about a payout to be displayed on the user's bank statement.
    @[JSON::Field(key: "statement_descriptor", type: String?, presence: true, ignore_serialize: statement_descriptor.nil? && !statement_descriptor_present?)]
    getter statement_descriptor : String?

    @[JSON::Field(ignore: true)]
    property? statement_descriptor_present : Bool = false

    # List of class defined in anyOf (OpenAPI v3)
    def self.openapi_any_of
      [
        Stripe::Payout,
        String,
      ]
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(
      *,
      # Required properties
      @amount : Int64? = nil,
      @arrival_date : Int64? = nil,
      @automatic : Bool? = nil,
      @created : Int64? = nil,
      @currency : String? = nil,
      @id : String? = nil,
      @livemode : Bool? = nil,
      @method : String? = nil,
      @object : String? = nil,
      @source_type : String? = nil,
      @status : String? = nil,
      @_type : String? = nil,
      # Optional properties
      @balance_transaction : PayoutBalanceTransaction? = nil,
      @description : String? = nil,
      @destination : PayoutDestination? = nil,
      @failure_balance_transaction : PayoutFailureBalanceTransaction? = nil,
      @failure_code : String? = nil,
      @failure_message : String? = nil,
      @metadata : Hash(String, String)? = nil,
      @original_payout : PayoutOriginalPayout? = nil,
      @reversed_by : PayoutReversedBy? = nil,
      @statement_descriptor : String? = nil
    )
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array(String).new

      if @id.to_s.size > 5000
        invalid_properties.push("invalid value for \"id\", the character length must be smaller than or equal to 5000.")
      end

      if @method.to_s.size > 5000
        invalid_properties.push("invalid value for \"method\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties.push(ENUM_VALIDATOR_FOR_OBJECT.error_message) unless ENUM_VALIDATOR_FOR_OBJECT.valid?(@object, false)

      if @source_type.to_s.size > 5000
        invalid_properties.push("invalid value for \"source_type\", the character length must be smaller than or equal to 5000.")
      end

      if @status.to_s.size > 5000
        invalid_properties.push("invalid value for \"status\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties.push(ENUM_VALIDATOR_FOR__TYPE.error_message) unless ENUM_VALIDATOR_FOR__TYPE.valid?(@_type, false)

      if !@description.nil? && @description.to_s.size > 5000
        invalid_properties.push("invalid value for \"description\", the character length must be smaller than or equal to 5000.")
      end

      if !@failure_code.nil? && @failure_code.to_s.size > 5000
        invalid_properties.push("invalid value for \"failure_code\", the character length must be smaller than or equal to 5000.")
      end

      if !@failure_message.nil? && @failure_message.to_s.size > 5000
        invalid_properties.push("invalid value for \"failure_message\", the character length must be smaller than or equal to 5000.")
      end

      if !@statement_descriptor.nil? && @statement_descriptor.to_s.size > 5000
        invalid_properties.push("invalid value for \"statement_descriptor\", the character length must be smaller than or equal to 5000.")
      end

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if @id.to_s.size > 5000
      return false if @method.to_s.size > 5000
      return false unless ENUM_VALIDATOR_FOR_OBJECT.valid?(@object, false)
      return false if @source_type.to_s.size > 5000
      return false if @status.to_s.size > 5000
      return false unless ENUM_VALIDATOR_FOR__TYPE.valid?(@_type, false)
      return false if !@description.nil? && @description.to_s.size > 5000
      return false if !@failure_code.nil? && @failure_code.to_s.size > 5000
      return false if !@failure_message.nil? && @failure_message.to_s.size > 5000
      return false if !@statement_descriptor.nil? && @statement_descriptor.to_s.size > 5000

      _any_of_found = false
      json_string : String = self.to_json
      _any_of_found = self.class.openapi_any_of.any? do |_class|
        _any_of = begin
          _class.from_json(json_string)
        rescue
          nil
        end

        !_any_of.nil? && _any_of.not_nil!.valid?
      end
      return false if !_any_of_found

      true
    end

    # Custom attribute writer method with validation
    # @param [Object] id Value to be assigned
    def id=(id)
      if id.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"id\", the character length must be smaller than or equal to 5000.")
      end

      @id = id
    end

    # Custom attribute writer method with validation
    # @param [Object] method Value to be assigned
    def method=(method)
      if method.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"method\", the character length must be smaller than or equal to 5000.")
      end

      @method = method
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] object Object to be assigned
    def object=(object)
      ENUM_VALIDATOR_FOR_OBJECT.valid!(object, false)
      @object = object
    end

    # Custom attribute writer method with validation
    # @param [Object] source_type Value to be assigned
    def source_type=(source_type)
      if source_type.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"source_type\", the character length must be smaller than or equal to 5000.")
      end

      @source_type = source_type
    end

    # Custom attribute writer method with validation
    # @param [Object] status Value to be assigned
    def status=(status)
      if status.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"status\", the character length must be smaller than or equal to 5000.")
      end

      @status = status
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] _type Object to be assigned
    def _type=(_type)
      ENUM_VALIDATOR_FOR__TYPE.valid!(_type, false)
      @_type = _type
    end

    # Custom attribute writer method with validation
    # @param [Object] description Value to be assigned
    def description=(description)
      if !description.nil? && description.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"description\", the character length must be smaller than or equal to 5000.")
      end

      @description = description
    end

    # Custom attribute writer method with validation
    # @param [Object] failure_code Value to be assigned
    def failure_code=(failure_code)
      if !failure_code.nil? && failure_code.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"failure_code\", the character length must be smaller than or equal to 5000.")
      end

      @failure_code = failure_code
    end

    # Custom attribute writer method with validation
    # @param [Object] failure_message Value to be assigned
    def failure_message=(failure_message)
      if !failure_message.nil? && failure_message.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"failure_message\", the character length must be smaller than or equal to 5000.")
      end

      @failure_message = failure_message
    end

    # Custom attribute writer method with validation
    # @param [Object] statement_descriptor Value to be assigned
    def statement_descriptor=(statement_descriptor)
      if !statement_descriptor.nil? && statement_descriptor.to_s.size > 5000
        raise ArgumentError.new("invalid value for \"statement_descriptor\", the character length must be smaller than or equal to 5000.")
      end

      @statement_descriptor = statement_descriptor
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Generates #hash and #== methods from all fields
    # #== @return [Bool]
    # #hash calculates hash code according to all attributes.
    # #hash @return [UInt64] Hash code
    def_equals_and_hash(@amount, @arrival_date, @automatic, @created, @currency, @id, @livemode, @method, @object, @source_type, @status, @_type, @balance_transaction, @description, @destination, @failure_balance_transaction, @failure_code, @failure_message, @metadata, @original_payout, @reversed_by, @statement_descriptor)
  end
end
