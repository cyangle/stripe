#  Stripe API
#
# The Stripe REST API. Please see https://stripe.com/docs/api for more details.
#
# The version of the OpenAPI document: 2022-08-01
# Contact: dev-platform@stripe.com
# Generated by: https://openapi-generator.tech
#

require "uri"

module Stripe
  class DefaultApi
    property api_client : ApiClient

    delegate client_side_validation, debugging, to: @api_client.config

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end

    # <p>With <a href=\"/docs/connect\">Connect</a>, you can delete accounts you manage.</p>  <p>Accounts created using test-mode keys can be deleted at any time. Standard accounts created using live-mode keys cannot be deleted. Custom or Express accounts created using live-mode keys can only be deleted once all balances are zero.</p>  <p>If you want to delete your own account, use the <a href=\"https://dashboard.stripe.com/account\">account information tab in your account settings</a> instead.</p>
    # @optional @param account [String?]
    # @return [DeletedAccount]
    def delete_account(*, account : String? = nil)
      data, _status_code, _headers = delete_account_with_http_info(account: account)
      data
    end

    # &lt;p&gt;With &lt;a href&#x3D;\&quot;/docs/connect\&quot;&gt;Connect&lt;/a&gt;, you can delete accounts you manage.&lt;/p&gt;  &lt;p&gt;Accounts created using test-mode keys can be deleted at any time. Standard accounts created using live-mode keys cannot be deleted. Custom or Express accounts created using live-mode keys can only be deleted once all balances are zero.&lt;/p&gt;  &lt;p&gt;If you want to delete your own account, use the &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/account\&quot;&gt;account information tab in your account settings&lt;/a&gt; instead.&lt;/p&gt;
    # @optional @param account [String?]
    # @return [Array<(DeletedAccount, Integer, Hash)>] DeletedAccount data, response status code and response headers
    def delete_account_with_http_info(*, account : String? = nil)
      request = build_api_request_for_delete_account(account: account)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_account\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;With &lt;a href&#x3D;\&quot;/docs/connect\&quot;&gt;Connect&lt;/a&gt;, you can delete accounts you manage.&lt;/p&gt;  &lt;p&gt;Accounts created using test-mode keys can be deleted at any time. Standard accounts created using live-mode keys cannot be deleted. Custom or Express accounts created using live-mode keys can only be deleted once all balances are zero.&lt;/p&gt;  &lt;p&gt;If you want to delete your own account, use the &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/account\&quot;&gt;account information tab in your account settings&lt;/a&gt; instead.&lt;/p&gt;
    # @optional @param account [String?]
    # @return nil
    def delete_account(*, account : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_account(account: account).execute(&block)
    end

    DELETE_ACCOUNT_MAX_LENGTH_FOR_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_delete_account(*, account : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_account ..." }
      end

      if client_side_validation
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, DELETE_ACCOUNT_MAX_LENGTH_FOR_ACCOUNT)
        end
      end

      # resource path
      local_var_path = "/v1/account"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account"] = account.to_s if !account.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_account",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Delete a specified external account for a given account.</p>
    # @param id [String?]
    # @return [DeletedExternalAccount]
    def delete_account_bank_accounts_id(*, id : String? = nil)
      data, _status_code, _headers = delete_account_bank_accounts_id_with_http_info(id: id)
      data
    end

    # &lt;p&gt;Delete a specified external account for a given account.&lt;/p&gt;
    # @param id [String?]
    # @return [Array<(DeletedExternalAccount, Integer, Hash)>] DeletedExternalAccount data, response status code and response headers
    def delete_account_bank_accounts_id_with_http_info(*, id : String? = nil)
      request = build_api_request_for_delete_account_bank_accounts_id(id: id)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_account_bank_accounts_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedExternalAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Delete a specified external account for a given account.&lt;/p&gt;
    # @param id [String?]
    # @return nil
    def delete_account_bank_accounts_id(*, id : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_account_bank_accounts_id(id: id).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_delete_account_bank_accounts_id(*, id : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_account_bank_accounts_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
      end

      # resource path
      local_var_path = "/v1/account/bank_accounts/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_account_bank_accounts_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Delete a specified external account for a given account.</p>
    # @param id [String?]
    # @return [DeletedExternalAccount]
    def delete_account_external_accounts_id(*, id : String? = nil)
      data, _status_code, _headers = delete_account_external_accounts_id_with_http_info(id: id)
      data
    end

    # &lt;p&gt;Delete a specified external account for a given account.&lt;/p&gt;
    # @param id [String?]
    # @return [Array<(DeletedExternalAccount, Integer, Hash)>] DeletedExternalAccount data, response status code and response headers
    def delete_account_external_accounts_id_with_http_info(*, id : String? = nil)
      request = build_api_request_for_delete_account_external_accounts_id(id: id)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_account_external_accounts_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedExternalAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Delete a specified external account for a given account.&lt;/p&gt;
    # @param id [String?]
    # @return nil
    def delete_account_external_accounts_id(*, id : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_account_external_accounts_id(id: id).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_delete_account_external_accounts_id(*, id : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_account_external_accounts_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
      end

      # resource path
      local_var_path = "/v1/account/external_accounts/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_account_external_accounts_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Deletes an existing person’s relationship to the account’s legal entity. Any person with a relationship for an account can be deleted through the API, except if the person is the <code>account_opener</code>. If your integration is using the <code>executive</code> parameter, you cannot delete the only verified <code>executive</code> on file.</p>
    # @param person [String?]
    # @return [DeletedPerson]
    def delete_account_people_person(*, person : String? = nil)
      data, _status_code, _headers = delete_account_people_person_with_http_info(person: person)
      data
    end

    # &lt;p&gt;Deletes an existing person’s relationship to the account’s legal entity. Any person with a relationship for an account can be deleted through the API, except if the person is the &lt;code&gt;account_opener&lt;/code&gt;. If your integration is using the &lt;code&gt;executive&lt;/code&gt; parameter, you cannot delete the only verified &lt;code&gt;executive&lt;/code&gt; on file.&lt;/p&gt;
    # @param person [String?]
    # @return [Array<(DeletedPerson, Integer, Hash)>] DeletedPerson data, response status code and response headers
    def delete_account_people_person_with_http_info(*, person : String? = nil)
      request = build_api_request_for_delete_account_people_person(person: person)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_account_people_person\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedPerson.from_json(data), status_code, headers
    end

    # &lt;p&gt;Deletes an existing person’s relationship to the account’s legal entity. Any person with a relationship for an account can be deleted through the API, except if the person is the &lt;code&gt;account_opener&lt;/code&gt;. If your integration is using the &lt;code&gt;executive&lt;/code&gt; parameter, you cannot delete the only verified &lt;code&gt;executive&lt;/code&gt; on file.&lt;/p&gt;
    # @param person [String?]
    # @return nil
    def delete_account_people_person(*, person : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_account_people_person(person: person).execute(&block)
    end

    DELETE_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_PERSON = 5000

    # @return Crest::Request
    def build_api_request_for_delete_account_people_person(*, person : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_account_people_person ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"person\" is required and cannot be null") if person.nil?
        if _person = person
          OpenApi::PrimitiveValidator.validate_max_length("person", person.to_s.size, DELETE_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_PERSON)
        end
      end

      # resource path
      local_var_path = "/v1/account/people/{person}".sub("{" + "person" + "}", URI.encode_path(person.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_account_people_person",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Deletes an existing person’s relationship to the account’s legal entity. Any person with a relationship for an account can be deleted through the API, except if the person is the <code>account_opener</code>. If your integration is using the <code>executive</code> parameter, you cannot delete the only verified <code>executive</code> on file.</p>
    # @param person [String?]
    # @return [DeletedPerson]
    def delete_account_persons_person(*, person : String? = nil)
      data, _status_code, _headers = delete_account_persons_person_with_http_info(person: person)
      data
    end

    # &lt;p&gt;Deletes an existing person’s relationship to the account’s legal entity. Any person with a relationship for an account can be deleted through the API, except if the person is the &lt;code&gt;account_opener&lt;/code&gt;. If your integration is using the &lt;code&gt;executive&lt;/code&gt; parameter, you cannot delete the only verified &lt;code&gt;executive&lt;/code&gt; on file.&lt;/p&gt;
    # @param person [String?]
    # @return [Array<(DeletedPerson, Integer, Hash)>] DeletedPerson data, response status code and response headers
    def delete_account_persons_person_with_http_info(*, person : String? = nil)
      request = build_api_request_for_delete_account_persons_person(person: person)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_account_persons_person\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedPerson.from_json(data), status_code, headers
    end

    # &lt;p&gt;Deletes an existing person’s relationship to the account’s legal entity. Any person with a relationship for an account can be deleted through the API, except if the person is the &lt;code&gt;account_opener&lt;/code&gt;. If your integration is using the &lt;code&gt;executive&lt;/code&gt; parameter, you cannot delete the only verified &lt;code&gt;executive&lt;/code&gt; on file.&lt;/p&gt;
    # @param person [String?]
    # @return nil
    def delete_account_persons_person(*, person : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_account_persons_person(person: person).execute(&block)
    end

    DELETE_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_PERSON = 5000

    # @return Crest::Request
    def build_api_request_for_delete_account_persons_person(*, person : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_account_persons_person ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"person\" is required and cannot be null") if person.nil?
        if _person = person
          OpenApi::PrimitiveValidator.validate_max_length("person", person.to_s.size, DELETE_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_PERSON)
        end
      end

      # resource path
      local_var_path = "/v1/account/persons/{person}".sub("{" + "person" + "}", URI.encode_path(person.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_account_persons_person",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>With <a href=\"/docs/connect\">Connect</a>, you can delete accounts you manage.</p>  <p>Accounts created using test-mode keys can be deleted at any time. Standard accounts created using live-mode keys cannot be deleted. Custom or Express accounts created using live-mode keys can only be deleted once all balances are zero.</p>  <p>If you want to delete your own account, use the <a href=\"https://dashboard.stripe.com/account\">account information tab in your account settings</a> instead.</p>
    # @param account [String?]
    # @return [DeletedAccount]
    def delete_accounts_account(*, account : String? = nil)
      data, _status_code, _headers = delete_accounts_account_with_http_info(account: account)
      data
    end

    # &lt;p&gt;With &lt;a href&#x3D;\&quot;/docs/connect\&quot;&gt;Connect&lt;/a&gt;, you can delete accounts you manage.&lt;/p&gt;  &lt;p&gt;Accounts created using test-mode keys can be deleted at any time. Standard accounts created using live-mode keys cannot be deleted. Custom or Express accounts created using live-mode keys can only be deleted once all balances are zero.&lt;/p&gt;  &lt;p&gt;If you want to delete your own account, use the &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/account\&quot;&gt;account information tab in your account settings&lt;/a&gt; instead.&lt;/p&gt;
    # @param account [String?]
    # @return [Array<(DeletedAccount, Integer, Hash)>] DeletedAccount data, response status code and response headers
    def delete_accounts_account_with_http_info(*, account : String? = nil)
      request = build_api_request_for_delete_accounts_account(account: account)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_accounts_account\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;With &lt;a href&#x3D;\&quot;/docs/connect\&quot;&gt;Connect&lt;/a&gt;, you can delete accounts you manage.&lt;/p&gt;  &lt;p&gt;Accounts created using test-mode keys can be deleted at any time. Standard accounts created using live-mode keys cannot be deleted. Custom or Express accounts created using live-mode keys can only be deleted once all balances are zero.&lt;/p&gt;  &lt;p&gt;If you want to delete your own account, use the &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/account\&quot;&gt;account information tab in your account settings&lt;/a&gt; instead.&lt;/p&gt;
    # @param account [String?]
    # @return nil
    def delete_accounts_account(*, account : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_accounts_account(account: account).execute(&block)
    end

    DELETE_ACCOUNTS_ACCOUNT_MAX_LENGTH_FOR_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_delete_accounts_account(*, account : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_accounts_account ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, DELETE_ACCOUNTS_ACCOUNT_MAX_LENGTH_FOR_ACCOUNT)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_accounts_account",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Delete a specified external account for a given account.</p>
    # @param account [String?]
    # @param id [String?]
    # @return [DeletedExternalAccount]
    def delete_accounts_account_bank_accounts_id(*, account : String? = nil, id : String? = nil)
      data, _status_code, _headers = delete_accounts_account_bank_accounts_id_with_http_info(account: account, id: id)
      data
    end

    # &lt;p&gt;Delete a specified external account for a given account.&lt;/p&gt;
    # @param account [String?]
    # @param id [String?]
    # @return [Array<(DeletedExternalAccount, Integer, Hash)>] DeletedExternalAccount data, response status code and response headers
    def delete_accounts_account_bank_accounts_id_with_http_info(*, account : String? = nil, id : String? = nil)
      request = build_api_request_for_delete_accounts_account_bank_accounts_id(account: account, id: id)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_accounts_account_bank_accounts_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedExternalAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Delete a specified external account for a given account.&lt;/p&gt;
    # @param account [String?]
    # @param id [String?]
    # @return nil
    def delete_accounts_account_bank_accounts_id(*, account : String? = nil, id : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_accounts_account_bank_accounts_id(account: account, id: id).execute(&block)
    end

    DELETE_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_delete_accounts_account_bank_accounts_id(*, account : String? = nil, id : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_accounts_account_bank_accounts_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, DELETE_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/bank_accounts/{id}".sub("{" + "account" + "}", URI.encode_path(account.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_accounts_account_bank_accounts_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Delete a specified external account for a given account.</p>
    # @param account [String?]
    # @param id [String?]
    # @return [DeletedExternalAccount]
    def delete_accounts_account_external_accounts_id(*, account : String? = nil, id : String? = nil)
      data, _status_code, _headers = delete_accounts_account_external_accounts_id_with_http_info(account: account, id: id)
      data
    end

    # &lt;p&gt;Delete a specified external account for a given account.&lt;/p&gt;
    # @param account [String?]
    # @param id [String?]
    # @return [Array<(DeletedExternalAccount, Integer, Hash)>] DeletedExternalAccount data, response status code and response headers
    def delete_accounts_account_external_accounts_id_with_http_info(*, account : String? = nil, id : String? = nil)
      request = build_api_request_for_delete_accounts_account_external_accounts_id(account: account, id: id)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_accounts_account_external_accounts_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedExternalAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Delete a specified external account for a given account.&lt;/p&gt;
    # @param account [String?]
    # @param id [String?]
    # @return nil
    def delete_accounts_account_external_accounts_id(*, account : String? = nil, id : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_accounts_account_external_accounts_id(account: account, id: id).execute(&block)
    end

    DELETE_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_delete_accounts_account_external_accounts_id(*, account : String? = nil, id : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_accounts_account_external_accounts_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, DELETE_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/external_accounts/{id}".sub("{" + "account" + "}", URI.encode_path(account.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_accounts_account_external_accounts_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Deletes an existing person’s relationship to the account’s legal entity. Any person with a relationship for an account can be deleted through the API, except if the person is the <code>account_opener</code>. If your integration is using the <code>executive</code> parameter, you cannot delete the only verified <code>executive</code> on file.</p>
    # @param account [String?]
    # @param person [String?]
    # @return [DeletedPerson]
    def delete_accounts_account_people_person(*, account : String? = nil, person : String? = nil)
      data, _status_code, _headers = delete_accounts_account_people_person_with_http_info(account: account, person: person)
      data
    end

    # &lt;p&gt;Deletes an existing person’s relationship to the account’s legal entity. Any person with a relationship for an account can be deleted through the API, except if the person is the &lt;code&gt;account_opener&lt;/code&gt;. If your integration is using the &lt;code&gt;executive&lt;/code&gt; parameter, you cannot delete the only verified &lt;code&gt;executive&lt;/code&gt; on file.&lt;/p&gt;
    # @param account [String?]
    # @param person [String?]
    # @return [Array<(DeletedPerson, Integer, Hash)>] DeletedPerson data, response status code and response headers
    def delete_accounts_account_people_person_with_http_info(*, account : String? = nil, person : String? = nil)
      request = build_api_request_for_delete_accounts_account_people_person(account: account, person: person)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_accounts_account_people_person\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedPerson.from_json(data), status_code, headers
    end

    # &lt;p&gt;Deletes an existing person’s relationship to the account’s legal entity. Any person with a relationship for an account can be deleted through the API, except if the person is the &lt;code&gt;account_opener&lt;/code&gt;. If your integration is using the &lt;code&gt;executive&lt;/code&gt; parameter, you cannot delete the only verified &lt;code&gt;executive&lt;/code&gt; on file.&lt;/p&gt;
    # @param account [String?]
    # @param person [String?]
    # @return nil
    def delete_accounts_account_people_person(*, account : String? = nil, person : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_accounts_account_people_person(account: account, person: person).execute(&block)
    end

    DELETE_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_ACCOUNT = 5000
    DELETE_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_PERSON  = 5000

    # @return Crest::Request
    def build_api_request_for_delete_accounts_account_people_person(*, account : String? = nil, person : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_accounts_account_people_person ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, DELETE_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_ACCOUNT)
        end
        raise ArgumentError.new("\"person\" is required and cannot be null") if person.nil?
        if _person = person
          OpenApi::PrimitiveValidator.validate_max_length("person", person.to_s.size, DELETE_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_PERSON)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/people/{person}".sub("{" + "account" + "}", URI.encode_path(account.to_s)).sub("{" + "person" + "}", URI.encode_path(person.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_accounts_account_people_person",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Deletes an existing person’s relationship to the account’s legal entity. Any person with a relationship for an account can be deleted through the API, except if the person is the <code>account_opener</code>. If your integration is using the <code>executive</code> parameter, you cannot delete the only verified <code>executive</code> on file.</p>
    # @param account [String?]
    # @param person [String?]
    # @return [DeletedPerson]
    def delete_accounts_account_persons_person(*, account : String? = nil, person : String? = nil)
      data, _status_code, _headers = delete_accounts_account_persons_person_with_http_info(account: account, person: person)
      data
    end

    # &lt;p&gt;Deletes an existing person’s relationship to the account’s legal entity. Any person with a relationship for an account can be deleted through the API, except if the person is the &lt;code&gt;account_opener&lt;/code&gt;. If your integration is using the &lt;code&gt;executive&lt;/code&gt; parameter, you cannot delete the only verified &lt;code&gt;executive&lt;/code&gt; on file.&lt;/p&gt;
    # @param account [String?]
    # @param person [String?]
    # @return [Array<(DeletedPerson, Integer, Hash)>] DeletedPerson data, response status code and response headers
    def delete_accounts_account_persons_person_with_http_info(*, account : String? = nil, person : String? = nil)
      request = build_api_request_for_delete_accounts_account_persons_person(account: account, person: person)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_accounts_account_persons_person\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedPerson.from_json(data), status_code, headers
    end

    # &lt;p&gt;Deletes an existing person’s relationship to the account’s legal entity. Any person with a relationship for an account can be deleted through the API, except if the person is the &lt;code&gt;account_opener&lt;/code&gt;. If your integration is using the &lt;code&gt;executive&lt;/code&gt; parameter, you cannot delete the only verified &lt;code&gt;executive&lt;/code&gt; on file.&lt;/p&gt;
    # @param account [String?]
    # @param person [String?]
    # @return nil
    def delete_accounts_account_persons_person(*, account : String? = nil, person : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_accounts_account_persons_person(account: account, person: person).execute(&block)
    end

    DELETE_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_ACCOUNT = 5000
    DELETE_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_PERSON  = 5000

    # @return Crest::Request
    def build_api_request_for_delete_accounts_account_persons_person(*, account : String? = nil, person : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_accounts_account_persons_person ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, DELETE_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_ACCOUNT)
        end
        raise ArgumentError.new("\"person\" is required and cannot be null") if person.nil?
        if _person = person
          OpenApi::PrimitiveValidator.validate_max_length("person", person.to_s.size, DELETE_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_PERSON)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/persons/{person}".sub("{" + "account" + "}", URI.encode_path(account.to_s)).sub("{" + "person" + "}", URI.encode_path(person.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_accounts_account_persons_person",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Delete an apple pay domain.</p>
    # @param domain [String?]
    # @return [DeletedApplePayDomain]
    def delete_apple_pay_domains_domain(*, domain : String? = nil)
      data, _status_code, _headers = delete_apple_pay_domains_domain_with_http_info(domain: domain)
      data
    end

    # &lt;p&gt;Delete an apple pay domain.&lt;/p&gt;
    # @param domain [String?]
    # @return [Array<(DeletedApplePayDomain, Integer, Hash)>] DeletedApplePayDomain data, response status code and response headers
    def delete_apple_pay_domains_domain_with_http_info(*, domain : String? = nil)
      request = build_api_request_for_delete_apple_pay_domains_domain(domain: domain)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_apple_pay_domains_domain\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedApplePayDomain.from_json(data), status_code, headers
    end

    # &lt;p&gt;Delete an apple pay domain.&lt;/p&gt;
    # @param domain [String?]
    # @return nil
    def delete_apple_pay_domains_domain(*, domain : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_apple_pay_domains_domain(domain: domain).execute(&block)
    end

    DELETE_APPLE_PAY_DOMAINS_DOMAIN_MAX_LENGTH_FOR_DOMAIN = 5000

    # @return Crest::Request
    def build_api_request_for_delete_apple_pay_domains_domain(*, domain : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_apple_pay_domains_domain ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"domain\" is required and cannot be null") if domain.nil?
        if _domain = domain
          OpenApi::PrimitiveValidator.validate_max_length("domain", domain.to_s.size, DELETE_APPLE_PAY_DOMAINS_DOMAIN_MAX_LENGTH_FOR_DOMAIN)
        end
      end

      # resource path
      local_var_path = "/v1/apple_pay/domains/{domain}".sub("{" + "domain" + "}", URI.encode_path(domain.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_apple_pay_domains_domain",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>You can delete coupons via the <a href=\"https://dashboard.stripe.com/coupons\">coupon management</a> page of the Stripe dashboard. However, deleting a coupon does not affect any customers who have already applied the coupon; it means that new customers can’t redeem the coupon. You can also delete coupons via the API.</p>
    # @param coupon [String?]
    # @return [DeletedCoupon]
    def delete_coupons_coupon(*, coupon : String? = nil)
      data, _status_code, _headers = delete_coupons_coupon_with_http_info(coupon: coupon)
      data
    end

    # &lt;p&gt;You can delete coupons via the &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/coupons\&quot;&gt;coupon management&lt;/a&gt; page of the Stripe dashboard. However, deleting a coupon does not affect any customers who have already applied the coupon; it means that new customers can’t redeem the coupon. You can also delete coupons via the API.&lt;/p&gt;
    # @param coupon [String?]
    # @return [Array<(DeletedCoupon, Integer, Hash)>] DeletedCoupon data, response status code and response headers
    def delete_coupons_coupon_with_http_info(*, coupon : String? = nil)
      request = build_api_request_for_delete_coupons_coupon(coupon: coupon)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_coupons_coupon\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedCoupon.from_json(data), status_code, headers
    end

    # &lt;p&gt;You can delete coupons via the &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/coupons\&quot;&gt;coupon management&lt;/a&gt; page of the Stripe dashboard. However, deleting a coupon does not affect any customers who have already applied the coupon; it means that new customers can’t redeem the coupon. You can also delete coupons via the API.&lt;/p&gt;
    # @param coupon [String?]
    # @return nil
    def delete_coupons_coupon(*, coupon : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_coupons_coupon(coupon: coupon).execute(&block)
    end

    DELETE_COUPONS_COUPON_MAX_LENGTH_FOR_COUPON = 5000

    # @return Crest::Request
    def build_api_request_for_delete_coupons_coupon(*, coupon : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_coupons_coupon ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"coupon\" is required and cannot be null") if coupon.nil?
        if _coupon = coupon
          OpenApi::PrimitiveValidator.validate_max_length("coupon", coupon.to_s.size, DELETE_COUPONS_COUPON_MAX_LENGTH_FOR_COUPON)
        end
      end

      # resource path
      local_var_path = "/v1/coupons/{coupon}".sub("{" + "coupon" + "}", URI.encode_path(coupon.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_coupons_coupon",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Permanently deletes a customer. It cannot be undone. Also immediately cancels any active subscriptions on the customer.</p>
    # @param customer [String?]
    # @return [DeletedCustomer]
    def delete_customers_customer(*, customer : String? = nil)
      data, _status_code, _headers = delete_customers_customer_with_http_info(customer: customer)
      data
    end

    # &lt;p&gt;Permanently deletes a customer. It cannot be undone. Also immediately cancels any active subscriptions on the customer.&lt;/p&gt;
    # @param customer [String?]
    # @return [Array<(DeletedCustomer, Integer, Hash)>] DeletedCustomer data, response status code and response headers
    def delete_customers_customer_with_http_info(*, customer : String? = nil)
      request = build_api_request_for_delete_customers_customer(customer: customer)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_customers_customer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedCustomer.from_json(data), status_code, headers
    end

    # &lt;p&gt;Permanently deletes a customer. It cannot be undone. Also immediately cancels any active subscriptions on the customer.&lt;/p&gt;
    # @param customer [String?]
    # @return nil
    def delete_customers_customer(*, customer : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_customers_customer(customer: customer).execute(&block)
    end

    DELETE_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_CUSTOMER = 5000

    # @return Crest::Request
    def build_api_request_for_delete_customers_customer(*, customer : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_customers_customer ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, DELETE_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_CUSTOMER)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_customers_customer",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Delete a specified source for a given customer.</p>
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [DeleteCustomersCustomerBankAccountsId200Response]
    def delete_customers_customer_bank_accounts_id(*, customer : String? = nil, id : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = delete_customers_customer_bank_accounts_id_with_http_info(customer: customer, id: id, expand: expand)
      data
    end

    # &lt;p&gt;Delete a specified source for a given customer.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(DeleteCustomersCustomerBankAccountsId200Response, Integer, Hash)>] DeleteCustomersCustomerBankAccountsId200Response data, response status code and response headers
    def delete_customers_customer_bank_accounts_id_with_http_info(*, customer : String? = nil, id : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_delete_customers_customer_bank_accounts_id(customer: customer, id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_customers_customer_bank_accounts_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeleteCustomersCustomerBankAccountsId200Response.from_json(data), status_code, headers
    end

    # &lt;p&gt;Delete a specified source for a given customer.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def delete_customers_customer_bank_accounts_id(*, customer : String? = nil, id : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_customers_customer_bank_accounts_id(customer: customer, id: id, expand: expand).execute(&block)
    end

    DELETE_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_CUSTOMER = 5000

    # @return Crest::Request
    def build_api_request_for_delete_customers_customer_bank_accounts_id(*, customer : String? = nil, id : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_customers_customer_bank_accounts_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, DELETE_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/bank_accounts/{id}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_customers_customer_bank_accounts_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Delete a specified source for a given customer.</p>
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [DeleteCustomersCustomerBankAccountsId200Response]
    def delete_customers_customer_cards_id(*, customer : String? = nil, id : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = delete_customers_customer_cards_id_with_http_info(customer: customer, id: id, expand: expand)
      data
    end

    # &lt;p&gt;Delete a specified source for a given customer.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(DeleteCustomersCustomerBankAccountsId200Response, Integer, Hash)>] DeleteCustomersCustomerBankAccountsId200Response data, response status code and response headers
    def delete_customers_customer_cards_id_with_http_info(*, customer : String? = nil, id : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_delete_customers_customer_cards_id(customer: customer, id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_customers_customer_cards_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeleteCustomersCustomerBankAccountsId200Response.from_json(data), status_code, headers
    end

    # &lt;p&gt;Delete a specified source for a given customer.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def delete_customers_customer_cards_id(*, customer : String? = nil, id : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_customers_customer_cards_id(customer: customer, id: id, expand: expand).execute(&block)
    end

    DELETE_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_CUSTOMER = 5000

    # @return Crest::Request
    def build_api_request_for_delete_customers_customer_cards_id(*, customer : String? = nil, id : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_customers_customer_cards_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, DELETE_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/cards/{id}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_customers_customer_cards_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Removes the currently applied discount on a customer.</p>
    # @param customer [String?]
    # @return [DeletedDiscount]
    def delete_customers_customer_discount(*, customer : String? = nil)
      data, _status_code, _headers = delete_customers_customer_discount_with_http_info(customer: customer)
      data
    end

    # &lt;p&gt;Removes the currently applied discount on a customer.&lt;/p&gt;
    # @param customer [String?]
    # @return [Array<(DeletedDiscount, Integer, Hash)>] DeletedDiscount data, response status code and response headers
    def delete_customers_customer_discount_with_http_info(*, customer : String? = nil)
      request = build_api_request_for_delete_customers_customer_discount(customer: customer)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_customers_customer_discount\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedDiscount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Removes the currently applied discount on a customer.&lt;/p&gt;
    # @param customer [String?]
    # @return nil
    def delete_customers_customer_discount(*, customer : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_customers_customer_discount(customer: customer).execute(&block)
    end

    DELETE_CUSTOMERS_CUSTOMER_DISCOUNT_MAX_LENGTH_FOR_CUSTOMER = 5000

    # @return Crest::Request
    def build_api_request_for_delete_customers_customer_discount(*, customer : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_customers_customer_discount ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, DELETE_CUSTOMERS_CUSTOMER_DISCOUNT_MAX_LENGTH_FOR_CUSTOMER)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/discount".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_customers_customer_discount",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Delete a specified source for a given customer.</p>
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [DeleteCustomersCustomerBankAccountsId200Response]
    def delete_customers_customer_sources_id(*, customer : String? = nil, id : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = delete_customers_customer_sources_id_with_http_info(customer: customer, id: id, expand: expand)
      data
    end

    # &lt;p&gt;Delete a specified source for a given customer.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(DeleteCustomersCustomerBankAccountsId200Response, Integer, Hash)>] DeleteCustomersCustomerBankAccountsId200Response data, response status code and response headers
    def delete_customers_customer_sources_id_with_http_info(*, customer : String? = nil, id : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_delete_customers_customer_sources_id(customer: customer, id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_customers_customer_sources_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeleteCustomersCustomerBankAccountsId200Response.from_json(data), status_code, headers
    end

    # &lt;p&gt;Delete a specified source for a given customer.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def delete_customers_customer_sources_id(*, customer : String? = nil, id : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_customers_customer_sources_id(customer: customer, id: id, expand: expand).execute(&block)
    end

    DELETE_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_CUSTOMER = 5000

    # @return Crest::Request
    def build_api_request_for_delete_customers_customer_sources_id(*, customer : String? = nil, id : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_customers_customer_sources_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, DELETE_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/sources/{id}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_customers_customer_sources_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Cancels a customer’s subscription. If you set the <code>at_period_end</code> parameter to <code>true</code>, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. Otherwise, with the default <code>false</code> value, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription.</p>  <p>Note, however, that any pending invoice items that you’ve created will still be charged for at the end of the period, unless manually <a href=\"#delete_invoiceitem\">deleted</a>. If you’ve set the subscription to cancel at the end of the period, any pending prorations will also be left in place and collected at the end of the period. But if the subscription is set to cancel immediately, pending prorations will be removed.</p>  <p>By default, upon subscription cancellation, Stripe will stop automatic collection of all finalized invoices for the customer. This is intended to prevent unexpected payment attempts after the customer has canceled a subscription. However, you can resume automatic collection of the invoices manually after subscription cancellation to have us proceed. Or, you could check for unpaid invoices before allowing the customer to cancel the subscription at all.</p>
    # @param customer [String?]
    # @param subscription_exposed_id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_now [Bool?] Can be set to `true` if `at_period_end` is not set to `true`. Will generate a final invoice that invoices for any un-invoiced metered usage and new/pending proration invoice items.
    # @optional @param prorate [Bool?] Can be set to `true` if `at_period_end` is not set to `true`. Will generate a proration invoice item that credits remaining unused time until the subscription period end.
    # @return [Subscription]
    def delete_customers_customer_subscriptions_subscription_exposed_id(*, customer : String? = nil, subscription_exposed_id : String? = nil, expand : Array(String)? = nil, invoice_now : Bool? = nil, prorate : Bool? = nil)
      data, _status_code, _headers = delete_customers_customer_subscriptions_subscription_exposed_id_with_http_info(customer: customer, subscription_exposed_id: subscription_exposed_id, expand: expand, invoice_now: invoice_now, prorate: prorate)
      data
    end

    # &lt;p&gt;Cancels a customer’s subscription. If you set the &lt;code&gt;at_period_end&lt;/code&gt; parameter to &lt;code&gt;true&lt;/code&gt;, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. Otherwise, with the default &lt;code&gt;false&lt;/code&gt; value, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription.&lt;/p&gt;  &lt;p&gt;Note, however, that any pending invoice items that you’ve created will still be charged for at the end of the period, unless manually &lt;a href&#x3D;\&quot;#delete_invoiceitem\&quot;&gt;deleted&lt;/a&gt;. If you’ve set the subscription to cancel at the end of the period, any pending prorations will also be left in place and collected at the end of the period. But if the subscription is set to cancel immediately, pending prorations will be removed.&lt;/p&gt;  &lt;p&gt;By default, upon subscription cancellation, Stripe will stop automatic collection of all finalized invoices for the customer. This is intended to prevent unexpected payment attempts after the customer has canceled a subscription. However, you can resume automatic collection of the invoices manually after subscription cancellation to have us proceed. Or, you could check for unpaid invoices before allowing the customer to cancel the subscription at all.&lt;/p&gt;
    # @param customer [String?]
    # @param subscription_exposed_id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_now [Bool?] Can be set to `true` if `at_period_end` is not set to `true`. Will generate a final invoice that invoices for any un-invoiced metered usage and new/pending proration invoice items.
    # @optional @param prorate [Bool?] Can be set to `true` if `at_period_end` is not set to `true`. Will generate a proration invoice item that credits remaining unused time until the subscription period end.
    # @return [Array<(Subscription, Integer, Hash)>] Subscription data, response status code and response headers
    def delete_customers_customer_subscriptions_subscription_exposed_id_with_http_info(*, customer : String? = nil, subscription_exposed_id : String? = nil, expand : Array(String)? = nil, invoice_now : Bool? = nil, prorate : Bool? = nil)
      request = build_api_request_for_delete_customers_customer_subscriptions_subscription_exposed_id(customer: customer, subscription_exposed_id: subscription_exposed_id, expand: expand, invoice_now: invoice_now, prorate: prorate)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_customers_customer_subscriptions_subscription_exposed_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Subscription.from_json(data), status_code, headers
    end

    # &lt;p&gt;Cancels a customer’s subscription. If you set the &lt;code&gt;at_period_end&lt;/code&gt; parameter to &lt;code&gt;true&lt;/code&gt;, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. Otherwise, with the default &lt;code&gt;false&lt;/code&gt; value, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription.&lt;/p&gt;  &lt;p&gt;Note, however, that any pending invoice items that you’ve created will still be charged for at the end of the period, unless manually &lt;a href&#x3D;\&quot;#delete_invoiceitem\&quot;&gt;deleted&lt;/a&gt;. If you’ve set the subscription to cancel at the end of the period, any pending prorations will also be left in place and collected at the end of the period. But if the subscription is set to cancel immediately, pending prorations will be removed.&lt;/p&gt;  &lt;p&gt;By default, upon subscription cancellation, Stripe will stop automatic collection of all finalized invoices for the customer. This is intended to prevent unexpected payment attempts after the customer has canceled a subscription. However, you can resume automatic collection of the invoices manually after subscription cancellation to have us proceed. Or, you could check for unpaid invoices before allowing the customer to cancel the subscription at all.&lt;/p&gt;
    # @param customer [String?]
    # @param subscription_exposed_id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_now [Bool?] Can be set to `true` if `at_period_end` is not set to `true`. Will generate a final invoice that invoices for any un-invoiced metered usage and new/pending proration invoice items.
    # @optional @param prorate [Bool?] Can be set to `true` if `at_period_end` is not set to `true`. Will generate a proration invoice item that credits remaining unused time until the subscription period end.
    # @return nil
    def delete_customers_customer_subscriptions_subscription_exposed_id(*, customer : String? = nil, subscription_exposed_id : String? = nil, expand : Array(String)? = nil, invoice_now : Bool? = nil, prorate : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_customers_customer_subscriptions_subscription_exposed_id(customer: customer, subscription_exposed_id: subscription_exposed_id, expand: expand, invoice_now: invoice_now, prorate: prorate).execute(&block)
    end

    DELETE_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_CUSTOMER                = 5000
    DELETE_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID = 5000

    # @return Crest::Request
    def build_api_request_for_delete_customers_customer_subscriptions_subscription_exposed_id(*, customer : String? = nil, subscription_exposed_id : String? = nil, expand : Array(String)? = nil, invoice_now : Bool? = nil, prorate : Bool? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_customers_customer_subscriptions_subscription_exposed_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, DELETE_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"subscription_exposed_id\" is required and cannot be null") if subscription_exposed_id.nil?
        if _subscription_exposed_id = subscription_exposed_id
          OpenApi::PrimitiveValidator.validate_max_length("subscription_exposed_id", subscription_exposed_id.to_s.size, DELETE_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/subscriptions/{subscription_exposed_id}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "subscription_exposed_id" + "}", URI.encode_path(subscription_exposed_id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["invoice_now"] = invoice_now.to_s if !invoice_now.nil?
      form_params["prorate"] = prorate.to_s if !prorate.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_customers_customer_subscriptions_subscription_exposed_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Removes the currently applied discount on a customer.</p>
    # @param customer [String?]
    # @param subscription_exposed_id [String?]
    # @return [DeletedDiscount]
    def delete_customers_customer_subscriptions_subscription_exposed_id_discount(*, customer : String? = nil, subscription_exposed_id : String? = nil)
      data, _status_code, _headers = delete_customers_customer_subscriptions_subscription_exposed_id_discount_with_http_info(customer: customer, subscription_exposed_id: subscription_exposed_id)
      data
    end

    # &lt;p&gt;Removes the currently applied discount on a customer.&lt;/p&gt;
    # @param customer [String?]
    # @param subscription_exposed_id [String?]
    # @return [Array<(DeletedDiscount, Integer, Hash)>] DeletedDiscount data, response status code and response headers
    def delete_customers_customer_subscriptions_subscription_exposed_id_discount_with_http_info(*, customer : String? = nil, subscription_exposed_id : String? = nil)
      request = build_api_request_for_delete_customers_customer_subscriptions_subscription_exposed_id_discount(customer: customer, subscription_exposed_id: subscription_exposed_id)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_customers_customer_subscriptions_subscription_exposed_id_discount\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedDiscount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Removes the currently applied discount on a customer.&lt;/p&gt;
    # @param customer [String?]
    # @param subscription_exposed_id [String?]
    # @return nil
    def delete_customers_customer_subscriptions_subscription_exposed_id_discount(*, customer : String? = nil, subscription_exposed_id : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_customers_customer_subscriptions_subscription_exposed_id_discount(customer: customer, subscription_exposed_id: subscription_exposed_id).execute(&block)
    end

    DELETE_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_DISCOUNT_MAX_LENGTH_FOR_CUSTOMER                = 5000
    DELETE_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_DISCOUNT_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID = 5000

    # @return Crest::Request
    def build_api_request_for_delete_customers_customer_subscriptions_subscription_exposed_id_discount(*, customer : String? = nil, subscription_exposed_id : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_customers_customer_subscriptions_subscription_exposed_id_discount ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, DELETE_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_DISCOUNT_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"subscription_exposed_id\" is required and cannot be null") if subscription_exposed_id.nil?
        if _subscription_exposed_id = subscription_exposed_id
          OpenApi::PrimitiveValidator.validate_max_length("subscription_exposed_id", subscription_exposed_id.to_s.size, DELETE_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_DISCOUNT_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/subscriptions/{subscription_exposed_id}/discount".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "subscription_exposed_id" + "}", URI.encode_path(subscription_exposed_id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_customers_customer_subscriptions_subscription_exposed_id_discount",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Deletes an existing <code>TaxID</code> object.</p>
    # @param customer [String?]
    # @param id [String?]
    # @return [DeletedTaxId]
    def delete_customers_customer_tax_ids_id(*, customer : String? = nil, id : String? = nil)
      data, _status_code, _headers = delete_customers_customer_tax_ids_id_with_http_info(customer: customer, id: id)
      data
    end

    # &lt;p&gt;Deletes an existing &lt;code&gt;TaxID&lt;/code&gt; object.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @return [Array<(DeletedTaxId, Integer, Hash)>] DeletedTaxId data, response status code and response headers
    def delete_customers_customer_tax_ids_id_with_http_info(*, customer : String? = nil, id : String? = nil)
      request = build_api_request_for_delete_customers_customer_tax_ids_id(customer: customer, id: id)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_customers_customer_tax_ids_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedTaxId.from_json(data), status_code, headers
    end

    # &lt;p&gt;Deletes an existing &lt;code&gt;TaxID&lt;/code&gt; object.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @return nil
    def delete_customers_customer_tax_ids_id(*, customer : String? = nil, id : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_customers_customer_tax_ids_id(customer: customer, id: id).execute(&block)
    end

    DELETE_CUSTOMERS_CUSTOMER_TAX_IDS_ID_MAX_LENGTH_FOR_CUSTOMER = 5000

    # @return Crest::Request
    def build_api_request_for_delete_customers_customer_tax_ids_id(*, customer : String? = nil, id : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_customers_customer_tax_ids_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, DELETE_CUSTOMERS_CUSTOMER_TAX_IDS_ID_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/tax_ids/{id}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_customers_customer_tax_ids_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Invalidates a short-lived API key for a given resource.</p>
    # @param key [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [EphemeralKey]
    def delete_ephemeral_keys_key(*, key : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = delete_ephemeral_keys_key_with_http_info(key: key, expand: expand)
      data
    end

    # &lt;p&gt;Invalidates a short-lived API key for a given resource.&lt;/p&gt;
    # @param key [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(EphemeralKey, Integer, Hash)>] EphemeralKey data, response status code and response headers
    def delete_ephemeral_keys_key_with_http_info(*, key : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_delete_ephemeral_keys_key(key: key, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_ephemeral_keys_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return EphemeralKey.from_json(data), status_code, headers
    end

    # &lt;p&gt;Invalidates a short-lived API key for a given resource.&lt;/p&gt;
    # @param key [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def delete_ephemeral_keys_key(*, key : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_ephemeral_keys_key(key: key, expand: expand).execute(&block)
    end

    DELETE_EPHEMERAL_KEYS_KEY_MAX_LENGTH_FOR_KEY = 5000

    # @return Crest::Request
    def build_api_request_for_delete_ephemeral_keys_key(*, key : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_ephemeral_keys_key ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"key\" is required and cannot be null") if key.nil?
        if _key = key
          OpenApi::PrimitiveValidator.validate_max_length("key", key.to_s.size, DELETE_EPHEMERAL_KEYS_KEY_MAX_LENGTH_FOR_KEY)
        end
      end

      # resource path
      local_var_path = "/v1/ephemeral_keys/{key}".sub("{" + "key" + "}", URI.encode_path(key.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_ephemeral_keys_key",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Deletes an invoice item, removing it from an invoice. Deleting invoice items is only possible when they’re not attached to invoices, or if it’s attached to a draft invoice.</p>
    # @param invoiceitem [String?]
    # @return [DeletedInvoiceitem]
    def delete_invoiceitems_invoiceitem(*, invoiceitem : String? = nil)
      data, _status_code, _headers = delete_invoiceitems_invoiceitem_with_http_info(invoiceitem: invoiceitem)
      data
    end

    # &lt;p&gt;Deletes an invoice item, removing it from an invoice. Deleting invoice items is only possible when they’re not attached to invoices, or if it’s attached to a draft invoice.&lt;/p&gt;
    # @param invoiceitem [String?]
    # @return [Array<(DeletedInvoiceitem, Integer, Hash)>] DeletedInvoiceitem data, response status code and response headers
    def delete_invoiceitems_invoiceitem_with_http_info(*, invoiceitem : String? = nil)
      request = build_api_request_for_delete_invoiceitems_invoiceitem(invoiceitem: invoiceitem)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_invoiceitems_invoiceitem\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedInvoiceitem.from_json(data), status_code, headers
    end

    # &lt;p&gt;Deletes an invoice item, removing it from an invoice. Deleting invoice items is only possible when they’re not attached to invoices, or if it’s attached to a draft invoice.&lt;/p&gt;
    # @param invoiceitem [String?]
    # @return nil
    def delete_invoiceitems_invoiceitem(*, invoiceitem : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_invoiceitems_invoiceitem(invoiceitem: invoiceitem).execute(&block)
    end

    DELETE_INVOICEITEMS_INVOICEITEM_MAX_LENGTH_FOR_INVOICEITEM = 5000

    # @return Crest::Request
    def build_api_request_for_delete_invoiceitems_invoiceitem(*, invoiceitem : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_invoiceitems_invoiceitem ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"invoiceitem\" is required and cannot be null") if invoiceitem.nil?
        if _invoiceitem = invoiceitem
          OpenApi::PrimitiveValidator.validate_max_length("invoiceitem", invoiceitem.to_s.size, DELETE_INVOICEITEMS_INVOICEITEM_MAX_LENGTH_FOR_INVOICEITEM)
        end
      end

      # resource path
      local_var_path = "/v1/invoiceitems/{invoiceitem}".sub("{" + "invoiceitem" + "}", URI.encode_path(invoiceitem.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_invoiceitems_invoiceitem",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Permanently deletes a one-off invoice draft. This cannot be undone. Attempts to delete invoices that are no longer in a draft state will fail; once an invoice has been finalized or if an invoice is for a subscription, it must be <a href=\"#void_invoice\">voided</a>.</p>
    # @param invoice [String?]
    # @return [DeletedInvoice]
    def delete_invoices_invoice(*, invoice : String? = nil)
      data, _status_code, _headers = delete_invoices_invoice_with_http_info(invoice: invoice)
      data
    end

    # &lt;p&gt;Permanently deletes a one-off invoice draft. This cannot be undone. Attempts to delete invoices that are no longer in a draft state will fail; once an invoice has been finalized or if an invoice is for a subscription, it must be &lt;a href&#x3D;\&quot;#void_invoice\&quot;&gt;voided&lt;/a&gt;.&lt;/p&gt;
    # @param invoice [String?]
    # @return [Array<(DeletedInvoice, Integer, Hash)>] DeletedInvoice data, response status code and response headers
    def delete_invoices_invoice_with_http_info(*, invoice : String? = nil)
      request = build_api_request_for_delete_invoices_invoice(invoice: invoice)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_invoices_invoice\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedInvoice.from_json(data), status_code, headers
    end

    # &lt;p&gt;Permanently deletes a one-off invoice draft. This cannot be undone. Attempts to delete invoices that are no longer in a draft state will fail; once an invoice has been finalized or if an invoice is for a subscription, it must be &lt;a href&#x3D;\&quot;#void_invoice\&quot;&gt;voided&lt;/a&gt;.&lt;/p&gt;
    # @param invoice [String?]
    # @return nil
    def delete_invoices_invoice(*, invoice : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_invoices_invoice(invoice: invoice).execute(&block)
    end

    DELETE_INVOICES_INVOICE_MAX_LENGTH_FOR_INVOICE = 5000

    # @return Crest::Request
    def build_api_request_for_delete_invoices_invoice(*, invoice : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_invoices_invoice ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"invoice\" is required and cannot be null") if invoice.nil?
        if _invoice = invoice
          OpenApi::PrimitiveValidator.validate_max_length("invoice", invoice.to_s.size, DELETE_INVOICES_INVOICE_MAX_LENGTH_FOR_INVOICE)
        end
      end

      # resource path
      local_var_path = "/v1/invoices/{invoice}".sub("{" + "invoice" + "}", URI.encode_path(invoice.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_invoices_invoice",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Deleting plans means new subscribers can’t be added. Existing subscribers aren’t affected.</p>
    # @param plan [String?]
    # @return [DeletedPlan]
    def delete_plans_plan(*, plan : String? = nil)
      data, _status_code, _headers = delete_plans_plan_with_http_info(plan: plan)
      data
    end

    # &lt;p&gt;Deleting plans means new subscribers can’t be added. Existing subscribers aren’t affected.&lt;/p&gt;
    # @param plan [String?]
    # @return [Array<(DeletedPlan, Integer, Hash)>] DeletedPlan data, response status code and response headers
    def delete_plans_plan_with_http_info(*, plan : String? = nil)
      request = build_api_request_for_delete_plans_plan(plan: plan)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_plans_plan\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedPlan.from_json(data), status_code, headers
    end

    # &lt;p&gt;Deleting plans means new subscribers can’t be added. Existing subscribers aren’t affected.&lt;/p&gt;
    # @param plan [String?]
    # @return nil
    def delete_plans_plan(*, plan : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_plans_plan(plan: plan).execute(&block)
    end

    DELETE_PLANS_PLAN_MAX_LENGTH_FOR_PLAN = 5000

    # @return Crest::Request
    def build_api_request_for_delete_plans_plan(*, plan : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_plans_plan ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"plan\" is required and cannot be null") if plan.nil?
        if _plan = plan
          OpenApi::PrimitiveValidator.validate_max_length("plan", plan.to_s.size, DELETE_PLANS_PLAN_MAX_LENGTH_FOR_PLAN)
        end
      end

      # resource path
      local_var_path = "/v1/plans/{plan}".sub("{" + "plan" + "}", URI.encode_path(plan.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_plans_plan",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Delete a product. Deleting a product is only possible if it has no prices associated with it. Additionally, deleting a product with <code>type=good</code> is only possible if it has no SKUs associated with it.</p>
    # @param id [String?]
    # @return [DeletedProduct]
    def delete_products_id(*, id : String? = nil)
      data, _status_code, _headers = delete_products_id_with_http_info(id: id)
      data
    end

    # &lt;p&gt;Delete a product. Deleting a product is only possible if it has no prices associated with it. Additionally, deleting a product with &lt;code&gt;type&#x3D;good&lt;/code&gt; is only possible if it has no SKUs associated with it.&lt;/p&gt;
    # @param id [String?]
    # @return [Array<(DeletedProduct, Integer, Hash)>] DeletedProduct data, response status code and response headers
    def delete_products_id_with_http_info(*, id : String? = nil)
      request = build_api_request_for_delete_products_id(id: id)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_products_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedProduct.from_json(data), status_code, headers
    end

    # &lt;p&gt;Delete a product. Deleting a product is only possible if it has no prices associated with it. Additionally, deleting a product with &lt;code&gt;type&#x3D;good&lt;/code&gt; is only possible if it has no SKUs associated with it.&lt;/p&gt;
    # @param id [String?]
    # @return nil
    def delete_products_id(*, id : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_products_id(id: id).execute(&block)
    end

    DELETE_PRODUCTS_ID_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_delete_products_id(*, id : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_products_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, DELETE_PRODUCTS_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/products/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_products_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Deletes a <code>ValueListItem</code> object, removing it from its parent value list.</p>
    # @param item [String?]
    # @return [DeletedRadarValueListItem]
    def delete_radar_value_list_items_item(*, item : String? = nil)
      data, _status_code, _headers = delete_radar_value_list_items_item_with_http_info(item: item)
      data
    end

    # &lt;p&gt;Deletes a &lt;code&gt;ValueListItem&lt;/code&gt; object, removing it from its parent value list.&lt;/p&gt;
    # @param item [String?]
    # @return [Array<(DeletedRadarValueListItem, Integer, Hash)>] DeletedRadarValueListItem data, response status code and response headers
    def delete_radar_value_list_items_item_with_http_info(*, item : String? = nil)
      request = build_api_request_for_delete_radar_value_list_items_item(item: item)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_radar_value_list_items_item\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedRadarValueListItem.from_json(data), status_code, headers
    end

    # &lt;p&gt;Deletes a &lt;code&gt;ValueListItem&lt;/code&gt; object, removing it from its parent value list.&lt;/p&gt;
    # @param item [String?]
    # @return nil
    def delete_radar_value_list_items_item(*, item : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_radar_value_list_items_item(item: item).execute(&block)
    end

    DELETE_RADAR_VALUE_LIST_ITEMS_ITEM_MAX_LENGTH_FOR_ITEM = 5000

    # @return Crest::Request
    def build_api_request_for_delete_radar_value_list_items_item(*, item : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_radar_value_list_items_item ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"item\" is required and cannot be null") if item.nil?
        if _item = item
          OpenApi::PrimitiveValidator.validate_max_length("item", item.to_s.size, DELETE_RADAR_VALUE_LIST_ITEMS_ITEM_MAX_LENGTH_FOR_ITEM)
        end
      end

      # resource path
      local_var_path = "/v1/radar/value_list_items/{item}".sub("{" + "item" + "}", URI.encode_path(item.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_radar_value_list_items_item",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Deletes a <code>ValueList</code> object, also deleting any items contained within the value list. To be deleted, a value list must not be referenced in any rules.</p>
    # @param value_list [String?]
    # @return [DeletedRadarValueList]
    def delete_radar_value_lists_value_list(*, value_list : String? = nil)
      data, _status_code, _headers = delete_radar_value_lists_value_list_with_http_info(value_list: value_list)
      data
    end

    # &lt;p&gt;Deletes a &lt;code&gt;ValueList&lt;/code&gt; object, also deleting any items contained within the value list. To be deleted, a value list must not be referenced in any rules.&lt;/p&gt;
    # @param value_list [String?]
    # @return [Array<(DeletedRadarValueList, Integer, Hash)>] DeletedRadarValueList data, response status code and response headers
    def delete_radar_value_lists_value_list_with_http_info(*, value_list : String? = nil)
      request = build_api_request_for_delete_radar_value_lists_value_list(value_list: value_list)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_radar_value_lists_value_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedRadarValueList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Deletes a &lt;code&gt;ValueList&lt;/code&gt; object, also deleting any items contained within the value list. To be deleted, a value list must not be referenced in any rules.&lt;/p&gt;
    # @param value_list [String?]
    # @return nil
    def delete_radar_value_lists_value_list(*, value_list : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_radar_value_lists_value_list(value_list: value_list).execute(&block)
    end

    DELETE_RADAR_VALUE_LISTS_VALUE_LIST_MAX_LENGTH_FOR_VALUE_LIST = 5000

    # @return Crest::Request
    def build_api_request_for_delete_radar_value_lists_value_list(*, value_list : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_radar_value_lists_value_list ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"value_list\" is required and cannot be null") if value_list.nil?
        if _value_list = value_list
          OpenApi::PrimitiveValidator.validate_max_length("value_list", value_list.to_s.size, DELETE_RADAR_VALUE_LISTS_VALUE_LIST_MAX_LENGTH_FOR_VALUE_LIST)
        end
      end

      # resource path
      local_var_path = "/v1/radar/value_lists/{value_list}".sub("{" + "value_list" + "}", URI.encode_path(value_list.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_radar_value_lists_value_list",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Delete a SKU. Deleting a SKU is only possible until it has been used in an order.</p>
    # @param id [String?]
    # @return [DeletedSku]
    def delete_skus_id(*, id : String? = nil)
      data, _status_code, _headers = delete_skus_id_with_http_info(id: id)
      data
    end

    # &lt;p&gt;Delete a SKU. Deleting a SKU is only possible until it has been used in an order.&lt;/p&gt;
    # @param id [String?]
    # @return [Array<(DeletedSku, Integer, Hash)>] DeletedSku data, response status code and response headers
    def delete_skus_id_with_http_info(*, id : String? = nil)
      request = build_api_request_for_delete_skus_id(id: id)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_skus_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedSku.from_json(data), status_code, headers
    end

    # &lt;p&gt;Delete a SKU. Deleting a SKU is only possible until it has been used in an order.&lt;/p&gt;
    # @param id [String?]
    # @return nil
    def delete_skus_id(*, id : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_skus_id(id: id).execute(&block)
    end

    DELETE_SKUS_ID_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_delete_skus_id(*, id : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_skus_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, DELETE_SKUS_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/skus/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_skus_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Deletes an item from the subscription. Removing a subscription item from a subscription will not cancel the subscription.</p>
    # @param item [String?]
    # @optional @param clear_usage [Bool?] Delete all usage for the given subscription item. Allowed only when the current plan's `usage_type` is `metered`.
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param proration_date [Int64?] If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply the same proration that was previewed with the [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint.
    # @return [DeletedSubscriptionItem]
    def delete_subscription_items_item(*, item : String? = nil, clear_usage : Bool? = nil, proration_behavior : String? = nil, proration_date : Int64? = nil)
      data, _status_code, _headers = delete_subscription_items_item_with_http_info(item: item, clear_usage: clear_usage, proration_behavior: proration_behavior, proration_date: proration_date)
      data
    end

    # &lt;p&gt;Deletes an item from the subscription. Removing a subscription item from a subscription will not cancel the subscription.&lt;/p&gt;
    # @param item [String?]
    # @optional @param clear_usage [Bool?] Delete all usage for the given subscription item. Allowed only when the current plan's `usage_type` is `metered`.
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param proration_date [Int64?] If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply the same proration that was previewed with the [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint.
    # @return [Array<(DeletedSubscriptionItem, Integer, Hash)>] DeletedSubscriptionItem data, response status code and response headers
    def delete_subscription_items_item_with_http_info(*, item : String? = nil, clear_usage : Bool? = nil, proration_behavior : String? = nil, proration_date : Int64? = nil)
      request = build_api_request_for_delete_subscription_items_item(item: item, clear_usage: clear_usage, proration_behavior: proration_behavior, proration_date: proration_date)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_subscription_items_item\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedSubscriptionItem.from_json(data), status_code, headers
    end

    # &lt;p&gt;Deletes an item from the subscription. Removing a subscription item from a subscription will not cancel the subscription.&lt;/p&gt;
    # @param item [String?]
    # @optional @param clear_usage [Bool?] Delete all usage for the given subscription item. Allowed only when the current plan's `usage_type` is `metered`.
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param proration_date [Int64?] If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply the same proration that was previewed with the [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint.
    # @return nil
    def delete_subscription_items_item(*, item : String? = nil, clear_usage : Bool? = nil, proration_behavior : String? = nil, proration_date : Int64? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_subscription_items_item(item: item, clear_usage: clear_usage, proration_behavior: proration_behavior, proration_date: proration_date).execute(&block)
    end

    DELETE_SUBSCRIPTION_ITEMS_ITEM_MAX_LENGTH_FOR_ITEM                 = 5000
    DELETE_SUBSCRIPTION_ITEMS_ITEM_VALID_VALUES_FOR_PRORATION_BEHAVIOR = StaticArray["always_invoice", "create_prorations", "none"]

    # @return Crest::Request
    def build_api_request_for_delete_subscription_items_item(*, item : String? = nil, clear_usage : Bool? = nil, proration_behavior : String? = nil, proration_date : Int64? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_subscription_items_item ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"item\" is required and cannot be null") if item.nil?
        if _item = item
          OpenApi::PrimitiveValidator.validate_max_length("item", item.to_s.size, DELETE_SUBSCRIPTION_ITEMS_ITEM_MAX_LENGTH_FOR_ITEM)
        end

        if _proration_behavior = proration_behavior
          OpenApi::EnumValidator.validate("proration_behavior", _proration_behavior, DELETE_SUBSCRIPTION_ITEMS_ITEM_VALID_VALUES_FOR_PRORATION_BEHAVIOR)
        end
      end

      # resource path
      local_var_path = "/v1/subscription_items/{item}".sub("{" + "item" + "}", URI.encode_path(item.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["clear_usage"] = clear_usage.to_s if !clear_usage.nil?
      form_params["proration_behavior"] = proration_behavior.to_s if !proration_behavior.nil?
      form_params["proration_date"] = proration_date.to_s if !proration_date.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_subscription_items_item",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Cancels a customer’s subscription immediately. The customer will not be charged again for the subscription.</p>  <p>Note, however, that any pending invoice items that you’ve created will still be charged for at the end of the period, unless manually <a href=\"#delete_invoiceitem\">deleted</a>. If you’ve set the subscription to cancel at the end of the period, any pending prorations will also be left in place and collected at the end of the period. But if the subscription is set to cancel immediately, pending prorations will be removed.</p>  <p>By default, upon subscription cancellation, Stripe will stop automatic collection of all finalized invoices for the customer. This is intended to prevent unexpected payment attempts after the customer has canceled a subscription. However, you can resume automatic collection of the invoices manually after subscription cancellation to have us proceed. Or, you could check for unpaid invoices before allowing the customer to cancel the subscription at all.</p>
    # @param subscription_exposed_id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_now [Bool?] Will generate a final invoice that invoices for any un-invoiced metered usage and new/pending proration invoice items.
    # @optional @param prorate [Bool?] Will generate a proration invoice item that credits remaining unused time until the subscription period end.
    # @return [Subscription]
    def delete_subscriptions_subscription_exposed_id(*, subscription_exposed_id : String? = nil, expand : Array(String)? = nil, invoice_now : Bool? = nil, prorate : Bool? = nil)
      data, _status_code, _headers = delete_subscriptions_subscription_exposed_id_with_http_info(subscription_exposed_id: subscription_exposed_id, expand: expand, invoice_now: invoice_now, prorate: prorate)
      data
    end

    # &lt;p&gt;Cancels a customer’s subscription immediately. The customer will not be charged again for the subscription.&lt;/p&gt;  &lt;p&gt;Note, however, that any pending invoice items that you’ve created will still be charged for at the end of the period, unless manually &lt;a href&#x3D;\&quot;#delete_invoiceitem\&quot;&gt;deleted&lt;/a&gt;. If you’ve set the subscription to cancel at the end of the period, any pending prorations will also be left in place and collected at the end of the period. But if the subscription is set to cancel immediately, pending prorations will be removed.&lt;/p&gt;  &lt;p&gt;By default, upon subscription cancellation, Stripe will stop automatic collection of all finalized invoices for the customer. This is intended to prevent unexpected payment attempts after the customer has canceled a subscription. However, you can resume automatic collection of the invoices manually after subscription cancellation to have us proceed. Or, you could check for unpaid invoices before allowing the customer to cancel the subscription at all.&lt;/p&gt;
    # @param subscription_exposed_id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_now [Bool?] Will generate a final invoice that invoices for any un-invoiced metered usage and new/pending proration invoice items.
    # @optional @param prorate [Bool?] Will generate a proration invoice item that credits remaining unused time until the subscription period end.
    # @return [Array<(Subscription, Integer, Hash)>] Subscription data, response status code and response headers
    def delete_subscriptions_subscription_exposed_id_with_http_info(*, subscription_exposed_id : String? = nil, expand : Array(String)? = nil, invoice_now : Bool? = nil, prorate : Bool? = nil)
      request = build_api_request_for_delete_subscriptions_subscription_exposed_id(subscription_exposed_id: subscription_exposed_id, expand: expand, invoice_now: invoice_now, prorate: prorate)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_subscriptions_subscription_exposed_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Subscription.from_json(data), status_code, headers
    end

    # &lt;p&gt;Cancels a customer’s subscription immediately. The customer will not be charged again for the subscription.&lt;/p&gt;  &lt;p&gt;Note, however, that any pending invoice items that you’ve created will still be charged for at the end of the period, unless manually &lt;a href&#x3D;\&quot;#delete_invoiceitem\&quot;&gt;deleted&lt;/a&gt;. If you’ve set the subscription to cancel at the end of the period, any pending prorations will also be left in place and collected at the end of the period. But if the subscription is set to cancel immediately, pending prorations will be removed.&lt;/p&gt;  &lt;p&gt;By default, upon subscription cancellation, Stripe will stop automatic collection of all finalized invoices for the customer. This is intended to prevent unexpected payment attempts after the customer has canceled a subscription. However, you can resume automatic collection of the invoices manually after subscription cancellation to have us proceed. Or, you could check for unpaid invoices before allowing the customer to cancel the subscription at all.&lt;/p&gt;
    # @param subscription_exposed_id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_now [Bool?] Will generate a final invoice that invoices for any un-invoiced metered usage and new/pending proration invoice items.
    # @optional @param prorate [Bool?] Will generate a proration invoice item that credits remaining unused time until the subscription period end.
    # @return nil
    def delete_subscriptions_subscription_exposed_id(*, subscription_exposed_id : String? = nil, expand : Array(String)? = nil, invoice_now : Bool? = nil, prorate : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_subscriptions_subscription_exposed_id(subscription_exposed_id: subscription_exposed_id, expand: expand, invoice_now: invoice_now, prorate: prorate).execute(&block)
    end

    DELETE_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID = 5000

    # @return Crest::Request
    def build_api_request_for_delete_subscriptions_subscription_exposed_id(*, subscription_exposed_id : String? = nil, expand : Array(String)? = nil, invoice_now : Bool? = nil, prorate : Bool? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_subscriptions_subscription_exposed_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"subscription_exposed_id\" is required and cannot be null") if subscription_exposed_id.nil?
        if _subscription_exposed_id = subscription_exposed_id
          OpenApi::PrimitiveValidator.validate_max_length("subscription_exposed_id", subscription_exposed_id.to_s.size, DELETE_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID)
        end
      end

      # resource path
      local_var_path = "/v1/subscriptions/{subscription_exposed_id}".sub("{" + "subscription_exposed_id" + "}", URI.encode_path(subscription_exposed_id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["invoice_now"] = invoice_now.to_s if !invoice_now.nil?
      form_params["prorate"] = prorate.to_s if !prorate.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_subscriptions_subscription_exposed_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Removes the currently applied discount on a subscription.</p>
    # @param subscription_exposed_id [String?]
    # @return [DeletedDiscount]
    def delete_subscriptions_subscription_exposed_id_discount(*, subscription_exposed_id : String? = nil)
      data, _status_code, _headers = delete_subscriptions_subscription_exposed_id_discount_with_http_info(subscription_exposed_id: subscription_exposed_id)
      data
    end

    # &lt;p&gt;Removes the currently applied discount on a subscription.&lt;/p&gt;
    # @param subscription_exposed_id [String?]
    # @return [Array<(DeletedDiscount, Integer, Hash)>] DeletedDiscount data, response status code and response headers
    def delete_subscriptions_subscription_exposed_id_discount_with_http_info(*, subscription_exposed_id : String? = nil)
      request = build_api_request_for_delete_subscriptions_subscription_exposed_id_discount(subscription_exposed_id: subscription_exposed_id)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_subscriptions_subscription_exposed_id_discount\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedDiscount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Removes the currently applied discount on a subscription.&lt;/p&gt;
    # @param subscription_exposed_id [String?]
    # @return nil
    def delete_subscriptions_subscription_exposed_id_discount(*, subscription_exposed_id : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_subscriptions_subscription_exposed_id_discount(subscription_exposed_id: subscription_exposed_id).execute(&block)
    end

    DELETE_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_DISCOUNT_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID = 5000

    # @return Crest::Request
    def build_api_request_for_delete_subscriptions_subscription_exposed_id_discount(*, subscription_exposed_id : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_subscriptions_subscription_exposed_id_discount ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"subscription_exposed_id\" is required and cannot be null") if subscription_exposed_id.nil?
        if _subscription_exposed_id = subscription_exposed_id
          OpenApi::PrimitiveValidator.validate_max_length("subscription_exposed_id", subscription_exposed_id.to_s.size, DELETE_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_DISCOUNT_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID)
        end
      end

      # resource path
      local_var_path = "/v1/subscriptions/{subscription_exposed_id}/discount".sub("{" + "subscription_exposed_id" + "}", URI.encode_path(subscription_exposed_id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_subscriptions_subscription_exposed_id_discount",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Deletes a <code>Configuration</code> object.</p>
    # @param configuration [String?]
    # @return [DeletedTerminalConfiguration]
    def delete_terminal_configurations_configuration(*, configuration : String? = nil)
      data, _status_code, _headers = delete_terminal_configurations_configuration_with_http_info(configuration: configuration)
      data
    end

    # &lt;p&gt;Deletes a &lt;code&gt;Configuration&lt;/code&gt; object.&lt;/p&gt;
    # @param configuration [String?]
    # @return [Array<(DeletedTerminalConfiguration, Integer, Hash)>] DeletedTerminalConfiguration data, response status code and response headers
    def delete_terminal_configurations_configuration_with_http_info(*, configuration : String? = nil)
      request = build_api_request_for_delete_terminal_configurations_configuration(configuration: configuration)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_terminal_configurations_configuration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedTerminalConfiguration.from_json(data), status_code, headers
    end

    # &lt;p&gt;Deletes a &lt;code&gt;Configuration&lt;/code&gt; object.&lt;/p&gt;
    # @param configuration [String?]
    # @return nil
    def delete_terminal_configurations_configuration(*, configuration : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_terminal_configurations_configuration(configuration: configuration).execute(&block)
    end

    DELETE_TERMINAL_CONFIGURATIONS_CONFIGURATION_MAX_LENGTH_FOR_CONFIGURATION = 5000

    # @return Crest::Request
    def build_api_request_for_delete_terminal_configurations_configuration(*, configuration : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_terminal_configurations_configuration ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"configuration\" is required and cannot be null") if configuration.nil?
        if _configuration = configuration
          OpenApi::PrimitiveValidator.validate_max_length("configuration", configuration.to_s.size, DELETE_TERMINAL_CONFIGURATIONS_CONFIGURATION_MAX_LENGTH_FOR_CONFIGURATION)
        end
      end

      # resource path
      local_var_path = "/v1/terminal/configurations/{configuration}".sub("{" + "configuration" + "}", URI.encode_path(configuration.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_terminal_configurations_configuration",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Deletes a <code>Location</code> object.</p>
    # @param location [String?]
    # @return [DeletedTerminalLocation]
    def delete_terminal_locations_location(*, location : String? = nil)
      data, _status_code, _headers = delete_terminal_locations_location_with_http_info(location: location)
      data
    end

    # &lt;p&gt;Deletes a &lt;code&gt;Location&lt;/code&gt; object.&lt;/p&gt;
    # @param location [String?]
    # @return [Array<(DeletedTerminalLocation, Integer, Hash)>] DeletedTerminalLocation data, response status code and response headers
    def delete_terminal_locations_location_with_http_info(*, location : String? = nil)
      request = build_api_request_for_delete_terminal_locations_location(location: location)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_terminal_locations_location\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedTerminalLocation.from_json(data), status_code, headers
    end

    # &lt;p&gt;Deletes a &lt;code&gt;Location&lt;/code&gt; object.&lt;/p&gt;
    # @param location [String?]
    # @return nil
    def delete_terminal_locations_location(*, location : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_terminal_locations_location(location: location).execute(&block)
    end

    DELETE_TERMINAL_LOCATIONS_LOCATION_MAX_LENGTH_FOR_LOCATION = 5000

    # @return Crest::Request
    def build_api_request_for_delete_terminal_locations_location(*, location : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_terminal_locations_location ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"location\" is required and cannot be null") if location.nil?
        if _location = location
          OpenApi::PrimitiveValidator.validate_max_length("location", location.to_s.size, DELETE_TERMINAL_LOCATIONS_LOCATION_MAX_LENGTH_FOR_LOCATION)
        end
      end

      # resource path
      local_var_path = "/v1/terminal/locations/{location}".sub("{" + "location" + "}", URI.encode_path(location.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_terminal_locations_location",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Deletes a <code>Reader</code> object.</p>
    # @param reader [String?]
    # @return [DeletedTerminalReader]
    def delete_terminal_readers_reader(*, reader : String? = nil)
      data, _status_code, _headers = delete_terminal_readers_reader_with_http_info(reader: reader)
      data
    end

    # &lt;p&gt;Deletes a &lt;code&gt;Reader&lt;/code&gt; object.&lt;/p&gt;
    # @param reader [String?]
    # @return [Array<(DeletedTerminalReader, Integer, Hash)>] DeletedTerminalReader data, response status code and response headers
    def delete_terminal_readers_reader_with_http_info(*, reader : String? = nil)
      request = build_api_request_for_delete_terminal_readers_reader(reader: reader)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_terminal_readers_reader\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedTerminalReader.from_json(data), status_code, headers
    end

    # &lt;p&gt;Deletes a &lt;code&gt;Reader&lt;/code&gt; object.&lt;/p&gt;
    # @param reader [String?]
    # @return nil
    def delete_terminal_readers_reader(*, reader : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_terminal_readers_reader(reader: reader).execute(&block)
    end

    DELETE_TERMINAL_READERS_READER_MAX_LENGTH_FOR_READER = 5000

    # @return Crest::Request
    def build_api_request_for_delete_terminal_readers_reader(*, reader : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_terminal_readers_reader ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"reader\" is required and cannot be null") if reader.nil?
        if _reader = reader
          OpenApi::PrimitiveValidator.validate_max_length("reader", reader.to_s.size, DELETE_TERMINAL_READERS_READER_MAX_LENGTH_FOR_READER)
        end
      end

      # resource path
      local_var_path = "/v1/terminal/readers/{reader}".sub("{" + "reader" + "}", URI.encode_path(reader.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_terminal_readers_reader",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Deletes a test clock.</p>
    # @param test_clock [String?]
    # @return [DeletedTestHelpersTestClock]
    def delete_test_helpers_test_clocks_test_clock(*, test_clock : String? = nil)
      data, _status_code, _headers = delete_test_helpers_test_clocks_test_clock_with_http_info(test_clock: test_clock)
      data
    end

    # &lt;p&gt;Deletes a test clock.&lt;/p&gt;
    # @param test_clock [String?]
    # @return [Array<(DeletedTestHelpersTestClock, Integer, Hash)>] DeletedTestHelpersTestClock data, response status code and response headers
    def delete_test_helpers_test_clocks_test_clock_with_http_info(*, test_clock : String? = nil)
      request = build_api_request_for_delete_test_helpers_test_clocks_test_clock(test_clock: test_clock)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_test_helpers_test_clocks_test_clock\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedTestHelpersTestClock.from_json(data), status_code, headers
    end

    # &lt;p&gt;Deletes a test clock.&lt;/p&gt;
    # @param test_clock [String?]
    # @return nil
    def delete_test_helpers_test_clocks_test_clock(*, test_clock : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_test_helpers_test_clocks_test_clock(test_clock: test_clock).execute(&block)
    end

    DELETE_TEST_HELPERS_TEST_CLOCKS_TEST_CLOCK_MAX_LENGTH_FOR_TEST_CLOCK = 5000

    # @return Crest::Request
    def build_api_request_for_delete_test_helpers_test_clocks_test_clock(*, test_clock : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_test_helpers_test_clocks_test_clock ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"test_clock\" is required and cannot be null") if test_clock.nil?
        if _test_clock = test_clock
          OpenApi::PrimitiveValidator.validate_max_length("test_clock", test_clock.to_s.size, DELETE_TEST_HELPERS_TEST_CLOCKS_TEST_CLOCK_MAX_LENGTH_FOR_TEST_CLOCK)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/test_clocks/{test_clock}".sub("{" + "test_clock" + "}", URI.encode_path(test_clock.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_test_helpers_test_clocks_test_clock",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>You can also delete webhook endpoints via the <a href=\"https://dashboard.stripe.com/account/webhooks\">webhook endpoint management</a> page of the Stripe dashboard.</p>
    # @param webhook_endpoint [String?]
    # @return [DeletedWebhookEndpoint]
    def delete_webhook_endpoints_webhook_endpoint(*, webhook_endpoint : String? = nil)
      data, _status_code, _headers = delete_webhook_endpoints_webhook_endpoint_with_http_info(webhook_endpoint: webhook_endpoint)
      data
    end

    # &lt;p&gt;You can also delete webhook endpoints via the &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/account/webhooks\&quot;&gt;webhook endpoint management&lt;/a&gt; page of the Stripe dashboard.&lt;/p&gt;
    # @param webhook_endpoint [String?]
    # @return [Array<(DeletedWebhookEndpoint, Integer, Hash)>] DeletedWebhookEndpoint data, response status code and response headers
    def delete_webhook_endpoints_webhook_endpoint_with_http_info(*, webhook_endpoint : String? = nil)
      request = build_api_request_for_delete_webhook_endpoints_webhook_endpoint(webhook_endpoint: webhook_endpoint)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#delete_webhook_endpoints_webhook_endpoint\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DeletedWebhookEndpoint.from_json(data), status_code, headers
    end

    # &lt;p&gt;You can also delete webhook endpoints via the &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/account/webhooks\&quot;&gt;webhook endpoint management&lt;/a&gt; page of the Stripe dashboard.&lt;/p&gt;
    # @param webhook_endpoint [String?]
    # @return nil
    def delete_webhook_endpoints_webhook_endpoint(*, webhook_endpoint : String? = nil, &block : Crest::Response ->)
      build_api_request_for_delete_webhook_endpoints_webhook_endpoint(webhook_endpoint: webhook_endpoint).execute(&block)
    end

    DELETE_WEBHOOK_ENDPOINTS_WEBHOOK_ENDPOINT_MAX_LENGTH_FOR_WEBHOOK_ENDPOINT = 5000

    # @return Crest::Request
    def build_api_request_for_delete_webhook_endpoints_webhook_endpoint(*, webhook_endpoint : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.delete_webhook_endpoints_webhook_endpoint ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"webhook_endpoint\" is required and cannot be null") if webhook_endpoint.nil?
        if _webhook_endpoint = webhook_endpoint
          OpenApi::PrimitiveValidator.validate_max_length("webhook_endpoint", webhook_endpoint.to_s.size, DELETE_WEBHOOK_ENDPOINTS_WEBHOOK_ENDPOINT_MAX_LENGTH_FOR_WEBHOOK_ENDPOINT)
        end
      end

      # resource path
      local_var_path = "/v1/webhook_endpoints/{webhook_endpoint}".sub("{" + "webhook_endpoint" + "}", URI.encode_path(webhook_endpoint.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "DefaultApi.delete_webhook_endpoints_webhook_endpoint",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an account.</p>
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Account]
    def get_account(*, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_account_with_http_info(expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an account.&lt;/p&gt;
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Account, Integer, Hash)>] Account data, response status code and response headers
    def get_account_with_http_info(*, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_account(expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_account\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Account.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an account.&lt;/p&gt;
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_account(*, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_account(expand: expand).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_get_account(*, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_account ..." }
      end

      if client_side_validation
      end

      # resource path
      local_var_path = "/v1/account"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_account",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieve a specified external account for a given account.</p>
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [ExternalAccount]
    def get_account_bank_accounts_id(*, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_account_bank_accounts_id_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieve a specified external account for a given account.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(ExternalAccount, Integer, Hash)>] ExternalAccount data, response status code and response headers
    def get_account_bank_accounts_id_with_http_info(*, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_account_bank_accounts_id(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_account_bank_accounts_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ExternalAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieve a specified external account for a given account.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_account_bank_accounts_id(*, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_account_bank_accounts_id(id: id, expand: expand).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_get_account_bank_accounts_id(*, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_account_bank_accounts_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
      end

      # resource path
      local_var_path = "/v1/account/bank_accounts/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_account_bank_accounts_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of capabilities associated with the account. The capabilities are returned sorted by creation date, with the most recent capability appearing first.</p>
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [ListAccountCapability]
    def get_account_capabilities(*, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_account_capabilities_with_http_info(expand: expand)
      data
    end

    # &lt;p&gt;Returns a list of capabilities associated with the account. The capabilities are returned sorted by creation date, with the most recent capability appearing first.&lt;/p&gt;
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(ListAccountCapability, Integer, Hash)>] ListAccountCapability data, response status code and response headers
    def get_account_capabilities_with_http_info(*, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_account_capabilities(expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_account_capabilities\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ListAccountCapability.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of capabilities associated with the account. The capabilities are returned sorted by creation date, with the most recent capability appearing first.&lt;/p&gt;
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_account_capabilities(*, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_account_capabilities(expand: expand).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_get_account_capabilities(*, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_account_capabilities ..." }
      end

      if client_side_validation
      end

      # resource path
      local_var_path = "/v1/account/capabilities"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_account_capabilities",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves information about the specified Account Capability.</p>
    # @param capability [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Capability]
    def get_account_capabilities_capability(*, capability : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_account_capabilities_capability_with_http_info(capability: capability, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves information about the specified Account Capability.&lt;/p&gt;
    # @param capability [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Capability, Integer, Hash)>] Capability data, response status code and response headers
    def get_account_capabilities_capability_with_http_info(*, capability : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_account_capabilities_capability(capability: capability, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_account_capabilities_capability\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Capability.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves information about the specified Account Capability.&lt;/p&gt;
    # @param capability [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_account_capabilities_capability(*, capability : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_account_capabilities_capability(capability: capability, expand: expand).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_get_account_capabilities_capability(*, capability : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_account_capabilities_capability ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"capability\" is required and cannot be null") if capability.nil?
      end

      # resource path
      local_var_path = "/v1/account/capabilities/{capability}".sub("{" + "capability" + "}", URI.encode_path(capability.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_account_capabilities_capability",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>List external accounts for an account.</p>
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [ExternalAccountList]
    def get_account_external_accounts(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_account_external_accounts_with_http_info(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;List external accounts for an account.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(ExternalAccountList, Integer, Hash)>] ExternalAccountList data, response status code and response headers
    def get_account_external_accounts_with_http_info(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_account_external_accounts(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_account_external_accounts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ExternalAccountList.from_json(data), status_code, headers
    end

    # &lt;p&gt;List external accounts for an account.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_account_external_accounts(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_account_external_accounts(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_get_account_external_accounts(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_account_external_accounts ..." }
      end

      if client_side_validation
      end

      # resource path
      local_var_path = "/v1/account/external_accounts"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_account_external_accounts",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieve a specified external account for a given account.</p>
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [ExternalAccount]
    def get_account_external_accounts_id(*, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_account_external_accounts_id_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieve a specified external account for a given account.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(ExternalAccount, Integer, Hash)>] ExternalAccount data, response status code and response headers
    def get_account_external_accounts_id_with_http_info(*, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_account_external_accounts_id(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_account_external_accounts_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ExternalAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieve a specified external account for a given account.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_account_external_accounts_id(*, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_account_external_accounts_id(id: id, expand: expand).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_get_account_external_accounts_id(*, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_account_external_accounts_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
      end

      # resource path
      local_var_path = "/v1/account/external_accounts/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_account_external_accounts_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of people associated with the account’s legal entity. The people are returned sorted by creation date, with the most recent people appearing first.</p>
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param relationship [Stripe::AllPeopleRelationshipSpecs?] Filters on the list of people returned based on the person's relationship to the account's company.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [PersonList]
    def get_account_people(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, relationship : Stripe::AllPeopleRelationshipSpecs? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_account_people_with_http_info(ending_before: ending_before, expand: expand, limit: limit, relationship: relationship, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of people associated with the account’s legal entity. The people are returned sorted by creation date, with the most recent people appearing first.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param relationship [Stripe::AllPeopleRelationshipSpecs?] Filters on the list of people returned based on the person's relationship to the account's company.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(PersonList, Integer, Hash)>] PersonList data, response status code and response headers
    def get_account_people_with_http_info(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, relationship : Stripe::AllPeopleRelationshipSpecs? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_account_people(ending_before: ending_before, expand: expand, limit: limit, relationship: relationship, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_account_people\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PersonList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of people associated with the account’s legal entity. The people are returned sorted by creation date, with the most recent people appearing first.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param relationship [Stripe::AllPeopleRelationshipSpecs?] Filters on the list of people returned based on the person's relationship to the account's company.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_account_people(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, relationship : Stripe::AllPeopleRelationshipSpecs? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_account_people(ending_before: ending_before, expand: expand, limit: limit, relationship: relationship, starting_after: starting_after).execute(&block)
    end

    GET_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_account_people(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, relationship : Stripe::AllPeopleRelationshipSpecs? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_account_people ..." }
      end

      if client_side_validation
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _relationship = relationship
          _relationship.validate if _relationship.is_a?(OpenApi::Validatable)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/account/people"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["relationship"] = relationship.to_s if !relationship.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_account_people",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves an existing person.</p>
    # @param person [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Person]
    def get_account_people_person(*, person : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_account_people_person_with_http_info(person: person, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves an existing person.&lt;/p&gt;
    # @param person [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Person, Integer, Hash)>] Person data, response status code and response headers
    def get_account_people_person_with_http_info(*, person : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_account_people_person(person: person, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_account_people_person\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Person.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves an existing person.&lt;/p&gt;
    # @param person [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_account_people_person(*, person : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_account_people_person(person: person, expand: expand).execute(&block)
    end

    GET_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_PERSON = 5000

    # @return Crest::Request
    def build_api_request_for_get_account_people_person(*, person : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_account_people_person ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"person\" is required and cannot be null") if person.nil?
        if _person = person
          OpenApi::PrimitiveValidator.validate_max_length("person", person.to_s.size, GET_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_PERSON)
        end
      end

      # resource path
      local_var_path = "/v1/account/people/{person}".sub("{" + "person" + "}", URI.encode_path(person.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_account_people_person",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of people associated with the account’s legal entity. The people are returned sorted by creation date, with the most recent people appearing first.</p>
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param relationship [Stripe::AllPeopleRelationshipSpecs?] Filters on the list of people returned based on the person's relationship to the account's company.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [PersonList]
    def get_account_persons(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, relationship : Stripe::AllPeopleRelationshipSpecs? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_account_persons_with_http_info(ending_before: ending_before, expand: expand, limit: limit, relationship: relationship, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of people associated with the account’s legal entity. The people are returned sorted by creation date, with the most recent people appearing first.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param relationship [Stripe::AllPeopleRelationshipSpecs?] Filters on the list of people returned based on the person's relationship to the account's company.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(PersonList, Integer, Hash)>] PersonList data, response status code and response headers
    def get_account_persons_with_http_info(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, relationship : Stripe::AllPeopleRelationshipSpecs? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_account_persons(ending_before: ending_before, expand: expand, limit: limit, relationship: relationship, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_account_persons\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PersonList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of people associated with the account’s legal entity. The people are returned sorted by creation date, with the most recent people appearing first.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param relationship [Stripe::AllPeopleRelationshipSpecs?] Filters on the list of people returned based on the person's relationship to the account's company.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_account_persons(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, relationship : Stripe::AllPeopleRelationshipSpecs? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_account_persons(ending_before: ending_before, expand: expand, limit: limit, relationship: relationship, starting_after: starting_after).execute(&block)
    end

    GET_ACCOUNT_PERSONS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_ACCOUNT_PERSONS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_account_persons(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, relationship : Stripe::AllPeopleRelationshipSpecs? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_account_persons ..." }
      end

      if client_side_validation
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_ACCOUNT_PERSONS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _relationship = relationship
          _relationship.validate if _relationship.is_a?(OpenApi::Validatable)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_ACCOUNT_PERSONS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/account/persons"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["relationship"] = relationship.to_s if !relationship.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_account_persons",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves an existing person.</p>
    # @param person [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Person]
    def get_account_persons_person(*, person : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_account_persons_person_with_http_info(person: person, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves an existing person.&lt;/p&gt;
    # @param person [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Person, Integer, Hash)>] Person data, response status code and response headers
    def get_account_persons_person_with_http_info(*, person : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_account_persons_person(person: person, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_account_persons_person\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Person.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves an existing person.&lt;/p&gt;
    # @param person [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_account_persons_person(*, person : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_account_persons_person(person: person, expand: expand).execute(&block)
    end

    GET_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_PERSON = 5000

    # @return Crest::Request
    def build_api_request_for_get_account_persons_person(*, person : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_account_persons_person ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"person\" is required and cannot be null") if person.nil?
        if _person = person
          OpenApi::PrimitiveValidator.validate_max_length("person", person.to_s.size, GET_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_PERSON)
        end
      end

      # resource path
      local_var_path = "/v1/account/persons/{person}".sub("{" + "person" + "}", URI.encode_path(person.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_account_persons_person",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of accounts connected to your platform via <a href=\"/docs/connect\">Connect</a>. If you’re not a platform, the list is empty.</p>
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [AccountList]
    def get_accounts(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_accounts_with_http_info(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of accounts connected to your platform via &lt;a href&#x3D;\&quot;/docs/connect\&quot;&gt;Connect&lt;/a&gt;. If you’re not a platform, the list is empty.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(AccountList, Integer, Hash)>] AccountList data, response status code and response headers
    def get_accounts_with_http_info(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_accounts(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_accounts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return AccountList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of accounts connected to your platform via &lt;a href&#x3D;\&quot;/docs/connect\&quot;&gt;Connect&lt;/a&gt;. If you’re not a platform, the list is empty.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_accounts(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_accounts(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_get_accounts(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_accounts ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/accounts"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_accounts",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an account.</p>
    # @param account [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Account]
    def get_accounts_account(*, account : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_accounts_account_with_http_info(account: account, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an account.&lt;/p&gt;
    # @param account [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Account, Integer, Hash)>] Account data, response status code and response headers
    def get_accounts_account_with_http_info(*, account : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_accounts_account(account: account, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_accounts_account\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Account.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an account.&lt;/p&gt;
    # @param account [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_accounts_account(*, account : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_accounts_account(account: account, expand: expand).execute(&block)
    end

    GET_ACCOUNTS_ACCOUNT_MAX_LENGTH_FOR_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_get_accounts_account(*, account : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_accounts_account ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, GET_ACCOUNTS_ACCOUNT_MAX_LENGTH_FOR_ACCOUNT)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_accounts_account",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieve a specified external account for a given account.</p>
    # @param account [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [ExternalAccount]
    def get_accounts_account_bank_accounts_id(*, account : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_accounts_account_bank_accounts_id_with_http_info(account: account, id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieve a specified external account for a given account.&lt;/p&gt;
    # @param account [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(ExternalAccount, Integer, Hash)>] ExternalAccount data, response status code and response headers
    def get_accounts_account_bank_accounts_id_with_http_info(*, account : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_accounts_account_bank_accounts_id(account: account, id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_accounts_account_bank_accounts_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ExternalAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieve a specified external account for a given account.&lt;/p&gt;
    # @param account [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_accounts_account_bank_accounts_id(*, account : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_accounts_account_bank_accounts_id(account: account, id: id, expand: expand).execute(&block)
    end

    GET_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_get_accounts_account_bank_accounts_id(*, account : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_accounts_account_bank_accounts_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, GET_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/bank_accounts/{id}".sub("{" + "account" + "}", URI.encode_path(account.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_accounts_account_bank_accounts_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of capabilities associated with the account. The capabilities are returned sorted by creation date, with the most recent capability appearing first.</p>
    # @param account [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [ListAccountCapability]
    def get_accounts_account_capabilities(*, account : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_accounts_account_capabilities_with_http_info(account: account, expand: expand)
      data
    end

    # &lt;p&gt;Returns a list of capabilities associated with the account. The capabilities are returned sorted by creation date, with the most recent capability appearing first.&lt;/p&gt;
    # @param account [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(ListAccountCapability, Integer, Hash)>] ListAccountCapability data, response status code and response headers
    def get_accounts_account_capabilities_with_http_info(*, account : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_accounts_account_capabilities(account: account, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_accounts_account_capabilities\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ListAccountCapability.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of capabilities associated with the account. The capabilities are returned sorted by creation date, with the most recent capability appearing first.&lt;/p&gt;
    # @param account [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_accounts_account_capabilities(*, account : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_accounts_account_capabilities(account: account, expand: expand).execute(&block)
    end

    GET_ACCOUNTS_ACCOUNT_CAPABILITIES_MAX_LENGTH_FOR_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_get_accounts_account_capabilities(*, account : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_accounts_account_capabilities ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, GET_ACCOUNTS_ACCOUNT_CAPABILITIES_MAX_LENGTH_FOR_ACCOUNT)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/capabilities".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_accounts_account_capabilities",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves information about the specified Account Capability.</p>
    # @param account [String?]
    # @param capability [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Capability]
    def get_accounts_account_capabilities_capability(*, account : String? = nil, capability : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_accounts_account_capabilities_capability_with_http_info(account: account, capability: capability, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves information about the specified Account Capability.&lt;/p&gt;
    # @param account [String?]
    # @param capability [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Capability, Integer, Hash)>] Capability data, response status code and response headers
    def get_accounts_account_capabilities_capability_with_http_info(*, account : String? = nil, capability : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_accounts_account_capabilities_capability(account: account, capability: capability, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_accounts_account_capabilities_capability\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Capability.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves information about the specified Account Capability.&lt;/p&gt;
    # @param account [String?]
    # @param capability [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_accounts_account_capabilities_capability(*, account : String? = nil, capability : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_accounts_account_capabilities_capability(account: account, capability: capability, expand: expand).execute(&block)
    end

    GET_ACCOUNTS_ACCOUNT_CAPABILITIES_CAPABILITY_MAX_LENGTH_FOR_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_get_accounts_account_capabilities_capability(*, account : String? = nil, capability : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_accounts_account_capabilities_capability ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, GET_ACCOUNTS_ACCOUNT_CAPABILITIES_CAPABILITY_MAX_LENGTH_FOR_ACCOUNT)
        end
        raise ArgumentError.new("\"capability\" is required and cannot be null") if capability.nil?
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/capabilities/{capability}".sub("{" + "account" + "}", URI.encode_path(account.to_s)).sub("{" + "capability" + "}", URI.encode_path(capability.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_accounts_account_capabilities_capability",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>List external accounts for an account.</p>
    # @param account [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [ExternalAccountList]
    def get_accounts_account_external_accounts(*, account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_accounts_account_external_accounts_with_http_info(account: account, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;List external accounts for an account.&lt;/p&gt;
    # @param account [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(ExternalAccountList, Integer, Hash)>] ExternalAccountList data, response status code and response headers
    def get_accounts_account_external_accounts_with_http_info(*, account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_accounts_account_external_accounts(account: account, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_accounts_account_external_accounts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ExternalAccountList.from_json(data), status_code, headers
    end

    # &lt;p&gt;List external accounts for an account.&lt;/p&gt;
    # @param account [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_accounts_account_external_accounts(*, account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_accounts_account_external_accounts(account: account, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_MAX_LENGTH_FOR_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_get_accounts_account_external_accounts(*, account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_accounts_account_external_accounts ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, GET_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_MAX_LENGTH_FOR_ACCOUNT)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/external_accounts".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_accounts_account_external_accounts",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieve a specified external account for a given account.</p>
    # @param account [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [ExternalAccount]
    def get_accounts_account_external_accounts_id(*, account : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_accounts_account_external_accounts_id_with_http_info(account: account, id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieve a specified external account for a given account.&lt;/p&gt;
    # @param account [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(ExternalAccount, Integer, Hash)>] ExternalAccount data, response status code and response headers
    def get_accounts_account_external_accounts_id_with_http_info(*, account : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_accounts_account_external_accounts_id(account: account, id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_accounts_account_external_accounts_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ExternalAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieve a specified external account for a given account.&lt;/p&gt;
    # @param account [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_accounts_account_external_accounts_id(*, account : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_accounts_account_external_accounts_id(account: account, id: id, expand: expand).execute(&block)
    end

    GET_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_get_accounts_account_external_accounts_id(*, account : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_accounts_account_external_accounts_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, GET_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/external_accounts/{id}".sub("{" + "account" + "}", URI.encode_path(account.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_accounts_account_external_accounts_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of people associated with the account’s legal entity. The people are returned sorted by creation date, with the most recent people appearing first.</p>
    # @param account [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param relationship [Stripe::AllPeopleRelationshipSpecs?] Filters on the list of people returned based on the person's relationship to the account's company.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [PersonList]
    def get_accounts_account_people(*, account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, relationship : Stripe::AllPeopleRelationshipSpecs? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_accounts_account_people_with_http_info(account: account, ending_before: ending_before, expand: expand, limit: limit, relationship: relationship, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of people associated with the account’s legal entity. The people are returned sorted by creation date, with the most recent people appearing first.&lt;/p&gt;
    # @param account [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param relationship [Stripe::AllPeopleRelationshipSpecs?] Filters on the list of people returned based on the person's relationship to the account's company.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(PersonList, Integer, Hash)>] PersonList data, response status code and response headers
    def get_accounts_account_people_with_http_info(*, account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, relationship : Stripe::AllPeopleRelationshipSpecs? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_accounts_account_people(account: account, ending_before: ending_before, expand: expand, limit: limit, relationship: relationship, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_accounts_account_people\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PersonList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of people associated with the account’s legal entity. The people are returned sorted by creation date, with the most recent people appearing first.&lt;/p&gt;
    # @param account [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param relationship [Stripe::AllPeopleRelationshipSpecs?] Filters on the list of people returned based on the person's relationship to the account's company.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_accounts_account_people(*, account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, relationship : Stripe::AllPeopleRelationshipSpecs? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_accounts_account_people(account: account, ending_before: ending_before, expand: expand, limit: limit, relationship: relationship, starting_after: starting_after).execute(&block)
    end

    GET_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_ACCOUNT        = 5000
    GET_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_accounts_account_people(*, account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, relationship : Stripe::AllPeopleRelationshipSpecs? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_accounts_account_people ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, GET_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_ACCOUNT)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _relationship = relationship
          _relationship.validate if _relationship.is_a?(OpenApi::Validatable)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/people".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["relationship"] = relationship.to_s if !relationship.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_accounts_account_people",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves an existing person.</p>
    # @param account [String?]
    # @param person [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Person]
    def get_accounts_account_people_person(*, account : String? = nil, person : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_accounts_account_people_person_with_http_info(account: account, person: person, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves an existing person.&lt;/p&gt;
    # @param account [String?]
    # @param person [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Person, Integer, Hash)>] Person data, response status code and response headers
    def get_accounts_account_people_person_with_http_info(*, account : String? = nil, person : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_accounts_account_people_person(account: account, person: person, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_accounts_account_people_person\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Person.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves an existing person.&lt;/p&gt;
    # @param account [String?]
    # @param person [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_accounts_account_people_person(*, account : String? = nil, person : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_accounts_account_people_person(account: account, person: person, expand: expand).execute(&block)
    end

    GET_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_ACCOUNT = 5000
    GET_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_PERSON  = 5000

    # @return Crest::Request
    def build_api_request_for_get_accounts_account_people_person(*, account : String? = nil, person : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_accounts_account_people_person ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, GET_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_ACCOUNT)
        end
        raise ArgumentError.new("\"person\" is required and cannot be null") if person.nil?
        if _person = person
          OpenApi::PrimitiveValidator.validate_max_length("person", person.to_s.size, GET_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_PERSON)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/people/{person}".sub("{" + "account" + "}", URI.encode_path(account.to_s)).sub("{" + "person" + "}", URI.encode_path(person.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_accounts_account_people_person",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of people associated with the account’s legal entity. The people are returned sorted by creation date, with the most recent people appearing first.</p>
    # @param account [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param relationship [Stripe::AllPeopleRelationshipSpecs?] Filters on the list of people returned based on the person's relationship to the account's company.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [PersonList]
    def get_accounts_account_persons(*, account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, relationship : Stripe::AllPeopleRelationshipSpecs? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_accounts_account_persons_with_http_info(account: account, ending_before: ending_before, expand: expand, limit: limit, relationship: relationship, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of people associated with the account’s legal entity. The people are returned sorted by creation date, with the most recent people appearing first.&lt;/p&gt;
    # @param account [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param relationship [Stripe::AllPeopleRelationshipSpecs?] Filters on the list of people returned based on the person's relationship to the account's company.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(PersonList, Integer, Hash)>] PersonList data, response status code and response headers
    def get_accounts_account_persons_with_http_info(*, account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, relationship : Stripe::AllPeopleRelationshipSpecs? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_accounts_account_persons(account: account, ending_before: ending_before, expand: expand, limit: limit, relationship: relationship, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_accounts_account_persons\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PersonList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of people associated with the account’s legal entity. The people are returned sorted by creation date, with the most recent people appearing first.&lt;/p&gt;
    # @param account [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param relationship [Stripe::AllPeopleRelationshipSpecs?] Filters on the list of people returned based on the person's relationship to the account's company.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_accounts_account_persons(*, account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, relationship : Stripe::AllPeopleRelationshipSpecs? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_accounts_account_persons(account: account, ending_before: ending_before, expand: expand, limit: limit, relationship: relationship, starting_after: starting_after).execute(&block)
    end

    GET_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_ACCOUNT        = 5000
    GET_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_accounts_account_persons(*, account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, relationship : Stripe::AllPeopleRelationshipSpecs? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_accounts_account_persons ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, GET_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_ACCOUNT)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _relationship = relationship
          _relationship.validate if _relationship.is_a?(OpenApi::Validatable)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/persons".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["relationship"] = relationship.to_s if !relationship.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_accounts_account_persons",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves an existing person.</p>
    # @param account [String?]
    # @param person [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Person]
    def get_accounts_account_persons_person(*, account : String? = nil, person : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_accounts_account_persons_person_with_http_info(account: account, person: person, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves an existing person.&lt;/p&gt;
    # @param account [String?]
    # @param person [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Person, Integer, Hash)>] Person data, response status code and response headers
    def get_accounts_account_persons_person_with_http_info(*, account : String? = nil, person : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_accounts_account_persons_person(account: account, person: person, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_accounts_account_persons_person\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Person.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves an existing person.&lt;/p&gt;
    # @param account [String?]
    # @param person [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_accounts_account_persons_person(*, account : String? = nil, person : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_accounts_account_persons_person(account: account, person: person, expand: expand).execute(&block)
    end

    GET_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_ACCOUNT = 5000
    GET_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_PERSON  = 5000

    # @return Crest::Request
    def build_api_request_for_get_accounts_account_persons_person(*, account : String? = nil, person : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_accounts_account_persons_person ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, GET_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_ACCOUNT)
        end
        raise ArgumentError.new("\"person\" is required and cannot be null") if person.nil?
        if _person = person
          OpenApi::PrimitiveValidator.validate_max_length("person", person.to_s.size, GET_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_PERSON)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/persons/{person}".sub("{" + "account" + "}", URI.encode_path(account.to_s)).sub("{" + "person" + "}", URI.encode_path(person.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_accounts_account_persons_person",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>List apple pay domains.</p>
    # @optional @param domain_name [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [ApplePayDomainList]
    def get_apple_pay_domains(*, domain_name : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_apple_pay_domains_with_http_info(domain_name: domain_name, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;List apple pay domains.&lt;/p&gt;
    # @optional @param domain_name [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(ApplePayDomainList, Integer, Hash)>] ApplePayDomainList data, response status code and response headers
    def get_apple_pay_domains_with_http_info(*, domain_name : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_apple_pay_domains(domain_name: domain_name, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_apple_pay_domains\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ApplePayDomainList.from_json(data), status_code, headers
    end

    # &lt;p&gt;List apple pay domains.&lt;/p&gt;
    # @optional @param domain_name [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_apple_pay_domains(*, domain_name : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_apple_pay_domains(domain_name: domain_name, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_APPLE_PAY_DOMAINS_MAX_LENGTH_FOR_DOMAIN_NAME    = 5000
    GET_APPLE_PAY_DOMAINS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_APPLE_PAY_DOMAINS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_apple_pay_domains(*, domain_name : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_apple_pay_domains ..." }
      end

      if client_side_validation
        if _domain_name = domain_name
          OpenApi::PrimitiveValidator.validate_max_length("domain_name", domain_name.to_s.size, GET_APPLE_PAY_DOMAINS_MAX_LENGTH_FOR_DOMAIN_NAME)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_APPLE_PAY_DOMAINS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_APPLE_PAY_DOMAINS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/apple_pay/domains"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["domain_name"] = domain_name.to_s if !domain_name.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_apple_pay_domains",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieve an apple pay domain.</p>
    # @param domain [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [ApplePayDomain]
    def get_apple_pay_domains_domain(*, domain : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_apple_pay_domains_domain_with_http_info(domain: domain, expand: expand)
      data
    end

    # &lt;p&gt;Retrieve an apple pay domain.&lt;/p&gt;
    # @param domain [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(ApplePayDomain, Integer, Hash)>] ApplePayDomain data, response status code and response headers
    def get_apple_pay_domains_domain_with_http_info(*, domain : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_apple_pay_domains_domain(domain: domain, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_apple_pay_domains_domain\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ApplePayDomain.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieve an apple pay domain.&lt;/p&gt;
    # @param domain [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_apple_pay_domains_domain(*, domain : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_apple_pay_domains_domain(domain: domain, expand: expand).execute(&block)
    end

    GET_APPLE_PAY_DOMAINS_DOMAIN_MAX_LENGTH_FOR_DOMAIN = 5000

    # @return Crest::Request
    def build_api_request_for_get_apple_pay_domains_domain(*, domain : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_apple_pay_domains_domain ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"domain\" is required and cannot be null") if domain.nil?
        if _domain = domain
          OpenApi::PrimitiveValidator.validate_max_length("domain", domain.to_s.size, GET_APPLE_PAY_DOMAINS_DOMAIN_MAX_LENGTH_FOR_DOMAIN)
        end
      end

      # resource path
      local_var_path = "/v1/apple_pay/domains/{domain}".sub("{" + "domain" + "}", URI.encode_path(domain.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_apple_pay_domains_domain",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of application fees you’ve previously collected. The application fees are returned in sorted order, with the most recent fees appearing first.</p>
    # @optional @param charge [String?] Only return application fees for the charge specified by this charge ID.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [PlatformEarningList]
    def get_application_fees(*, charge : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_application_fees_with_http_info(charge: charge, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of application fees you’ve previously collected. The application fees are returned in sorted order, with the most recent fees appearing first.&lt;/p&gt;
    # @optional @param charge [String?] Only return application fees for the charge specified by this charge ID.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(PlatformEarningList, Integer, Hash)>] PlatformEarningList data, response status code and response headers
    def get_application_fees_with_http_info(*, charge : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_application_fees(charge: charge, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_application_fees\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PlatformEarningList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of application fees you’ve previously collected. The application fees are returned in sorted order, with the most recent fees appearing first.&lt;/p&gt;
    # @optional @param charge [String?] Only return application fees for the charge specified by this charge ID.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_application_fees(*, charge : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_application_fees(charge: charge, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_APPLICATION_FEES_MAX_LENGTH_FOR_CHARGE         = 5000
    GET_APPLICATION_FEES_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_APPLICATION_FEES_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_application_fees(*, charge : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_application_fees ..." }
      end

      if client_side_validation
        if _charge = charge
          OpenApi::PrimitiveValidator.validate_max_length("charge", charge.to_s.size, GET_APPLICATION_FEES_MAX_LENGTH_FOR_CHARGE)
        end
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_APPLICATION_FEES_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_APPLICATION_FEES_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/application_fees"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["charge"] = charge.to_s if !charge.nil?
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_application_fees",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>By default, you can see the 10 most recent refunds stored directly on the application fee object, but you can also retrieve details about a specific refund stored on the application fee.</p>
    # @param fee [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [FeeRefund]
    def get_application_fees_fee_refunds_id(*, fee : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_application_fees_fee_refunds_id_with_http_info(fee: fee, id: id, expand: expand)
      data
    end

    # &lt;p&gt;By default, you can see the 10 most recent refunds stored directly on the application fee object, but you can also retrieve details about a specific refund stored on the application fee.&lt;/p&gt;
    # @param fee [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(FeeRefund, Integer, Hash)>] FeeRefund data, response status code and response headers
    def get_application_fees_fee_refunds_id_with_http_info(*, fee : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_application_fees_fee_refunds_id(fee: fee, id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_application_fees_fee_refunds_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FeeRefund.from_json(data), status_code, headers
    end

    # &lt;p&gt;By default, you can see the 10 most recent refunds stored directly on the application fee object, but you can also retrieve details about a specific refund stored on the application fee.&lt;/p&gt;
    # @param fee [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_application_fees_fee_refunds_id(*, fee : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_application_fees_fee_refunds_id(fee: fee, id: id, expand: expand).execute(&block)
    end

    GET_APPLICATION_FEES_FEE_REFUNDS_ID_MAX_LENGTH_FOR_FEE = 5000
    GET_APPLICATION_FEES_FEE_REFUNDS_ID_MAX_LENGTH_FOR_ID  = 5000

    # @return Crest::Request
    def build_api_request_for_get_application_fees_fee_refunds_id(*, fee : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_application_fees_fee_refunds_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"fee\" is required and cannot be null") if fee.nil?
        if _fee = fee
          OpenApi::PrimitiveValidator.validate_max_length("fee", fee.to_s.size, GET_APPLICATION_FEES_FEE_REFUNDS_ID_MAX_LENGTH_FOR_FEE)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_APPLICATION_FEES_FEE_REFUNDS_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/application_fees/{fee}/refunds/{id}".sub("{" + "fee" + "}", URI.encode_path(fee.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_application_fees_fee_refunds_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an application fee that your account has collected. The same information is returned when refunding the application fee.</p>
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [ApplicationFee]
    def get_application_fees_id(*, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_application_fees_id_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an application fee that your account has collected. The same information is returned when refunding the application fee.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(ApplicationFee, Integer, Hash)>] ApplicationFee data, response status code and response headers
    def get_application_fees_id_with_http_info(*, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_application_fees_id(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_application_fees_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ApplicationFee.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an application fee that your account has collected. The same information is returned when refunding the application fee.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_application_fees_id(*, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_application_fees_id(id: id, expand: expand).execute(&block)
    end

    GET_APPLICATION_FEES_ID_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_get_application_fees_id(*, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_application_fees_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_APPLICATION_FEES_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/application_fees/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_application_fees_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>You can see a list of the refunds belonging to a specific application fee. Note that the 10 most recent refunds are always available by default on the application fee object. If you need more than those 10, you can use this API method and the <code>limit</code> and <code>starting_after</code> parameters to page through additional refunds.</p>
    # @param id [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [FeeRefundList]
    def get_application_fees_id_refunds(*, id : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_application_fees_id_refunds_with_http_info(id: id, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;You can see a list of the refunds belonging to a specific application fee. Note that the 10 most recent refunds are always available by default on the application fee object. If you need more than those 10, you can use this API method and the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;starting_after&lt;/code&gt; parameters to page through additional refunds.&lt;/p&gt;
    # @param id [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(FeeRefundList, Integer, Hash)>] FeeRefundList data, response status code and response headers
    def get_application_fees_id_refunds_with_http_info(*, id : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_application_fees_id_refunds(id: id, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_application_fees_id_refunds\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FeeRefundList.from_json(data), status_code, headers
    end

    # &lt;p&gt;You can see a list of the refunds belonging to a specific application fee. Note that the 10 most recent refunds are always available by default on the application fee object. If you need more than those 10, you can use this API method and the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;starting_after&lt;/code&gt; parameters to page through additional refunds.&lt;/p&gt;
    # @param id [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_application_fees_id_refunds(*, id : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_application_fees_id_refunds(id: id, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_APPLICATION_FEES_ID_REFUNDS_MAX_LENGTH_FOR_ID             = 5000
    GET_APPLICATION_FEES_ID_REFUNDS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_APPLICATION_FEES_ID_REFUNDS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_application_fees_id_refunds(*, id : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_application_fees_id_refunds ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_APPLICATION_FEES_ID_REFUNDS_MAX_LENGTH_FOR_ID)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_APPLICATION_FEES_ID_REFUNDS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_APPLICATION_FEES_ID_REFUNDS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/application_fees/{id}/refunds".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_application_fees_id_refunds",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>List all secrets stored on the given scope.</p>
    # @param scope [Stripe::ScopeParam?] Specifies the scoping of the secret. Requests originating from UI extensions can only access account-scoped secrets or secrets scoped to their own user.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [SecretServiceResourceSecretList]
    def get_apps_secrets(*, scope : Stripe::ScopeParam? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_apps_secrets_with_http_info(scope: scope, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;List all secrets stored on the given scope.&lt;/p&gt;
    # @param scope [Stripe::ScopeParam?] Specifies the scoping of the secret. Requests originating from UI extensions can only access account-scoped secrets or secrets scoped to their own user.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(SecretServiceResourceSecretList, Integer, Hash)>] SecretServiceResourceSecretList data, response status code and response headers
    def get_apps_secrets_with_http_info(*, scope : Stripe::ScopeParam? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_apps_secrets(scope: scope, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_apps_secrets\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SecretServiceResourceSecretList.from_json(data), status_code, headers
    end

    # &lt;p&gt;List all secrets stored on the given scope.&lt;/p&gt;
    # @param scope [Stripe::ScopeParam?] Specifies the scoping of the secret. Requests originating from UI extensions can only access account-scoped secrets or secrets scoped to their own user.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_apps_secrets(*, scope : Stripe::ScopeParam? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_apps_secrets(scope: scope, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_APPS_SECRETS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_APPS_SECRETS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_apps_secrets(*, scope : Stripe::ScopeParam? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_apps_secrets ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"scope\" is required and cannot be null") if scope.nil?
        if _scope = scope
          _scope.validate if _scope.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_APPS_SECRETS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_APPS_SECRETS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/apps/secrets"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["scope"] = scope.to_s if !scope.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_apps_secrets",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Finds a secret in the secret store by name and scope.</p>
    # @param name [String?] A name for the secret that's unique within the scope.
    # @param scope [Stripe::ScopeParam?] Specifies the scoping of the secret. Requests originating from UI extensions can only access account-scoped secrets or secrets scoped to their own user.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [AppsSecret]
    def get_apps_secrets_find(*, name : String? = nil, scope : Stripe::ScopeParam? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_apps_secrets_find_with_http_info(name: name, scope: scope, expand: expand)
      data
    end

    # &lt;p&gt;Finds a secret in the secret store by name and scope.&lt;/p&gt;
    # @param name [String?] A name for the secret that's unique within the scope.
    # @param scope [Stripe::ScopeParam?] Specifies the scoping of the secret. Requests originating from UI extensions can only access account-scoped secrets or secrets scoped to their own user.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(AppsSecret, Integer, Hash)>] AppsSecret data, response status code and response headers
    def get_apps_secrets_find_with_http_info(*, name : String? = nil, scope : Stripe::ScopeParam? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_apps_secrets_find(name: name, scope: scope, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_apps_secrets_find\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return AppsSecret.from_json(data), status_code, headers
    end

    # &lt;p&gt;Finds a secret in the secret store by name and scope.&lt;/p&gt;
    # @param name [String?] A name for the secret that's unique within the scope.
    # @param scope [Stripe::ScopeParam?] Specifies the scoping of the secret. Requests originating from UI extensions can only access account-scoped secrets or secrets scoped to their own user.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_apps_secrets_find(*, name : String? = nil, scope : Stripe::ScopeParam? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_apps_secrets_find(name: name, scope: scope, expand: expand).execute(&block)
    end

    GET_APPS_SECRETS_FIND_MAX_LENGTH_FOR_NAME = 5000

    # @return Crest::Request
    def build_api_request_for_get_apps_secrets_find(*, name : String? = nil, scope : Stripe::ScopeParam? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_apps_secrets_find ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"name\" is required and cannot be null") if name.nil?
        if _name = name
          OpenApi::PrimitiveValidator.validate_max_length("name", name.to_s.size, GET_APPS_SECRETS_FIND_MAX_LENGTH_FOR_NAME)
        end
        raise ArgumentError.new("\"scope\" is required and cannot be null") if scope.nil?
        if _scope = scope
          _scope.validate if _scope.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/apps/secrets/find"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["name"] = name.to_s if !name.nil?
      query_params["scope"] = scope.to_s if !scope.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_apps_secrets_find",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the current account balance, based on the authentication that was used to make the request.  For a sample request, see <a href=\"/docs/connect/account-balances#accounting-for-negative-balances\">Accounting for negative balances</a>.</p>
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Balance]
    def get_balance(*, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_balance_with_http_info(expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the current account balance, based on the authentication that was used to make the request.  For a sample request, see &lt;a href&#x3D;\&quot;/docs/connect/account-balances#accounting-for-negative-balances\&quot;&gt;Accounting for negative balances&lt;/a&gt;.&lt;/p&gt;
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Balance, Integer, Hash)>] Balance data, response status code and response headers
    def get_balance_with_http_info(*, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_balance(expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_balance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Balance.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the current account balance, based on the authentication that was used to make the request.  For a sample request, see &lt;a href&#x3D;\&quot;/docs/connect/account-balances#accounting-for-negative-balances\&quot;&gt;Accounting for negative balances&lt;/a&gt;.&lt;/p&gt;
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_balance(*, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_balance(expand: expand).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_get_balance(*, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_balance ..." }
      end

      if client_side_validation
      end

      # resource path
      local_var_path = "/v1/balance"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_balance",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of transactions that have contributed to the Stripe account balance (e.g., charges, transfers, and so forth). The transactions are returned in sorted order, with the most recent transactions appearing first.</p>  <p>Note that this endpoint was previously called “Balance history” and used the path <code>/v1/balance/history</code>.</p>
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param currency [String?] Only return transactions in a certain currency. Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payout [String?] For automatic Stripe payouts only, only returns transactions that were paid out on the specified payout ID.
    # @optional @param source [String?] Only returns the original transaction.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param _type [String?] Only returns transactions of the given type. One of: `adjustment`, `advance`, `advance_funding`, `anticipation_repayment`, `application_fee`, `application_fee_refund`, `charge`, `connect_collection_transfer`, `contribution`, `issuing_authorization_hold`, `issuing_authorization_release`, `issuing_dispute`, `issuing_transaction`, `payment`, `payment_failure_refund`, `payment_refund`, `payout`, `payout_cancel`, `payout_failure`, `refund`, `refund_failure`, `reserve_transaction`, `reserved_funds`, `stripe_fee`, `stripe_fx_fee`, `tax_fee`, `topup`, `topup_reversal`, `transfer`, `transfer_cancel`, `transfer_failure`, or `transfer_refund`.
    # @return [BalanceTransactionsList]
    def get_balance_history(*, created : Stripe::GetAccountsCreatedParameter? = nil, currency : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payout : String? = nil, source : String? = nil, starting_after : String? = nil, _type : String? = nil)
      data, _status_code, _headers = get_balance_history_with_http_info(created: created, currency: currency, ending_before: ending_before, expand: expand, limit: limit, payout: payout, source: source, starting_after: starting_after, _type: _type)
      data
    end

    # &lt;p&gt;Returns a list of transactions that have contributed to the Stripe account balance (e.g., charges, transfers, and so forth). The transactions are returned in sorted order, with the most recent transactions appearing first.&lt;/p&gt;  &lt;p&gt;Note that this endpoint was previously called “Balance history” and used the path &lt;code&gt;/v1/balance/history&lt;/code&gt;.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param currency [String?] Only return transactions in a certain currency. Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payout [String?] For automatic Stripe payouts only, only returns transactions that were paid out on the specified payout ID.
    # @optional @param source [String?] Only returns the original transaction.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param _type [String?] Only returns transactions of the given type. One of: `adjustment`, `advance`, `advance_funding`, `anticipation_repayment`, `application_fee`, `application_fee_refund`, `charge`, `connect_collection_transfer`, `contribution`, `issuing_authorization_hold`, `issuing_authorization_release`, `issuing_dispute`, `issuing_transaction`, `payment`, `payment_failure_refund`, `payment_refund`, `payout`, `payout_cancel`, `payout_failure`, `refund`, `refund_failure`, `reserve_transaction`, `reserved_funds`, `stripe_fee`, `stripe_fx_fee`, `tax_fee`, `topup`, `topup_reversal`, `transfer`, `transfer_cancel`, `transfer_failure`, or `transfer_refund`.
    # @return [Array<(BalanceTransactionsList, Integer, Hash)>] BalanceTransactionsList data, response status code and response headers
    def get_balance_history_with_http_info(*, created : Stripe::GetAccountsCreatedParameter? = nil, currency : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payout : String? = nil, source : String? = nil, starting_after : String? = nil, _type : String? = nil)
      request = build_api_request_for_get_balance_history(created: created, currency: currency, ending_before: ending_before, expand: expand, limit: limit, payout: payout, source: source, starting_after: starting_after, _type: _type)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_balance_history\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return BalanceTransactionsList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of transactions that have contributed to the Stripe account balance (e.g., charges, transfers, and so forth). The transactions are returned in sorted order, with the most recent transactions appearing first.&lt;/p&gt;  &lt;p&gt;Note that this endpoint was previously called “Balance history” and used the path &lt;code&gt;/v1/balance/history&lt;/code&gt;.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param currency [String?] Only return transactions in a certain currency. Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payout [String?] For automatic Stripe payouts only, only returns transactions that were paid out on the specified payout ID.
    # @optional @param source [String?] Only returns the original transaction.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param _type [String?] Only returns transactions of the given type. One of: `adjustment`, `advance`, `advance_funding`, `anticipation_repayment`, `application_fee`, `application_fee_refund`, `charge`, `connect_collection_transfer`, `contribution`, `issuing_authorization_hold`, `issuing_authorization_release`, `issuing_dispute`, `issuing_transaction`, `payment`, `payment_failure_refund`, `payment_refund`, `payout`, `payout_cancel`, `payout_failure`, `refund`, `refund_failure`, `reserve_transaction`, `reserved_funds`, `stripe_fee`, `stripe_fx_fee`, `tax_fee`, `topup`, `topup_reversal`, `transfer`, `transfer_cancel`, `transfer_failure`, or `transfer_refund`.
    # @return nil
    def get_balance_history(*, created : Stripe::GetAccountsCreatedParameter? = nil, currency : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payout : String? = nil, source : String? = nil, starting_after : String? = nil, _type : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_balance_history(created: created, currency: currency, ending_before: ending_before, expand: expand, limit: limit, payout: payout, source: source, starting_after: starting_after, _type: _type).execute(&block)
    end

    GET_BALANCE_HISTORY_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_BALANCE_HISTORY_MAX_LENGTH_FOR_PAYOUT         = 5000
    GET_BALANCE_HISTORY_MAX_LENGTH_FOR_SOURCE         = 5000
    GET_BALANCE_HISTORY_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_BALANCE_HISTORY_MAX_LENGTH_FOR__TYPE          = 5000

    # @return Crest::Request
    def build_api_request_for_get_balance_history(*, created : Stripe::GetAccountsCreatedParameter? = nil, currency : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payout : String? = nil, source : String? = nil, starting_after : String? = nil, _type : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_balance_history ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end

        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_BALANCE_HISTORY_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _payout = payout
          OpenApi::PrimitiveValidator.validate_max_length("payout", payout.to_s.size, GET_BALANCE_HISTORY_MAX_LENGTH_FOR_PAYOUT)
        end
        if _source = source
          OpenApi::PrimitiveValidator.validate_max_length("source", source.to_s.size, GET_BALANCE_HISTORY_MAX_LENGTH_FOR_SOURCE)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_BALANCE_HISTORY_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if __type = _type
          OpenApi::PrimitiveValidator.validate_max_length("_type", _type.to_s.size, GET_BALANCE_HISTORY_MAX_LENGTH_FOR__TYPE)
        end
      end

      # resource path
      local_var_path = "/v1/balance/history"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["currency"] = currency.to_s if !currency.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["payout"] = payout.to_s if !payout.nil?
      query_params["source"] = source.to_s if !source.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["type"] = _type.to_s if !_type.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_balance_history",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the balance transaction with the given ID.</p>  <p>Note that this endpoint previously used the path <code>/v1/balance/history/:id</code>.</p>
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [BalanceTransaction]
    def get_balance_history_id(*, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_balance_history_id_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the balance transaction with the given ID.&lt;/p&gt;  &lt;p&gt;Note that this endpoint previously used the path &lt;code&gt;/v1/balance/history/:id&lt;/code&gt;.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(BalanceTransaction, Integer, Hash)>] BalanceTransaction data, response status code and response headers
    def get_balance_history_id_with_http_info(*, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_balance_history_id(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_balance_history_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return BalanceTransaction.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the balance transaction with the given ID.&lt;/p&gt;  &lt;p&gt;Note that this endpoint previously used the path &lt;code&gt;/v1/balance/history/:id&lt;/code&gt;.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_balance_history_id(*, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_balance_history_id(id: id, expand: expand).execute(&block)
    end

    GET_BALANCE_HISTORY_ID_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_get_balance_history_id(*, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_balance_history_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_BALANCE_HISTORY_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/balance/history/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_balance_history_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of transactions that have contributed to the Stripe account balance (e.g., charges, transfers, and so forth). The transactions are returned in sorted order, with the most recent transactions appearing first.</p>  <p>Note that this endpoint was previously called “Balance history” and used the path <code>/v1/balance/history</code>.</p>
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param currency [String?] Only return transactions in a certain currency. Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payout [String?] For automatic Stripe payouts only, only returns transactions that were paid out on the specified payout ID.
    # @optional @param source [String?] Only returns the original transaction.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param _type [String?] Only returns transactions of the given type. One of: `adjustment`, `advance`, `advance_funding`, `anticipation_repayment`, `application_fee`, `application_fee_refund`, `charge`, `connect_collection_transfer`, `contribution`, `issuing_authorization_hold`, `issuing_authorization_release`, `issuing_dispute`, `issuing_transaction`, `payment`, `payment_failure_refund`, `payment_refund`, `payout`, `payout_cancel`, `payout_failure`, `refund`, `refund_failure`, `reserve_transaction`, `reserved_funds`, `stripe_fee`, `stripe_fx_fee`, `tax_fee`, `topup`, `topup_reversal`, `transfer`, `transfer_cancel`, `transfer_failure`, or `transfer_refund`.
    # @return [BalanceTransactionsList]
    def get_balance_transactions(*, created : Stripe::GetAccountsCreatedParameter? = nil, currency : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payout : String? = nil, source : String? = nil, starting_after : String? = nil, _type : String? = nil)
      data, _status_code, _headers = get_balance_transactions_with_http_info(created: created, currency: currency, ending_before: ending_before, expand: expand, limit: limit, payout: payout, source: source, starting_after: starting_after, _type: _type)
      data
    end

    # &lt;p&gt;Returns a list of transactions that have contributed to the Stripe account balance (e.g., charges, transfers, and so forth). The transactions are returned in sorted order, with the most recent transactions appearing first.&lt;/p&gt;  &lt;p&gt;Note that this endpoint was previously called “Balance history” and used the path &lt;code&gt;/v1/balance/history&lt;/code&gt;.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param currency [String?] Only return transactions in a certain currency. Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payout [String?] For automatic Stripe payouts only, only returns transactions that were paid out on the specified payout ID.
    # @optional @param source [String?] Only returns the original transaction.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param _type [String?] Only returns transactions of the given type. One of: `adjustment`, `advance`, `advance_funding`, `anticipation_repayment`, `application_fee`, `application_fee_refund`, `charge`, `connect_collection_transfer`, `contribution`, `issuing_authorization_hold`, `issuing_authorization_release`, `issuing_dispute`, `issuing_transaction`, `payment`, `payment_failure_refund`, `payment_refund`, `payout`, `payout_cancel`, `payout_failure`, `refund`, `refund_failure`, `reserve_transaction`, `reserved_funds`, `stripe_fee`, `stripe_fx_fee`, `tax_fee`, `topup`, `topup_reversal`, `transfer`, `transfer_cancel`, `transfer_failure`, or `transfer_refund`.
    # @return [Array<(BalanceTransactionsList, Integer, Hash)>] BalanceTransactionsList data, response status code and response headers
    def get_balance_transactions_with_http_info(*, created : Stripe::GetAccountsCreatedParameter? = nil, currency : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payout : String? = nil, source : String? = nil, starting_after : String? = nil, _type : String? = nil)
      request = build_api_request_for_get_balance_transactions(created: created, currency: currency, ending_before: ending_before, expand: expand, limit: limit, payout: payout, source: source, starting_after: starting_after, _type: _type)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_balance_transactions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return BalanceTransactionsList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of transactions that have contributed to the Stripe account balance (e.g., charges, transfers, and so forth). The transactions are returned in sorted order, with the most recent transactions appearing first.&lt;/p&gt;  &lt;p&gt;Note that this endpoint was previously called “Balance history” and used the path &lt;code&gt;/v1/balance/history&lt;/code&gt;.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param currency [String?] Only return transactions in a certain currency. Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payout [String?] For automatic Stripe payouts only, only returns transactions that were paid out on the specified payout ID.
    # @optional @param source [String?] Only returns the original transaction.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param _type [String?] Only returns transactions of the given type. One of: `adjustment`, `advance`, `advance_funding`, `anticipation_repayment`, `application_fee`, `application_fee_refund`, `charge`, `connect_collection_transfer`, `contribution`, `issuing_authorization_hold`, `issuing_authorization_release`, `issuing_dispute`, `issuing_transaction`, `payment`, `payment_failure_refund`, `payment_refund`, `payout`, `payout_cancel`, `payout_failure`, `refund`, `refund_failure`, `reserve_transaction`, `reserved_funds`, `stripe_fee`, `stripe_fx_fee`, `tax_fee`, `topup`, `topup_reversal`, `transfer`, `transfer_cancel`, `transfer_failure`, or `transfer_refund`.
    # @return nil
    def get_balance_transactions(*, created : Stripe::GetAccountsCreatedParameter? = nil, currency : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payout : String? = nil, source : String? = nil, starting_after : String? = nil, _type : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_balance_transactions(created: created, currency: currency, ending_before: ending_before, expand: expand, limit: limit, payout: payout, source: source, starting_after: starting_after, _type: _type).execute(&block)
    end

    GET_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_PAYOUT         = 5000
    GET_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_SOURCE         = 5000
    GET_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR__TYPE          = 5000

    # @return Crest::Request
    def build_api_request_for_get_balance_transactions(*, created : Stripe::GetAccountsCreatedParameter? = nil, currency : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payout : String? = nil, source : String? = nil, starting_after : String? = nil, _type : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_balance_transactions ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end

        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _payout = payout
          OpenApi::PrimitiveValidator.validate_max_length("payout", payout.to_s.size, GET_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_PAYOUT)
        end
        if _source = source
          OpenApi::PrimitiveValidator.validate_max_length("source", source.to_s.size, GET_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_SOURCE)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if __type = _type
          OpenApi::PrimitiveValidator.validate_max_length("_type", _type.to_s.size, GET_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR__TYPE)
        end
      end

      # resource path
      local_var_path = "/v1/balance_transactions"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["currency"] = currency.to_s if !currency.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["payout"] = payout.to_s if !payout.nil?
      query_params["source"] = source.to_s if !source.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["type"] = _type.to_s if !_type.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_balance_transactions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the balance transaction with the given ID.</p>  <p>Note that this endpoint previously used the path <code>/v1/balance/history/:id</code>.</p>
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [BalanceTransaction]
    def get_balance_transactions_id(*, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_balance_transactions_id_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the balance transaction with the given ID.&lt;/p&gt;  &lt;p&gt;Note that this endpoint previously used the path &lt;code&gt;/v1/balance/history/:id&lt;/code&gt;.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(BalanceTransaction, Integer, Hash)>] BalanceTransaction data, response status code and response headers
    def get_balance_transactions_id_with_http_info(*, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_balance_transactions_id(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_balance_transactions_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return BalanceTransaction.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the balance transaction with the given ID.&lt;/p&gt;  &lt;p&gt;Note that this endpoint previously used the path &lt;code&gt;/v1/balance/history/:id&lt;/code&gt;.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_balance_transactions_id(*, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_balance_transactions_id(id: id, expand: expand).execute(&block)
    end

    GET_BALANCE_TRANSACTIONS_ID_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_get_balance_transactions_id(*, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_balance_transactions_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_BALANCE_TRANSACTIONS_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/balance_transactions/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_balance_transactions_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of configurations that describe the functionality of the customer portal.</p>
    # @optional @param active [Bool?] Only return configurations that are active or inactive (e.g., pass `true` to only list active configurations).
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param is_default [Bool?] Only return the default or non-default configurations (e.g., pass `true` to only list the default configuration).
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [PortalConfigurationList]
    def get_billing_portal_configurations(*, active : Bool? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, is_default : Bool? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_billing_portal_configurations_with_http_info(active: active, ending_before: ending_before, expand: expand, is_default: is_default, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of configurations that describe the functionality of the customer portal.&lt;/p&gt;
    # @optional @param active [Bool?] Only return configurations that are active or inactive (e.g., pass `true` to only list active configurations).
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param is_default [Bool?] Only return the default or non-default configurations (e.g., pass `true` to only list the default configuration).
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(PortalConfigurationList, Integer, Hash)>] PortalConfigurationList data, response status code and response headers
    def get_billing_portal_configurations_with_http_info(*, active : Bool? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, is_default : Bool? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_billing_portal_configurations(active: active, ending_before: ending_before, expand: expand, is_default: is_default, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_billing_portal_configurations\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PortalConfigurationList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of configurations that describe the functionality of the customer portal.&lt;/p&gt;
    # @optional @param active [Bool?] Only return configurations that are active or inactive (e.g., pass `true` to only list active configurations).
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param is_default [Bool?] Only return the default or non-default configurations (e.g., pass `true` to only list the default configuration).
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_billing_portal_configurations(*, active : Bool? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, is_default : Bool? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_billing_portal_configurations(active: active, ending_before: ending_before, expand: expand, is_default: is_default, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_BILLING_PORTAL_CONFIGURATIONS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_BILLING_PORTAL_CONFIGURATIONS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_billing_portal_configurations(*, active : Bool? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, is_default : Bool? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_billing_portal_configurations ..." }
      end

      if client_side_validation
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_BILLING_PORTAL_CONFIGURATIONS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_BILLING_PORTAL_CONFIGURATIONS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/billing_portal/configurations"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["active"] = active.to_s if !active.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["is_default"] = is_default.to_s if !is_default.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_billing_portal_configurations",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a configuration that describes the functionality of the customer portal.</p>
    # @param configuration [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [BillingPortalConfiguration]
    def get_billing_portal_configurations_configuration(*, configuration : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_billing_portal_configurations_configuration_with_http_info(configuration: configuration, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves a configuration that describes the functionality of the customer portal.&lt;/p&gt;
    # @param configuration [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(BillingPortalConfiguration, Integer, Hash)>] BillingPortalConfiguration data, response status code and response headers
    def get_billing_portal_configurations_configuration_with_http_info(*, configuration : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_billing_portal_configurations_configuration(configuration: configuration, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_billing_portal_configurations_configuration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return BillingPortalConfiguration.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a configuration that describes the functionality of the customer portal.&lt;/p&gt;
    # @param configuration [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_billing_portal_configurations_configuration(*, configuration : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_billing_portal_configurations_configuration(configuration: configuration, expand: expand).execute(&block)
    end

    GET_BILLING_PORTAL_CONFIGURATIONS_CONFIGURATION_MAX_LENGTH_FOR_CONFIGURATION = 5000

    # @return Crest::Request
    def build_api_request_for_get_billing_portal_configurations_configuration(*, configuration : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_billing_portal_configurations_configuration ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"configuration\" is required and cannot be null") if configuration.nil?
        if _configuration = configuration
          OpenApi::PrimitiveValidator.validate_max_length("configuration", configuration.to_s.size, GET_BILLING_PORTAL_CONFIGURATIONS_CONFIGURATION_MAX_LENGTH_FOR_CONFIGURATION)
        end
      end

      # resource path
      local_var_path = "/v1/billing_portal/configurations/{configuration}".sub("{" + "configuration" + "}", URI.encode_path(configuration.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_billing_portal_configurations_configuration",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of charges you’ve previously created. The charges are returned in sorted order, with the most recent charges appearing first.</p>
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param customer [String?] Only return charges for the customer specified by this customer ID.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payment_intent [String?] Only return charges that were created by the PaymentIntent specified by this PaymentIntent ID.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param transfer_group [String?] Only return charges for this transfer group.
    # @return [ChargeList]
    def get_charges(*, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_intent : String? = nil, starting_after : String? = nil, transfer_group : String? = nil)
      data, _status_code, _headers = get_charges_with_http_info(created: created, customer: customer, ending_before: ending_before, expand: expand, limit: limit, payment_intent: payment_intent, starting_after: starting_after, transfer_group: transfer_group)
      data
    end

    # &lt;p&gt;Returns a list of charges you’ve previously created. The charges are returned in sorted order, with the most recent charges appearing first.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param customer [String?] Only return charges for the customer specified by this customer ID.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payment_intent [String?] Only return charges that were created by the PaymentIntent specified by this PaymentIntent ID.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param transfer_group [String?] Only return charges for this transfer group.
    # @return [Array<(ChargeList, Integer, Hash)>] ChargeList data, response status code and response headers
    def get_charges_with_http_info(*, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_intent : String? = nil, starting_after : String? = nil, transfer_group : String? = nil)
      request = build_api_request_for_get_charges(created: created, customer: customer, ending_before: ending_before, expand: expand, limit: limit, payment_intent: payment_intent, starting_after: starting_after, transfer_group: transfer_group)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_charges\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ChargeList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of charges you’ve previously created. The charges are returned in sorted order, with the most recent charges appearing first.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param customer [String?] Only return charges for the customer specified by this customer ID.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payment_intent [String?] Only return charges that were created by the PaymentIntent specified by this PaymentIntent ID.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param transfer_group [String?] Only return charges for this transfer group.
    # @return nil
    def get_charges(*, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_intent : String? = nil, starting_after : String? = nil, transfer_group : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_charges(created: created, customer: customer, ending_before: ending_before, expand: expand, limit: limit, payment_intent: payment_intent, starting_after: starting_after, transfer_group: transfer_group).execute(&block)
    end

    GET_CHARGES_MAX_LENGTH_FOR_CUSTOMER       = 5000
    GET_CHARGES_MAX_LENGTH_FOR_PAYMENT_INTENT = 5000
    GET_CHARGES_MAX_LENGTH_FOR_TRANSFER_GROUP = 5000

    # @return Crest::Request
    def build_api_request_for_get_charges(*, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_intent : String? = nil, starting_after : String? = nil, transfer_group : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_charges ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CHARGES_MAX_LENGTH_FOR_CUSTOMER)
        end

        if _payment_intent = payment_intent
          OpenApi::PrimitiveValidator.validate_max_length("payment_intent", payment_intent.to_s.size, GET_CHARGES_MAX_LENGTH_FOR_PAYMENT_INTENT)
        end

        if _transfer_group = transfer_group
          OpenApi::PrimitiveValidator.validate_max_length("transfer_group", transfer_group.to_s.size, GET_CHARGES_MAX_LENGTH_FOR_TRANSFER_GROUP)
        end
      end

      # resource path
      local_var_path = "/v1/charges"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["customer"] = customer.to_s if !customer.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["payment_intent"] = payment_intent.to_s if !payment_intent.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["transfer_group"] = transfer_group.to_s if !transfer_group.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_charges",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of a charge that has previously been created. Supply the unique charge ID that was returned from your previous request, and Stripe will return the corresponding charge information. The same information is returned when creating or refunding the charge.</p>
    # @param charge [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Charge]
    def get_charges_charge(*, charge : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_charges_charge_with_http_info(charge: charge, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of a charge that has previously been created. Supply the unique charge ID that was returned from your previous request, and Stripe will return the corresponding charge information. The same information is returned when creating or refunding the charge.&lt;/p&gt;
    # @param charge [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Charge, Integer, Hash)>] Charge data, response status code and response headers
    def get_charges_charge_with_http_info(*, charge : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_charges_charge(charge: charge, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_charges_charge\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Charge.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of a charge that has previously been created. Supply the unique charge ID that was returned from your previous request, and Stripe will return the corresponding charge information. The same information is returned when creating or refunding the charge.&lt;/p&gt;
    # @param charge [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_charges_charge(*, charge : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_charges_charge(charge: charge, expand: expand).execute(&block)
    end

    GET_CHARGES_CHARGE_MAX_LENGTH_FOR_CHARGE = 5000

    # @return Crest::Request
    def build_api_request_for_get_charges_charge(*, charge : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_charges_charge ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"charge\" is required and cannot be null") if charge.nil?
        if _charge = charge
          OpenApi::PrimitiveValidator.validate_max_length("charge", charge.to_s.size, GET_CHARGES_CHARGE_MAX_LENGTH_FOR_CHARGE)
        end
      end

      # resource path
      local_var_path = "/v1/charges/{charge}".sub("{" + "charge" + "}", URI.encode_path(charge.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_charges_charge",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieve a dispute for a specified charge.</p>
    # @param charge [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Dispute]
    def get_charges_charge_dispute(*, charge : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_charges_charge_dispute_with_http_info(charge: charge, expand: expand)
      data
    end

    # &lt;p&gt;Retrieve a dispute for a specified charge.&lt;/p&gt;
    # @param charge [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Dispute, Integer, Hash)>] Dispute data, response status code and response headers
    def get_charges_charge_dispute_with_http_info(*, charge : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_charges_charge_dispute(charge: charge, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_charges_charge_dispute\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Dispute.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieve a dispute for a specified charge.&lt;/p&gt;
    # @param charge [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_charges_charge_dispute(*, charge : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_charges_charge_dispute(charge: charge, expand: expand).execute(&block)
    end

    GET_CHARGES_CHARGE_DISPUTE_MAX_LENGTH_FOR_CHARGE = 5000

    # @return Crest::Request
    def build_api_request_for_get_charges_charge_dispute(*, charge : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_charges_charge_dispute ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"charge\" is required and cannot be null") if charge.nil?
        if _charge = charge
          OpenApi::PrimitiveValidator.validate_max_length("charge", charge.to_s.size, GET_CHARGES_CHARGE_DISPUTE_MAX_LENGTH_FOR_CHARGE)
        end
      end

      # resource path
      local_var_path = "/v1/charges/{charge}/dispute".sub("{" + "charge" + "}", URI.encode_path(charge.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_charges_charge_dispute",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>You can see a list of the refunds belonging to a specific charge. Note that the 10 most recent refunds are always available by default on the charge object. If you need more than those 10, you can use this API method and the <code>limit</code> and <code>starting_after</code> parameters to page through additional refunds.</p>
    # @param charge [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [RefundList]
    def get_charges_charge_refunds(*, charge : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_charges_charge_refunds_with_http_info(charge: charge, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;You can see a list of the refunds belonging to a specific charge. Note that the 10 most recent refunds are always available by default on the charge object. If you need more than those 10, you can use this API method and the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;starting_after&lt;/code&gt; parameters to page through additional refunds.&lt;/p&gt;
    # @param charge [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(RefundList, Integer, Hash)>] RefundList data, response status code and response headers
    def get_charges_charge_refunds_with_http_info(*, charge : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_charges_charge_refunds(charge: charge, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_charges_charge_refunds\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return RefundList.from_json(data), status_code, headers
    end

    # &lt;p&gt;You can see a list of the refunds belonging to a specific charge. Note that the 10 most recent refunds are always available by default on the charge object. If you need more than those 10, you can use this API method and the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;starting_after&lt;/code&gt; parameters to page through additional refunds.&lt;/p&gt;
    # @param charge [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_charges_charge_refunds(*, charge : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_charges_charge_refunds(charge: charge, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_get_charges_charge_refunds(*, charge : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_charges_charge_refunds ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"charge\" is required and cannot be null") if charge.nil?
      end

      # resource path
      local_var_path = "/v1/charges/{charge}/refunds".sub("{" + "charge" + "}", URI.encode_path(charge.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_charges_charge_refunds",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an existing refund.</p>
    # @param charge [String?]
    # @param refund [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Refund]
    def get_charges_charge_refunds_refund(*, charge : String? = nil, refund : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_charges_charge_refunds_refund_with_http_info(charge: charge, refund: refund, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an existing refund.&lt;/p&gt;
    # @param charge [String?]
    # @param refund [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Refund, Integer, Hash)>] Refund data, response status code and response headers
    def get_charges_charge_refunds_refund_with_http_info(*, charge : String? = nil, refund : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_charges_charge_refunds_refund(charge: charge, refund: refund, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_charges_charge_refunds_refund\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Refund.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an existing refund.&lt;/p&gt;
    # @param charge [String?]
    # @param refund [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_charges_charge_refunds_refund(*, charge : String? = nil, refund : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_charges_charge_refunds_refund(charge: charge, refund: refund, expand: expand).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_get_charges_charge_refunds_refund(*, charge : String? = nil, refund : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_charges_charge_refunds_refund ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"charge\" is required and cannot be null") if charge.nil?

        raise ArgumentError.new("\"refund\" is required and cannot be null") if refund.nil?
      end

      # resource path
      local_var_path = "/v1/charges/{charge}/refunds/{refund}".sub("{" + "charge" + "}", URI.encode_path(charge.to_s)).sub("{" + "refund" + "}", URI.encode_path(refund.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_charges_charge_refunds_refund",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Search for charges you’ve previously created using Stripe’s <a href=\"/docs/search#search-query-language\">Search Query Language</a>. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.</p>
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for charges](https://stripe.com/docs/search#query-fields-for-charges).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return [SearchResult]
    def get_charges_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil)
      data, _status_code, _headers = get_charges_search_with_http_info(query: query, expand: expand, limit: limit, page: page)
      data
    end

    # &lt;p&gt;Search for charges you’ve previously created using Stripe’s &lt;a href&#x3D;\&quot;/docs/search#search-query-language\&quot;&gt;Search Query Language&lt;/a&gt;. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.&lt;/p&gt;
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for charges](https://stripe.com/docs/search#query-fields-for-charges).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return [Array<(SearchResult, Integer, Hash)>] SearchResult data, response status code and response headers
    def get_charges_search_with_http_info(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil)
      request = build_api_request_for_get_charges_search(query: query, expand: expand, limit: limit, page: page)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_charges_search\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SearchResult.from_json(data), status_code, headers
    end

    # &lt;p&gt;Search for charges you’ve previously created using Stripe’s &lt;a href&#x3D;\&quot;/docs/search#search-query-language\&quot;&gt;Search Query Language&lt;/a&gt;. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.&lt;/p&gt;
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for charges](https://stripe.com/docs/search#query-fields-for-charges).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return nil
    def get_charges_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_charges_search(query: query, expand: expand, limit: limit, page: page).execute(&block)
    end

    GET_CHARGES_SEARCH_MAX_LENGTH_FOR_QUERY = 5000
    GET_CHARGES_SEARCH_MAX_LENGTH_FOR_PAGE  = 5000

    # @return Crest::Request
    def build_api_request_for_get_charges_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_charges_search ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"query\" is required and cannot be null") if query.nil?
        if _query = query
          OpenApi::PrimitiveValidator.validate_max_length("query", query.to_s.size, GET_CHARGES_SEARCH_MAX_LENGTH_FOR_QUERY)
        end

        if _page = page
          OpenApi::PrimitiveValidator.validate_max_length("page", page.to_s.size, GET_CHARGES_SEARCH_MAX_LENGTH_FOR_PAGE)
        end
      end

      # resource path
      local_var_path = "/v1/charges/search"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["page"] = page.to_s if !page.nil?
      query_params["query"] = query.to_s if !query.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_charges_search",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of Checkout Sessions.</p>
    # @optional @param customer [String?] Only return the Checkout Sessions for the Customer specified.
    # @optional @param customer_details [Stripe::CustomerDetailsParams?] Only return the Checkout Sessions for the Customer details specified.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payment_intent [String?] Only return the Checkout Session for the PaymentIntent specified.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param subscription [String?] Only return the Checkout Session for the subscription specified.
    # @return [PaymentPagesCheckoutSessionList]
    def get_checkout_sessions(*, customer : String? = nil, customer_details : Stripe::CustomerDetailsParams? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_intent : String? = nil, starting_after : String? = nil, subscription : String? = nil)
      data, _status_code, _headers = get_checkout_sessions_with_http_info(customer: customer, customer_details: customer_details, ending_before: ending_before, expand: expand, limit: limit, payment_intent: payment_intent, starting_after: starting_after, subscription: subscription)
      data
    end

    # &lt;p&gt;Returns a list of Checkout Sessions.&lt;/p&gt;
    # @optional @param customer [String?] Only return the Checkout Sessions for the Customer specified.
    # @optional @param customer_details [Stripe::CustomerDetailsParams?] Only return the Checkout Sessions for the Customer details specified.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payment_intent [String?] Only return the Checkout Session for the PaymentIntent specified.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param subscription [String?] Only return the Checkout Session for the subscription specified.
    # @return [Array<(PaymentPagesCheckoutSessionList, Integer, Hash)>] PaymentPagesCheckoutSessionList data, response status code and response headers
    def get_checkout_sessions_with_http_info(*, customer : String? = nil, customer_details : Stripe::CustomerDetailsParams? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_intent : String? = nil, starting_after : String? = nil, subscription : String? = nil)
      request = build_api_request_for_get_checkout_sessions(customer: customer, customer_details: customer_details, ending_before: ending_before, expand: expand, limit: limit, payment_intent: payment_intent, starting_after: starting_after, subscription: subscription)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_checkout_sessions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentPagesCheckoutSessionList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of Checkout Sessions.&lt;/p&gt;
    # @optional @param customer [String?] Only return the Checkout Sessions for the Customer specified.
    # @optional @param customer_details [Stripe::CustomerDetailsParams?] Only return the Checkout Sessions for the Customer details specified.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payment_intent [String?] Only return the Checkout Session for the PaymentIntent specified.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param subscription [String?] Only return the Checkout Session for the subscription specified.
    # @return nil
    def get_checkout_sessions(*, customer : String? = nil, customer_details : Stripe::CustomerDetailsParams? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_intent : String? = nil, starting_after : String? = nil, subscription : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_checkout_sessions(customer: customer, customer_details: customer_details, ending_before: ending_before, expand: expand, limit: limit, payment_intent: payment_intent, starting_after: starting_after, subscription: subscription).execute(&block)
    end

    GET_CHECKOUT_SESSIONS_MAX_LENGTH_FOR_CUSTOMER       = 5000
    GET_CHECKOUT_SESSIONS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_CHECKOUT_SESSIONS_MAX_LENGTH_FOR_PAYMENT_INTENT = 5000
    GET_CHECKOUT_SESSIONS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_CHECKOUT_SESSIONS_MAX_LENGTH_FOR_SUBSCRIPTION   = 5000

    # @return Crest::Request
    def build_api_request_for_get_checkout_sessions(*, customer : String? = nil, customer_details : Stripe::CustomerDetailsParams? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_intent : String? = nil, starting_after : String? = nil, subscription : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_checkout_sessions ..." }
      end

      if client_side_validation
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CHECKOUT_SESSIONS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _customer_details = customer_details
          _customer_details.validate if _customer_details.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_CHECKOUT_SESSIONS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _payment_intent = payment_intent
          OpenApi::PrimitiveValidator.validate_max_length("payment_intent", payment_intent.to_s.size, GET_CHECKOUT_SESSIONS_MAX_LENGTH_FOR_PAYMENT_INTENT)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_CHECKOUT_SESSIONS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _subscription = subscription
          OpenApi::PrimitiveValidator.validate_max_length("subscription", subscription.to_s.size, GET_CHECKOUT_SESSIONS_MAX_LENGTH_FOR_SUBSCRIPTION)
        end
      end

      # resource path
      local_var_path = "/v1/checkout/sessions"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["customer"] = customer.to_s if !customer.nil?
      query_params["customer_details"] = customer_details.to_s if !customer_details.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["payment_intent"] = payment_intent.to_s if !payment_intent.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["subscription"] = subscription.to_s if !subscription.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_checkout_sessions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a Session object.</p>
    # @param session [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [CheckoutSession]
    def get_checkout_sessions_session(*, session : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_checkout_sessions_session_with_http_info(session: session, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves a Session object.&lt;/p&gt;
    # @param session [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(CheckoutSession, Integer, Hash)>] CheckoutSession data, response status code and response headers
    def get_checkout_sessions_session_with_http_info(*, session : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_checkout_sessions_session(session: session, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_checkout_sessions_session\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CheckoutSession.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a Session object.&lt;/p&gt;
    # @param session [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_checkout_sessions_session(*, session : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_checkout_sessions_session(session: session, expand: expand).execute(&block)
    end

    GET_CHECKOUT_SESSIONS_SESSION_MAX_LENGTH_FOR_SESSION = 66

    # @return Crest::Request
    def build_api_request_for_get_checkout_sessions_session(*, session : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_checkout_sessions_session ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"session\" is required and cannot be null") if session.nil?
        if _session = session
          OpenApi::PrimitiveValidator.validate_max_length("session", session.to_s.size, GET_CHECKOUT_SESSIONS_SESSION_MAX_LENGTH_FOR_SESSION)
        end
      end

      # resource path
      local_var_path = "/v1/checkout/sessions/{session}".sub("{" + "session" + "}", URI.encode_path(session.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_checkout_sessions_session",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>When retrieving a Checkout Session, there is an includable <strong>line_items</strong> property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.</p>
    # @param session [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [PaymentPagesCheckoutSessionListLineItems]
    def get_checkout_sessions_session_line_items(*, session : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_checkout_sessions_session_line_items_with_http_info(session: session, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;When retrieving a Checkout Session, there is an includable &lt;strong&gt;line_items&lt;/strong&gt; property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.&lt;/p&gt;
    # @param session [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(PaymentPagesCheckoutSessionListLineItems, Integer, Hash)>] PaymentPagesCheckoutSessionListLineItems data, response status code and response headers
    def get_checkout_sessions_session_line_items_with_http_info(*, session : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_checkout_sessions_session_line_items(session: session, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_checkout_sessions_session_line_items\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentPagesCheckoutSessionListLineItems.from_json(data), status_code, headers
    end

    # &lt;p&gt;When retrieving a Checkout Session, there is an includable &lt;strong&gt;line_items&lt;/strong&gt; property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.&lt;/p&gt;
    # @param session [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_checkout_sessions_session_line_items(*, session : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_checkout_sessions_session_line_items(session: session, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_CHECKOUT_SESSIONS_SESSION_LINE_ITEMS_MAX_LENGTH_FOR_SESSION        = 5000
    GET_CHECKOUT_SESSIONS_SESSION_LINE_ITEMS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_CHECKOUT_SESSIONS_SESSION_LINE_ITEMS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_checkout_sessions_session_line_items(*, session : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_checkout_sessions_session_line_items ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"session\" is required and cannot be null") if session.nil?
        if _session = session
          OpenApi::PrimitiveValidator.validate_max_length("session", session.to_s.size, GET_CHECKOUT_SESSIONS_SESSION_LINE_ITEMS_MAX_LENGTH_FOR_SESSION)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_CHECKOUT_SESSIONS_SESSION_LINE_ITEMS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_CHECKOUT_SESSIONS_SESSION_LINE_ITEMS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/checkout/sessions/{session}/line_items".sub("{" + "session" + "}", URI.encode_path(session.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_checkout_sessions_session_line_items",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Lists all Country Spec objects available in the API.</p>
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [CountrySpecList]
    def get_country_specs(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_country_specs_with_http_info(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Lists all Country Spec objects available in the API.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(CountrySpecList, Integer, Hash)>] CountrySpecList data, response status code and response headers
    def get_country_specs_with_http_info(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_country_specs(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_country_specs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CountrySpecList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Lists all Country Spec objects available in the API.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_country_specs(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_country_specs(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_COUNTRY_SPECS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_COUNTRY_SPECS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_country_specs(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_country_specs ..." }
      end

      if client_side_validation
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_COUNTRY_SPECS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_COUNTRY_SPECS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/country_specs"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_country_specs",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a Country Spec for a given Country code.</p>
    # @param country [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [CountrySpec]
    def get_country_specs_country(*, country : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_country_specs_country_with_http_info(country: country, expand: expand)
      data
    end

    # &lt;p&gt;Returns a Country Spec for a given Country code.&lt;/p&gt;
    # @param country [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(CountrySpec, Integer, Hash)>] CountrySpec data, response status code and response headers
    def get_country_specs_country_with_http_info(*, country : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_country_specs_country(country: country, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_country_specs_country\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CountrySpec.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a Country Spec for a given Country code.&lt;/p&gt;
    # @param country [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_country_specs_country(*, country : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_country_specs_country(country: country, expand: expand).execute(&block)
    end

    GET_COUNTRY_SPECS_COUNTRY_MAX_LENGTH_FOR_COUNTRY = 5000

    # @return Crest::Request
    def build_api_request_for_get_country_specs_country(*, country : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_country_specs_country ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"country\" is required and cannot be null") if country.nil?
        if _country = country
          OpenApi::PrimitiveValidator.validate_max_length("country", country.to_s.size, GET_COUNTRY_SPECS_COUNTRY_MAX_LENGTH_FOR_COUNTRY)
        end
      end

      # resource path
      local_var_path = "/v1/country_specs/{country}".sub("{" + "country" + "}", URI.encode_path(country.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_country_specs_country",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of your coupons.</p>
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [CouponsResourceCouponList]
    def get_coupons(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_coupons_with_http_info(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of your coupons.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(CouponsResourceCouponList, Integer, Hash)>] CouponsResourceCouponList data, response status code and response headers
    def get_coupons_with_http_info(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_coupons(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_coupons\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CouponsResourceCouponList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of your coupons.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_coupons(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_coupons(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_COUPONS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_COUPONS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_coupons(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_coupons ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_COUPONS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_COUPONS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/coupons"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_coupons",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the coupon with the given ID.</p>
    # @param coupon [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Coupon]
    def get_coupons_coupon(*, coupon : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_coupons_coupon_with_http_info(coupon: coupon, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the coupon with the given ID.&lt;/p&gt;
    # @param coupon [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Coupon, Integer, Hash)>] Coupon data, response status code and response headers
    def get_coupons_coupon_with_http_info(*, coupon : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_coupons_coupon(coupon: coupon, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_coupons_coupon\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Coupon.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the coupon with the given ID.&lt;/p&gt;
    # @param coupon [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_coupons_coupon(*, coupon : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_coupons_coupon(coupon: coupon, expand: expand).execute(&block)
    end

    GET_COUPONS_COUPON_MAX_LENGTH_FOR_COUPON = 5000

    # @return Crest::Request
    def build_api_request_for_get_coupons_coupon(*, coupon : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_coupons_coupon ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"coupon\" is required and cannot be null") if coupon.nil?
        if _coupon = coupon
          OpenApi::PrimitiveValidator.validate_max_length("coupon", coupon.to_s.size, GET_COUPONS_COUPON_MAX_LENGTH_FOR_COUPON)
        end
      end

      # resource path
      local_var_path = "/v1/coupons/{coupon}".sub("{" + "coupon" + "}", URI.encode_path(coupon.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_coupons_coupon",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of credit notes.</p>
    # @optional @param customer [String?] Only return credit notes for the customer specified by this customer ID.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param invoice [String?] Only return credit notes for the invoice specified by this invoice ID.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [CreditNotesList]
    def get_credit_notes(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, invoice : String? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_credit_notes_with_http_info(customer: customer, ending_before: ending_before, expand: expand, invoice: invoice, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of credit notes.&lt;/p&gt;
    # @optional @param customer [String?] Only return credit notes for the customer specified by this customer ID.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param invoice [String?] Only return credit notes for the invoice specified by this invoice ID.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(CreditNotesList, Integer, Hash)>] CreditNotesList data, response status code and response headers
    def get_credit_notes_with_http_info(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, invoice : String? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_credit_notes(customer: customer, ending_before: ending_before, expand: expand, invoice: invoice, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_credit_notes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CreditNotesList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of credit notes.&lt;/p&gt;
    # @optional @param customer [String?] Only return credit notes for the customer specified by this customer ID.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param invoice [String?] Only return credit notes for the invoice specified by this invoice ID.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_credit_notes(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, invoice : String? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_credit_notes(customer: customer, ending_before: ending_before, expand: expand, invoice: invoice, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_CREDIT_NOTES_MAX_LENGTH_FOR_CUSTOMER       = 5000
    GET_CREDIT_NOTES_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_CREDIT_NOTES_MAX_LENGTH_FOR_INVOICE        = 5000
    GET_CREDIT_NOTES_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_credit_notes(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, invoice : String? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_credit_notes ..." }
      end

      if client_side_validation
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CREDIT_NOTES_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_CREDIT_NOTES_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _invoice = invoice
          OpenApi::PrimitiveValidator.validate_max_length("invoice", invoice.to_s.size, GET_CREDIT_NOTES_MAX_LENGTH_FOR_INVOICE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_CREDIT_NOTES_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/credit_notes"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["customer"] = customer.to_s if !customer.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["invoice"] = invoice.to_s if !invoice.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_credit_notes",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>When retrieving a credit note, you’ll get a <strong>lines</strong> property containing the the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.</p>
    # @param credit_note [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [CreditNoteLinesList]
    def get_credit_notes_credit_note_lines(*, credit_note : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_credit_notes_credit_note_lines_with_http_info(credit_note: credit_note, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;When retrieving a credit note, you’ll get a &lt;strong&gt;lines&lt;/strong&gt; property containing the the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.&lt;/p&gt;
    # @param credit_note [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(CreditNoteLinesList, Integer, Hash)>] CreditNoteLinesList data, response status code and response headers
    def get_credit_notes_credit_note_lines_with_http_info(*, credit_note : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_credit_notes_credit_note_lines(credit_note: credit_note, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_credit_notes_credit_note_lines\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CreditNoteLinesList.from_json(data), status_code, headers
    end

    # &lt;p&gt;When retrieving a credit note, you’ll get a &lt;strong&gt;lines&lt;/strong&gt; property containing the the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.&lt;/p&gt;
    # @param credit_note [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_credit_notes_credit_note_lines(*, credit_note : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_credit_notes_credit_note_lines(credit_note: credit_note, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_CREDIT_NOTES_CREDIT_NOTE_LINES_MAX_LENGTH_FOR_CREDIT_NOTE    = 5000
    GET_CREDIT_NOTES_CREDIT_NOTE_LINES_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_CREDIT_NOTES_CREDIT_NOTE_LINES_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_credit_notes_credit_note_lines(*, credit_note : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_credit_notes_credit_note_lines ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"credit_note\" is required and cannot be null") if credit_note.nil?
        if _credit_note = credit_note
          OpenApi::PrimitiveValidator.validate_max_length("credit_note", credit_note.to_s.size, GET_CREDIT_NOTES_CREDIT_NOTE_LINES_MAX_LENGTH_FOR_CREDIT_NOTE)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_CREDIT_NOTES_CREDIT_NOTE_LINES_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_CREDIT_NOTES_CREDIT_NOTE_LINES_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/credit_notes/{credit_note}/lines".sub("{" + "credit_note" + "}", URI.encode_path(credit_note.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_credit_notes_credit_note_lines",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the credit note object with the given identifier.</p>
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [CreditNote]
    def get_credit_notes_id(*, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_credit_notes_id_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the credit note object with the given identifier.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(CreditNote, Integer, Hash)>] CreditNote data, response status code and response headers
    def get_credit_notes_id_with_http_info(*, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_credit_notes_id(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_credit_notes_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CreditNote.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the credit note object with the given identifier.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_credit_notes_id(*, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_credit_notes_id(id: id, expand: expand).execute(&block)
    end

    GET_CREDIT_NOTES_ID_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_get_credit_notes_id(*, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_credit_notes_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_CREDIT_NOTES_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/credit_notes/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_credit_notes_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Get a preview of a credit note without creating it.</p>
    # @param invoice [String?] ID of the invoice.
    # @optional @param amount [Int64?] The integer amount in cents (or local equivalent) representing the total amount of the credit note.
    # @optional @param credit_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount to credit the customer's balance, which will be automatically applied to their next invoice.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param lines [Array(Array(CreditNoteLineItemParams))?] Line items that make up the credit note.
    # @optional @param memo [String?] The credit note's memo appears on the credit note PDF.
    # @optional @param metadata [Hash(String, Hash(String, String))?] Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
    # @optional @param out_of_band_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount that is credited outside of Stripe.
    # @optional @param reason [String?] Reason for issuing this credit note, one of `duplicate`, `fraudulent`, `order_change`, or `product_unsatisfactory`
    # @optional @param refund [String?] ID of an existing refund to link this credit note to.
    # @optional @param refund_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount to refund. If set, a refund will be created for the charge associated with the invoice.
    # @return [CreditNote]
    def get_credit_notes_preview(*, invoice : String? = nil, amount : Int64? = nil, credit_amount : Int64? = nil, expand : Array(Array(String))? = nil, lines : Array(Array(CreditNoteLineItemParams))? = nil, memo : String? = nil, metadata : Hash(String, Hash(String, String))? = nil, out_of_band_amount : Int64? = nil, reason : String? = nil, refund : String? = nil, refund_amount : Int64? = nil)
      data, _status_code, _headers = get_credit_notes_preview_with_http_info(invoice: invoice, amount: amount, credit_amount: credit_amount, expand: expand, lines: lines, memo: memo, metadata: metadata, out_of_band_amount: out_of_band_amount, reason: reason, refund: refund, refund_amount: refund_amount)
      data
    end

    # &lt;p&gt;Get a preview of a credit note without creating it.&lt;/p&gt;
    # @param invoice [String?] ID of the invoice.
    # @optional @param amount [Int64?] The integer amount in cents (or local equivalent) representing the total amount of the credit note.
    # @optional @param credit_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount to credit the customer's balance, which will be automatically applied to their next invoice.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param lines [Array(Array(CreditNoteLineItemParams))?] Line items that make up the credit note.
    # @optional @param memo [String?] The credit note's memo appears on the credit note PDF.
    # @optional @param metadata [Hash(String, Hash(String, String))?] Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
    # @optional @param out_of_band_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount that is credited outside of Stripe.
    # @optional @param reason [String?] Reason for issuing this credit note, one of `duplicate`, `fraudulent`, `order_change`, or `product_unsatisfactory`
    # @optional @param refund [String?] ID of an existing refund to link this credit note to.
    # @optional @param refund_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount to refund. If set, a refund will be created for the charge associated with the invoice.
    # @return [Array<(CreditNote, Integer, Hash)>] CreditNote data, response status code and response headers
    def get_credit_notes_preview_with_http_info(*, invoice : String? = nil, amount : Int64? = nil, credit_amount : Int64? = nil, expand : Array(Array(String))? = nil, lines : Array(Array(CreditNoteLineItemParams))? = nil, memo : String? = nil, metadata : Hash(String, Hash(String, String))? = nil, out_of_band_amount : Int64? = nil, reason : String? = nil, refund : String? = nil, refund_amount : Int64? = nil)
      request = build_api_request_for_get_credit_notes_preview(invoice: invoice, amount: amount, credit_amount: credit_amount, expand: expand, lines: lines, memo: memo, metadata: metadata, out_of_band_amount: out_of_band_amount, reason: reason, refund: refund, refund_amount: refund_amount)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_credit_notes_preview\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CreditNote.from_json(data), status_code, headers
    end

    # &lt;p&gt;Get a preview of a credit note without creating it.&lt;/p&gt;
    # @param invoice [String?] ID of the invoice.
    # @optional @param amount [Int64?] The integer amount in cents (or local equivalent) representing the total amount of the credit note.
    # @optional @param credit_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount to credit the customer's balance, which will be automatically applied to their next invoice.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param lines [Array(Array(CreditNoteLineItemParams))?] Line items that make up the credit note.
    # @optional @param memo [String?] The credit note's memo appears on the credit note PDF.
    # @optional @param metadata [Hash(String, Hash(String, String))?] Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
    # @optional @param out_of_band_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount that is credited outside of Stripe.
    # @optional @param reason [String?] Reason for issuing this credit note, one of `duplicate`, `fraudulent`, `order_change`, or `product_unsatisfactory`
    # @optional @param refund [String?] ID of an existing refund to link this credit note to.
    # @optional @param refund_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount to refund. If set, a refund will be created for the charge associated with the invoice.
    # @return nil
    def get_credit_notes_preview(*, invoice : String? = nil, amount : Int64? = nil, credit_amount : Int64? = nil, expand : Array(Array(String))? = nil, lines : Array(Array(CreditNoteLineItemParams))? = nil, memo : String? = nil, metadata : Hash(String, Hash(String, String))? = nil, out_of_band_amount : Int64? = nil, reason : String? = nil, refund : String? = nil, refund_amount : Int64? = nil, &block : Crest::Response ->)
      build_api_request_for_get_credit_notes_preview(invoice: invoice, amount: amount, credit_amount: credit_amount, expand: expand, lines: lines, memo: memo, metadata: metadata, out_of_band_amount: out_of_band_amount, reason: reason, refund: refund, refund_amount: refund_amount).execute(&block)
    end

    GET_CREDIT_NOTES_PREVIEW_MAX_LENGTH_FOR_INVOICE  = 5000
    GET_CREDIT_NOTES_PREVIEW_MAX_LENGTH_FOR_MEMO     = 5000
    GET_CREDIT_NOTES_PREVIEW_VALID_VALUES_FOR_REASON = StaticArray["duplicate", "fraudulent", "order_change", "product_unsatisfactory"]

    # @return Crest::Request
    def build_api_request_for_get_credit_notes_preview(*, invoice : String? = nil, amount : Int64? = nil, credit_amount : Int64? = nil, expand : Array(Array(String))? = nil, lines : Array(Array(CreditNoteLineItemParams))? = nil, memo : String? = nil, metadata : Hash(String, Hash(String, String))? = nil, out_of_band_amount : Int64? = nil, reason : String? = nil, refund : String? = nil, refund_amount : Int64? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_credit_notes_preview ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"invoice\" is required and cannot be null") if invoice.nil?
        if _invoice = invoice
          OpenApi::PrimitiveValidator.validate_max_length("invoice", invoice.to_s.size, GET_CREDIT_NOTES_PREVIEW_MAX_LENGTH_FOR_INVOICE)
        end

        if _memo = memo
          OpenApi::PrimitiveValidator.validate_max_length("memo", memo.to_s.size, GET_CREDIT_NOTES_PREVIEW_MAX_LENGTH_FOR_MEMO)
        end

        if _reason = reason
          OpenApi::EnumValidator.validate("reason", _reason, GET_CREDIT_NOTES_PREVIEW_VALID_VALUES_FOR_REASON)
        end
      end

      # resource path
      local_var_path = "/v1/credit_notes/preview"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["amount"] = amount.to_s if !amount.nil?
      query_params["credit_amount"] = credit_amount.to_s if !credit_amount.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["invoice"] = invoice.to_s if !invoice.nil?
      query_params["lines"] = @api_client.build_collection_param(lines, "csv") if !lines.nil? && !lines.empty?
      query_params["memo"] = memo.to_s if !memo.nil?
      query_params["metadata"] = metadata.to_s if !metadata.nil?
      query_params["out_of_band_amount"] = out_of_band_amount.to_s if !out_of_band_amount.nil?
      query_params["reason"] = reason.to_s if !reason.nil?
      query_params["refund"] = refund.to_s if !refund.nil?
      query_params["refund_amount"] = refund_amount.to_s if !refund_amount.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_credit_notes_preview",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>When retrieving a credit note preview, you’ll get a <strong>lines</strong> property containing the first handful of those items. This URL you can retrieve the full (paginated) list of line items.</p>
    # @param invoice [String?] ID of the invoice.
    # @optional @param amount [Int64?] The integer amount in cents (or local equivalent) representing the total amount of the credit note.
    # @optional @param credit_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount to credit the customer's balance, which will be automatically applied to their next invoice.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param lines [Array(Array(CreditNoteLineItemParams))?] Line items that make up the credit note.
    # @optional @param memo [String?] The credit note's memo appears on the credit note PDF.
    # @optional @param metadata [Hash(String, Hash(String, String))?] Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
    # @optional @param out_of_band_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount that is credited outside of Stripe.
    # @optional @param reason [String?] Reason for issuing this credit note, one of `duplicate`, `fraudulent`, `order_change`, or `product_unsatisfactory`
    # @optional @param refund [String?] ID of an existing refund to link this credit note to.
    # @optional @param refund_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount to refund. If set, a refund will be created for the charge associated with the invoice.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [CreditNoteLinesList]
    def get_credit_notes_preview_lines(*, invoice : String? = nil, amount : Int64? = nil, credit_amount : Int64? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, lines : Array(Array(CreditNoteLineItemParams))? = nil, memo : String? = nil, metadata : Hash(String, Hash(String, String))? = nil, out_of_band_amount : Int64? = nil, reason : String? = nil, refund : String? = nil, refund_amount : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_credit_notes_preview_lines_with_http_info(invoice: invoice, amount: amount, credit_amount: credit_amount, ending_before: ending_before, expand: expand, limit: limit, lines: lines, memo: memo, metadata: metadata, out_of_band_amount: out_of_band_amount, reason: reason, refund: refund, refund_amount: refund_amount, starting_after: starting_after)
      data
    end

    # &lt;p&gt;When retrieving a credit note preview, you’ll get a &lt;strong&gt;lines&lt;/strong&gt; property containing the first handful of those items. This URL you can retrieve the full (paginated) list of line items.&lt;/p&gt;
    # @param invoice [String?] ID of the invoice.
    # @optional @param amount [Int64?] The integer amount in cents (or local equivalent) representing the total amount of the credit note.
    # @optional @param credit_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount to credit the customer's balance, which will be automatically applied to their next invoice.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param lines [Array(Array(CreditNoteLineItemParams))?] Line items that make up the credit note.
    # @optional @param memo [String?] The credit note's memo appears on the credit note PDF.
    # @optional @param metadata [Hash(String, Hash(String, String))?] Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
    # @optional @param out_of_band_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount that is credited outside of Stripe.
    # @optional @param reason [String?] Reason for issuing this credit note, one of `duplicate`, `fraudulent`, `order_change`, or `product_unsatisfactory`
    # @optional @param refund [String?] ID of an existing refund to link this credit note to.
    # @optional @param refund_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount to refund. If set, a refund will be created for the charge associated with the invoice.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(CreditNoteLinesList, Integer, Hash)>] CreditNoteLinesList data, response status code and response headers
    def get_credit_notes_preview_lines_with_http_info(*, invoice : String? = nil, amount : Int64? = nil, credit_amount : Int64? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, lines : Array(Array(CreditNoteLineItemParams))? = nil, memo : String? = nil, metadata : Hash(String, Hash(String, String))? = nil, out_of_band_amount : Int64? = nil, reason : String? = nil, refund : String? = nil, refund_amount : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_credit_notes_preview_lines(invoice: invoice, amount: amount, credit_amount: credit_amount, ending_before: ending_before, expand: expand, limit: limit, lines: lines, memo: memo, metadata: metadata, out_of_band_amount: out_of_band_amount, reason: reason, refund: refund, refund_amount: refund_amount, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_credit_notes_preview_lines\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CreditNoteLinesList.from_json(data), status_code, headers
    end

    # &lt;p&gt;When retrieving a credit note preview, you’ll get a &lt;strong&gt;lines&lt;/strong&gt; property containing the first handful of those items. This URL you can retrieve the full (paginated) list of line items.&lt;/p&gt;
    # @param invoice [String?] ID of the invoice.
    # @optional @param amount [Int64?] The integer amount in cents (or local equivalent) representing the total amount of the credit note.
    # @optional @param credit_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount to credit the customer's balance, which will be automatically applied to their next invoice.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param lines [Array(Array(CreditNoteLineItemParams))?] Line items that make up the credit note.
    # @optional @param memo [String?] The credit note's memo appears on the credit note PDF.
    # @optional @param metadata [Hash(String, Hash(String, String))?] Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
    # @optional @param out_of_band_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount that is credited outside of Stripe.
    # @optional @param reason [String?] Reason for issuing this credit note, one of `duplicate`, `fraudulent`, `order_change`, or `product_unsatisfactory`
    # @optional @param refund [String?] ID of an existing refund to link this credit note to.
    # @optional @param refund_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount to refund. If set, a refund will be created for the charge associated with the invoice.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_credit_notes_preview_lines(*, invoice : String? = nil, amount : Int64? = nil, credit_amount : Int64? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, lines : Array(Array(CreditNoteLineItemParams))? = nil, memo : String? = nil, metadata : Hash(String, Hash(String, String))? = nil, out_of_band_amount : Int64? = nil, reason : String? = nil, refund : String? = nil, refund_amount : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_credit_notes_preview_lines(invoice: invoice, amount: amount, credit_amount: credit_amount, ending_before: ending_before, expand: expand, limit: limit, lines: lines, memo: memo, metadata: metadata, out_of_band_amount: out_of_band_amount, reason: reason, refund: refund, refund_amount: refund_amount, starting_after: starting_after).execute(&block)
    end

    GET_CREDIT_NOTES_PREVIEW_LINES_MAX_LENGTH_FOR_INVOICE        = 5000
    GET_CREDIT_NOTES_PREVIEW_LINES_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_CREDIT_NOTES_PREVIEW_LINES_MAX_LENGTH_FOR_MEMO           = 5000
    GET_CREDIT_NOTES_PREVIEW_LINES_VALID_VALUES_FOR_REASON       = StaticArray["duplicate", "fraudulent", "order_change", "product_unsatisfactory"]
    GET_CREDIT_NOTES_PREVIEW_LINES_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_credit_notes_preview_lines(*, invoice : String? = nil, amount : Int64? = nil, credit_amount : Int64? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, lines : Array(Array(CreditNoteLineItemParams))? = nil, memo : String? = nil, metadata : Hash(String, Hash(String, String))? = nil, out_of_band_amount : Int64? = nil, reason : String? = nil, refund : String? = nil, refund_amount : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_credit_notes_preview_lines ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"invoice\" is required and cannot be null") if invoice.nil?
        if _invoice = invoice
          OpenApi::PrimitiveValidator.validate_max_length("invoice", invoice.to_s.size, GET_CREDIT_NOTES_PREVIEW_LINES_MAX_LENGTH_FOR_INVOICE)
        end

        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_CREDIT_NOTES_PREVIEW_LINES_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _memo = memo
          OpenApi::PrimitiveValidator.validate_max_length("memo", memo.to_s.size, GET_CREDIT_NOTES_PREVIEW_LINES_MAX_LENGTH_FOR_MEMO)
        end

        if _reason = reason
          OpenApi::EnumValidator.validate("reason", _reason, GET_CREDIT_NOTES_PREVIEW_LINES_VALID_VALUES_FOR_REASON)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_CREDIT_NOTES_PREVIEW_LINES_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/credit_notes/preview/lines"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["amount"] = amount.to_s if !amount.nil?
      query_params["credit_amount"] = credit_amount.to_s if !credit_amount.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["invoice"] = invoice.to_s if !invoice.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["lines"] = @api_client.build_collection_param(lines, "csv") if !lines.nil? && !lines.empty?
      query_params["memo"] = memo.to_s if !memo.nil?
      query_params["metadata"] = metadata.to_s if !metadata.nil?
      query_params["out_of_band_amount"] = out_of_band_amount.to_s if !out_of_band_amount.nil?
      query_params["reason"] = reason.to_s if !reason.nil?
      query_params["refund"] = refund.to_s if !refund.nil?
      query_params["refund_amount"] = refund_amount.to_s if !refund_amount.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_credit_notes_preview_lines",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of your customers. The customers are returned sorted by creation date, with the most recent customers appearing first.</p>
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param email [String?] A case-sensitive filter on the list based on the customer's `email` field. The value must be a string.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param test_clock [String?] Provides a list of customers that are associated with the specified test clock. The response will not include customers with test clocks if this parameter is not set.
    # @return [CustomerResourceCustomerList]
    def get_customers(*, created : Stripe::GetAccountsCreatedParameter? = nil, email : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, test_clock : String? = nil)
      data, _status_code, _headers = get_customers_with_http_info(created: created, email: email, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, test_clock: test_clock)
      data
    end

    # &lt;p&gt;Returns a list of your customers. The customers are returned sorted by creation date, with the most recent customers appearing first.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param email [String?] A case-sensitive filter on the list based on the customer's `email` field. The value must be a string.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param test_clock [String?] Provides a list of customers that are associated with the specified test clock. The response will not include customers with test clocks if this parameter is not set.
    # @return [Array<(CustomerResourceCustomerList, Integer, Hash)>] CustomerResourceCustomerList data, response status code and response headers
    def get_customers_with_http_info(*, created : Stripe::GetAccountsCreatedParameter? = nil, email : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, test_clock : String? = nil)
      request = build_api_request_for_get_customers(created: created, email: email, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, test_clock: test_clock)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CustomerResourceCustomerList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of your customers. The customers are returned sorted by creation date, with the most recent customers appearing first.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param email [String?] A case-sensitive filter on the list based on the customer's `email` field. The value must be a string.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param test_clock [String?] Provides a list of customers that are associated with the specified test clock. The response will not include customers with test clocks if this parameter is not set.
    # @return nil
    def get_customers(*, created : Stripe::GetAccountsCreatedParameter? = nil, email : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, test_clock : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers(created: created, email: email, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, test_clock: test_clock).execute(&block)
    end

    GET_CUSTOMERS_MAX_LENGTH_FOR_EMAIL          =  512
    GET_CUSTOMERS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_CUSTOMERS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_CUSTOMERS_MAX_LENGTH_FOR_TEST_CLOCK     = 5000

    # @return Crest::Request
    def build_api_request_for_get_customers(*, created : Stripe::GetAccountsCreatedParameter? = nil, email : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, test_clock : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _email = email
          OpenApi::PrimitiveValidator.validate_max_length("email", email.to_s.size, GET_CUSTOMERS_MAX_LENGTH_FOR_EMAIL)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_CUSTOMERS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_CUSTOMERS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _test_clock = test_clock
          OpenApi::PrimitiveValidator.validate_max_length("test_clock", test_clock.to_s.size, GET_CUSTOMERS_MAX_LENGTH_FOR_TEST_CLOCK)
        end
      end

      # resource path
      local_var_path = "/v1/customers"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["email"] = email.to_s if !email.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["test_clock"] = test_clock.to_s if !test_clock.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a Customer object.</p>
    # @param customer [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [GetCustomersCustomer200Response]
    def get_customers_customer(*, customer : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_customers_customer_with_http_info(customer: customer, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves a Customer object.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(GetCustomersCustomer200Response, Integer, Hash)>] GetCustomersCustomer200Response data, response status code and response headers
    def get_customers_customer_with_http_info(*, customer : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_customers_customer(customer: customer, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_customer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return GetCustomersCustomer200Response.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a Customer object.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_customers_customer(*, customer : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_customer(customer: customer, expand: expand).execute(&block)
    end

    GET_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_CUSTOMER = 5000

    # @return Crest::Request
    def build_api_request_for_get_customers_customer(*, customer : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_customer ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_CUSTOMER)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_customer",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of transactions that updated the customer’s <a href=\"/docs/billing/customer/balance\">balances</a>.</p>
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [CustomerBalanceTransactionList]
    def get_customers_customer_balance_transactions(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_customers_customer_balance_transactions_with_http_info(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of transactions that updated the customer’s &lt;a href&#x3D;\&quot;/docs/billing/customer/balance\&quot;&gt;balances&lt;/a&gt;.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(CustomerBalanceTransactionList, Integer, Hash)>] CustomerBalanceTransactionList data, response status code and response headers
    def get_customers_customer_balance_transactions_with_http_info(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_customers_customer_balance_transactions(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_customer_balance_transactions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CustomerBalanceTransactionList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of transactions that updated the customer’s &lt;a href&#x3D;\&quot;/docs/billing/customer/balance\&quot;&gt;balances&lt;/a&gt;.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_customers_customer_balance_transactions(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_customer_balance_transactions(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_CUSTOMERS_CUSTOMER_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_CUSTOMER       = 5000
    GET_CUSTOMERS_CUSTOMER_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_CUSTOMERS_CUSTOMER_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_customers_customer_balance_transactions(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_customer_balance_transactions ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CUSTOMERS_CUSTOMER_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_CUSTOMERS_CUSTOMER_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_CUSTOMERS_CUSTOMER_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/balance_transactions".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_customer_balance_transactions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a specific customer balance transaction that updated the customer’s <a href=\"/docs/billing/customer/balance\">balances</a>.</p>
    # @param customer [String?]
    # @param transaction [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [CustomerBalanceTransaction]
    def get_customers_customer_balance_transactions_transaction(*, customer : String? = nil, transaction : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_customers_customer_balance_transactions_transaction_with_http_info(customer: customer, transaction: transaction, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves a specific customer balance transaction that updated the customer’s &lt;a href&#x3D;\&quot;/docs/billing/customer/balance\&quot;&gt;balances&lt;/a&gt;.&lt;/p&gt;
    # @param customer [String?]
    # @param transaction [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(CustomerBalanceTransaction, Integer, Hash)>] CustomerBalanceTransaction data, response status code and response headers
    def get_customers_customer_balance_transactions_transaction_with_http_info(*, customer : String? = nil, transaction : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_customers_customer_balance_transactions_transaction(customer: customer, transaction: transaction, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_customer_balance_transactions_transaction\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CustomerBalanceTransaction.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a specific customer balance transaction that updated the customer’s &lt;a href&#x3D;\&quot;/docs/billing/customer/balance\&quot;&gt;balances&lt;/a&gt;.&lt;/p&gt;
    # @param customer [String?]
    # @param transaction [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_customers_customer_balance_transactions_transaction(*, customer : String? = nil, transaction : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_customer_balance_transactions_transaction(customer: customer, transaction: transaction, expand: expand).execute(&block)
    end

    GET_CUSTOMERS_CUSTOMER_BALANCE_TRANSACTIONS_TRANSACTION_MAX_LENGTH_FOR_CUSTOMER = 5000

    # @return Crest::Request
    def build_api_request_for_get_customers_customer_balance_transactions_transaction(*, customer : String? = nil, transaction : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_customer_balance_transactions_transaction ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CUSTOMERS_CUSTOMER_BALANCE_TRANSACTIONS_TRANSACTION_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"transaction\" is required and cannot be null") if transaction.nil?
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/balance_transactions/{transaction}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "transaction" + "}", URI.encode_path(transaction.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_customer_balance_transactions_transaction",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>You can see a list of the bank accounts belonging to a Customer. Note that the 10 most recent sources are always available by default on the Customer. If you need more than those 10, you can use this API method and the <code>limit</code> and <code>starting_after</code> parameters to page through additional bank accounts.</p>
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [BankAccountList]
    def get_customers_customer_bank_accounts(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_customers_customer_bank_accounts_with_http_info(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;You can see a list of the bank accounts belonging to a Customer. Note that the 10 most recent sources are always available by default on the Customer. If you need more than those 10, you can use this API method and the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;starting_after&lt;/code&gt; parameters to page through additional bank accounts.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(BankAccountList, Integer, Hash)>] BankAccountList data, response status code and response headers
    def get_customers_customer_bank_accounts_with_http_info(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_customers_customer_bank_accounts(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_customer_bank_accounts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return BankAccountList.from_json(data), status_code, headers
    end

    # &lt;p&gt;You can see a list of the bank accounts belonging to a Customer. Note that the 10 most recent sources are always available by default on the Customer. If you need more than those 10, you can use this API method and the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;starting_after&lt;/code&gt; parameters to page through additional bank accounts.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_customers_customer_bank_accounts(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_customer_bank_accounts(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_MAX_LENGTH_FOR_CUSTOMER = 5000

    # @return Crest::Request
    def build_api_request_for_get_customers_customer_bank_accounts(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_customer_bank_accounts ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_MAX_LENGTH_FOR_CUSTOMER)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/bank_accounts".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_customer_bank_accounts",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>By default, you can see the 10 most recent sources stored on a Customer directly on the object, but you can also retrieve details about a specific bank account stored on the Stripe account.</p>
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [BankAccount]
    def get_customers_customer_bank_accounts_id(*, customer : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_customers_customer_bank_accounts_id_with_http_info(customer: customer, id: id, expand: expand)
      data
    end

    # &lt;p&gt;By default, you can see the 10 most recent sources stored on a Customer directly on the object, but you can also retrieve details about a specific bank account stored on the Stripe account.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(BankAccount, Integer, Hash)>] BankAccount data, response status code and response headers
    def get_customers_customer_bank_accounts_id_with_http_info(*, customer : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_customers_customer_bank_accounts_id(customer: customer, id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_customer_bank_accounts_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return BankAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;By default, you can see the 10 most recent sources stored on a Customer directly on the object, but you can also retrieve details about a specific bank account stored on the Stripe account.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_customers_customer_bank_accounts_id(*, customer : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_customer_bank_accounts_id(customer: customer, id: id, expand: expand).execute(&block)
    end

    GET_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_CUSTOMER = 5000
    GET_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ID       = 5000

    # @return Crest::Request
    def build_api_request_for_get_customers_customer_bank_accounts_id(*, customer : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_customer_bank_accounts_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/bank_accounts/{id}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_customer_bank_accounts_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>You can see a list of the cards belonging to a customer. Note that the 10 most recent sources are always available on the <code>Customer</code> object. If you need more than those 10, you can use this API method and the <code>limit</code> and <code>starting_after</code> parameters to page through additional cards.</p>
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [CardList]
    def get_customers_customer_cards(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_customers_customer_cards_with_http_info(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;You can see a list of the cards belonging to a customer. Note that the 10 most recent sources are always available on the &lt;code&gt;Customer&lt;/code&gt; object. If you need more than those 10, you can use this API method and the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;starting_after&lt;/code&gt; parameters to page through additional cards.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(CardList, Integer, Hash)>] CardList data, response status code and response headers
    def get_customers_customer_cards_with_http_info(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_customers_customer_cards(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_customer_cards\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CardList.from_json(data), status_code, headers
    end

    # &lt;p&gt;You can see a list of the cards belonging to a customer. Note that the 10 most recent sources are always available on the &lt;code&gt;Customer&lt;/code&gt; object. If you need more than those 10, you can use this API method and the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;starting_after&lt;/code&gt; parameters to page through additional cards.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_customers_customer_cards(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_customer_cards(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_CUSTOMERS_CUSTOMER_CARDS_MAX_LENGTH_FOR_CUSTOMER = 5000

    # @return Crest::Request
    def build_api_request_for_get_customers_customer_cards(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_customer_cards ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CUSTOMERS_CUSTOMER_CARDS_MAX_LENGTH_FOR_CUSTOMER)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/cards".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_customer_cards",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>You can always see the 10 most recent cards directly on a customer; this method lets you retrieve details about a specific card stored on the customer.</p>
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Card]
    def get_customers_customer_cards_id(*, customer : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_customers_customer_cards_id_with_http_info(customer: customer, id: id, expand: expand)
      data
    end

    # &lt;p&gt;You can always see the 10 most recent cards directly on a customer; this method lets you retrieve details about a specific card stored on the customer.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Card, Integer, Hash)>] Card data, response status code and response headers
    def get_customers_customer_cards_id_with_http_info(*, customer : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_customers_customer_cards_id(customer: customer, id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_customer_cards_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Card.from_json(data), status_code, headers
    end

    # &lt;p&gt;You can always see the 10 most recent cards directly on a customer; this method lets you retrieve details about a specific card stored on the customer.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_customers_customer_cards_id(*, customer : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_customer_cards_id(customer: customer, id: id, expand: expand).execute(&block)
    end

    GET_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_CUSTOMER = 5000
    GET_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_ID       = 5000

    # @return Crest::Request
    def build_api_request_for_get_customers_customer_cards_id(*, customer : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_customer_cards_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/cards/{id}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_customer_cards_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a customer’s cash balance.</p>
    # @param customer [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [CashBalance]
    def get_customers_customer_cash_balance(*, customer : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_customers_customer_cash_balance_with_http_info(customer: customer, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves a customer’s cash balance.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(CashBalance, Integer, Hash)>] CashBalance data, response status code and response headers
    def get_customers_customer_cash_balance_with_http_info(*, customer : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_customers_customer_cash_balance(customer: customer, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_customer_cash_balance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CashBalance.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a customer’s cash balance.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_customers_customer_cash_balance(*, customer : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_customer_cash_balance(customer: customer, expand: expand).execute(&block)
    end

    GET_CUSTOMERS_CUSTOMER_CASH_BALANCE_MAX_LENGTH_FOR_CUSTOMER = 5000

    # @return Crest::Request
    def build_api_request_for_get_customers_customer_cash_balance(*, customer : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_customer_cash_balance ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CUSTOMERS_CUSTOMER_CASH_BALANCE_MAX_LENGTH_FOR_CUSTOMER)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/cash_balance".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_customer_cash_balance",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of transactions that modified the customer’s <a href=\"/docs/payments/customer-balance\">cash balance</a>.</p>
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [CustomerCashBalanceTransactionList]
    def get_customers_customer_cash_balance_transactions(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_customers_customer_cash_balance_transactions_with_http_info(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of transactions that modified the customer’s &lt;a href&#x3D;\&quot;/docs/payments/customer-balance\&quot;&gt;cash balance&lt;/a&gt;.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(CustomerCashBalanceTransactionList, Integer, Hash)>] CustomerCashBalanceTransactionList data, response status code and response headers
    def get_customers_customer_cash_balance_transactions_with_http_info(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_customers_customer_cash_balance_transactions(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_customer_cash_balance_transactions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CustomerCashBalanceTransactionList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of transactions that modified the customer’s &lt;a href&#x3D;\&quot;/docs/payments/customer-balance\&quot;&gt;cash balance&lt;/a&gt;.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_customers_customer_cash_balance_transactions(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_customer_cash_balance_transactions(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_CUSTOMERS_CUSTOMER_CASH_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_CUSTOMER       = 5000
    GET_CUSTOMERS_CUSTOMER_CASH_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_CUSTOMERS_CUSTOMER_CASH_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_customers_customer_cash_balance_transactions(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_customer_cash_balance_transactions ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CUSTOMERS_CUSTOMER_CASH_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_CUSTOMERS_CUSTOMER_CASH_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_CUSTOMERS_CUSTOMER_CASH_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/cash_balance_transactions".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_customer_cash_balance_transactions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a specific cash balance transaction, which updated the customer’s <a href=\"/docs/payments/customer-balance\">cash balance</a>.</p>
    # @param customer [String?]
    # @param transaction [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [CustomerCashBalanceTransaction]
    def get_customers_customer_cash_balance_transactions_transaction(*, customer : String? = nil, transaction : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_customers_customer_cash_balance_transactions_transaction_with_http_info(customer: customer, transaction: transaction, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves a specific cash balance transaction, which updated the customer’s &lt;a href&#x3D;\&quot;/docs/payments/customer-balance\&quot;&gt;cash balance&lt;/a&gt;.&lt;/p&gt;
    # @param customer [String?]
    # @param transaction [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(CustomerCashBalanceTransaction, Integer, Hash)>] CustomerCashBalanceTransaction data, response status code and response headers
    def get_customers_customer_cash_balance_transactions_transaction_with_http_info(*, customer : String? = nil, transaction : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_customers_customer_cash_balance_transactions_transaction(customer: customer, transaction: transaction, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_customer_cash_balance_transactions_transaction\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CustomerCashBalanceTransaction.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a specific cash balance transaction, which updated the customer’s &lt;a href&#x3D;\&quot;/docs/payments/customer-balance\&quot;&gt;cash balance&lt;/a&gt;.&lt;/p&gt;
    # @param customer [String?]
    # @param transaction [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_customers_customer_cash_balance_transactions_transaction(*, customer : String? = nil, transaction : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_customer_cash_balance_transactions_transaction(customer: customer, transaction: transaction, expand: expand).execute(&block)
    end

    GET_CUSTOMERS_CUSTOMER_CASH_BALANCE_TRANSACTIONS_TRANSACTION_MAX_LENGTH_FOR_CUSTOMER = 5000

    # @return Crest::Request
    def build_api_request_for_get_customers_customer_cash_balance_transactions_transaction(*, customer : String? = nil, transaction : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_customer_cash_balance_transactions_transaction ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CUSTOMERS_CUSTOMER_CASH_BALANCE_TRANSACTIONS_TRANSACTION_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"transaction\" is required and cannot be null") if transaction.nil?
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/cash_balance_transactions/{transaction}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "transaction" + "}", URI.encode_path(transaction.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_customer_cash_balance_transactions_transaction",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    #
    # @param customer [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Discount]
    def get_customers_customer_discount(*, customer : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_customers_customer_discount_with_http_info(customer: customer, expand: expand)
      data
    end

    #
    # @param customer [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Discount, Integer, Hash)>] Discount data, response status code and response headers
    def get_customers_customer_discount_with_http_info(*, customer : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_customers_customer_discount(customer: customer, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_customer_discount\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Discount.from_json(data), status_code, headers
    end

    #
    # @param customer [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_customers_customer_discount(*, customer : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_customer_discount(customer: customer, expand: expand).execute(&block)
    end

    GET_CUSTOMERS_CUSTOMER_DISCOUNT_MAX_LENGTH_FOR_CUSTOMER = 5000

    # @return Crest::Request
    def build_api_request_for_get_customers_customer_discount(*, customer : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_customer_discount ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CUSTOMERS_CUSTOMER_DISCOUNT_MAX_LENGTH_FOR_CUSTOMER)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/discount".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_customer_discount",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of PaymentMethods for a given Customer</p>
    # @param customer [String?]
    # @param _type [String?] A required filter on the list, based on the object `type` field.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [CustomerPaymentMethodResourceList]
    def get_customers_customer_payment_methods(*, customer : String? = nil, _type : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_customers_customer_payment_methods_with_http_info(customer: customer, _type: _type, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of PaymentMethods for a given Customer&lt;/p&gt;
    # @param customer [String?]
    # @param _type [String?] A required filter on the list, based on the object `type` field.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(CustomerPaymentMethodResourceList, Integer, Hash)>] CustomerPaymentMethodResourceList data, response status code and response headers
    def get_customers_customer_payment_methods_with_http_info(*, customer : String? = nil, _type : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_customers_customer_payment_methods(customer: customer, _type: _type, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_customer_payment_methods\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CustomerPaymentMethodResourceList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of PaymentMethods for a given Customer&lt;/p&gt;
    # @param customer [String?]
    # @param _type [String?] A required filter on the list, based on the object `type` field.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_customers_customer_payment_methods(*, customer : String? = nil, _type : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_customer_payment_methods(customer: customer, _type: _type, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_CUSTOMERS_CUSTOMER_PAYMENT_METHODS_MAX_LENGTH_FOR_CUSTOMER = 5000
    GET_CUSTOMERS_CUSTOMER_PAYMENT_METHODS_VALID_VALUES_FOR__TYPE  = StaticArray["acss_debit", "affirm", "afterpay_clearpay", "alipay", "au_becs_debit", "bacs_debit", "bancontact", "blik", "boleto", "card", "customer_balance", "eps", "fpx", "giropay", "grabpay", "ideal", "klarna", "konbini", "link", "oxxo", "p24", "paynow", "pix", "promptpay", "sepa_debit", "sofort", "us_bank_account", "wechat_pay"]

    # @return Crest::Request
    def build_api_request_for_get_customers_customer_payment_methods(*, customer : String? = nil, _type : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_customer_payment_methods ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CUSTOMERS_CUSTOMER_PAYMENT_METHODS_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"_type\" is required and cannot be null") if _type.nil?
        if __type = _type
          OpenApi::EnumValidator.validate("_type", __type, GET_CUSTOMERS_CUSTOMER_PAYMENT_METHODS_VALID_VALUES_FOR__TYPE)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/payment_methods".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["type"] = _type.to_s if !_type.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_customer_payment_methods",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a PaymentMethod object for a given Customer.</p>
    # @param customer [String?]
    # @param payment_method [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [PaymentMethod]
    def get_customers_customer_payment_methods_payment_method(*, customer : String? = nil, payment_method : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_customers_customer_payment_methods_payment_method_with_http_info(customer: customer, payment_method: payment_method, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves a PaymentMethod object for a given Customer.&lt;/p&gt;
    # @param customer [String?]
    # @param payment_method [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(PaymentMethod, Integer, Hash)>] PaymentMethod data, response status code and response headers
    def get_customers_customer_payment_methods_payment_method_with_http_info(*, customer : String? = nil, payment_method : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_customers_customer_payment_methods_payment_method(customer: customer, payment_method: payment_method, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_customer_payment_methods_payment_method\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentMethod.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a PaymentMethod object for a given Customer.&lt;/p&gt;
    # @param customer [String?]
    # @param payment_method [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_customers_customer_payment_methods_payment_method(*, customer : String? = nil, payment_method : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_customer_payment_methods_payment_method(customer: customer, payment_method: payment_method, expand: expand).execute(&block)
    end

    GET_CUSTOMERS_CUSTOMER_PAYMENT_METHODS_PAYMENT_METHOD_MAX_LENGTH_FOR_CUSTOMER       = 5000
    GET_CUSTOMERS_CUSTOMER_PAYMENT_METHODS_PAYMENT_METHOD_MAX_LENGTH_FOR_PAYMENT_METHOD = 5000

    # @return Crest::Request
    def build_api_request_for_get_customers_customer_payment_methods_payment_method(*, customer : String? = nil, payment_method : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_customer_payment_methods_payment_method ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CUSTOMERS_CUSTOMER_PAYMENT_METHODS_PAYMENT_METHOD_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"payment_method\" is required and cannot be null") if payment_method.nil?
        if _payment_method = payment_method
          OpenApi::PrimitiveValidator.validate_max_length("payment_method", payment_method.to_s.size, GET_CUSTOMERS_CUSTOMER_PAYMENT_METHODS_PAYMENT_METHOD_MAX_LENGTH_FOR_PAYMENT_METHOD)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/payment_methods/{payment_method}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "payment_method" + "}", URI.encode_path(payment_method.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_customer_payment_methods_payment_method",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>List sources for a specified customer.</p>
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param object [String?] Filter sources according to a particular object type.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [ApmsSourcesSourceList]
    def get_customers_customer_sources(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, object : String? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_customers_customer_sources_with_http_info(customer: customer, ending_before: ending_before, expand: expand, limit: limit, object: object, starting_after: starting_after)
      data
    end

    # &lt;p&gt;List sources for a specified customer.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param object [String?] Filter sources according to a particular object type.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(ApmsSourcesSourceList, Integer, Hash)>] ApmsSourcesSourceList data, response status code and response headers
    def get_customers_customer_sources_with_http_info(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, object : String? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_customers_customer_sources(customer: customer, ending_before: ending_before, expand: expand, limit: limit, object: object, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_customer_sources\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ApmsSourcesSourceList.from_json(data), status_code, headers
    end

    # &lt;p&gt;List sources for a specified customer.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param object [String?] Filter sources according to a particular object type.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_customers_customer_sources(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, object : String? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_customer_sources(customer: customer, ending_before: ending_before, expand: expand, limit: limit, object: object, starting_after: starting_after).execute(&block)
    end

    GET_CUSTOMERS_CUSTOMER_SOURCES_MAX_LENGTH_FOR_CUSTOMER = 5000
    GET_CUSTOMERS_CUSTOMER_SOURCES_MAX_LENGTH_FOR_OBJECT   = 5000

    # @return Crest::Request
    def build_api_request_for_get_customers_customer_sources(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, object : String? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_customer_sources ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CUSTOMERS_CUSTOMER_SOURCES_MAX_LENGTH_FOR_CUSTOMER)
        end

        if _object = object
          OpenApi::PrimitiveValidator.validate_max_length("object", object.to_s.size, GET_CUSTOMERS_CUSTOMER_SOURCES_MAX_LENGTH_FOR_OBJECT)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/sources".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["object"] = object.to_s if !object.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_customer_sources",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieve a specified source for a given customer.</p>
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [PaymentSource]
    def get_customers_customer_sources_id(*, customer : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_customers_customer_sources_id_with_http_info(customer: customer, id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieve a specified source for a given customer.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(PaymentSource, Integer, Hash)>] PaymentSource data, response status code and response headers
    def get_customers_customer_sources_id_with_http_info(*, customer : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_customers_customer_sources_id(customer: customer, id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_customer_sources_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentSource.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieve a specified source for a given customer.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_customers_customer_sources_id(*, customer : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_customer_sources_id(customer: customer, id: id, expand: expand).execute(&block)
    end

    GET_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_CUSTOMER = 5000
    GET_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_ID       =  500

    # @return Crest::Request
    def build_api_request_for_get_customers_customer_sources_id(*, customer : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_customer_sources_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/sources/{id}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_customer_sources_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>You can see a list of the customer’s active subscriptions. Note that the 10 most recent active subscriptions are always available by default on the customer object. If you need more than those 10, you can use the limit and starting_after parameters to page through additional subscriptions.</p>
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [SubscriptionList]
    def get_customers_customer_subscriptions(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_customers_customer_subscriptions_with_http_info(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;You can see a list of the customer’s active subscriptions. Note that the 10 most recent active subscriptions are always available by default on the customer object. If you need more than those 10, you can use the limit and starting_after parameters to page through additional subscriptions.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(SubscriptionList, Integer, Hash)>] SubscriptionList data, response status code and response headers
    def get_customers_customer_subscriptions_with_http_info(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_customers_customer_subscriptions(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_customer_subscriptions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SubscriptionList.from_json(data), status_code, headers
    end

    # &lt;p&gt;You can see a list of the customer’s active subscriptions. Note that the 10 most recent active subscriptions are always available by default on the customer object. If you need more than those 10, you can use the limit and starting_after parameters to page through additional subscriptions.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_customers_customer_subscriptions(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_customer_subscriptions(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_MAX_LENGTH_FOR_CUSTOMER       = 5000
    GET_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_customers_customer_subscriptions(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_customer_subscriptions ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/subscriptions".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_customer_subscriptions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the subscription with the given ID.</p>
    # @param customer [String?]
    # @param subscription_exposed_id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Subscription]
    def get_customers_customer_subscriptions_subscription_exposed_id(*, customer : String? = nil, subscription_exposed_id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_customers_customer_subscriptions_subscription_exposed_id_with_http_info(customer: customer, subscription_exposed_id: subscription_exposed_id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the subscription with the given ID.&lt;/p&gt;
    # @param customer [String?]
    # @param subscription_exposed_id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Subscription, Integer, Hash)>] Subscription data, response status code and response headers
    def get_customers_customer_subscriptions_subscription_exposed_id_with_http_info(*, customer : String? = nil, subscription_exposed_id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_customers_customer_subscriptions_subscription_exposed_id(customer: customer, subscription_exposed_id: subscription_exposed_id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_customer_subscriptions_subscription_exposed_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Subscription.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the subscription with the given ID.&lt;/p&gt;
    # @param customer [String?]
    # @param subscription_exposed_id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_customers_customer_subscriptions_subscription_exposed_id(*, customer : String? = nil, subscription_exposed_id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_customer_subscriptions_subscription_exposed_id(customer: customer, subscription_exposed_id: subscription_exposed_id, expand: expand).execute(&block)
    end

    GET_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_CUSTOMER                = 5000
    GET_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID = 5000

    # @return Crest::Request
    def build_api_request_for_get_customers_customer_subscriptions_subscription_exposed_id(*, customer : String? = nil, subscription_exposed_id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_customer_subscriptions_subscription_exposed_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"subscription_exposed_id\" is required and cannot be null") if subscription_exposed_id.nil?
        if _subscription_exposed_id = subscription_exposed_id
          OpenApi::PrimitiveValidator.validate_max_length("subscription_exposed_id", subscription_exposed_id.to_s.size, GET_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/subscriptions/{subscription_exposed_id}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "subscription_exposed_id" + "}", URI.encode_path(subscription_exposed_id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_customer_subscriptions_subscription_exposed_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    #
    # @param customer [String?]
    # @param subscription_exposed_id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Discount]
    def get_customers_customer_subscriptions_subscription_exposed_id_discount(*, customer : String? = nil, subscription_exposed_id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_customers_customer_subscriptions_subscription_exposed_id_discount_with_http_info(customer: customer, subscription_exposed_id: subscription_exposed_id, expand: expand)
      data
    end

    #
    # @param customer [String?]
    # @param subscription_exposed_id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Discount, Integer, Hash)>] Discount data, response status code and response headers
    def get_customers_customer_subscriptions_subscription_exposed_id_discount_with_http_info(*, customer : String? = nil, subscription_exposed_id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_customers_customer_subscriptions_subscription_exposed_id_discount(customer: customer, subscription_exposed_id: subscription_exposed_id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_customer_subscriptions_subscription_exposed_id_discount\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Discount.from_json(data), status_code, headers
    end

    #
    # @param customer [String?]
    # @param subscription_exposed_id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_customers_customer_subscriptions_subscription_exposed_id_discount(*, customer : String? = nil, subscription_exposed_id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_customer_subscriptions_subscription_exposed_id_discount(customer: customer, subscription_exposed_id: subscription_exposed_id, expand: expand).execute(&block)
    end

    GET_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_DISCOUNT_MAX_LENGTH_FOR_CUSTOMER                = 5000
    GET_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_DISCOUNT_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID = 5000

    # @return Crest::Request
    def build_api_request_for_get_customers_customer_subscriptions_subscription_exposed_id_discount(*, customer : String? = nil, subscription_exposed_id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_customer_subscriptions_subscription_exposed_id_discount ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_DISCOUNT_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"subscription_exposed_id\" is required and cannot be null") if subscription_exposed_id.nil?
        if _subscription_exposed_id = subscription_exposed_id
          OpenApi::PrimitiveValidator.validate_max_length("subscription_exposed_id", subscription_exposed_id.to_s.size, GET_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_DISCOUNT_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/subscriptions/{subscription_exposed_id}/discount".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "subscription_exposed_id" + "}", URI.encode_path(subscription_exposed_id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_customer_subscriptions_subscription_exposed_id_discount",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of tax IDs for a customer.</p>
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [TaxIDsList]
    def get_customers_customer_tax_ids(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_customers_customer_tax_ids_with_http_info(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of tax IDs for a customer.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(TaxIDsList, Integer, Hash)>] TaxIDsList data, response status code and response headers
    def get_customers_customer_tax_ids_with_http_info(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_customers_customer_tax_ids(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_customer_tax_ids\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TaxIDsList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of tax IDs for a customer.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_customers_customer_tax_ids(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_customer_tax_ids(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_CUSTOMERS_CUSTOMER_TAX_IDS_MAX_LENGTH_FOR_CUSTOMER       = 5000
    GET_CUSTOMERS_CUSTOMER_TAX_IDS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_CUSTOMERS_CUSTOMER_TAX_IDS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_customers_customer_tax_ids(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_customer_tax_ids ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CUSTOMERS_CUSTOMER_TAX_IDS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_CUSTOMERS_CUSTOMER_TAX_IDS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_CUSTOMERS_CUSTOMER_TAX_IDS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/tax_ids".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_customer_tax_ids",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the <code>TaxID</code> object with the given identifier.</p>
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [TaxId]
    def get_customers_customer_tax_ids_id(*, customer : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_customers_customer_tax_ids_id_with_http_info(customer: customer, id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the &lt;code&gt;TaxID&lt;/code&gt; object with the given identifier.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(TaxId, Integer, Hash)>] TaxId data, response status code and response headers
    def get_customers_customer_tax_ids_id_with_http_info(*, customer : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_customers_customer_tax_ids_id(customer: customer, id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_customer_tax_ids_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TaxId.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the &lt;code&gt;TaxID&lt;/code&gt; object with the given identifier.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_customers_customer_tax_ids_id(*, customer : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_customer_tax_ids_id(customer: customer, id: id, expand: expand).execute(&block)
    end

    GET_CUSTOMERS_CUSTOMER_TAX_IDS_ID_MAX_LENGTH_FOR_CUSTOMER = 5000

    # @return Crest::Request
    def build_api_request_for_get_customers_customer_tax_ids_id(*, customer : String? = nil, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_customer_tax_ids_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_CUSTOMERS_CUSTOMER_TAX_IDS_ID_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/tax_ids/{id}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_customer_tax_ids_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Search for customers you’ve previously created using Stripe’s <a href=\"/docs/search#search-query-language\">Search Query Language</a>. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.</p>
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for customers](https://stripe.com/docs/search#query-fields-for-customers).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return [SearchResult1]
    def get_customers_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil)
      data, _status_code, _headers = get_customers_search_with_http_info(query: query, expand: expand, limit: limit, page: page)
      data
    end

    # &lt;p&gt;Search for customers you’ve previously created using Stripe’s &lt;a href&#x3D;\&quot;/docs/search#search-query-language\&quot;&gt;Search Query Language&lt;/a&gt;. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.&lt;/p&gt;
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for customers](https://stripe.com/docs/search#query-fields-for-customers).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return [Array<(SearchResult1, Integer, Hash)>] SearchResult1 data, response status code and response headers
    def get_customers_search_with_http_info(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil)
      request = build_api_request_for_get_customers_search(query: query, expand: expand, limit: limit, page: page)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_customers_search\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SearchResult1.from_json(data), status_code, headers
    end

    # &lt;p&gt;Search for customers you’ve previously created using Stripe’s &lt;a href&#x3D;\&quot;/docs/search#search-query-language\&quot;&gt;Search Query Language&lt;/a&gt;. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.&lt;/p&gt;
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for customers](https://stripe.com/docs/search#query-fields-for-customers).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return nil
    def get_customers_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_customers_search(query: query, expand: expand, limit: limit, page: page).execute(&block)
    end

    GET_CUSTOMERS_SEARCH_MAX_LENGTH_FOR_QUERY = 5000
    GET_CUSTOMERS_SEARCH_MAX_LENGTH_FOR_PAGE  = 5000

    # @return Crest::Request
    def build_api_request_for_get_customers_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_customers_search ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"query\" is required and cannot be null") if query.nil?
        if _query = query
          OpenApi::PrimitiveValidator.validate_max_length("query", query.to_s.size, GET_CUSTOMERS_SEARCH_MAX_LENGTH_FOR_QUERY)
        end

        if _page = page
          OpenApi::PrimitiveValidator.validate_max_length("page", page.to_s.size, GET_CUSTOMERS_SEARCH_MAX_LENGTH_FOR_PAGE)
        end
      end

      # resource path
      local_var_path = "/v1/customers/search"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["page"] = page.to_s if !page.nil?
      query_params["query"] = query.to_s if !query.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_customers_search",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of your disputes.</p>
    # @optional @param charge [String?] Only return disputes associated to the charge specified by this charge ID.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payment_intent [String?] Only return disputes associated to the PaymentIntent specified by this PaymentIntent ID.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [DisputeList]
    def get_disputes(*, charge : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_intent : String? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_disputes_with_http_info(charge: charge, created: created, ending_before: ending_before, expand: expand, limit: limit, payment_intent: payment_intent, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of your disputes.&lt;/p&gt;
    # @optional @param charge [String?] Only return disputes associated to the charge specified by this charge ID.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payment_intent [String?] Only return disputes associated to the PaymentIntent specified by this PaymentIntent ID.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(DisputeList, Integer, Hash)>] DisputeList data, response status code and response headers
    def get_disputes_with_http_info(*, charge : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_intent : String? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_disputes(charge: charge, created: created, ending_before: ending_before, expand: expand, limit: limit, payment_intent: payment_intent, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_disputes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return DisputeList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of your disputes.&lt;/p&gt;
    # @optional @param charge [String?] Only return disputes associated to the charge specified by this charge ID.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payment_intent [String?] Only return disputes associated to the PaymentIntent specified by this PaymentIntent ID.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_disputes(*, charge : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_intent : String? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_disputes(charge: charge, created: created, ending_before: ending_before, expand: expand, limit: limit, payment_intent: payment_intent, starting_after: starting_after).execute(&block)
    end

    GET_DISPUTES_MAX_LENGTH_FOR_CHARGE         = 5000
    GET_DISPUTES_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_DISPUTES_MAX_LENGTH_FOR_PAYMENT_INTENT = 5000
    GET_DISPUTES_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_disputes(*, charge : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_intent : String? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_disputes ..." }
      end

      if client_side_validation
        if _charge = charge
          OpenApi::PrimitiveValidator.validate_max_length("charge", charge.to_s.size, GET_DISPUTES_MAX_LENGTH_FOR_CHARGE)
        end
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_DISPUTES_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _payment_intent = payment_intent
          OpenApi::PrimitiveValidator.validate_max_length("payment_intent", payment_intent.to_s.size, GET_DISPUTES_MAX_LENGTH_FOR_PAYMENT_INTENT)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_DISPUTES_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/disputes"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["charge"] = charge.to_s if !charge.nil?
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["payment_intent"] = payment_intent.to_s if !payment_intent.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_disputes",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the dispute with the given ID.</p>
    # @param dispute [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Dispute]
    def get_disputes_dispute(*, dispute : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_disputes_dispute_with_http_info(dispute: dispute, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the dispute with the given ID.&lt;/p&gt;
    # @param dispute [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Dispute, Integer, Hash)>] Dispute data, response status code and response headers
    def get_disputes_dispute_with_http_info(*, dispute : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_disputes_dispute(dispute: dispute, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_disputes_dispute\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Dispute.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the dispute with the given ID.&lt;/p&gt;
    # @param dispute [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_disputes_dispute(*, dispute : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_disputes_dispute(dispute: dispute, expand: expand).execute(&block)
    end

    GET_DISPUTES_DISPUTE_MAX_LENGTH_FOR_DISPUTE = 5000

    # @return Crest::Request
    def build_api_request_for_get_disputes_dispute(*, dispute : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_disputes_dispute ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"dispute\" is required and cannot be null") if dispute.nil?
        if _dispute = dispute
          OpenApi::PrimitiveValidator.validate_max_length("dispute", dispute.to_s.size, GET_DISPUTES_DISPUTE_MAX_LENGTH_FOR_DISPUTE)
        end
      end

      # resource path
      local_var_path = "/v1/disputes/{dispute}".sub("{" + "dispute" + "}", URI.encode_path(dispute.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_disputes_dispute",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>List events, going back up to 30 days. Each event data is rendered according to Stripe API version at its creation time, specified in <a href=\"/docs/api/events/object\">event object</a> <code>api_version</code> attribute (not according to your current Stripe API version or <code>Stripe-Version</code> header).</p>
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param delivery_success [Bool?] Filter events by whether all webhooks were successfully delivered. If false, events which are still pending or have failed all delivery attempts to a webhook endpoint will be returned.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param _type [String?] A string containing a specific event name, or group of events using * as a wildcard. The list will be filtered to include only events with a matching event property.
    # @optional @param types [Array(Array(String))?] An array of up to 20 strings containing specific event names. The list will be filtered to include only events with a matching event property. You may pass either `type` or `types`, but not both.
    # @return [NotificationEventList]
    def get_events(*, created : Stripe::GetAccountsCreatedParameter? = nil, delivery_success : Bool? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, _type : String? = nil, types : Array(Array(String))? = nil)
      data, _status_code, _headers = get_events_with_http_info(created: created, delivery_success: delivery_success, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, _type: _type, types: types)
      data
    end

    # &lt;p&gt;List events, going back up to 30 days. Each event data is rendered according to Stripe API version at its creation time, specified in &lt;a href&#x3D;\&quot;/docs/api/events/object\&quot;&gt;event object&lt;/a&gt; &lt;code&gt;api_version&lt;/code&gt; attribute (not according to your current Stripe API version or &lt;code&gt;Stripe-Version&lt;/code&gt; header).&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param delivery_success [Bool?] Filter events by whether all webhooks were successfully delivered. If false, events which are still pending or have failed all delivery attempts to a webhook endpoint will be returned.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param _type [String?] A string containing a specific event name, or group of events using * as a wildcard. The list will be filtered to include only events with a matching event property.
    # @optional @param types [Array(Array(String))?] An array of up to 20 strings containing specific event names. The list will be filtered to include only events with a matching event property. You may pass either `type` or `types`, but not both.
    # @return [Array<(NotificationEventList, Integer, Hash)>] NotificationEventList data, response status code and response headers
    def get_events_with_http_info(*, created : Stripe::GetAccountsCreatedParameter? = nil, delivery_success : Bool? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, _type : String? = nil, types : Array(Array(String))? = nil)
      request = build_api_request_for_get_events(created: created, delivery_success: delivery_success, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, _type: _type, types: types)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_events\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return NotificationEventList.from_json(data), status_code, headers
    end

    # &lt;p&gt;List events, going back up to 30 days. Each event data is rendered according to Stripe API version at its creation time, specified in &lt;a href&#x3D;\&quot;/docs/api/events/object\&quot;&gt;event object&lt;/a&gt; &lt;code&gt;api_version&lt;/code&gt; attribute (not according to your current Stripe API version or &lt;code&gt;Stripe-Version&lt;/code&gt; header).&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param delivery_success [Bool?] Filter events by whether all webhooks were successfully delivered. If false, events which are still pending or have failed all delivery attempts to a webhook endpoint will be returned.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param _type [String?] A string containing a specific event name, or group of events using * as a wildcard. The list will be filtered to include only events with a matching event property.
    # @optional @param types [Array(Array(String))?] An array of up to 20 strings containing specific event names. The list will be filtered to include only events with a matching event property. You may pass either `type` or `types`, but not both.
    # @return nil
    def get_events(*, created : Stripe::GetAccountsCreatedParameter? = nil, delivery_success : Bool? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, _type : String? = nil, types : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_events(created: created, delivery_success: delivery_success, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, _type: _type, types: types).execute(&block)
    end

    GET_EVENTS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_EVENTS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_EVENTS_MAX_LENGTH_FOR__TYPE          = 5000

    # @return Crest::Request
    def build_api_request_for_get_events(*, created : Stripe::GetAccountsCreatedParameter? = nil, delivery_success : Bool? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, _type : String? = nil, types : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_events ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end

        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_EVENTS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_EVENTS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if __type = _type
          OpenApi::PrimitiveValidator.validate_max_length("_type", _type.to_s.size, GET_EVENTS_MAX_LENGTH_FOR__TYPE)
        end
      end

      # resource path
      local_var_path = "/v1/events"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["delivery_success"] = delivery_success.to_s if !delivery_success.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["type"] = _type.to_s if !_type.nil?
      query_params["types"] = @api_client.build_collection_param(types, "csv") if !types.nil? && !types.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_events",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an event. Supply the unique identifier of the event, which you might have received in a webhook.</p>
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Event]
    def get_events_id(*, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_events_id_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an event. Supply the unique identifier of the event, which you might have received in a webhook.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Event, Integer, Hash)>] Event data, response status code and response headers
    def get_events_id_with_http_info(*, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_events_id(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_events_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Event.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an event. Supply the unique identifier of the event, which you might have received in a webhook.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_events_id(*, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_events_id(id: id, expand: expand).execute(&block)
    end

    GET_EVENTS_ID_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_get_events_id(*, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_events_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_EVENTS_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/events/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_events_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of objects that contain the rates at which foreign currencies are converted to one another. Only shows the currencies for which Stripe supports.</p>
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is the currency that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with the exchange rate for currency X your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and total number of supported payout currencies, and the default is the max.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is the currency that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with the exchange rate for currency X, your subsequent call can include `starting_after=X` in order to fetch the next page of the list.
    # @return [ExchangeRateList]
    def get_exchange_rates(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_exchange_rates_with_http_info(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of objects that contain the rates at which foreign currencies are converted to one another. Only shows the currencies for which Stripe supports.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is the currency that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with the exchange rate for currency X your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and total number of supported payout currencies, and the default is the max.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is the currency that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with the exchange rate for currency X, your subsequent call can include `starting_after=X` in order to fetch the next page of the list.
    # @return [Array<(ExchangeRateList, Integer, Hash)>] ExchangeRateList data, response status code and response headers
    def get_exchange_rates_with_http_info(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_exchange_rates(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_exchange_rates\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ExchangeRateList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of objects that contain the rates at which foreign currencies are converted to one another. Only shows the currencies for which Stripe supports.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is the currency that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with the exchange rate for currency X your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and total number of supported payout currencies, and the default is the max.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is the currency that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with the exchange rate for currency X, your subsequent call can include `starting_after=X` in order to fetch the next page of the list.
    # @return nil
    def get_exchange_rates(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_exchange_rates(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_EXCHANGE_RATES_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_EXCHANGE_RATES_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_exchange_rates(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_exchange_rates ..." }
      end

      if client_side_validation
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_EXCHANGE_RATES_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_EXCHANGE_RATES_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/exchange_rates"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_exchange_rates",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the exchange rates from the given currency to every supported currency.</p>
    # @param rate_id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [ExchangeRate]
    def get_exchange_rates_rate_id(*, rate_id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_exchange_rates_rate_id_with_http_info(rate_id: rate_id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the exchange rates from the given currency to every supported currency.&lt;/p&gt;
    # @param rate_id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(ExchangeRate, Integer, Hash)>] ExchangeRate data, response status code and response headers
    def get_exchange_rates_rate_id_with_http_info(*, rate_id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_exchange_rates_rate_id(rate_id: rate_id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_exchange_rates_rate_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ExchangeRate.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the exchange rates from the given currency to every supported currency.&lt;/p&gt;
    # @param rate_id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_exchange_rates_rate_id(*, rate_id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_exchange_rates_rate_id(rate_id: rate_id, expand: expand).execute(&block)
    end

    GET_EXCHANGE_RATES_RATE_ID_MAX_LENGTH_FOR_RATE_ID = 5000

    # @return Crest::Request
    def build_api_request_for_get_exchange_rates_rate_id(*, rate_id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_exchange_rates_rate_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"rate_id\" is required and cannot be null") if rate_id.nil?
        if _rate_id = rate_id
          OpenApi::PrimitiveValidator.validate_max_length("rate_id", rate_id.to_s.size, GET_EXCHANGE_RATES_RATE_ID_MAX_LENGTH_FOR_RATE_ID)
        end
      end

      # resource path
      local_var_path = "/v1/exchange_rates/{rate_id}".sub("{" + "rate_id" + "}", URI.encode_path(rate_id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_exchange_rates_rate_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of file links.</p>
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param expired [Bool?] Filter links by their expiration status. By default, all links are returned.
    # @optional @param file [String?] Only return links for the given file.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [FileFileLinkList]
    def get_file_links(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, expired : Bool? = nil, file : String? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_file_links_with_http_info(created: created, ending_before: ending_before, expand: expand, expired: expired, file: file, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of file links.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param expired [Bool?] Filter links by their expiration status. By default, all links are returned.
    # @optional @param file [String?] Only return links for the given file.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(FileFileLinkList, Integer, Hash)>] FileFileLinkList data, response status code and response headers
    def get_file_links_with_http_info(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, expired : Bool? = nil, file : String? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_file_links(created: created, ending_before: ending_before, expand: expand, expired: expired, file: file, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_file_links\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FileFileLinkList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of file links.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param expired [Bool?] Filter links by their expiration status. By default, all links are returned.
    # @optional @param file [String?] Only return links for the given file.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_file_links(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, expired : Bool? = nil, file : String? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_file_links(created: created, ending_before: ending_before, expand: expand, expired: expired, file: file, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_FILE_LINKS_MAX_LENGTH_FOR_FILE = 5000

    # @return Crest::Request
    def build_api_request_for_get_file_links(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, expired : Bool? = nil, file : String? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_file_links ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end

        if _file = file
          OpenApi::PrimitiveValidator.validate_max_length("file", file.to_s.size, GET_FILE_LINKS_MAX_LENGTH_FOR_FILE)
        end
      end

      # resource path
      local_var_path = "/v1/file_links"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["expired"] = expired.to_s if !expired.nil?
      query_params["file"] = file.to_s if !file.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_file_links",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the file link with the given ID.</p>
    # @param link [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [FileLink]
    def get_file_links_link(*, link : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_file_links_link_with_http_info(link: link, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the file link with the given ID.&lt;/p&gt;
    # @param link [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(FileLink, Integer, Hash)>] FileLink data, response status code and response headers
    def get_file_links_link_with_http_info(*, link : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_file_links_link(link: link, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_file_links_link\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FileLink.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the file link with the given ID.&lt;/p&gt;
    # @param link [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_file_links_link(*, link : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_file_links_link(link: link, expand: expand).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_get_file_links_link(*, link : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_file_links_link ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"link\" is required and cannot be null") if link.nil?
      end

      # resource path
      local_var_path = "/v1/file_links/{link}".sub("{" + "link" + "}", URI.encode_path(link.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_file_links_link",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of the files that your account has access to. The files are returned sorted by creation date, with the most recently created files appearing first.</p>
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param purpose [String?] The file purpose to filter queries by. If none is provided, files will not be filtered by purpose.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [FileFileList]
    def get_files(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, purpose : String? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_files_with_http_info(created: created, ending_before: ending_before, expand: expand, limit: limit, purpose: purpose, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of the files that your account has access to. The files are returned sorted by creation date, with the most recently created files appearing first.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param purpose [String?] The file purpose to filter queries by. If none is provided, files will not be filtered by purpose.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(FileFileList, Integer, Hash)>] FileFileList data, response status code and response headers
    def get_files_with_http_info(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, purpose : String? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_files(created: created, ending_before: ending_before, expand: expand, limit: limit, purpose: purpose, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_files\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FileFileList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of the files that your account has access to. The files are returned sorted by creation date, with the most recently created files appearing first.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param purpose [String?] The file purpose to filter queries by. If none is provided, files will not be filtered by purpose.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_files(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, purpose : String? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_files(created: created, ending_before: ending_before, expand: expand, limit: limit, purpose: purpose, starting_after: starting_after).execute(&block)
    end

    GET_FILES_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_FILES_MAX_LENGTH_FOR_PURPOSE        = 5000
    GET_FILES_VALID_VALUES_FOR_PURPOSE      = StaticArray["account_requirement", "additional_verification", "business_icon", "business_logo", "customer_signature", "dispute_evidence", "document_provider_identity_document", "finance_report_run", "identity_document", "identity_document_downloadable", "pci_document", "selfie", "sigma_scheduled_query", "tax_document_user_upload", "terminal_reader_splashscreen"]
    GET_FILES_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_files(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, purpose : String? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_files ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_FILES_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _purpose = purpose
          OpenApi::EnumValidator.validate("purpose", _purpose, GET_FILES_VALID_VALUES_FOR_PURPOSE)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_FILES_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/files"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["purpose"] = purpose.to_s if !purpose.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_files",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an existing file object. Supply the unique file ID from a file, and Stripe will return the corresponding file object. To access file contents, see the <a href=\"/docs/file-upload#download-file-contents\">File Upload Guide</a>.</p>
    # @param file [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [::File]
    def get_files_file(*, file : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_files_file_with_http_info(file: file, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an existing file object. Supply the unique file ID from a file, and Stripe will return the corresponding file object. To access file contents, see the &lt;a href&#x3D;\&quot;/docs/file-upload#download-file-contents\&quot;&gt;File Upload Guide&lt;/a&gt;.&lt;/p&gt;
    # @param file [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(::File, Integer, Hash)>] ::File data, response status code and response headers
    def get_files_file_with_http_info(*, file : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_files_file(file: file, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_files_file\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ::File.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an existing file object. Supply the unique file ID from a file, and Stripe will return the corresponding file object. To access file contents, see the &lt;a href&#x3D;\&quot;/docs/file-upload#download-file-contents\&quot;&gt;File Upload Guide&lt;/a&gt;.&lt;/p&gt;
    # @param file [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_files_file(*, file : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_files_file(file: file, expand: expand).execute(&block)
    end

    GET_FILES_FILE_MAX_LENGTH_FOR_FILE = 5000

    # @return Crest::Request
    def build_api_request_for_get_files_file(*, file : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_files_file ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"file\" is required and cannot be null") if file.nil?
        if _file = file
          OpenApi::PrimitiveValidator.validate_max_length("file", file.to_s.size, GET_FILES_FILE_MAX_LENGTH_FOR_FILE)
        end
      end

      # resource path
      local_var_path = "/v1/files/{file}".sub("{" + "file" + "}", URI.encode_path(file.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_files_file",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of Financial Connections <code>Account</code> objects.</p>
    # @optional @param account_holder [Stripe::AccountholderParams?] If present, only return accounts that belong to the specified account holder. `account_holder[customer]` and `account_holder[account]` are mutually exclusive.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param session [String?] If present, only return accounts that were collected as part of the given session.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [BankConnectionsResourceLinkedAccountList]
    def get_financial_connections_accounts(*, account_holder : Stripe::AccountholderParams? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, session : String? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_financial_connections_accounts_with_http_info(account_holder: account_holder, ending_before: ending_before, expand: expand, limit: limit, session: session, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of Financial Connections &lt;code&gt;Account&lt;/code&gt; objects.&lt;/p&gt;
    # @optional @param account_holder [Stripe::AccountholderParams?] If present, only return accounts that belong to the specified account holder. `account_holder[customer]` and `account_holder[account]` are mutually exclusive.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param session [String?] If present, only return accounts that were collected as part of the given session.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(BankConnectionsResourceLinkedAccountList, Integer, Hash)>] BankConnectionsResourceLinkedAccountList data, response status code and response headers
    def get_financial_connections_accounts_with_http_info(*, account_holder : Stripe::AccountholderParams? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, session : String? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_financial_connections_accounts(account_holder: account_holder, ending_before: ending_before, expand: expand, limit: limit, session: session, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_financial_connections_accounts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return BankConnectionsResourceLinkedAccountList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of Financial Connections &lt;code&gt;Account&lt;/code&gt; objects.&lt;/p&gt;
    # @optional @param account_holder [Stripe::AccountholderParams?] If present, only return accounts that belong to the specified account holder. `account_holder[customer]` and `account_holder[account]` are mutually exclusive.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param session [String?] If present, only return accounts that were collected as part of the given session.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_financial_connections_accounts(*, account_holder : Stripe::AccountholderParams? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, session : String? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_financial_connections_accounts(account_holder: account_holder, ending_before: ending_before, expand: expand, limit: limit, session: session, starting_after: starting_after).execute(&block)
    end

    GET_FINANCIAL_CONNECTIONS_ACCOUNTS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_FINANCIAL_CONNECTIONS_ACCOUNTS_MAX_LENGTH_FOR_SESSION        = 5000
    GET_FINANCIAL_CONNECTIONS_ACCOUNTS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_financial_connections_accounts(*, account_holder : Stripe::AccountholderParams? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, session : String? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_financial_connections_accounts ..." }
      end

      if client_side_validation
        if _account_holder = account_holder
          _account_holder.validate if _account_holder.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_FINANCIAL_CONNECTIONS_ACCOUNTS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _session = session
          OpenApi::PrimitiveValidator.validate_max_length("session", session.to_s.size, GET_FINANCIAL_CONNECTIONS_ACCOUNTS_MAX_LENGTH_FOR_SESSION)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_FINANCIAL_CONNECTIONS_ACCOUNTS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/financial_connections/accounts"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["account_holder"] = account_holder.to_s if !account_holder.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["session"] = session.to_s if !session.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_financial_connections_accounts",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an Financial Connections <code>Account</code>.</p>
    # @param account [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [FinancialConnectionsAccount]
    def get_financial_connections_accounts_account(*, account : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_financial_connections_accounts_account_with_http_info(account: account, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an Financial Connections &lt;code&gt;Account&lt;/code&gt;.&lt;/p&gt;
    # @param account [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(FinancialConnectionsAccount, Integer, Hash)>] FinancialConnectionsAccount data, response status code and response headers
    def get_financial_connections_accounts_account_with_http_info(*, account : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_financial_connections_accounts_account(account: account, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_financial_connections_accounts_account\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FinancialConnectionsAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an Financial Connections &lt;code&gt;Account&lt;/code&gt;.&lt;/p&gt;
    # @param account [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_financial_connections_accounts_account(*, account : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_financial_connections_accounts_account(account: account, expand: expand).execute(&block)
    end

    GET_FINANCIAL_CONNECTIONS_ACCOUNTS_ACCOUNT_MAX_LENGTH_FOR_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_get_financial_connections_accounts_account(*, account : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_financial_connections_accounts_account ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, GET_FINANCIAL_CONNECTIONS_ACCOUNTS_ACCOUNT_MAX_LENGTH_FOR_ACCOUNT)
        end
      end

      # resource path
      local_var_path = "/v1/financial_connections/accounts/{account}".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_financial_connections_accounts_account",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Lists all owners for a given <code>Account</code></p>
    # @param account [String?]
    # @param ownership [String?] The ID of the ownership object to fetch owners from.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [BankConnectionsResourceOwnerList]
    def get_financial_connections_accounts_account_owners(*, account : String? = nil, ownership : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_financial_connections_accounts_account_owners_with_http_info(account: account, ownership: ownership, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Lists all owners for a given &lt;code&gt;Account&lt;/code&gt;&lt;/p&gt;
    # @param account [String?]
    # @param ownership [String?] The ID of the ownership object to fetch owners from.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(BankConnectionsResourceOwnerList, Integer, Hash)>] BankConnectionsResourceOwnerList data, response status code and response headers
    def get_financial_connections_accounts_account_owners_with_http_info(*, account : String? = nil, ownership : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_financial_connections_accounts_account_owners(account: account, ownership: ownership, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_financial_connections_accounts_account_owners\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return BankConnectionsResourceOwnerList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Lists all owners for a given &lt;code&gt;Account&lt;/code&gt;&lt;/p&gt;
    # @param account [String?]
    # @param ownership [String?] The ID of the ownership object to fetch owners from.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_financial_connections_accounts_account_owners(*, account : String? = nil, ownership : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_financial_connections_accounts_account_owners(account: account, ownership: ownership, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_FINANCIAL_CONNECTIONS_ACCOUNTS_ACCOUNT_OWNERS_MAX_LENGTH_FOR_ACCOUNT        = 5000
    GET_FINANCIAL_CONNECTIONS_ACCOUNTS_ACCOUNT_OWNERS_MAX_LENGTH_FOR_OWNERSHIP      = 5000
    GET_FINANCIAL_CONNECTIONS_ACCOUNTS_ACCOUNT_OWNERS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_FINANCIAL_CONNECTIONS_ACCOUNTS_ACCOUNT_OWNERS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_financial_connections_accounts_account_owners(*, account : String? = nil, ownership : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_financial_connections_accounts_account_owners ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, GET_FINANCIAL_CONNECTIONS_ACCOUNTS_ACCOUNT_OWNERS_MAX_LENGTH_FOR_ACCOUNT)
        end
        raise ArgumentError.new("\"ownership\" is required and cannot be null") if ownership.nil?
        if _ownership = ownership
          OpenApi::PrimitiveValidator.validate_max_length("ownership", ownership.to_s.size, GET_FINANCIAL_CONNECTIONS_ACCOUNTS_ACCOUNT_OWNERS_MAX_LENGTH_FOR_OWNERSHIP)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_FINANCIAL_CONNECTIONS_ACCOUNTS_ACCOUNT_OWNERS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_FINANCIAL_CONNECTIONS_ACCOUNTS_ACCOUNT_OWNERS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/financial_connections/accounts/{account}/owners".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["ownership"] = ownership.to_s if !ownership.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_financial_connections_accounts_account_owners",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of a Financial Connections <code>Session</code></p>
    # @param session [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [FinancialConnectionsSession]
    def get_financial_connections_sessions_session(*, session : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_financial_connections_sessions_session_with_http_info(session: session, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of a Financial Connections &lt;code&gt;Session&lt;/code&gt;&lt;/p&gt;
    # @param session [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(FinancialConnectionsSession, Integer, Hash)>] FinancialConnectionsSession data, response status code and response headers
    def get_financial_connections_sessions_session_with_http_info(*, session : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_financial_connections_sessions_session(session: session, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_financial_connections_sessions_session\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FinancialConnectionsSession.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of a Financial Connections &lt;code&gt;Session&lt;/code&gt;&lt;/p&gt;
    # @param session [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_financial_connections_sessions_session(*, session : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_financial_connections_sessions_session(session: session, expand: expand).execute(&block)
    end

    GET_FINANCIAL_CONNECTIONS_SESSIONS_SESSION_MAX_LENGTH_FOR_SESSION = 5000

    # @return Crest::Request
    def build_api_request_for_get_financial_connections_sessions_session(*, session : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_financial_connections_sessions_session ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"session\" is required and cannot be null") if session.nil?
        if _session = session
          OpenApi::PrimitiveValidator.validate_max_length("session", session.to_s.size, GET_FINANCIAL_CONNECTIONS_SESSIONS_SESSION_MAX_LENGTH_FOR_SESSION)
        end
      end

      # resource path
      local_var_path = "/v1/financial_connections/sessions/{session}".sub("{" + "session" + "}", URI.encode_path(session.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_financial_connections_sessions_session",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>List all verification reports.</p>
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param _type [String?] Only return VerificationReports of this type
    # @optional @param verification_session [String?] Only return VerificationReports created by this VerificationSession ID. It is allowed to provide a VerificationIntent ID.
    # @return [GelatoVerificationReportList]
    def get_identity_verification_reports(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, _type : String? = nil, verification_session : String? = nil)
      data, _status_code, _headers = get_identity_verification_reports_with_http_info(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, _type: _type, verification_session: verification_session)
      data
    end

    # &lt;p&gt;List all verification reports.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param _type [String?] Only return VerificationReports of this type
    # @optional @param verification_session [String?] Only return VerificationReports created by this VerificationSession ID. It is allowed to provide a VerificationIntent ID.
    # @return [Array<(GelatoVerificationReportList, Integer, Hash)>] GelatoVerificationReportList data, response status code and response headers
    def get_identity_verification_reports_with_http_info(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, _type : String? = nil, verification_session : String? = nil)
      request = build_api_request_for_get_identity_verification_reports(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, _type: _type, verification_session: verification_session)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_identity_verification_reports\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return GelatoVerificationReportList.from_json(data), status_code, headers
    end

    # &lt;p&gt;List all verification reports.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param _type [String?] Only return VerificationReports of this type
    # @optional @param verification_session [String?] Only return VerificationReports created by this VerificationSession ID. It is allowed to provide a VerificationIntent ID.
    # @return nil
    def get_identity_verification_reports(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, _type : String? = nil, verification_session : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_identity_verification_reports(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, _type: _type, verification_session: verification_session).execute(&block)
    end

    GET_IDENTITY_VERIFICATION_REPORTS_MAX_LENGTH_FOR_ENDING_BEFORE        = 5000
    GET_IDENTITY_VERIFICATION_REPORTS_MAX_LENGTH_FOR_STARTING_AFTER       = 5000
    GET_IDENTITY_VERIFICATION_REPORTS_VALID_VALUES_FOR__TYPE              = StaticArray["document", "id_number"]
    GET_IDENTITY_VERIFICATION_REPORTS_MAX_LENGTH_FOR_VERIFICATION_SESSION = 5000

    # @return Crest::Request
    def build_api_request_for_get_identity_verification_reports(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, _type : String? = nil, verification_session : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_identity_verification_reports ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_IDENTITY_VERIFICATION_REPORTS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_IDENTITY_VERIFICATION_REPORTS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if __type = _type
          OpenApi::EnumValidator.validate("_type", __type, GET_IDENTITY_VERIFICATION_REPORTS_VALID_VALUES_FOR__TYPE)
        end
        if _verification_session = verification_session
          OpenApi::PrimitiveValidator.validate_max_length("verification_session", verification_session.to_s.size, GET_IDENTITY_VERIFICATION_REPORTS_MAX_LENGTH_FOR_VERIFICATION_SESSION)
        end
      end

      # resource path
      local_var_path = "/v1/identity/verification_reports"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["type"] = _type.to_s if !_type.nil?
      query_params["verification_session"] = verification_session.to_s if !verification_session.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_identity_verification_reports",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves an existing VerificationReport</p>
    # @param report [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [IdentityVerificationReport]
    def get_identity_verification_reports_report(*, report : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_identity_verification_reports_report_with_http_info(report: report, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves an existing VerificationReport&lt;/p&gt;
    # @param report [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(IdentityVerificationReport, Integer, Hash)>] IdentityVerificationReport data, response status code and response headers
    def get_identity_verification_reports_report_with_http_info(*, report : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_identity_verification_reports_report(report: report, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_identity_verification_reports_report\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IdentityVerificationReport.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves an existing VerificationReport&lt;/p&gt;
    # @param report [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_identity_verification_reports_report(*, report : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_identity_verification_reports_report(report: report, expand: expand).execute(&block)
    end

    GET_IDENTITY_VERIFICATION_REPORTS_REPORT_MAX_LENGTH_FOR_REPORT = 5000

    # @return Crest::Request
    def build_api_request_for_get_identity_verification_reports_report(*, report : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_identity_verification_reports_report ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"report\" is required and cannot be null") if report.nil?
        if _report = report
          OpenApi::PrimitiveValidator.validate_max_length("report", report.to_s.size, GET_IDENTITY_VERIFICATION_REPORTS_REPORT_MAX_LENGTH_FOR_REPORT)
        end
      end

      # resource path
      local_var_path = "/v1/identity/verification_reports/{report}".sub("{" + "report" + "}", URI.encode_path(report.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_identity_verification_reports_report",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of VerificationSessions</p>
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return VerificationSessions with this status. [Learn more about the lifecycle of sessions](https://stripe.com/docs/identity/how-sessions-work).
    # @return [GelatoVerificationSessionList]
    def get_identity_verification_sessions(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil)
      data, _status_code, _headers = get_identity_verification_sessions_with_http_info(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status)
      data
    end

    # &lt;p&gt;Returns a list of VerificationSessions&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return VerificationSessions with this status. [Learn more about the lifecycle of sessions](https://stripe.com/docs/identity/how-sessions-work).
    # @return [Array<(GelatoVerificationSessionList, Integer, Hash)>] GelatoVerificationSessionList data, response status code and response headers
    def get_identity_verification_sessions_with_http_info(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil)
      request = build_api_request_for_get_identity_verification_sessions(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_identity_verification_sessions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return GelatoVerificationSessionList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of VerificationSessions&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return VerificationSessions with this status. [Learn more about the lifecycle of sessions](https://stripe.com/docs/identity/how-sessions-work).
    # @return nil
    def get_identity_verification_sessions(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_identity_verification_sessions(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status).execute(&block)
    end

    GET_IDENTITY_VERIFICATION_SESSIONS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_IDENTITY_VERIFICATION_SESSIONS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_IDENTITY_VERIFICATION_SESSIONS_VALID_VALUES_FOR_STATUS       = StaticArray["canceled", "processing", "requires_input", "verified"]

    # @return Crest::Request
    def build_api_request_for_get_identity_verification_sessions(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_identity_verification_sessions ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_IDENTITY_VERIFICATION_SESSIONS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_IDENTITY_VERIFICATION_SESSIONS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, GET_IDENTITY_VERIFICATION_SESSIONS_VALID_VALUES_FOR_STATUS)
        end
      end

      # resource path
      local_var_path = "/v1/identity/verification_sessions"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["status"] = status.to_s if !status.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_identity_verification_sessions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of a VerificationSession that was previously created.</p>  <p>When the session status is <code>requires_input</code>, you can use this method to retrieve a valid <code>client_secret</code> or <code>url</code> to allow re-submission.</p>
    # @param session [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [IdentityVerificationSession]
    def get_identity_verification_sessions_session(*, session : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_identity_verification_sessions_session_with_http_info(session: session, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of a VerificationSession that was previously created.&lt;/p&gt;  &lt;p&gt;When the session status is &lt;code&gt;requires_input&lt;/code&gt;, you can use this method to retrieve a valid &lt;code&gt;client_secret&lt;/code&gt; or &lt;code&gt;url&lt;/code&gt; to allow re-submission.&lt;/p&gt;
    # @param session [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(IdentityVerificationSession, Integer, Hash)>] IdentityVerificationSession data, response status code and response headers
    def get_identity_verification_sessions_session_with_http_info(*, session : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_identity_verification_sessions_session(session: session, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_identity_verification_sessions_session\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IdentityVerificationSession.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of a VerificationSession that was previously created.&lt;/p&gt;  &lt;p&gt;When the session status is &lt;code&gt;requires_input&lt;/code&gt;, you can use this method to retrieve a valid &lt;code&gt;client_secret&lt;/code&gt; or &lt;code&gt;url&lt;/code&gt; to allow re-submission.&lt;/p&gt;
    # @param session [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_identity_verification_sessions_session(*, session : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_identity_verification_sessions_session(session: session, expand: expand).execute(&block)
    end

    GET_IDENTITY_VERIFICATION_SESSIONS_SESSION_MAX_LENGTH_FOR_SESSION = 5000

    # @return Crest::Request
    def build_api_request_for_get_identity_verification_sessions_session(*, session : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_identity_verification_sessions_session ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"session\" is required and cannot be null") if session.nil?
        if _session = session
          OpenApi::PrimitiveValidator.validate_max_length("session", session.to_s.size, GET_IDENTITY_VERIFICATION_SESSIONS_SESSION_MAX_LENGTH_FOR_SESSION)
        end
      end

      # resource path
      local_var_path = "/v1/identity/verification_sessions/{session}".sub("{" + "session" + "}", URI.encode_path(session.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_identity_verification_sessions_session",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of your invoice items. Invoice items are returned sorted by creation date, with the most recently created invoice items appearing first.</p>
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param customer [String?] The identifier of the customer whose invoice items to return. If none is provided, all invoice items will be returned.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param invoice [String?] Only return invoice items belonging to this invoice. If none is provided, all invoice items will be returned. If specifying an invoice, no customer identifier is needed.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param pending [Bool?] Set to `true` to only show pending invoice items, which are not yet attached to any invoices. Set to `false` to only show invoice items already attached to invoices. If unspecified, no filter is applied.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [InvoicesItemsList]
    def get_invoiceitems(*, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, invoice : String? = nil, limit : Int64? = nil, pending : Bool? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_invoiceitems_with_http_info(created: created, customer: customer, ending_before: ending_before, expand: expand, invoice: invoice, limit: limit, pending: pending, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of your invoice items. Invoice items are returned sorted by creation date, with the most recently created invoice items appearing first.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param customer [String?] The identifier of the customer whose invoice items to return. If none is provided, all invoice items will be returned.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param invoice [String?] Only return invoice items belonging to this invoice. If none is provided, all invoice items will be returned. If specifying an invoice, no customer identifier is needed.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param pending [Bool?] Set to `true` to only show pending invoice items, which are not yet attached to any invoices. Set to `false` to only show invoice items already attached to invoices. If unspecified, no filter is applied.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(InvoicesItemsList, Integer, Hash)>] InvoicesItemsList data, response status code and response headers
    def get_invoiceitems_with_http_info(*, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, invoice : String? = nil, limit : Int64? = nil, pending : Bool? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_invoiceitems(created: created, customer: customer, ending_before: ending_before, expand: expand, invoice: invoice, limit: limit, pending: pending, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_invoiceitems\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return InvoicesItemsList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of your invoice items. Invoice items are returned sorted by creation date, with the most recently created invoice items appearing first.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param customer [String?] The identifier of the customer whose invoice items to return. If none is provided, all invoice items will be returned.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param invoice [String?] Only return invoice items belonging to this invoice. If none is provided, all invoice items will be returned. If specifying an invoice, no customer identifier is needed.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param pending [Bool?] Set to `true` to only show pending invoice items, which are not yet attached to any invoices. Set to `false` to only show invoice items already attached to invoices. If unspecified, no filter is applied.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_invoiceitems(*, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, invoice : String? = nil, limit : Int64? = nil, pending : Bool? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_invoiceitems(created: created, customer: customer, ending_before: ending_before, expand: expand, invoice: invoice, limit: limit, pending: pending, starting_after: starting_after).execute(&block)
    end

    GET_INVOICEITEMS_MAX_LENGTH_FOR_CUSTOMER       = 5000
    GET_INVOICEITEMS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_INVOICEITEMS_MAX_LENGTH_FOR_INVOICE        = 5000
    GET_INVOICEITEMS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_invoiceitems(*, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, invoice : String? = nil, limit : Int64? = nil, pending : Bool? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_invoiceitems ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_INVOICEITEMS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_INVOICEITEMS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _invoice = invoice
          OpenApi::PrimitiveValidator.validate_max_length("invoice", invoice.to_s.size, GET_INVOICEITEMS_MAX_LENGTH_FOR_INVOICE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_INVOICEITEMS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/invoiceitems"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["customer"] = customer.to_s if !customer.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["invoice"] = invoice.to_s if !invoice.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["pending"] = pending.to_s if !pending.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_invoiceitems",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the invoice item with the given ID.</p>
    # @param invoiceitem [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Invoiceitem]
    def get_invoiceitems_invoiceitem(*, invoiceitem : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_invoiceitems_invoiceitem_with_http_info(invoiceitem: invoiceitem, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the invoice item with the given ID.&lt;/p&gt;
    # @param invoiceitem [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Invoiceitem, Integer, Hash)>] Invoiceitem data, response status code and response headers
    def get_invoiceitems_invoiceitem_with_http_info(*, invoiceitem : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_invoiceitems_invoiceitem(invoiceitem: invoiceitem, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_invoiceitems_invoiceitem\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Invoiceitem.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the invoice item with the given ID.&lt;/p&gt;
    # @param invoiceitem [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_invoiceitems_invoiceitem(*, invoiceitem : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_invoiceitems_invoiceitem(invoiceitem: invoiceitem, expand: expand).execute(&block)
    end

    GET_INVOICEITEMS_INVOICEITEM_MAX_LENGTH_FOR_INVOICEITEM = 5000

    # @return Crest::Request
    def build_api_request_for_get_invoiceitems_invoiceitem(*, invoiceitem : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_invoiceitems_invoiceitem ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"invoiceitem\" is required and cannot be null") if invoiceitem.nil?
        if _invoiceitem = invoiceitem
          OpenApi::PrimitiveValidator.validate_max_length("invoiceitem", invoiceitem.to_s.size, GET_INVOICEITEMS_INVOICEITEM_MAX_LENGTH_FOR_INVOICEITEM)
        end
      end

      # resource path
      local_var_path = "/v1/invoiceitems/{invoiceitem}".sub("{" + "invoiceitem" + "}", URI.encode_path(invoiceitem.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_invoiceitems_invoiceitem",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>You can list all invoices, or list the invoices for a specific customer. The invoices are returned sorted by creation date, with the most recently created invoices appearing first.</p>
    # @optional @param collection_method [String?] The collection method of the invoice to retrieve. Either `charge_automatically` or `send_invoice`.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param customer [String?] Only return invoices for the customer specified by this customer ID.
    # @optional @param due_date [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] The status of the invoice, one of `draft`, `open`, `paid`, `uncollectible`, or `void`. [Learn more](https://stripe.com/docs/billing/invoices/workflow#workflow-overview)
    # @optional @param subscription [String?] Only return invoices for the subscription specified by this subscription ID.
    # @return [InvoicesList]
    def get_invoices(*, collection_method : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, due_date : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, subscription : String? = nil)
      data, _status_code, _headers = get_invoices_with_http_info(collection_method: collection_method, created: created, customer: customer, due_date: due_date, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status, subscription: subscription)
      data
    end

    # &lt;p&gt;You can list all invoices, or list the invoices for a specific customer. The invoices are returned sorted by creation date, with the most recently created invoices appearing first.&lt;/p&gt;
    # @optional @param collection_method [String?] The collection method of the invoice to retrieve. Either `charge_automatically` or `send_invoice`.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param customer [String?] Only return invoices for the customer specified by this customer ID.
    # @optional @param due_date [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] The status of the invoice, one of `draft`, `open`, `paid`, `uncollectible`, or `void`. [Learn more](https://stripe.com/docs/billing/invoices/workflow#workflow-overview)
    # @optional @param subscription [String?] Only return invoices for the subscription specified by this subscription ID.
    # @return [Array<(InvoicesList, Integer, Hash)>] InvoicesList data, response status code and response headers
    def get_invoices_with_http_info(*, collection_method : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, due_date : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, subscription : String? = nil)
      request = build_api_request_for_get_invoices(collection_method: collection_method, created: created, customer: customer, due_date: due_date, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status, subscription: subscription)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_invoices\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return InvoicesList.from_json(data), status_code, headers
    end

    # &lt;p&gt;You can list all invoices, or list the invoices for a specific customer. The invoices are returned sorted by creation date, with the most recently created invoices appearing first.&lt;/p&gt;
    # @optional @param collection_method [String?] The collection method of the invoice to retrieve. Either `charge_automatically` or `send_invoice`.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param customer [String?] Only return invoices for the customer specified by this customer ID.
    # @optional @param due_date [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] The status of the invoice, one of `draft`, `open`, `paid`, `uncollectible`, or `void`. [Learn more](https://stripe.com/docs/billing/invoices/workflow#workflow-overview)
    # @optional @param subscription [String?] Only return invoices for the subscription specified by this subscription ID.
    # @return nil
    def get_invoices(*, collection_method : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, due_date : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, subscription : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_invoices(collection_method: collection_method, created: created, customer: customer, due_date: due_date, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status, subscription: subscription).execute(&block)
    end

    GET_INVOICES_VALID_VALUES_FOR_COLLECTION_METHOD = StaticArray["charge_automatically", "send_invoice"]
    GET_INVOICES_MAX_LENGTH_FOR_CUSTOMER            = 5000
    GET_INVOICES_MAX_LENGTH_FOR_ENDING_BEFORE       = 5000
    GET_INVOICES_MAX_LENGTH_FOR_STARTING_AFTER      = 5000
    GET_INVOICES_MAX_LENGTH_FOR_STATUS              = 5000
    GET_INVOICES_VALID_VALUES_FOR_STATUS            = StaticArray["draft", "open", "paid", "uncollectible", "void"]
    GET_INVOICES_MAX_LENGTH_FOR_SUBSCRIPTION        = 5000

    # @return Crest::Request
    def build_api_request_for_get_invoices(*, collection_method : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, due_date : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, subscription : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_invoices ..." }
      end

      if client_side_validation
        if _collection_method = collection_method
          OpenApi::EnumValidator.validate("collection_method", _collection_method, GET_INVOICES_VALID_VALUES_FOR_COLLECTION_METHOD)
        end
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_INVOICES_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _due_date = due_date
          _due_date.validate if _due_date.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_INVOICES_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_INVOICES_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, GET_INVOICES_VALID_VALUES_FOR_STATUS)
        end
        if _subscription = subscription
          OpenApi::PrimitiveValidator.validate_max_length("subscription", subscription.to_s.size, GET_INVOICES_MAX_LENGTH_FOR_SUBSCRIPTION)
        end
      end

      # resource path
      local_var_path = "/v1/invoices"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["collection_method"] = collection_method.to_s if !collection_method.nil?
      query_params["created"] = created.to_s if !created.nil?
      query_params["customer"] = customer.to_s if !customer.nil?
      query_params["due_date"] = due_date.to_s if !due_date.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["status"] = status.to_s if !status.nil?
      query_params["subscription"] = subscription.to_s if !subscription.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_invoices",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the invoice with the given ID.</p>
    # @param invoice [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Invoice]
    def get_invoices_invoice(*, invoice : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_invoices_invoice_with_http_info(invoice: invoice, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the invoice with the given ID.&lt;/p&gt;
    # @param invoice [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Invoice, Integer, Hash)>] Invoice data, response status code and response headers
    def get_invoices_invoice_with_http_info(*, invoice : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_invoices_invoice(invoice: invoice, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_invoices_invoice\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Invoice.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the invoice with the given ID.&lt;/p&gt;
    # @param invoice [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_invoices_invoice(*, invoice : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_invoices_invoice(invoice: invoice, expand: expand).execute(&block)
    end

    GET_INVOICES_INVOICE_MAX_LENGTH_FOR_INVOICE = 5000

    # @return Crest::Request
    def build_api_request_for_get_invoices_invoice(*, invoice : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_invoices_invoice ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"invoice\" is required and cannot be null") if invoice.nil?
        if _invoice = invoice
          OpenApi::PrimitiveValidator.validate_max_length("invoice", invoice.to_s.size, GET_INVOICES_INVOICE_MAX_LENGTH_FOR_INVOICE)
        end
      end

      # resource path
      local_var_path = "/v1/invoices/{invoice}".sub("{" + "invoice" + "}", URI.encode_path(invoice.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_invoices_invoice",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>When retrieving an invoice, you’ll get a <strong>lines</strong> property containing the total count of line items and the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.</p>
    # @param invoice [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [InvoiceLinesList]
    def get_invoices_invoice_lines(*, invoice : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_invoices_invoice_lines_with_http_info(invoice: invoice, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;When retrieving an invoice, you’ll get a &lt;strong&gt;lines&lt;/strong&gt; property containing the total count of line items and the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.&lt;/p&gt;
    # @param invoice [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(InvoiceLinesList, Integer, Hash)>] InvoiceLinesList data, response status code and response headers
    def get_invoices_invoice_lines_with_http_info(*, invoice : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_invoices_invoice_lines(invoice: invoice, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_invoices_invoice_lines\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return InvoiceLinesList.from_json(data), status_code, headers
    end

    # &lt;p&gt;When retrieving an invoice, you’ll get a &lt;strong&gt;lines&lt;/strong&gt; property containing the total count of line items and the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.&lt;/p&gt;
    # @param invoice [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_invoices_invoice_lines(*, invoice : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_invoices_invoice_lines(invoice: invoice, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_INVOICES_INVOICE_LINES_MAX_LENGTH_FOR_INVOICE        = 5000
    GET_INVOICES_INVOICE_LINES_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_INVOICES_INVOICE_LINES_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_invoices_invoice_lines(*, invoice : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_invoices_invoice_lines ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"invoice\" is required and cannot be null") if invoice.nil?
        if _invoice = invoice
          OpenApi::PrimitiveValidator.validate_max_length("invoice", invoice.to_s.size, GET_INVOICES_INVOICE_LINES_MAX_LENGTH_FOR_INVOICE)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_INVOICES_INVOICE_LINES_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_INVOICES_INVOICE_LINES_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/invoices/{invoice}/lines".sub("{" + "invoice" + "}", URI.encode_path(invoice.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_invoices_invoice_lines",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Search for invoices you’ve previously created using Stripe’s <a href=\"/docs/search#search-query-language\">Search Query Language</a>. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.</p>
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for invoices](https://stripe.com/docs/search#query-fields-for-invoices).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return [SearchResult2]
    def get_invoices_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil)
      data, _status_code, _headers = get_invoices_search_with_http_info(query: query, expand: expand, limit: limit, page: page)
      data
    end

    # &lt;p&gt;Search for invoices you’ve previously created using Stripe’s &lt;a href&#x3D;\&quot;/docs/search#search-query-language\&quot;&gt;Search Query Language&lt;/a&gt;. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.&lt;/p&gt;
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for invoices](https://stripe.com/docs/search#query-fields-for-invoices).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return [Array<(SearchResult2, Integer, Hash)>] SearchResult2 data, response status code and response headers
    def get_invoices_search_with_http_info(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil)
      request = build_api_request_for_get_invoices_search(query: query, expand: expand, limit: limit, page: page)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_invoices_search\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SearchResult2.from_json(data), status_code, headers
    end

    # &lt;p&gt;Search for invoices you’ve previously created using Stripe’s &lt;a href&#x3D;\&quot;/docs/search#search-query-language\&quot;&gt;Search Query Language&lt;/a&gt;. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.&lt;/p&gt;
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for invoices](https://stripe.com/docs/search#query-fields-for-invoices).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return nil
    def get_invoices_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_invoices_search(query: query, expand: expand, limit: limit, page: page).execute(&block)
    end

    GET_INVOICES_SEARCH_MAX_LENGTH_FOR_QUERY = 5000
    GET_INVOICES_SEARCH_MAX_LENGTH_FOR_PAGE  = 5000

    # @return Crest::Request
    def build_api_request_for_get_invoices_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_invoices_search ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"query\" is required and cannot be null") if query.nil?
        if _query = query
          OpenApi::PrimitiveValidator.validate_max_length("query", query.to_s.size, GET_INVOICES_SEARCH_MAX_LENGTH_FOR_QUERY)
        end

        if _page = page
          OpenApi::PrimitiveValidator.validate_max_length("page", page.to_s.size, GET_INVOICES_SEARCH_MAX_LENGTH_FOR_PAGE)
        end
      end

      # resource path
      local_var_path = "/v1/invoices/search"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["page"] = page.to_s if !page.nil?
      query_params["query"] = query.to_s if !query.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_invoices_search",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>At any time, you can preview the upcoming invoice for a customer. This will show you all the charges that are pending, including subscription renewal charges, invoice item charges, etc. It will also show you any discounts that are applicable to the invoice.</p>  <p>Note that when you are viewing an upcoming invoice, you are simply viewing a preview – the invoice has not yet been created. As such, the upcoming invoice will not show up in invoice listing calls, and you cannot use the API to pay or edit the invoice. If you want to change the amount that your customer will be billed, you can add, remove, or update pending invoice items, or update the customer’s discount.</p>  <p>You can preview the effects of updating a subscription, including a preview of what proration will take place. To ensure that the actual proration is calculated exactly the same as the previewed proration, you should pass a <code>proration_date</code> parameter when doing the actual subscription update. The value passed in should be the same as the <code>subscription_proration_date</code> returned on the upcoming invoice resource. The recommended way to get only the prorations being previewed is to consider only proration line items where <code>period[start]</code> is equal to the <code>subscription_proration_date</code> on the upcoming invoice resource.</p>
    # @optional @param automatic_tax [Stripe::AutomaticTaxParam1?] Settings for automatic tax lookup for this invoice preview.
    # @optional @param coupon [String?] The code of the coupon to apply. If `subscription` or `subscription_items` is provided, the invoice returned will preview updating or creating a subscription with that coupon. Otherwise, it will preview applying that coupon to the customer for the next upcoming invoice from among the customer's subscriptions. The invoice can be previewed without a coupon by passing this value as an empty string.
    # @optional @param currency [String?] The currency to preview this invoice in. Defaults to that of `customer` if not specified.
    # @optional @param customer [String?] The identifier of the customer whose upcoming invoice you'd like to retrieve.
    # @optional @param customer_details [Stripe::CustomerDetailsParam?] Details about the customer you want to invoice or overrides for an existing customer.
    # @optional @param discounts [Stripe::GetInvoicesUpcomingDiscountsParameter?] The coupons to redeem into discounts for the invoice preview. If not specified, inherits the discount from the customer or subscription. This only works for coupons directly applied to the invoice. To apply a coupon to a subscription, you must use the `coupon` parameter instead. Pass an empty string to avoid inheriting any discounts. To preview the upcoming invoice for a subscription that hasn't been created, use `coupon` instead.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_items [Array(Array(InvoiceItemPreviewParams))?] List of invoice items to add or update in the upcoming invoice preview.
    # @optional @param schedule [String?] The identifier of the unstarted schedule whose upcoming invoice you'd like to retrieve. Cannot be used with subscription or subscription fields.
    # @optional @param subscription [String?] The identifier of the subscription for which you'd like to retrieve the upcoming invoice. If not provided, but a `subscription_items` is provided, you will preview creating a subscription with those items. If neither `subscription` nor `subscription_items` is provided, you will retrieve the next upcoming invoice from among the customer's subscriptions.
    # @optional @param subscription_billing_cycle_anchor [Stripe::GetInvoicesUpcomingSubscriptionBillingCycleAnchorParameter?] For new subscriptions, a future timestamp to anchor the subscription's [billing cycle](https://stripe.com/docs/subscriptions/billing-cycle). This is used to determine the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices. For existing subscriptions, the value can only be set to `now` or `unchanged`.
    # @optional @param subscription_cancel_at [Stripe::GetInvoicesUpcomingSubscriptionCancelAtParameter?] Timestamp indicating when the subscription should be scheduled to cancel. Will prorate if within the current period and prorations have been enabled using `proration_behavior`.
    # @optional @param subscription_cancel_at_period_end [Bool?] Boolean indicating whether this subscription should cancel at the end of the current period.
    # @optional @param subscription_cancel_now [Bool?] This simulates the subscription being canceled or expired immediately.
    # @optional @param subscription_default_tax_rates [Stripe::CreditNoteLineItemParamsTaxRates?] If provided, the invoice returned will preview updating or creating a subscription with these default tax rates. The default tax rates will apply to any line item that does not have `tax_rates` set.
    # @optional @param subscription_items [Array(Array(SubscriptionItemUpdateParams))?] A list of up to 20 subscription items, each with an attached price.
    # @optional @param subscription_proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param subscription_proration_date [Int64?] If previewing an update to a subscription, and doing proration, `subscription_proration_date` forces the proration to be calculated as though the update was done at the specified time. The time given must be within the current subscription period, and cannot be before the subscription was on its current plan. If set, `subscription`, and one of `subscription_items`, or `subscription_trial_end` are required. Also, `subscription_proration_behavior` cannot be set to 'none'.
    # @optional @param subscription_start_date [Int64?] Date a subscription is intended to start (can be future or past)
    # @optional @param subscription_trial_end [Stripe::GetInvoicesUpcomingSubscriptionTrialEndParameter?] If provided, the invoice returned will preview updating or creating a subscription with that trial end. If set, one of `subscription_items` or `subscription` is required.
    # @optional @param subscription_trial_from_plan [Bool?] Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `subscription_trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `subscription_trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @return [Invoice]
    def get_invoices_upcoming(*, automatic_tax : Stripe::AutomaticTaxParam1? = nil, coupon : String? = nil, currency : String? = nil, customer : String? = nil, customer_details : Stripe::CustomerDetailsParam? = nil, discounts : Stripe::GetInvoicesUpcomingDiscountsParameter? = nil, expand : Array(Array(String))? = nil, invoice_items : Array(Array(InvoiceItemPreviewParams))? = nil, schedule : String? = nil, subscription : String? = nil, subscription_billing_cycle_anchor : Stripe::GetInvoicesUpcomingSubscriptionBillingCycleAnchorParameter? = nil, subscription_cancel_at : Stripe::GetInvoicesUpcomingSubscriptionCancelAtParameter? = nil, subscription_cancel_at_period_end : Bool? = nil, subscription_cancel_now : Bool? = nil, subscription_default_tax_rates : Stripe::CreditNoteLineItemParamsTaxRates? = nil, subscription_items : Array(Array(SubscriptionItemUpdateParams))? = nil, subscription_proration_behavior : String? = nil, subscription_proration_date : Int64? = nil, subscription_start_date : Int64? = nil, subscription_trial_end : Stripe::GetInvoicesUpcomingSubscriptionTrialEndParameter? = nil, subscription_trial_from_plan : Bool? = nil)
      data, _status_code, _headers = get_invoices_upcoming_with_http_info(automatic_tax: automatic_tax, coupon: coupon, currency: currency, customer: customer, customer_details: customer_details, discounts: discounts, expand: expand, invoice_items: invoice_items, schedule: schedule, subscription: subscription, subscription_billing_cycle_anchor: subscription_billing_cycle_anchor, subscription_cancel_at: subscription_cancel_at, subscription_cancel_at_period_end: subscription_cancel_at_period_end, subscription_cancel_now: subscription_cancel_now, subscription_default_tax_rates: subscription_default_tax_rates, subscription_items: subscription_items, subscription_proration_behavior: subscription_proration_behavior, subscription_proration_date: subscription_proration_date, subscription_start_date: subscription_start_date, subscription_trial_end: subscription_trial_end, subscription_trial_from_plan: subscription_trial_from_plan)
      data
    end

    # &lt;p&gt;At any time, you can preview the upcoming invoice for a customer. This will show you all the charges that are pending, including subscription renewal charges, invoice item charges, etc. It will also show you any discounts that are applicable to the invoice.&lt;/p&gt;  &lt;p&gt;Note that when you are viewing an upcoming invoice, you are simply viewing a preview – the invoice has not yet been created. As such, the upcoming invoice will not show up in invoice listing calls, and you cannot use the API to pay or edit the invoice. If you want to change the amount that your customer will be billed, you can add, remove, or update pending invoice items, or update the customer’s discount.&lt;/p&gt;  &lt;p&gt;You can preview the effects of updating a subscription, including a preview of what proration will take place. To ensure that the actual proration is calculated exactly the same as the previewed proration, you should pass a &lt;code&gt;proration_date&lt;/code&gt; parameter when doing the actual subscription update. The value passed in should be the same as the &lt;code&gt;subscription_proration_date&lt;/code&gt; returned on the upcoming invoice resource. The recommended way to get only the prorations being previewed is to consider only proration line items where &lt;code&gt;period[start]&lt;/code&gt; is equal to the &lt;code&gt;subscription_proration_date&lt;/code&gt; on the upcoming invoice resource.&lt;/p&gt;
    # @optional @param automatic_tax [Stripe::AutomaticTaxParam1?] Settings for automatic tax lookup for this invoice preview.
    # @optional @param coupon [String?] The code of the coupon to apply. If `subscription` or `subscription_items` is provided, the invoice returned will preview updating or creating a subscription with that coupon. Otherwise, it will preview applying that coupon to the customer for the next upcoming invoice from among the customer's subscriptions. The invoice can be previewed without a coupon by passing this value as an empty string.
    # @optional @param currency [String?] The currency to preview this invoice in. Defaults to that of `customer` if not specified.
    # @optional @param customer [String?] The identifier of the customer whose upcoming invoice you'd like to retrieve.
    # @optional @param customer_details [Stripe::CustomerDetailsParam?] Details about the customer you want to invoice or overrides for an existing customer.
    # @optional @param discounts [Stripe::GetInvoicesUpcomingDiscountsParameter?] The coupons to redeem into discounts for the invoice preview. If not specified, inherits the discount from the customer or subscription. This only works for coupons directly applied to the invoice. To apply a coupon to a subscription, you must use the `coupon` parameter instead. Pass an empty string to avoid inheriting any discounts. To preview the upcoming invoice for a subscription that hasn't been created, use `coupon` instead.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_items [Array(Array(InvoiceItemPreviewParams))?] List of invoice items to add or update in the upcoming invoice preview.
    # @optional @param schedule [String?] The identifier of the unstarted schedule whose upcoming invoice you'd like to retrieve. Cannot be used with subscription or subscription fields.
    # @optional @param subscription [String?] The identifier of the subscription for which you'd like to retrieve the upcoming invoice. If not provided, but a `subscription_items` is provided, you will preview creating a subscription with those items. If neither `subscription` nor `subscription_items` is provided, you will retrieve the next upcoming invoice from among the customer's subscriptions.
    # @optional @param subscription_billing_cycle_anchor [Stripe::GetInvoicesUpcomingSubscriptionBillingCycleAnchorParameter?] For new subscriptions, a future timestamp to anchor the subscription's [billing cycle](https://stripe.com/docs/subscriptions/billing-cycle). This is used to determine the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices. For existing subscriptions, the value can only be set to `now` or `unchanged`.
    # @optional @param subscription_cancel_at [Stripe::GetInvoicesUpcomingSubscriptionCancelAtParameter?] Timestamp indicating when the subscription should be scheduled to cancel. Will prorate if within the current period and prorations have been enabled using `proration_behavior`.
    # @optional @param subscription_cancel_at_period_end [Bool?] Boolean indicating whether this subscription should cancel at the end of the current period.
    # @optional @param subscription_cancel_now [Bool?] This simulates the subscription being canceled or expired immediately.
    # @optional @param subscription_default_tax_rates [Stripe::CreditNoteLineItemParamsTaxRates?] If provided, the invoice returned will preview updating or creating a subscription with these default tax rates. The default tax rates will apply to any line item that does not have `tax_rates` set.
    # @optional @param subscription_items [Array(Array(SubscriptionItemUpdateParams))?] A list of up to 20 subscription items, each with an attached price.
    # @optional @param subscription_proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param subscription_proration_date [Int64?] If previewing an update to a subscription, and doing proration, `subscription_proration_date` forces the proration to be calculated as though the update was done at the specified time. The time given must be within the current subscription period, and cannot be before the subscription was on its current plan. If set, `subscription`, and one of `subscription_items`, or `subscription_trial_end` are required. Also, `subscription_proration_behavior` cannot be set to 'none'.
    # @optional @param subscription_start_date [Int64?] Date a subscription is intended to start (can be future or past)
    # @optional @param subscription_trial_end [Stripe::GetInvoicesUpcomingSubscriptionTrialEndParameter?] If provided, the invoice returned will preview updating or creating a subscription with that trial end. If set, one of `subscription_items` or `subscription` is required.
    # @optional @param subscription_trial_from_plan [Bool?] Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `subscription_trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `subscription_trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @return [Array<(Invoice, Integer, Hash)>] Invoice data, response status code and response headers
    def get_invoices_upcoming_with_http_info(*, automatic_tax : Stripe::AutomaticTaxParam1? = nil, coupon : String? = nil, currency : String? = nil, customer : String? = nil, customer_details : Stripe::CustomerDetailsParam? = nil, discounts : Stripe::GetInvoicesUpcomingDiscountsParameter? = nil, expand : Array(Array(String))? = nil, invoice_items : Array(Array(InvoiceItemPreviewParams))? = nil, schedule : String? = nil, subscription : String? = nil, subscription_billing_cycle_anchor : Stripe::GetInvoicesUpcomingSubscriptionBillingCycleAnchorParameter? = nil, subscription_cancel_at : Stripe::GetInvoicesUpcomingSubscriptionCancelAtParameter? = nil, subscription_cancel_at_period_end : Bool? = nil, subscription_cancel_now : Bool? = nil, subscription_default_tax_rates : Stripe::CreditNoteLineItemParamsTaxRates? = nil, subscription_items : Array(Array(SubscriptionItemUpdateParams))? = nil, subscription_proration_behavior : String? = nil, subscription_proration_date : Int64? = nil, subscription_start_date : Int64? = nil, subscription_trial_end : Stripe::GetInvoicesUpcomingSubscriptionTrialEndParameter? = nil, subscription_trial_from_plan : Bool? = nil)
      request = build_api_request_for_get_invoices_upcoming(automatic_tax: automatic_tax, coupon: coupon, currency: currency, customer: customer, customer_details: customer_details, discounts: discounts, expand: expand, invoice_items: invoice_items, schedule: schedule, subscription: subscription, subscription_billing_cycle_anchor: subscription_billing_cycle_anchor, subscription_cancel_at: subscription_cancel_at, subscription_cancel_at_period_end: subscription_cancel_at_period_end, subscription_cancel_now: subscription_cancel_now, subscription_default_tax_rates: subscription_default_tax_rates, subscription_items: subscription_items, subscription_proration_behavior: subscription_proration_behavior, subscription_proration_date: subscription_proration_date, subscription_start_date: subscription_start_date, subscription_trial_end: subscription_trial_end, subscription_trial_from_plan: subscription_trial_from_plan)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_invoices_upcoming\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Invoice.from_json(data), status_code, headers
    end

    # &lt;p&gt;At any time, you can preview the upcoming invoice for a customer. This will show you all the charges that are pending, including subscription renewal charges, invoice item charges, etc. It will also show you any discounts that are applicable to the invoice.&lt;/p&gt;  &lt;p&gt;Note that when you are viewing an upcoming invoice, you are simply viewing a preview – the invoice has not yet been created. As such, the upcoming invoice will not show up in invoice listing calls, and you cannot use the API to pay or edit the invoice. If you want to change the amount that your customer will be billed, you can add, remove, or update pending invoice items, or update the customer’s discount.&lt;/p&gt;  &lt;p&gt;You can preview the effects of updating a subscription, including a preview of what proration will take place. To ensure that the actual proration is calculated exactly the same as the previewed proration, you should pass a &lt;code&gt;proration_date&lt;/code&gt; parameter when doing the actual subscription update. The value passed in should be the same as the &lt;code&gt;subscription_proration_date&lt;/code&gt; returned on the upcoming invoice resource. The recommended way to get only the prorations being previewed is to consider only proration line items where &lt;code&gt;period[start]&lt;/code&gt; is equal to the &lt;code&gt;subscription_proration_date&lt;/code&gt; on the upcoming invoice resource.&lt;/p&gt;
    # @optional @param automatic_tax [Stripe::AutomaticTaxParam1?] Settings for automatic tax lookup for this invoice preview.
    # @optional @param coupon [String?] The code of the coupon to apply. If `subscription` or `subscription_items` is provided, the invoice returned will preview updating or creating a subscription with that coupon. Otherwise, it will preview applying that coupon to the customer for the next upcoming invoice from among the customer's subscriptions. The invoice can be previewed without a coupon by passing this value as an empty string.
    # @optional @param currency [String?] The currency to preview this invoice in. Defaults to that of `customer` if not specified.
    # @optional @param customer [String?] The identifier of the customer whose upcoming invoice you'd like to retrieve.
    # @optional @param customer_details [Stripe::CustomerDetailsParam?] Details about the customer you want to invoice or overrides for an existing customer.
    # @optional @param discounts [Stripe::GetInvoicesUpcomingDiscountsParameter?] The coupons to redeem into discounts for the invoice preview. If not specified, inherits the discount from the customer or subscription. This only works for coupons directly applied to the invoice. To apply a coupon to a subscription, you must use the `coupon` parameter instead. Pass an empty string to avoid inheriting any discounts. To preview the upcoming invoice for a subscription that hasn't been created, use `coupon` instead.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_items [Array(Array(InvoiceItemPreviewParams))?] List of invoice items to add or update in the upcoming invoice preview.
    # @optional @param schedule [String?] The identifier of the unstarted schedule whose upcoming invoice you'd like to retrieve. Cannot be used with subscription or subscription fields.
    # @optional @param subscription [String?] The identifier of the subscription for which you'd like to retrieve the upcoming invoice. If not provided, but a `subscription_items` is provided, you will preview creating a subscription with those items. If neither `subscription` nor `subscription_items` is provided, you will retrieve the next upcoming invoice from among the customer's subscriptions.
    # @optional @param subscription_billing_cycle_anchor [Stripe::GetInvoicesUpcomingSubscriptionBillingCycleAnchorParameter?] For new subscriptions, a future timestamp to anchor the subscription's [billing cycle](https://stripe.com/docs/subscriptions/billing-cycle). This is used to determine the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices. For existing subscriptions, the value can only be set to `now` or `unchanged`.
    # @optional @param subscription_cancel_at [Stripe::GetInvoicesUpcomingSubscriptionCancelAtParameter?] Timestamp indicating when the subscription should be scheduled to cancel. Will prorate if within the current period and prorations have been enabled using `proration_behavior`.
    # @optional @param subscription_cancel_at_period_end [Bool?] Boolean indicating whether this subscription should cancel at the end of the current period.
    # @optional @param subscription_cancel_now [Bool?] This simulates the subscription being canceled or expired immediately.
    # @optional @param subscription_default_tax_rates [Stripe::CreditNoteLineItemParamsTaxRates?] If provided, the invoice returned will preview updating or creating a subscription with these default tax rates. The default tax rates will apply to any line item that does not have `tax_rates` set.
    # @optional @param subscription_items [Array(Array(SubscriptionItemUpdateParams))?] A list of up to 20 subscription items, each with an attached price.
    # @optional @param subscription_proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param subscription_proration_date [Int64?] If previewing an update to a subscription, and doing proration, `subscription_proration_date` forces the proration to be calculated as though the update was done at the specified time. The time given must be within the current subscription period, and cannot be before the subscription was on its current plan. If set, `subscription`, and one of `subscription_items`, or `subscription_trial_end` are required. Also, `subscription_proration_behavior` cannot be set to 'none'.
    # @optional @param subscription_start_date [Int64?] Date a subscription is intended to start (can be future or past)
    # @optional @param subscription_trial_end [Stripe::GetInvoicesUpcomingSubscriptionTrialEndParameter?] If provided, the invoice returned will preview updating or creating a subscription with that trial end. If set, one of `subscription_items` or `subscription` is required.
    # @optional @param subscription_trial_from_plan [Bool?] Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `subscription_trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `subscription_trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @return nil
    def get_invoices_upcoming(*, automatic_tax : Stripe::AutomaticTaxParam1? = nil, coupon : String? = nil, currency : String? = nil, customer : String? = nil, customer_details : Stripe::CustomerDetailsParam? = nil, discounts : Stripe::GetInvoicesUpcomingDiscountsParameter? = nil, expand : Array(Array(String))? = nil, invoice_items : Array(Array(InvoiceItemPreviewParams))? = nil, schedule : String? = nil, subscription : String? = nil, subscription_billing_cycle_anchor : Stripe::GetInvoicesUpcomingSubscriptionBillingCycleAnchorParameter? = nil, subscription_cancel_at : Stripe::GetInvoicesUpcomingSubscriptionCancelAtParameter? = nil, subscription_cancel_at_period_end : Bool? = nil, subscription_cancel_now : Bool? = nil, subscription_default_tax_rates : Stripe::CreditNoteLineItemParamsTaxRates? = nil, subscription_items : Array(Array(SubscriptionItemUpdateParams))? = nil, subscription_proration_behavior : String? = nil, subscription_proration_date : Int64? = nil, subscription_start_date : Int64? = nil, subscription_trial_end : Stripe::GetInvoicesUpcomingSubscriptionTrialEndParameter? = nil, subscription_trial_from_plan : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_get_invoices_upcoming(automatic_tax: automatic_tax, coupon: coupon, currency: currency, customer: customer, customer_details: customer_details, discounts: discounts, expand: expand, invoice_items: invoice_items, schedule: schedule, subscription: subscription, subscription_billing_cycle_anchor: subscription_billing_cycle_anchor, subscription_cancel_at: subscription_cancel_at, subscription_cancel_at_period_end: subscription_cancel_at_period_end, subscription_cancel_now: subscription_cancel_now, subscription_default_tax_rates: subscription_default_tax_rates, subscription_items: subscription_items, subscription_proration_behavior: subscription_proration_behavior, subscription_proration_date: subscription_proration_date, subscription_start_date: subscription_start_date, subscription_trial_end: subscription_trial_end, subscription_trial_from_plan: subscription_trial_from_plan).execute(&block)
    end

    GET_INVOICES_UPCOMING_MAX_LENGTH_FOR_COUPON                            = 5000
    GET_INVOICES_UPCOMING_MAX_LENGTH_FOR_CUSTOMER                          = 5000
    GET_INVOICES_UPCOMING_MAX_LENGTH_FOR_SCHEDULE                          = 5000
    GET_INVOICES_UPCOMING_MAX_LENGTH_FOR_SUBSCRIPTION                      = 5000
    GET_INVOICES_UPCOMING_VALID_VALUES_FOR_SUBSCRIPTION_PRORATION_BEHAVIOR = StaticArray["always_invoice", "create_prorations", "none"]

    # @return Crest::Request
    def build_api_request_for_get_invoices_upcoming(*, automatic_tax : Stripe::AutomaticTaxParam1? = nil, coupon : String? = nil, currency : String? = nil, customer : String? = nil, customer_details : Stripe::CustomerDetailsParam? = nil, discounts : Stripe::GetInvoicesUpcomingDiscountsParameter? = nil, expand : Array(Array(String))? = nil, invoice_items : Array(Array(InvoiceItemPreviewParams))? = nil, schedule : String? = nil, subscription : String? = nil, subscription_billing_cycle_anchor : Stripe::GetInvoicesUpcomingSubscriptionBillingCycleAnchorParameter? = nil, subscription_cancel_at : Stripe::GetInvoicesUpcomingSubscriptionCancelAtParameter? = nil, subscription_cancel_at_period_end : Bool? = nil, subscription_cancel_now : Bool? = nil, subscription_default_tax_rates : Stripe::CreditNoteLineItemParamsTaxRates? = nil, subscription_items : Array(Array(SubscriptionItemUpdateParams))? = nil, subscription_proration_behavior : String? = nil, subscription_proration_date : Int64? = nil, subscription_start_date : Int64? = nil, subscription_trial_end : Stripe::GetInvoicesUpcomingSubscriptionTrialEndParameter? = nil, subscription_trial_from_plan : Bool? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_invoices_upcoming ..." }
      end

      if client_side_validation
        if _automatic_tax = automatic_tax
          _automatic_tax.validate if _automatic_tax.is_a?(OpenApi::Validatable)
        end
        if _coupon = coupon
          OpenApi::PrimitiveValidator.validate_max_length("coupon", coupon.to_s.size, GET_INVOICES_UPCOMING_MAX_LENGTH_FOR_COUPON)
        end

        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_INVOICES_UPCOMING_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _customer_details = customer_details
          _customer_details.validate if _customer_details.is_a?(OpenApi::Validatable)
        end
        if _discounts = discounts
          _discounts.validate if _discounts.is_a?(OpenApi::Validatable)
        end

        if _schedule = schedule
          OpenApi::PrimitiveValidator.validate_max_length("schedule", schedule.to_s.size, GET_INVOICES_UPCOMING_MAX_LENGTH_FOR_SCHEDULE)
        end
        if _subscription = subscription
          OpenApi::PrimitiveValidator.validate_max_length("subscription", subscription.to_s.size, GET_INVOICES_UPCOMING_MAX_LENGTH_FOR_SUBSCRIPTION)
        end
        if _subscription_billing_cycle_anchor = subscription_billing_cycle_anchor
          _subscription_billing_cycle_anchor.validate if _subscription_billing_cycle_anchor.is_a?(OpenApi::Validatable)
        end
        if _subscription_cancel_at = subscription_cancel_at
          _subscription_cancel_at.validate if _subscription_cancel_at.is_a?(OpenApi::Validatable)
        end

        if _subscription_default_tax_rates = subscription_default_tax_rates
          _subscription_default_tax_rates.validate if _subscription_default_tax_rates.is_a?(OpenApi::Validatable)
        end

        if _subscription_proration_behavior = subscription_proration_behavior
          OpenApi::EnumValidator.validate("subscription_proration_behavior", _subscription_proration_behavior, GET_INVOICES_UPCOMING_VALID_VALUES_FOR_SUBSCRIPTION_PRORATION_BEHAVIOR)
        end

        if _subscription_trial_end = subscription_trial_end
          _subscription_trial_end.validate if _subscription_trial_end.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/invoices/upcoming"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["automatic_tax"] = automatic_tax.to_s if !automatic_tax.nil?
      query_params["coupon"] = coupon.to_s if !coupon.nil?
      query_params["currency"] = currency.to_s if !currency.nil?
      query_params["customer"] = customer.to_s if !customer.nil?
      query_params["customer_details"] = customer_details.to_s if !customer_details.nil?
      query_params["discounts"] = discounts.to_s if !discounts.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["invoice_items"] = @api_client.build_collection_param(invoice_items, "csv") if !invoice_items.nil? && !invoice_items.empty?
      query_params["schedule"] = schedule.to_s if !schedule.nil?
      query_params["subscription"] = subscription.to_s if !subscription.nil?
      query_params["subscription_billing_cycle_anchor"] = subscription_billing_cycle_anchor.to_s if !subscription_billing_cycle_anchor.nil?
      query_params["subscription_cancel_at"] = subscription_cancel_at.to_s if !subscription_cancel_at.nil?
      query_params["subscription_cancel_at_period_end"] = subscription_cancel_at_period_end.to_s if !subscription_cancel_at_period_end.nil?
      query_params["subscription_cancel_now"] = subscription_cancel_now.to_s if !subscription_cancel_now.nil?
      query_params["subscription_default_tax_rates"] = subscription_default_tax_rates.to_s if !subscription_default_tax_rates.nil?
      query_params["subscription_items"] = @api_client.build_collection_param(subscription_items, "csv") if !subscription_items.nil? && !subscription_items.empty?
      query_params["subscription_proration_behavior"] = subscription_proration_behavior.to_s if !subscription_proration_behavior.nil?
      query_params["subscription_proration_date"] = subscription_proration_date.to_s if !subscription_proration_date.nil?
      query_params["subscription_start_date"] = subscription_start_date.to_s if !subscription_start_date.nil?
      query_params["subscription_trial_end"] = subscription_trial_end.to_s if !subscription_trial_end.nil?
      query_params["subscription_trial_from_plan"] = subscription_trial_from_plan.to_s if !subscription_trial_from_plan.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_invoices_upcoming",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>When retrieving an upcoming invoice, you’ll get a <strong>lines</strong> property containing the total count of line items and the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.</p>
    # @optional @param automatic_tax [Stripe::AutomaticTaxParam1?] Settings for automatic tax lookup for this invoice preview.
    # @optional @param coupon [String?] The code of the coupon to apply. If `subscription` or `subscription_items` is provided, the invoice returned will preview updating or creating a subscription with that coupon. Otherwise, it will preview applying that coupon to the customer for the next upcoming invoice from among the customer's subscriptions. The invoice can be previewed without a coupon by passing this value as an empty string.
    # @optional @param currency [String?] The currency to preview this invoice in. Defaults to that of `customer` if not specified.
    # @optional @param customer [String?] The identifier of the customer whose upcoming invoice you'd like to retrieve.
    # @optional @param customer_details [Stripe::CustomerDetailsParam?] Details about the customer you want to invoice or overrides for an existing customer.
    # @optional @param discounts [Stripe::GetInvoicesUpcomingDiscountsParameter?] The coupons to redeem into discounts for the invoice preview. If not specified, inherits the discount from the customer or subscription. This only works for coupons directly applied to the invoice. To apply a coupon to a subscription, you must use the `coupon` parameter instead. Pass an empty string to avoid inheriting any discounts. To preview the upcoming invoice for a subscription that hasn't been created, use `coupon` instead.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_items [Array(Array(InvoiceItemPreviewParams))?] List of invoice items to add or update in the upcoming invoice preview.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param schedule [String?] The identifier of the unstarted schedule whose upcoming invoice you'd like to retrieve. Cannot be used with subscription or subscription fields.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param subscription [String?] The identifier of the subscription for which you'd like to retrieve the upcoming invoice. If not provided, but a `subscription_items` is provided, you will preview creating a subscription with those items. If neither `subscription` nor `subscription_items` is provided, you will retrieve the next upcoming invoice from among the customer's subscriptions.
    # @optional @param subscription_billing_cycle_anchor [Stripe::GetInvoicesUpcomingSubscriptionBillingCycleAnchorParameter?] For new subscriptions, a future timestamp to anchor the subscription's [billing cycle](https://stripe.com/docs/subscriptions/billing-cycle). This is used to determine the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices. For existing subscriptions, the value can only be set to `now` or `unchanged`.
    # @optional @param subscription_cancel_at [Stripe::GetInvoicesUpcomingSubscriptionCancelAtParameter?] Timestamp indicating when the subscription should be scheduled to cancel. Will prorate if within the current period and prorations have been enabled using `proration_behavior`.
    # @optional @param subscription_cancel_at_period_end [Bool?] Boolean indicating whether this subscription should cancel at the end of the current period.
    # @optional @param subscription_cancel_now [Bool?] This simulates the subscription being canceled or expired immediately.
    # @optional @param subscription_default_tax_rates [Stripe::CreditNoteLineItemParamsTaxRates?] If provided, the invoice returned will preview updating or creating a subscription with these default tax rates. The default tax rates will apply to any line item that does not have `tax_rates` set.
    # @optional @param subscription_items [Array(Array(SubscriptionItemUpdateParams))?] A list of up to 20 subscription items, each with an attached price.
    # @optional @param subscription_proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param subscription_proration_date [Int64?] If previewing an update to a subscription, and doing proration, `subscription_proration_date` forces the proration to be calculated as though the update was done at the specified time. The time given must be within the current subscription period, and cannot be before the subscription was on its current plan. If set, `subscription`, and one of `subscription_items`, or `subscription_trial_end` are required. Also, `subscription_proration_behavior` cannot be set to 'none'.
    # @optional @param subscription_start_date [Int64?] Date a subscription is intended to start (can be future or past)
    # @optional @param subscription_trial_end [Stripe::GetInvoicesUpcomingSubscriptionTrialEndParameter?] If provided, the invoice returned will preview updating or creating a subscription with that trial end. If set, one of `subscription_items` or `subscription` is required.
    # @optional @param subscription_trial_from_plan [Bool?] Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `subscription_trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `subscription_trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @return [InvoiceLinesList]
    def get_invoices_upcoming_lines(*, automatic_tax : Stripe::AutomaticTaxParam1? = nil, coupon : String? = nil, currency : String? = nil, customer : String? = nil, customer_details : Stripe::CustomerDetailsParam? = nil, discounts : Stripe::GetInvoicesUpcomingDiscountsParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, invoice_items : Array(Array(InvoiceItemPreviewParams))? = nil, limit : Int64? = nil, schedule : String? = nil, starting_after : String? = nil, subscription : String? = nil, subscription_billing_cycle_anchor : Stripe::GetInvoicesUpcomingSubscriptionBillingCycleAnchorParameter? = nil, subscription_cancel_at : Stripe::GetInvoicesUpcomingSubscriptionCancelAtParameter? = nil, subscription_cancel_at_period_end : Bool? = nil, subscription_cancel_now : Bool? = nil, subscription_default_tax_rates : Stripe::CreditNoteLineItemParamsTaxRates? = nil, subscription_items : Array(Array(SubscriptionItemUpdateParams))? = nil, subscription_proration_behavior : String? = nil, subscription_proration_date : Int64? = nil, subscription_start_date : Int64? = nil, subscription_trial_end : Stripe::GetInvoicesUpcomingSubscriptionTrialEndParameter? = nil, subscription_trial_from_plan : Bool? = nil)
      data, _status_code, _headers = get_invoices_upcoming_lines_with_http_info(automatic_tax: automatic_tax, coupon: coupon, currency: currency, customer: customer, customer_details: customer_details, discounts: discounts, ending_before: ending_before, expand: expand, invoice_items: invoice_items, limit: limit, schedule: schedule, starting_after: starting_after, subscription: subscription, subscription_billing_cycle_anchor: subscription_billing_cycle_anchor, subscription_cancel_at: subscription_cancel_at, subscription_cancel_at_period_end: subscription_cancel_at_period_end, subscription_cancel_now: subscription_cancel_now, subscription_default_tax_rates: subscription_default_tax_rates, subscription_items: subscription_items, subscription_proration_behavior: subscription_proration_behavior, subscription_proration_date: subscription_proration_date, subscription_start_date: subscription_start_date, subscription_trial_end: subscription_trial_end, subscription_trial_from_plan: subscription_trial_from_plan)
      data
    end

    # &lt;p&gt;When retrieving an upcoming invoice, you’ll get a &lt;strong&gt;lines&lt;/strong&gt; property containing the total count of line items and the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.&lt;/p&gt;
    # @optional @param automatic_tax [Stripe::AutomaticTaxParam1?] Settings for automatic tax lookup for this invoice preview.
    # @optional @param coupon [String?] The code of the coupon to apply. If `subscription` or `subscription_items` is provided, the invoice returned will preview updating or creating a subscription with that coupon. Otherwise, it will preview applying that coupon to the customer for the next upcoming invoice from among the customer's subscriptions. The invoice can be previewed without a coupon by passing this value as an empty string.
    # @optional @param currency [String?] The currency to preview this invoice in. Defaults to that of `customer` if not specified.
    # @optional @param customer [String?] The identifier of the customer whose upcoming invoice you'd like to retrieve.
    # @optional @param customer_details [Stripe::CustomerDetailsParam?] Details about the customer you want to invoice or overrides for an existing customer.
    # @optional @param discounts [Stripe::GetInvoicesUpcomingDiscountsParameter?] The coupons to redeem into discounts for the invoice preview. If not specified, inherits the discount from the customer or subscription. This only works for coupons directly applied to the invoice. To apply a coupon to a subscription, you must use the `coupon` parameter instead. Pass an empty string to avoid inheriting any discounts. To preview the upcoming invoice for a subscription that hasn't been created, use `coupon` instead.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_items [Array(Array(InvoiceItemPreviewParams))?] List of invoice items to add or update in the upcoming invoice preview.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param schedule [String?] The identifier of the unstarted schedule whose upcoming invoice you'd like to retrieve. Cannot be used with subscription or subscription fields.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param subscription [String?] The identifier of the subscription for which you'd like to retrieve the upcoming invoice. If not provided, but a `subscription_items` is provided, you will preview creating a subscription with those items. If neither `subscription` nor `subscription_items` is provided, you will retrieve the next upcoming invoice from among the customer's subscriptions.
    # @optional @param subscription_billing_cycle_anchor [Stripe::GetInvoicesUpcomingSubscriptionBillingCycleAnchorParameter?] For new subscriptions, a future timestamp to anchor the subscription's [billing cycle](https://stripe.com/docs/subscriptions/billing-cycle). This is used to determine the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices. For existing subscriptions, the value can only be set to `now` or `unchanged`.
    # @optional @param subscription_cancel_at [Stripe::GetInvoicesUpcomingSubscriptionCancelAtParameter?] Timestamp indicating when the subscription should be scheduled to cancel. Will prorate if within the current period and prorations have been enabled using `proration_behavior`.
    # @optional @param subscription_cancel_at_period_end [Bool?] Boolean indicating whether this subscription should cancel at the end of the current period.
    # @optional @param subscription_cancel_now [Bool?] This simulates the subscription being canceled or expired immediately.
    # @optional @param subscription_default_tax_rates [Stripe::CreditNoteLineItemParamsTaxRates?] If provided, the invoice returned will preview updating or creating a subscription with these default tax rates. The default tax rates will apply to any line item that does not have `tax_rates` set.
    # @optional @param subscription_items [Array(Array(SubscriptionItemUpdateParams))?] A list of up to 20 subscription items, each with an attached price.
    # @optional @param subscription_proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param subscription_proration_date [Int64?] If previewing an update to a subscription, and doing proration, `subscription_proration_date` forces the proration to be calculated as though the update was done at the specified time. The time given must be within the current subscription period, and cannot be before the subscription was on its current plan. If set, `subscription`, and one of `subscription_items`, or `subscription_trial_end` are required. Also, `subscription_proration_behavior` cannot be set to 'none'.
    # @optional @param subscription_start_date [Int64?] Date a subscription is intended to start (can be future or past)
    # @optional @param subscription_trial_end [Stripe::GetInvoicesUpcomingSubscriptionTrialEndParameter?] If provided, the invoice returned will preview updating or creating a subscription with that trial end. If set, one of `subscription_items` or `subscription` is required.
    # @optional @param subscription_trial_from_plan [Bool?] Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `subscription_trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `subscription_trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @return [Array<(InvoiceLinesList, Integer, Hash)>] InvoiceLinesList data, response status code and response headers
    def get_invoices_upcoming_lines_with_http_info(*, automatic_tax : Stripe::AutomaticTaxParam1? = nil, coupon : String? = nil, currency : String? = nil, customer : String? = nil, customer_details : Stripe::CustomerDetailsParam? = nil, discounts : Stripe::GetInvoicesUpcomingDiscountsParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, invoice_items : Array(Array(InvoiceItemPreviewParams))? = nil, limit : Int64? = nil, schedule : String? = nil, starting_after : String? = nil, subscription : String? = nil, subscription_billing_cycle_anchor : Stripe::GetInvoicesUpcomingSubscriptionBillingCycleAnchorParameter? = nil, subscription_cancel_at : Stripe::GetInvoicesUpcomingSubscriptionCancelAtParameter? = nil, subscription_cancel_at_period_end : Bool? = nil, subscription_cancel_now : Bool? = nil, subscription_default_tax_rates : Stripe::CreditNoteLineItemParamsTaxRates? = nil, subscription_items : Array(Array(SubscriptionItemUpdateParams))? = nil, subscription_proration_behavior : String? = nil, subscription_proration_date : Int64? = nil, subscription_start_date : Int64? = nil, subscription_trial_end : Stripe::GetInvoicesUpcomingSubscriptionTrialEndParameter? = nil, subscription_trial_from_plan : Bool? = nil)
      request = build_api_request_for_get_invoices_upcoming_lines(automatic_tax: automatic_tax, coupon: coupon, currency: currency, customer: customer, customer_details: customer_details, discounts: discounts, ending_before: ending_before, expand: expand, invoice_items: invoice_items, limit: limit, schedule: schedule, starting_after: starting_after, subscription: subscription, subscription_billing_cycle_anchor: subscription_billing_cycle_anchor, subscription_cancel_at: subscription_cancel_at, subscription_cancel_at_period_end: subscription_cancel_at_period_end, subscription_cancel_now: subscription_cancel_now, subscription_default_tax_rates: subscription_default_tax_rates, subscription_items: subscription_items, subscription_proration_behavior: subscription_proration_behavior, subscription_proration_date: subscription_proration_date, subscription_start_date: subscription_start_date, subscription_trial_end: subscription_trial_end, subscription_trial_from_plan: subscription_trial_from_plan)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_invoices_upcoming_lines\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return InvoiceLinesList.from_json(data), status_code, headers
    end

    # &lt;p&gt;When retrieving an upcoming invoice, you’ll get a &lt;strong&gt;lines&lt;/strong&gt; property containing the total count of line items and the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.&lt;/p&gt;
    # @optional @param automatic_tax [Stripe::AutomaticTaxParam1?] Settings for automatic tax lookup for this invoice preview.
    # @optional @param coupon [String?] The code of the coupon to apply. If `subscription` or `subscription_items` is provided, the invoice returned will preview updating or creating a subscription with that coupon. Otherwise, it will preview applying that coupon to the customer for the next upcoming invoice from among the customer's subscriptions. The invoice can be previewed without a coupon by passing this value as an empty string.
    # @optional @param currency [String?] The currency to preview this invoice in. Defaults to that of `customer` if not specified.
    # @optional @param customer [String?] The identifier of the customer whose upcoming invoice you'd like to retrieve.
    # @optional @param customer_details [Stripe::CustomerDetailsParam?] Details about the customer you want to invoice or overrides for an existing customer.
    # @optional @param discounts [Stripe::GetInvoicesUpcomingDiscountsParameter?] The coupons to redeem into discounts for the invoice preview. If not specified, inherits the discount from the customer or subscription. This only works for coupons directly applied to the invoice. To apply a coupon to a subscription, you must use the `coupon` parameter instead. Pass an empty string to avoid inheriting any discounts. To preview the upcoming invoice for a subscription that hasn't been created, use `coupon` instead.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_items [Array(Array(InvoiceItemPreviewParams))?] List of invoice items to add or update in the upcoming invoice preview.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param schedule [String?] The identifier of the unstarted schedule whose upcoming invoice you'd like to retrieve. Cannot be used with subscription or subscription fields.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param subscription [String?] The identifier of the subscription for which you'd like to retrieve the upcoming invoice. If not provided, but a `subscription_items` is provided, you will preview creating a subscription with those items. If neither `subscription` nor `subscription_items` is provided, you will retrieve the next upcoming invoice from among the customer's subscriptions.
    # @optional @param subscription_billing_cycle_anchor [Stripe::GetInvoicesUpcomingSubscriptionBillingCycleAnchorParameter?] For new subscriptions, a future timestamp to anchor the subscription's [billing cycle](https://stripe.com/docs/subscriptions/billing-cycle). This is used to determine the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices. For existing subscriptions, the value can only be set to `now` or `unchanged`.
    # @optional @param subscription_cancel_at [Stripe::GetInvoicesUpcomingSubscriptionCancelAtParameter?] Timestamp indicating when the subscription should be scheduled to cancel. Will prorate if within the current period and prorations have been enabled using `proration_behavior`.
    # @optional @param subscription_cancel_at_period_end [Bool?] Boolean indicating whether this subscription should cancel at the end of the current period.
    # @optional @param subscription_cancel_now [Bool?] This simulates the subscription being canceled or expired immediately.
    # @optional @param subscription_default_tax_rates [Stripe::CreditNoteLineItemParamsTaxRates?] If provided, the invoice returned will preview updating or creating a subscription with these default tax rates. The default tax rates will apply to any line item that does not have `tax_rates` set.
    # @optional @param subscription_items [Array(Array(SubscriptionItemUpdateParams))?] A list of up to 20 subscription items, each with an attached price.
    # @optional @param subscription_proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param subscription_proration_date [Int64?] If previewing an update to a subscription, and doing proration, `subscription_proration_date` forces the proration to be calculated as though the update was done at the specified time. The time given must be within the current subscription period, and cannot be before the subscription was on its current plan. If set, `subscription`, and one of `subscription_items`, or `subscription_trial_end` are required. Also, `subscription_proration_behavior` cannot be set to 'none'.
    # @optional @param subscription_start_date [Int64?] Date a subscription is intended to start (can be future or past)
    # @optional @param subscription_trial_end [Stripe::GetInvoicesUpcomingSubscriptionTrialEndParameter?] If provided, the invoice returned will preview updating or creating a subscription with that trial end. If set, one of `subscription_items` or `subscription` is required.
    # @optional @param subscription_trial_from_plan [Bool?] Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `subscription_trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `subscription_trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @return nil
    def get_invoices_upcoming_lines(*, automatic_tax : Stripe::AutomaticTaxParam1? = nil, coupon : String? = nil, currency : String? = nil, customer : String? = nil, customer_details : Stripe::CustomerDetailsParam? = nil, discounts : Stripe::GetInvoicesUpcomingDiscountsParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, invoice_items : Array(Array(InvoiceItemPreviewParams))? = nil, limit : Int64? = nil, schedule : String? = nil, starting_after : String? = nil, subscription : String? = nil, subscription_billing_cycle_anchor : Stripe::GetInvoicesUpcomingSubscriptionBillingCycleAnchorParameter? = nil, subscription_cancel_at : Stripe::GetInvoicesUpcomingSubscriptionCancelAtParameter? = nil, subscription_cancel_at_period_end : Bool? = nil, subscription_cancel_now : Bool? = nil, subscription_default_tax_rates : Stripe::CreditNoteLineItemParamsTaxRates? = nil, subscription_items : Array(Array(SubscriptionItemUpdateParams))? = nil, subscription_proration_behavior : String? = nil, subscription_proration_date : Int64? = nil, subscription_start_date : Int64? = nil, subscription_trial_end : Stripe::GetInvoicesUpcomingSubscriptionTrialEndParameter? = nil, subscription_trial_from_plan : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_get_invoices_upcoming_lines(automatic_tax: automatic_tax, coupon: coupon, currency: currency, customer: customer, customer_details: customer_details, discounts: discounts, ending_before: ending_before, expand: expand, invoice_items: invoice_items, limit: limit, schedule: schedule, starting_after: starting_after, subscription: subscription, subscription_billing_cycle_anchor: subscription_billing_cycle_anchor, subscription_cancel_at: subscription_cancel_at, subscription_cancel_at_period_end: subscription_cancel_at_period_end, subscription_cancel_now: subscription_cancel_now, subscription_default_tax_rates: subscription_default_tax_rates, subscription_items: subscription_items, subscription_proration_behavior: subscription_proration_behavior, subscription_proration_date: subscription_proration_date, subscription_start_date: subscription_start_date, subscription_trial_end: subscription_trial_end, subscription_trial_from_plan: subscription_trial_from_plan).execute(&block)
    end

    GET_INVOICES_UPCOMING_LINES_MAX_LENGTH_FOR_COUPON                            = 5000
    GET_INVOICES_UPCOMING_LINES_MAX_LENGTH_FOR_CUSTOMER                          = 5000
    GET_INVOICES_UPCOMING_LINES_MAX_LENGTH_FOR_ENDING_BEFORE                     = 5000
    GET_INVOICES_UPCOMING_LINES_MAX_LENGTH_FOR_SCHEDULE                          = 5000
    GET_INVOICES_UPCOMING_LINES_MAX_LENGTH_FOR_STARTING_AFTER                    = 5000
    GET_INVOICES_UPCOMING_LINES_MAX_LENGTH_FOR_SUBSCRIPTION                      = 5000
    GET_INVOICES_UPCOMING_LINES_VALID_VALUES_FOR_SUBSCRIPTION_PRORATION_BEHAVIOR = StaticArray["always_invoice", "create_prorations", "none"]

    # @return Crest::Request
    def build_api_request_for_get_invoices_upcoming_lines(*, automatic_tax : Stripe::AutomaticTaxParam1? = nil, coupon : String? = nil, currency : String? = nil, customer : String? = nil, customer_details : Stripe::CustomerDetailsParam? = nil, discounts : Stripe::GetInvoicesUpcomingDiscountsParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, invoice_items : Array(Array(InvoiceItemPreviewParams))? = nil, limit : Int64? = nil, schedule : String? = nil, starting_after : String? = nil, subscription : String? = nil, subscription_billing_cycle_anchor : Stripe::GetInvoicesUpcomingSubscriptionBillingCycleAnchorParameter? = nil, subscription_cancel_at : Stripe::GetInvoicesUpcomingSubscriptionCancelAtParameter? = nil, subscription_cancel_at_period_end : Bool? = nil, subscription_cancel_now : Bool? = nil, subscription_default_tax_rates : Stripe::CreditNoteLineItemParamsTaxRates? = nil, subscription_items : Array(Array(SubscriptionItemUpdateParams))? = nil, subscription_proration_behavior : String? = nil, subscription_proration_date : Int64? = nil, subscription_start_date : Int64? = nil, subscription_trial_end : Stripe::GetInvoicesUpcomingSubscriptionTrialEndParameter? = nil, subscription_trial_from_plan : Bool? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_invoices_upcoming_lines ..." }
      end

      if client_side_validation
        if _automatic_tax = automatic_tax
          _automatic_tax.validate if _automatic_tax.is_a?(OpenApi::Validatable)
        end
        if _coupon = coupon
          OpenApi::PrimitiveValidator.validate_max_length("coupon", coupon.to_s.size, GET_INVOICES_UPCOMING_LINES_MAX_LENGTH_FOR_COUPON)
        end

        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_INVOICES_UPCOMING_LINES_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _customer_details = customer_details
          _customer_details.validate if _customer_details.is_a?(OpenApi::Validatable)
        end
        if _discounts = discounts
          _discounts.validate if _discounts.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_INVOICES_UPCOMING_LINES_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _schedule = schedule
          OpenApi::PrimitiveValidator.validate_max_length("schedule", schedule.to_s.size, GET_INVOICES_UPCOMING_LINES_MAX_LENGTH_FOR_SCHEDULE)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_INVOICES_UPCOMING_LINES_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _subscription = subscription
          OpenApi::PrimitiveValidator.validate_max_length("subscription", subscription.to_s.size, GET_INVOICES_UPCOMING_LINES_MAX_LENGTH_FOR_SUBSCRIPTION)
        end
        if _subscription_billing_cycle_anchor = subscription_billing_cycle_anchor
          _subscription_billing_cycle_anchor.validate if _subscription_billing_cycle_anchor.is_a?(OpenApi::Validatable)
        end
        if _subscription_cancel_at = subscription_cancel_at
          _subscription_cancel_at.validate if _subscription_cancel_at.is_a?(OpenApi::Validatable)
        end

        if _subscription_default_tax_rates = subscription_default_tax_rates
          _subscription_default_tax_rates.validate if _subscription_default_tax_rates.is_a?(OpenApi::Validatable)
        end

        if _subscription_proration_behavior = subscription_proration_behavior
          OpenApi::EnumValidator.validate("subscription_proration_behavior", _subscription_proration_behavior, GET_INVOICES_UPCOMING_LINES_VALID_VALUES_FOR_SUBSCRIPTION_PRORATION_BEHAVIOR)
        end

        if _subscription_trial_end = subscription_trial_end
          _subscription_trial_end.validate if _subscription_trial_end.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/invoices/upcoming/lines"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["automatic_tax"] = automatic_tax.to_s if !automatic_tax.nil?
      query_params["coupon"] = coupon.to_s if !coupon.nil?
      query_params["currency"] = currency.to_s if !currency.nil?
      query_params["customer"] = customer.to_s if !customer.nil?
      query_params["customer_details"] = customer_details.to_s if !customer_details.nil?
      query_params["discounts"] = discounts.to_s if !discounts.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["invoice_items"] = @api_client.build_collection_param(invoice_items, "csv") if !invoice_items.nil? && !invoice_items.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["schedule"] = schedule.to_s if !schedule.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["subscription"] = subscription.to_s if !subscription.nil?
      query_params["subscription_billing_cycle_anchor"] = subscription_billing_cycle_anchor.to_s if !subscription_billing_cycle_anchor.nil?
      query_params["subscription_cancel_at"] = subscription_cancel_at.to_s if !subscription_cancel_at.nil?
      query_params["subscription_cancel_at_period_end"] = subscription_cancel_at_period_end.to_s if !subscription_cancel_at_period_end.nil?
      query_params["subscription_cancel_now"] = subscription_cancel_now.to_s if !subscription_cancel_now.nil?
      query_params["subscription_default_tax_rates"] = subscription_default_tax_rates.to_s if !subscription_default_tax_rates.nil?
      query_params["subscription_items"] = @api_client.build_collection_param(subscription_items, "csv") if !subscription_items.nil? && !subscription_items.empty?
      query_params["subscription_proration_behavior"] = subscription_proration_behavior.to_s if !subscription_proration_behavior.nil?
      query_params["subscription_proration_date"] = subscription_proration_date.to_s if !subscription_proration_date.nil?
      query_params["subscription_start_date"] = subscription_start_date.to_s if !subscription_start_date.nil?
      query_params["subscription_trial_end"] = subscription_trial_end.to_s if !subscription_trial_end.nil?
      query_params["subscription_trial_from_plan"] = subscription_trial_from_plan.to_s if !subscription_trial_from_plan.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_invoices_upcoming_lines",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of Issuing <code>Authorization</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
    # @optional @param card [String?] Only return authorizations that belong to the given card.
    # @optional @param cardholder [String?] Only return authorizations that belong to the given cardholder.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return authorizations that were created during the given date interval.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return authorizations with the given status. One of `pending`, `closed`, or `reversed`.
    # @return [IssuingAuthorizationList]
    def get_issuing_authorizations(*, card : String? = nil, cardholder : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil)
      data, _status_code, _headers = get_issuing_authorizations_with_http_info(card: card, cardholder: cardholder, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status)
      data
    end

    # &lt;p&gt;Returns a list of Issuing &lt;code&gt;Authorization&lt;/code&gt; objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.&lt;/p&gt;
    # @optional @param card [String?] Only return authorizations that belong to the given card.
    # @optional @param cardholder [String?] Only return authorizations that belong to the given cardholder.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return authorizations that were created during the given date interval.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return authorizations with the given status. One of `pending`, `closed`, or `reversed`.
    # @return [Array<(IssuingAuthorizationList, Integer, Hash)>] IssuingAuthorizationList data, response status code and response headers
    def get_issuing_authorizations_with_http_info(*, card : String? = nil, cardholder : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil)
      request = build_api_request_for_get_issuing_authorizations(card: card, cardholder: cardholder, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_issuing_authorizations\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingAuthorizationList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of Issuing &lt;code&gt;Authorization&lt;/code&gt; objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.&lt;/p&gt;
    # @optional @param card [String?] Only return authorizations that belong to the given card.
    # @optional @param cardholder [String?] Only return authorizations that belong to the given cardholder.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return authorizations that were created during the given date interval.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return authorizations with the given status. One of `pending`, `closed`, or `reversed`.
    # @return nil
    def get_issuing_authorizations(*, card : String? = nil, cardholder : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_issuing_authorizations(card: card, cardholder: cardholder, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status).execute(&block)
    end

    GET_ISSUING_AUTHORIZATIONS_MAX_LENGTH_FOR_CARD           = 5000
    GET_ISSUING_AUTHORIZATIONS_MAX_LENGTH_FOR_CARDHOLDER     = 5000
    GET_ISSUING_AUTHORIZATIONS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_ISSUING_AUTHORIZATIONS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_ISSUING_AUTHORIZATIONS_VALID_VALUES_FOR_STATUS       = StaticArray["closed", "pending", "reversed"]

    # @return Crest::Request
    def build_api_request_for_get_issuing_authorizations(*, card : String? = nil, cardholder : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_issuing_authorizations ..." }
      end

      if client_side_validation
        if _card = card
          OpenApi::PrimitiveValidator.validate_max_length("card", card.to_s.size, GET_ISSUING_AUTHORIZATIONS_MAX_LENGTH_FOR_CARD)
        end
        if _cardholder = cardholder
          OpenApi::PrimitiveValidator.validate_max_length("cardholder", cardholder.to_s.size, GET_ISSUING_AUTHORIZATIONS_MAX_LENGTH_FOR_CARDHOLDER)
        end
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_ISSUING_AUTHORIZATIONS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_ISSUING_AUTHORIZATIONS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, GET_ISSUING_AUTHORIZATIONS_VALID_VALUES_FOR_STATUS)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/authorizations"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["card"] = card.to_s if !card.nil?
      query_params["cardholder"] = cardholder.to_s if !cardholder.nil?
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["status"] = status.to_s if !status.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_issuing_authorizations",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves an Issuing <code>Authorization</code> object.</p>
    # @param authorization [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [IssuingAuthorization]
    def get_issuing_authorizations_authorization(*, authorization : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_issuing_authorizations_authorization_with_http_info(authorization: authorization, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves an Issuing &lt;code&gt;Authorization&lt;/code&gt; object.&lt;/p&gt;
    # @param authorization [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(IssuingAuthorization, Integer, Hash)>] IssuingAuthorization data, response status code and response headers
    def get_issuing_authorizations_authorization_with_http_info(*, authorization : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_issuing_authorizations_authorization(authorization: authorization, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_issuing_authorizations_authorization\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingAuthorization.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves an Issuing &lt;code&gt;Authorization&lt;/code&gt; object.&lt;/p&gt;
    # @param authorization [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_issuing_authorizations_authorization(*, authorization : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_issuing_authorizations_authorization(authorization: authorization, expand: expand).execute(&block)
    end

    GET_ISSUING_AUTHORIZATIONS_AUTHORIZATION_MAX_LENGTH_FOR_AUTHORIZATION = 5000

    # @return Crest::Request
    def build_api_request_for_get_issuing_authorizations_authorization(*, authorization : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_issuing_authorizations_authorization ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"authorization\" is required and cannot be null") if authorization.nil?
        if _authorization = authorization
          OpenApi::PrimitiveValidator.validate_max_length("authorization", authorization.to_s.size, GET_ISSUING_AUTHORIZATIONS_AUTHORIZATION_MAX_LENGTH_FOR_AUTHORIZATION)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/authorizations/{authorization}".sub("{" + "authorization" + "}", URI.encode_path(authorization.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_issuing_authorizations_authorization",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of Issuing <code>Cardholder</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return cardholders that were created during the given date interval.
    # @optional @param email [String?] Only return cardholders that have the given email address.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param phone_number [String?] Only return cardholders that have the given phone number.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return cardholders that have the given status. One of `active`, `inactive`, or `blocked`.
    # @optional @param _type [String?] Only return cardholders that have the given type. One of `individual` or `company`.
    # @return [IssuingCardholderList]
    def get_issuing_cardholders(*, created : Stripe::GetAccountsCreatedParameter? = nil, email : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, phone_number : String? = nil, starting_after : String? = nil, status : String? = nil, _type : String? = nil)
      data, _status_code, _headers = get_issuing_cardholders_with_http_info(created: created, email: email, ending_before: ending_before, expand: expand, limit: limit, phone_number: phone_number, starting_after: starting_after, status: status, _type: _type)
      data
    end

    # &lt;p&gt;Returns a list of Issuing &lt;code&gt;Cardholder&lt;/code&gt; objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return cardholders that were created during the given date interval.
    # @optional @param email [String?] Only return cardholders that have the given email address.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param phone_number [String?] Only return cardholders that have the given phone number.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return cardholders that have the given status. One of `active`, `inactive`, or `blocked`.
    # @optional @param _type [String?] Only return cardholders that have the given type. One of `individual` or `company`.
    # @return [Array<(IssuingCardholderList, Integer, Hash)>] IssuingCardholderList data, response status code and response headers
    def get_issuing_cardholders_with_http_info(*, created : Stripe::GetAccountsCreatedParameter? = nil, email : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, phone_number : String? = nil, starting_after : String? = nil, status : String? = nil, _type : String? = nil)
      request = build_api_request_for_get_issuing_cardholders(created: created, email: email, ending_before: ending_before, expand: expand, limit: limit, phone_number: phone_number, starting_after: starting_after, status: status, _type: _type)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_issuing_cardholders\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingCardholderList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of Issuing &lt;code&gt;Cardholder&lt;/code&gt; objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return cardholders that were created during the given date interval.
    # @optional @param email [String?] Only return cardholders that have the given email address.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param phone_number [String?] Only return cardholders that have the given phone number.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return cardholders that have the given status. One of `active`, `inactive`, or `blocked`.
    # @optional @param _type [String?] Only return cardholders that have the given type. One of `individual` or `company`.
    # @return nil
    def get_issuing_cardholders(*, created : Stripe::GetAccountsCreatedParameter? = nil, email : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, phone_number : String? = nil, starting_after : String? = nil, status : String? = nil, _type : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_issuing_cardholders(created: created, email: email, ending_before: ending_before, expand: expand, limit: limit, phone_number: phone_number, starting_after: starting_after, status: status, _type: _type).execute(&block)
    end

    GET_ISSUING_CARDHOLDERS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_ISSUING_CARDHOLDERS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_ISSUING_CARDHOLDERS_VALID_VALUES_FOR_STATUS       = StaticArray["active", "blocked", "inactive"]
    GET_ISSUING_CARDHOLDERS_VALID_VALUES_FOR__TYPE        = StaticArray["company", "individual"]

    # @return Crest::Request
    def build_api_request_for_get_issuing_cardholders(*, created : Stripe::GetAccountsCreatedParameter? = nil, email : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, phone_number : String? = nil, starting_after : String? = nil, status : String? = nil, _type : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_issuing_cardholders ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end

        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_ISSUING_CARDHOLDERS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_ISSUING_CARDHOLDERS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, GET_ISSUING_CARDHOLDERS_VALID_VALUES_FOR_STATUS)
        end
        if __type = _type
          OpenApi::EnumValidator.validate("_type", __type, GET_ISSUING_CARDHOLDERS_VALID_VALUES_FOR__TYPE)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/cardholders"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["email"] = email.to_s if !email.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["phone_number"] = phone_number.to_s if !phone_number.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["status"] = status.to_s if !status.nil?
      query_params["type"] = _type.to_s if !_type.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_issuing_cardholders",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves an Issuing <code>Cardholder</code> object.</p>
    # @param cardholder [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [IssuingCardholder]
    def get_issuing_cardholders_cardholder(*, cardholder : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_issuing_cardholders_cardholder_with_http_info(cardholder: cardholder, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves an Issuing &lt;code&gt;Cardholder&lt;/code&gt; object.&lt;/p&gt;
    # @param cardholder [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(IssuingCardholder, Integer, Hash)>] IssuingCardholder data, response status code and response headers
    def get_issuing_cardholders_cardholder_with_http_info(*, cardholder : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_issuing_cardholders_cardholder(cardholder: cardholder, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_issuing_cardholders_cardholder\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingCardholder.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves an Issuing &lt;code&gt;Cardholder&lt;/code&gt; object.&lt;/p&gt;
    # @param cardholder [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_issuing_cardholders_cardholder(*, cardholder : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_issuing_cardholders_cardholder(cardholder: cardholder, expand: expand).execute(&block)
    end

    GET_ISSUING_CARDHOLDERS_CARDHOLDER_MAX_LENGTH_FOR_CARDHOLDER = 5000

    # @return Crest::Request
    def build_api_request_for_get_issuing_cardholders_cardholder(*, cardholder : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_issuing_cardholders_cardholder ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"cardholder\" is required and cannot be null") if cardholder.nil?
        if _cardholder = cardholder
          OpenApi::PrimitiveValidator.validate_max_length("cardholder", cardholder.to_s.size, GET_ISSUING_CARDHOLDERS_CARDHOLDER_MAX_LENGTH_FOR_CARDHOLDER)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/cardholders/{cardholder}".sub("{" + "cardholder" + "}", URI.encode_path(cardholder.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_issuing_cardholders_cardholder",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of Issuing <code>Card</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
    # @optional @param cardholder [String?] Only return cards belonging to the Cardholder with the provided ID.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return cards that were issued during the given date interval.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param exp_month [Int64?] Only return cards that have the given expiration month.
    # @optional @param exp_year [Int64?] Only return cards that have the given expiration year.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param last4 [String?] Only return cards that have the given last four digits.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return cards that have the given status. One of `active`, `inactive`, or `canceled`.
    # @optional @param _type [String?] Only return cards that have the given type. One of `virtual` or `physical`.
    # @return [IssuingCardList]
    def get_issuing_cards(*, cardholder : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, exp_month : Int64? = nil, exp_year : Int64? = nil, expand : Array(Array(String))? = nil, last4 : String? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, _type : String? = nil)
      data, _status_code, _headers = get_issuing_cards_with_http_info(cardholder: cardholder, created: created, ending_before: ending_before, exp_month: exp_month, exp_year: exp_year, expand: expand, last4: last4, limit: limit, starting_after: starting_after, status: status, _type: _type)
      data
    end

    # &lt;p&gt;Returns a list of Issuing &lt;code&gt;Card&lt;/code&gt; objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.&lt;/p&gt;
    # @optional @param cardholder [String?] Only return cards belonging to the Cardholder with the provided ID.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return cards that were issued during the given date interval.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param exp_month [Int64?] Only return cards that have the given expiration month.
    # @optional @param exp_year [Int64?] Only return cards that have the given expiration year.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param last4 [String?] Only return cards that have the given last four digits.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return cards that have the given status. One of `active`, `inactive`, or `canceled`.
    # @optional @param _type [String?] Only return cards that have the given type. One of `virtual` or `physical`.
    # @return [Array<(IssuingCardList, Integer, Hash)>] IssuingCardList data, response status code and response headers
    def get_issuing_cards_with_http_info(*, cardholder : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, exp_month : Int64? = nil, exp_year : Int64? = nil, expand : Array(Array(String))? = nil, last4 : String? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, _type : String? = nil)
      request = build_api_request_for_get_issuing_cards(cardholder: cardholder, created: created, ending_before: ending_before, exp_month: exp_month, exp_year: exp_year, expand: expand, last4: last4, limit: limit, starting_after: starting_after, status: status, _type: _type)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_issuing_cards\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingCardList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of Issuing &lt;code&gt;Card&lt;/code&gt; objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.&lt;/p&gt;
    # @optional @param cardholder [String?] Only return cards belonging to the Cardholder with the provided ID.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return cards that were issued during the given date interval.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param exp_month [Int64?] Only return cards that have the given expiration month.
    # @optional @param exp_year [Int64?] Only return cards that have the given expiration year.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param last4 [String?] Only return cards that have the given last four digits.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return cards that have the given status. One of `active`, `inactive`, or `canceled`.
    # @optional @param _type [String?] Only return cards that have the given type. One of `virtual` or `physical`.
    # @return nil
    def get_issuing_cards(*, cardholder : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, exp_month : Int64? = nil, exp_year : Int64? = nil, expand : Array(Array(String))? = nil, last4 : String? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, _type : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_issuing_cards(cardholder: cardholder, created: created, ending_before: ending_before, exp_month: exp_month, exp_year: exp_year, expand: expand, last4: last4, limit: limit, starting_after: starting_after, status: status, _type: _type).execute(&block)
    end

    GET_ISSUING_CARDS_MAX_LENGTH_FOR_CARDHOLDER     = 5000
    GET_ISSUING_CARDS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_ISSUING_CARDS_MAX_LENGTH_FOR_LAST4          = 5000
    GET_ISSUING_CARDS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_ISSUING_CARDS_VALID_VALUES_FOR_STATUS       = StaticArray["active", "canceled", "inactive"]
    GET_ISSUING_CARDS_VALID_VALUES_FOR__TYPE        = StaticArray["physical", "virtual"]

    # @return Crest::Request
    def build_api_request_for_get_issuing_cards(*, cardholder : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, exp_month : Int64? = nil, exp_year : Int64? = nil, expand : Array(Array(String))? = nil, last4 : String? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, _type : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_issuing_cards ..." }
      end

      if client_side_validation
        if _cardholder = cardholder
          OpenApi::PrimitiveValidator.validate_max_length("cardholder", cardholder.to_s.size, GET_ISSUING_CARDS_MAX_LENGTH_FOR_CARDHOLDER)
        end
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_ISSUING_CARDS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _last4 = last4
          OpenApi::PrimitiveValidator.validate_max_length("last4", last4.to_s.size, GET_ISSUING_CARDS_MAX_LENGTH_FOR_LAST4)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_ISSUING_CARDS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, GET_ISSUING_CARDS_VALID_VALUES_FOR_STATUS)
        end
        if __type = _type
          OpenApi::EnumValidator.validate("_type", __type, GET_ISSUING_CARDS_VALID_VALUES_FOR__TYPE)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/cards"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["cardholder"] = cardholder.to_s if !cardholder.nil?
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["exp_month"] = exp_month.to_s if !exp_month.nil?
      query_params["exp_year"] = exp_year.to_s if !exp_year.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["last4"] = last4.to_s if !last4.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["status"] = status.to_s if !status.nil?
      query_params["type"] = _type.to_s if !_type.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_issuing_cards",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves an Issuing <code>Card</code> object.</p>
    # @param card [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [IssuingCard]
    def get_issuing_cards_card(*, card : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_issuing_cards_card_with_http_info(card: card, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves an Issuing &lt;code&gt;Card&lt;/code&gt; object.&lt;/p&gt;
    # @param card [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(IssuingCard, Integer, Hash)>] IssuingCard data, response status code and response headers
    def get_issuing_cards_card_with_http_info(*, card : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_issuing_cards_card(card: card, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_issuing_cards_card\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingCard.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves an Issuing &lt;code&gt;Card&lt;/code&gt; object.&lt;/p&gt;
    # @param card [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_issuing_cards_card(*, card : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_issuing_cards_card(card: card, expand: expand).execute(&block)
    end

    GET_ISSUING_CARDS_CARD_MAX_LENGTH_FOR_CARD = 5000

    # @return Crest::Request
    def build_api_request_for_get_issuing_cards_card(*, card : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_issuing_cards_card ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"card\" is required and cannot be null") if card.nil?
        if _card = card
          OpenApi::PrimitiveValidator.validate_max_length("card", card.to_s.size, GET_ISSUING_CARDS_CARD_MAX_LENGTH_FOR_CARD)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/cards/{card}".sub("{" + "card" + "}", URI.encode_path(card.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_issuing_cards_card",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of Issuing <code>Dispute</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Select Issuing disputes that were created during the given date interval.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Select Issuing disputes with the given status.
    # @optional @param transaction [String?] Select the Issuing dispute for the given transaction.
    # @return [IssuingDisputeList]
    def get_issuing_disputes(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, transaction : String? = nil)
      data, _status_code, _headers = get_issuing_disputes_with_http_info(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status, transaction: transaction)
      data
    end

    # &lt;p&gt;Returns a list of Issuing &lt;code&gt;Dispute&lt;/code&gt; objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Select Issuing disputes that were created during the given date interval.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Select Issuing disputes with the given status.
    # @optional @param transaction [String?] Select the Issuing dispute for the given transaction.
    # @return [Array<(IssuingDisputeList, Integer, Hash)>] IssuingDisputeList data, response status code and response headers
    def get_issuing_disputes_with_http_info(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, transaction : String? = nil)
      request = build_api_request_for_get_issuing_disputes(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status, transaction: transaction)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_issuing_disputes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingDisputeList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of Issuing &lt;code&gt;Dispute&lt;/code&gt; objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Select Issuing disputes that were created during the given date interval.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Select Issuing disputes with the given status.
    # @optional @param transaction [String?] Select the Issuing dispute for the given transaction.
    # @return nil
    def get_issuing_disputes(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, transaction : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_issuing_disputes(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status, transaction: transaction).execute(&block)
    end

    GET_ISSUING_DISPUTES_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_ISSUING_DISPUTES_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_ISSUING_DISPUTES_VALID_VALUES_FOR_STATUS       = StaticArray["expired", "lost", "submitted", "unsubmitted", "won"]
    GET_ISSUING_DISPUTES_MAX_LENGTH_FOR_TRANSACTION    = 5000

    # @return Crest::Request
    def build_api_request_for_get_issuing_disputes(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, transaction : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_issuing_disputes ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_ISSUING_DISPUTES_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_ISSUING_DISPUTES_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, GET_ISSUING_DISPUTES_VALID_VALUES_FOR_STATUS)
        end
        if _transaction = transaction
          OpenApi::PrimitiveValidator.validate_max_length("transaction", transaction.to_s.size, GET_ISSUING_DISPUTES_MAX_LENGTH_FOR_TRANSACTION)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/disputes"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["status"] = status.to_s if !status.nil?
      query_params["transaction"] = transaction.to_s if !transaction.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_issuing_disputes",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves an Issuing <code>Dispute</code> object.</p>
    # @param dispute [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [IssuingDispute]
    def get_issuing_disputes_dispute(*, dispute : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_issuing_disputes_dispute_with_http_info(dispute: dispute, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves an Issuing &lt;code&gt;Dispute&lt;/code&gt; object.&lt;/p&gt;
    # @param dispute [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(IssuingDispute, Integer, Hash)>] IssuingDispute data, response status code and response headers
    def get_issuing_disputes_dispute_with_http_info(*, dispute : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_issuing_disputes_dispute(dispute: dispute, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_issuing_disputes_dispute\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingDispute.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves an Issuing &lt;code&gt;Dispute&lt;/code&gt; object.&lt;/p&gt;
    # @param dispute [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_issuing_disputes_dispute(*, dispute : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_issuing_disputes_dispute(dispute: dispute, expand: expand).execute(&block)
    end

    GET_ISSUING_DISPUTES_DISPUTE_MAX_LENGTH_FOR_DISPUTE = 5000

    # @return Crest::Request
    def build_api_request_for_get_issuing_disputes_dispute(*, dispute : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_issuing_disputes_dispute ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"dispute\" is required and cannot be null") if dispute.nil?
        if _dispute = dispute
          OpenApi::PrimitiveValidator.validate_max_length("dispute", dispute.to_s.size, GET_ISSUING_DISPUTES_DISPUTE_MAX_LENGTH_FOR_DISPUTE)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/disputes/{dispute}".sub("{" + "dispute" + "}", URI.encode_path(dispute.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_issuing_disputes_dispute",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of Issuing <code>Settlement</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return issuing settlements that were created during the given date interval.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [IssuingSettlementList]
    def get_issuing_settlements(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_issuing_settlements_with_http_info(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of Issuing &lt;code&gt;Settlement&lt;/code&gt; objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return issuing settlements that were created during the given date interval.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(IssuingSettlementList, Integer, Hash)>] IssuingSettlementList data, response status code and response headers
    def get_issuing_settlements_with_http_info(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_issuing_settlements(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_issuing_settlements\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingSettlementList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of Issuing &lt;code&gt;Settlement&lt;/code&gt; objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return issuing settlements that were created during the given date interval.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_issuing_settlements(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_issuing_settlements(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_ISSUING_SETTLEMENTS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_ISSUING_SETTLEMENTS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_issuing_settlements(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_issuing_settlements ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_ISSUING_SETTLEMENTS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_ISSUING_SETTLEMENTS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/settlements"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_issuing_settlements",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves an Issuing <code>Settlement</code> object.</p>
    # @param settlement [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [IssuingSettlement]
    def get_issuing_settlements_settlement(*, settlement : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_issuing_settlements_settlement_with_http_info(settlement: settlement, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves an Issuing &lt;code&gt;Settlement&lt;/code&gt; object.&lt;/p&gt;
    # @param settlement [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(IssuingSettlement, Integer, Hash)>] IssuingSettlement data, response status code and response headers
    def get_issuing_settlements_settlement_with_http_info(*, settlement : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_issuing_settlements_settlement(settlement: settlement, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_issuing_settlements_settlement\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingSettlement.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves an Issuing &lt;code&gt;Settlement&lt;/code&gt; object.&lt;/p&gt;
    # @param settlement [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_issuing_settlements_settlement(*, settlement : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_issuing_settlements_settlement(settlement: settlement, expand: expand).execute(&block)
    end

    GET_ISSUING_SETTLEMENTS_SETTLEMENT_MAX_LENGTH_FOR_SETTLEMENT = 5000

    # @return Crest::Request
    def build_api_request_for_get_issuing_settlements_settlement(*, settlement : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_issuing_settlements_settlement ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"settlement\" is required and cannot be null") if settlement.nil?
        if _settlement = settlement
          OpenApi::PrimitiveValidator.validate_max_length("settlement", settlement.to_s.size, GET_ISSUING_SETTLEMENTS_SETTLEMENT_MAX_LENGTH_FOR_SETTLEMENT)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/settlements/{settlement}".sub("{" + "settlement" + "}", URI.encode_path(settlement.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_issuing_settlements_settlement",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of Issuing <code>Transaction</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
    # @optional @param card [String?] Only return transactions that belong to the given card.
    # @optional @param cardholder [String?] Only return transactions that belong to the given cardholder.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return transactions that were created during the given date interval.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param _type [String?] Only return transactions that have the given type. One of `capture` or `refund`.
    # @return [IssuingTransactionList]
    def get_issuing_transactions(*, card : String? = nil, cardholder : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, _type : String? = nil)
      data, _status_code, _headers = get_issuing_transactions_with_http_info(card: card, cardholder: cardholder, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, _type: _type)
      data
    end

    # &lt;p&gt;Returns a list of Issuing &lt;code&gt;Transaction&lt;/code&gt; objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.&lt;/p&gt;
    # @optional @param card [String?] Only return transactions that belong to the given card.
    # @optional @param cardholder [String?] Only return transactions that belong to the given cardholder.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return transactions that were created during the given date interval.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param _type [String?] Only return transactions that have the given type. One of `capture` or `refund`.
    # @return [Array<(IssuingTransactionList, Integer, Hash)>] IssuingTransactionList data, response status code and response headers
    def get_issuing_transactions_with_http_info(*, card : String? = nil, cardholder : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, _type : String? = nil)
      request = build_api_request_for_get_issuing_transactions(card: card, cardholder: cardholder, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, _type: _type)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_issuing_transactions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingTransactionList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of Issuing &lt;code&gt;Transaction&lt;/code&gt; objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.&lt;/p&gt;
    # @optional @param card [String?] Only return transactions that belong to the given card.
    # @optional @param cardholder [String?] Only return transactions that belong to the given cardholder.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return transactions that were created during the given date interval.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param _type [String?] Only return transactions that have the given type. One of `capture` or `refund`.
    # @return nil
    def get_issuing_transactions(*, card : String? = nil, cardholder : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, _type : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_issuing_transactions(card: card, cardholder: cardholder, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, _type: _type).execute(&block)
    end

    GET_ISSUING_TRANSACTIONS_MAX_LENGTH_FOR_CARD           = 5000
    GET_ISSUING_TRANSACTIONS_MAX_LENGTH_FOR_CARDHOLDER     = 5000
    GET_ISSUING_TRANSACTIONS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_ISSUING_TRANSACTIONS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_ISSUING_TRANSACTIONS_VALID_VALUES_FOR__TYPE        = StaticArray["capture", "refund"]

    # @return Crest::Request
    def build_api_request_for_get_issuing_transactions(*, card : String? = nil, cardholder : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, _type : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_issuing_transactions ..." }
      end

      if client_side_validation
        if _card = card
          OpenApi::PrimitiveValidator.validate_max_length("card", card.to_s.size, GET_ISSUING_TRANSACTIONS_MAX_LENGTH_FOR_CARD)
        end
        if _cardholder = cardholder
          OpenApi::PrimitiveValidator.validate_max_length("cardholder", cardholder.to_s.size, GET_ISSUING_TRANSACTIONS_MAX_LENGTH_FOR_CARDHOLDER)
        end
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_ISSUING_TRANSACTIONS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_ISSUING_TRANSACTIONS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if __type = _type
          OpenApi::EnumValidator.validate("_type", __type, GET_ISSUING_TRANSACTIONS_VALID_VALUES_FOR__TYPE)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/transactions"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["card"] = card.to_s if !card.nil?
      query_params["cardholder"] = cardholder.to_s if !cardholder.nil?
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["type"] = _type.to_s if !_type.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_issuing_transactions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves an Issuing <code>Transaction</code> object.</p>
    # @param transaction [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [IssuingTransaction]
    def get_issuing_transactions_transaction(*, transaction : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_issuing_transactions_transaction_with_http_info(transaction: transaction, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves an Issuing &lt;code&gt;Transaction&lt;/code&gt; object.&lt;/p&gt;
    # @param transaction [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(IssuingTransaction, Integer, Hash)>] IssuingTransaction data, response status code and response headers
    def get_issuing_transactions_transaction_with_http_info(*, transaction : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_issuing_transactions_transaction(transaction: transaction, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_issuing_transactions_transaction\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingTransaction.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves an Issuing &lt;code&gt;Transaction&lt;/code&gt; object.&lt;/p&gt;
    # @param transaction [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_issuing_transactions_transaction(*, transaction : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_issuing_transactions_transaction(transaction: transaction, expand: expand).execute(&block)
    end

    GET_ISSUING_TRANSACTIONS_TRANSACTION_MAX_LENGTH_FOR_TRANSACTION = 5000

    # @return Crest::Request
    def build_api_request_for_get_issuing_transactions_transaction(*, transaction : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_issuing_transactions_transaction ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"transaction\" is required and cannot be null") if transaction.nil?
        if _transaction = transaction
          OpenApi::PrimitiveValidator.validate_max_length("transaction", transaction.to_s.size, GET_ISSUING_TRANSACTIONS_TRANSACTION_MAX_LENGTH_FOR_TRANSACTION)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/transactions/{transaction}".sub("{" + "transaction" + "}", URI.encode_path(transaction.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_issuing_transactions_transaction",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of a Financial Connections <code>Session</code></p>
    # @param session [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [FinancialConnectionsSession]
    def get_link_account_sessions_session(*, session : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_link_account_sessions_session_with_http_info(session: session, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of a Financial Connections &lt;code&gt;Session&lt;/code&gt;&lt;/p&gt;
    # @param session [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(FinancialConnectionsSession, Integer, Hash)>] FinancialConnectionsSession data, response status code and response headers
    def get_link_account_sessions_session_with_http_info(*, session : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_link_account_sessions_session(session: session, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_link_account_sessions_session\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FinancialConnectionsSession.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of a Financial Connections &lt;code&gt;Session&lt;/code&gt;&lt;/p&gt;
    # @param session [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_link_account_sessions_session(*, session : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_link_account_sessions_session(session: session, expand: expand).execute(&block)
    end

    GET_LINK_ACCOUNT_SESSIONS_SESSION_MAX_LENGTH_FOR_SESSION = 5000

    # @return Crest::Request
    def build_api_request_for_get_link_account_sessions_session(*, session : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_link_account_sessions_session ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"session\" is required and cannot be null") if session.nil?
        if _session = session
          OpenApi::PrimitiveValidator.validate_max_length("session", session.to_s.size, GET_LINK_ACCOUNT_SESSIONS_SESSION_MAX_LENGTH_FOR_SESSION)
        end
      end

      # resource path
      local_var_path = "/v1/link_account_sessions/{session}".sub("{" + "session" + "}", URI.encode_path(session.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_link_account_sessions_session",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of Financial Connections <code>Account</code> objects.</p>
    # @optional @param account_holder [Stripe::AccountholderParams?] If present, only return accounts that belong to the specified account holder. `account_holder[customer]` and `account_holder[account]` are mutually exclusive.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param session [String?] If present, only return accounts that were collected as part of the given session.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [BankConnectionsResourceLinkedAccountList]
    def get_linked_accounts(*, account_holder : Stripe::AccountholderParams? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, session : String? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_linked_accounts_with_http_info(account_holder: account_holder, ending_before: ending_before, expand: expand, limit: limit, session: session, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of Financial Connections &lt;code&gt;Account&lt;/code&gt; objects.&lt;/p&gt;
    # @optional @param account_holder [Stripe::AccountholderParams?] If present, only return accounts that belong to the specified account holder. `account_holder[customer]` and `account_holder[account]` are mutually exclusive.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param session [String?] If present, only return accounts that were collected as part of the given session.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(BankConnectionsResourceLinkedAccountList, Integer, Hash)>] BankConnectionsResourceLinkedAccountList data, response status code and response headers
    def get_linked_accounts_with_http_info(*, account_holder : Stripe::AccountholderParams? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, session : String? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_linked_accounts(account_holder: account_holder, ending_before: ending_before, expand: expand, limit: limit, session: session, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_linked_accounts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return BankConnectionsResourceLinkedAccountList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of Financial Connections &lt;code&gt;Account&lt;/code&gt; objects.&lt;/p&gt;
    # @optional @param account_holder [Stripe::AccountholderParams?] If present, only return accounts that belong to the specified account holder. `account_holder[customer]` and `account_holder[account]` are mutually exclusive.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param session [String?] If present, only return accounts that were collected as part of the given session.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_linked_accounts(*, account_holder : Stripe::AccountholderParams? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, session : String? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_linked_accounts(account_holder: account_holder, ending_before: ending_before, expand: expand, limit: limit, session: session, starting_after: starting_after).execute(&block)
    end

    GET_LINKED_ACCOUNTS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_LINKED_ACCOUNTS_MAX_LENGTH_FOR_SESSION        = 5000
    GET_LINKED_ACCOUNTS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_linked_accounts(*, account_holder : Stripe::AccountholderParams? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, session : String? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_linked_accounts ..." }
      end

      if client_side_validation
        if _account_holder = account_holder
          _account_holder.validate if _account_holder.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_LINKED_ACCOUNTS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _session = session
          OpenApi::PrimitiveValidator.validate_max_length("session", session.to_s.size, GET_LINKED_ACCOUNTS_MAX_LENGTH_FOR_SESSION)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_LINKED_ACCOUNTS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/linked_accounts"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["account_holder"] = account_holder.to_s if !account_holder.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["session"] = session.to_s if !session.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_linked_accounts",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an Financial Connections <code>Account</code>.</p>
    # @param account [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [FinancialConnectionsAccount]
    def get_linked_accounts_account(*, account : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_linked_accounts_account_with_http_info(account: account, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an Financial Connections &lt;code&gt;Account&lt;/code&gt;.&lt;/p&gt;
    # @param account [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(FinancialConnectionsAccount, Integer, Hash)>] FinancialConnectionsAccount data, response status code and response headers
    def get_linked_accounts_account_with_http_info(*, account : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_linked_accounts_account(account: account, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_linked_accounts_account\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FinancialConnectionsAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an Financial Connections &lt;code&gt;Account&lt;/code&gt;.&lt;/p&gt;
    # @param account [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_linked_accounts_account(*, account : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_linked_accounts_account(account: account, expand: expand).execute(&block)
    end

    GET_LINKED_ACCOUNTS_ACCOUNT_MAX_LENGTH_FOR_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_get_linked_accounts_account(*, account : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_linked_accounts_account ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, GET_LINKED_ACCOUNTS_ACCOUNT_MAX_LENGTH_FOR_ACCOUNT)
        end
      end

      # resource path
      local_var_path = "/v1/linked_accounts/{account}".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_linked_accounts_account",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Lists all owners for a given <code>Account</code></p>
    # @param account [String?]
    # @param ownership [String?] The ID of the ownership object to fetch owners from.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [BankConnectionsResourceOwnerList]
    def get_linked_accounts_account_owners(*, account : String? = nil, ownership : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_linked_accounts_account_owners_with_http_info(account: account, ownership: ownership, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Lists all owners for a given &lt;code&gt;Account&lt;/code&gt;&lt;/p&gt;
    # @param account [String?]
    # @param ownership [String?] The ID of the ownership object to fetch owners from.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(BankConnectionsResourceOwnerList, Integer, Hash)>] BankConnectionsResourceOwnerList data, response status code and response headers
    def get_linked_accounts_account_owners_with_http_info(*, account : String? = nil, ownership : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_linked_accounts_account_owners(account: account, ownership: ownership, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_linked_accounts_account_owners\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return BankConnectionsResourceOwnerList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Lists all owners for a given &lt;code&gt;Account&lt;/code&gt;&lt;/p&gt;
    # @param account [String?]
    # @param ownership [String?] The ID of the ownership object to fetch owners from.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_linked_accounts_account_owners(*, account : String? = nil, ownership : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_linked_accounts_account_owners(account: account, ownership: ownership, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_LINKED_ACCOUNTS_ACCOUNT_OWNERS_MAX_LENGTH_FOR_ACCOUNT        = 5000
    GET_LINKED_ACCOUNTS_ACCOUNT_OWNERS_MAX_LENGTH_FOR_OWNERSHIP      = 5000
    GET_LINKED_ACCOUNTS_ACCOUNT_OWNERS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_LINKED_ACCOUNTS_ACCOUNT_OWNERS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_linked_accounts_account_owners(*, account : String? = nil, ownership : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_linked_accounts_account_owners ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, GET_LINKED_ACCOUNTS_ACCOUNT_OWNERS_MAX_LENGTH_FOR_ACCOUNT)
        end
        raise ArgumentError.new("\"ownership\" is required and cannot be null") if ownership.nil?
        if _ownership = ownership
          OpenApi::PrimitiveValidator.validate_max_length("ownership", ownership.to_s.size, GET_LINKED_ACCOUNTS_ACCOUNT_OWNERS_MAX_LENGTH_FOR_OWNERSHIP)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_LINKED_ACCOUNTS_ACCOUNT_OWNERS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_LINKED_ACCOUNTS_ACCOUNT_OWNERS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/linked_accounts/{account}/owners".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["ownership"] = ownership.to_s if !ownership.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_linked_accounts_account_owners",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a Mandate object.</p>
    # @param mandate [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Mandate]
    def get_mandates_mandate(*, mandate : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_mandates_mandate_with_http_info(mandate: mandate, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves a Mandate object.&lt;/p&gt;
    # @param mandate [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Mandate, Integer, Hash)>] Mandate data, response status code and response headers
    def get_mandates_mandate_with_http_info(*, mandate : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_mandates_mandate(mandate: mandate, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_mandates_mandate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Mandate.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a Mandate object.&lt;/p&gt;
    # @param mandate [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_mandates_mandate(*, mandate : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_mandates_mandate(mandate: mandate, expand: expand).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_get_mandates_mandate(*, mandate : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_mandates_mandate ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"mandate\" is required and cannot be null") if mandate.nil?
      end

      # resource path
      local_var_path = "/v1/mandates/{mandate}".sub("{" + "mandate" + "}", URI.encode_path(mandate.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_mandates_mandate",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of your orders. The orders are returned sorted by creation date, with the most recently created orders appearing first.</p>
    # @optional @param customer [String?] Only return orders for the given customer.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [OrdersV2ResourceOrderList]
    def get_orders(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_orders_with_http_info(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of your orders. The orders are returned sorted by creation date, with the most recently created orders appearing first.&lt;/p&gt;
    # @optional @param customer [String?] Only return orders for the given customer.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(OrdersV2ResourceOrderList, Integer, Hash)>] OrdersV2ResourceOrderList data, response status code and response headers
    def get_orders_with_http_info(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_orders(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_orders\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return OrdersV2ResourceOrderList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of your orders. The orders are returned sorted by creation date, with the most recently created orders appearing first.&lt;/p&gt;
    # @optional @param customer [String?] Only return orders for the given customer.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_orders(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_orders(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_ORDERS_MAX_LENGTH_FOR_CUSTOMER = 5000

    # @return Crest::Request
    def build_api_request_for_get_orders(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_orders ..." }
      end

      if client_side_validation
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_ORDERS_MAX_LENGTH_FOR_CUSTOMER)
        end
      end

      # resource path
      local_var_path = "/v1/orders"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["customer"] = customer.to_s if !customer.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_orders",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an existing order. Supply the unique order ID from either an order creation request or the order list, and Stripe will return the corresponding order information.</p>
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Order]
    def get_orders_id(*, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_orders_id_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an existing order. Supply the unique order ID from either an order creation request or the order list, and Stripe will return the corresponding order information.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Order, Integer, Hash)>] Order data, response status code and response headers
    def get_orders_id_with_http_info(*, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_orders_id(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_orders_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Order.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an existing order. Supply the unique order ID from either an order creation request or the order list, and Stripe will return the corresponding order information.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_orders_id(*, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_orders_id(id: id, expand: expand).execute(&block)
    end

    GET_ORDERS_ID_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_get_orders_id(*, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_orders_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_ORDERS_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/orders/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_orders_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>When retrieving an order, there is an includable <strong>line_items</strong> property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.</p>
    # @param id [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [OrdersV2ResourceLineItemList]
    def get_orders_id_line_items(*, id : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_orders_id_line_items_with_http_info(id: id, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;When retrieving an order, there is an includable &lt;strong&gt;line_items&lt;/strong&gt; property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.&lt;/p&gt;
    # @param id [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(OrdersV2ResourceLineItemList, Integer, Hash)>] OrdersV2ResourceLineItemList data, response status code and response headers
    def get_orders_id_line_items_with_http_info(*, id : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_orders_id_line_items(id: id, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_orders_id_line_items\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return OrdersV2ResourceLineItemList.from_json(data), status_code, headers
    end

    # &lt;p&gt;When retrieving an order, there is an includable &lt;strong&gt;line_items&lt;/strong&gt; property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.&lt;/p&gt;
    # @param id [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_orders_id_line_items(*, id : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_orders_id_line_items(id: id, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_ORDERS_ID_LINE_ITEMS_MAX_LENGTH_FOR_ID             = 5000
    GET_ORDERS_ID_LINE_ITEMS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_ORDERS_ID_LINE_ITEMS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_orders_id_line_items(*, id : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_orders_id_line_items ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_ORDERS_ID_LINE_ITEMS_MAX_LENGTH_FOR_ID)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_ORDERS_ID_LINE_ITEMS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_ORDERS_ID_LINE_ITEMS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/orders/{id}/line_items".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_orders_id_line_items",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of PaymentIntents.</p>
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param customer [String?] Only return PaymentIntents for the customer specified by this customer ID.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [PaymentFlowsPaymentIntentList]
    def get_payment_intents(*, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_payment_intents_with_http_info(created: created, customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of PaymentIntents.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param customer [String?] Only return PaymentIntents for the customer specified by this customer ID.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(PaymentFlowsPaymentIntentList, Integer, Hash)>] PaymentFlowsPaymentIntentList data, response status code and response headers
    def get_payment_intents_with_http_info(*, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_payment_intents(created: created, customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_payment_intents\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentFlowsPaymentIntentList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of PaymentIntents.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param customer [String?] Only return PaymentIntents for the customer specified by this customer ID.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_payment_intents(*, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_payment_intents(created: created, customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_PAYMENT_INTENTS_MAX_LENGTH_FOR_CUSTOMER       = 5000
    GET_PAYMENT_INTENTS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_PAYMENT_INTENTS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_payment_intents(*, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_payment_intents ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_PAYMENT_INTENTS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_PAYMENT_INTENTS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_PAYMENT_INTENTS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/payment_intents"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["customer"] = customer.to_s if !customer.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_payment_intents",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of a PaymentIntent that has previously been created. </p>  <p>Client-side retrieval using a publishable key is allowed when the <code>client_secret</code> is provided in the query string. </p>  <p>When retrieved with a publishable key, only a subset of properties will be returned. Please refer to the <a href=\"#payment_intent_object\">payment intent</a> object reference for more details.</p>
    # @param intent [String?]
    # @optional @param client_secret [String?] The client secret of the PaymentIntent. Required if a publishable key is used to retrieve the source.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [PaymentIntent]
    def get_payment_intents_intent(*, intent : String? = nil, client_secret : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_payment_intents_intent_with_http_info(intent: intent, client_secret: client_secret, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of a PaymentIntent that has previously been created. &lt;/p&gt;  &lt;p&gt;Client-side retrieval using a publishable key is allowed when the &lt;code&gt;client_secret&lt;/code&gt; is provided in the query string. &lt;/p&gt;  &lt;p&gt;When retrieved with a publishable key, only a subset of properties will be returned. Please refer to the &lt;a href&#x3D;\&quot;#payment_intent_object\&quot;&gt;payment intent&lt;/a&gt; object reference for more details.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param client_secret [String?] The client secret of the PaymentIntent. Required if a publishable key is used to retrieve the source.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(PaymentIntent, Integer, Hash)>] PaymentIntent data, response status code and response headers
    def get_payment_intents_intent_with_http_info(*, intent : String? = nil, client_secret : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_payment_intents_intent(intent: intent, client_secret: client_secret, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_payment_intents_intent\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentIntent.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of a PaymentIntent that has previously been created. &lt;/p&gt;  &lt;p&gt;Client-side retrieval using a publishable key is allowed when the &lt;code&gt;client_secret&lt;/code&gt; is provided in the query string. &lt;/p&gt;  &lt;p&gt;When retrieved with a publishable key, only a subset of properties will be returned. Please refer to the &lt;a href&#x3D;\&quot;#payment_intent_object\&quot;&gt;payment intent&lt;/a&gt; object reference for more details.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param client_secret [String?] The client secret of the PaymentIntent. Required if a publishable key is used to retrieve the source.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_payment_intents_intent(*, intent : String? = nil, client_secret : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_payment_intents_intent(intent: intent, client_secret: client_secret, expand: expand).execute(&block)
    end

    GET_PAYMENT_INTENTS_INTENT_MAX_LENGTH_FOR_INTENT        = 5000
    GET_PAYMENT_INTENTS_INTENT_MAX_LENGTH_FOR_CLIENT_SECRET = 5000

    # @return Crest::Request
    def build_api_request_for_get_payment_intents_intent(*, intent : String? = nil, client_secret : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_payment_intents_intent ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"intent\" is required and cannot be null") if intent.nil?
        if _intent = intent
          OpenApi::PrimitiveValidator.validate_max_length("intent", intent.to_s.size, GET_PAYMENT_INTENTS_INTENT_MAX_LENGTH_FOR_INTENT)
        end
        if _client_secret = client_secret
          OpenApi::PrimitiveValidator.validate_max_length("client_secret", client_secret.to_s.size, GET_PAYMENT_INTENTS_INTENT_MAX_LENGTH_FOR_CLIENT_SECRET)
        end
      end

      # resource path
      local_var_path = "/v1/payment_intents/{intent}".sub("{" + "intent" + "}", URI.encode_path(intent.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["client_secret"] = client_secret.to_s if !client_secret.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_payment_intents_intent",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Search for PaymentIntents you’ve previously created using Stripe’s <a href=\"/docs/search#search-query-language\">Search Query Language</a>. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.</p>
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for payment intents](https://stripe.com/docs/search#query-fields-for-payment-intents).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return [SearchResult3]
    def get_payment_intents_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil)
      data, _status_code, _headers = get_payment_intents_search_with_http_info(query: query, expand: expand, limit: limit, page: page)
      data
    end

    # &lt;p&gt;Search for PaymentIntents you’ve previously created using Stripe’s &lt;a href&#x3D;\&quot;/docs/search#search-query-language\&quot;&gt;Search Query Language&lt;/a&gt;. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.&lt;/p&gt;
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for payment intents](https://stripe.com/docs/search#query-fields-for-payment-intents).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return [Array<(SearchResult3, Integer, Hash)>] SearchResult3 data, response status code and response headers
    def get_payment_intents_search_with_http_info(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil)
      request = build_api_request_for_get_payment_intents_search(query: query, expand: expand, limit: limit, page: page)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_payment_intents_search\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SearchResult3.from_json(data), status_code, headers
    end

    # &lt;p&gt;Search for PaymentIntents you’ve previously created using Stripe’s &lt;a href&#x3D;\&quot;/docs/search#search-query-language\&quot;&gt;Search Query Language&lt;/a&gt;. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.&lt;/p&gt;
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for payment intents](https://stripe.com/docs/search#query-fields-for-payment-intents).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return nil
    def get_payment_intents_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_payment_intents_search(query: query, expand: expand, limit: limit, page: page).execute(&block)
    end

    GET_PAYMENT_INTENTS_SEARCH_MAX_LENGTH_FOR_QUERY = 5000
    GET_PAYMENT_INTENTS_SEARCH_MAX_LENGTH_FOR_PAGE  = 5000

    # @return Crest::Request
    def build_api_request_for_get_payment_intents_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_payment_intents_search ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"query\" is required and cannot be null") if query.nil?
        if _query = query
          OpenApi::PrimitiveValidator.validate_max_length("query", query.to_s.size, GET_PAYMENT_INTENTS_SEARCH_MAX_LENGTH_FOR_QUERY)
        end

        if _page = page
          OpenApi::PrimitiveValidator.validate_max_length("page", page.to_s.size, GET_PAYMENT_INTENTS_SEARCH_MAX_LENGTH_FOR_PAGE)
        end
      end

      # resource path
      local_var_path = "/v1/payment_intents/search"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["page"] = page.to_s if !page.nil?
      query_params["query"] = query.to_s if !query.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_payment_intents_search",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of your payment links.</p>
    # @optional @param active [Bool?] Only return payment links that are active or inactive (e.g., pass `false` to list all inactive payment links).
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [PaymentLinksResourcePaymentLinkList]
    def get_payment_links(*, active : Bool? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_payment_links_with_http_info(active: active, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of your payment links.&lt;/p&gt;
    # @optional @param active [Bool?] Only return payment links that are active or inactive (e.g., pass `false` to list all inactive payment links).
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(PaymentLinksResourcePaymentLinkList, Integer, Hash)>] PaymentLinksResourcePaymentLinkList data, response status code and response headers
    def get_payment_links_with_http_info(*, active : Bool? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_payment_links(active: active, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_payment_links\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentLinksResourcePaymentLinkList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of your payment links.&lt;/p&gt;
    # @optional @param active [Bool?] Only return payment links that are active or inactive (e.g., pass `false` to list all inactive payment links).
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_payment_links(*, active : Bool? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_payment_links(active: active, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_PAYMENT_LINKS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_PAYMENT_LINKS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_payment_links(*, active : Bool? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_payment_links ..." }
      end

      if client_side_validation
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_PAYMENT_LINKS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_PAYMENT_LINKS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/payment_links"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["active"] = active.to_s if !active.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_payment_links",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieve a payment link.</p>
    # @param payment_link [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [PaymentLink]
    def get_payment_links_payment_link(*, payment_link : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_payment_links_payment_link_with_http_info(payment_link: payment_link, expand: expand)
      data
    end

    # &lt;p&gt;Retrieve a payment link.&lt;/p&gt;
    # @param payment_link [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(PaymentLink, Integer, Hash)>] PaymentLink data, response status code and response headers
    def get_payment_links_payment_link_with_http_info(*, payment_link : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_payment_links_payment_link(payment_link: payment_link, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_payment_links_payment_link\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentLink.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieve a payment link.&lt;/p&gt;
    # @param payment_link [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_payment_links_payment_link(*, payment_link : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_payment_links_payment_link(payment_link: payment_link, expand: expand).execute(&block)
    end

    GET_PAYMENT_LINKS_PAYMENT_LINK_MAX_LENGTH_FOR_PAYMENT_LINK = 5000

    # @return Crest::Request
    def build_api_request_for_get_payment_links_payment_link(*, payment_link : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_payment_links_payment_link ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"payment_link\" is required and cannot be null") if payment_link.nil?
        if _payment_link = payment_link
          OpenApi::PrimitiveValidator.validate_max_length("payment_link", payment_link.to_s.size, GET_PAYMENT_LINKS_PAYMENT_LINK_MAX_LENGTH_FOR_PAYMENT_LINK)
        end
      end

      # resource path
      local_var_path = "/v1/payment_links/{payment_link}".sub("{" + "payment_link" + "}", URI.encode_path(payment_link.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_payment_links_payment_link",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>When retrieving a payment link, there is an includable <strong>line_items</strong> property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.</p>
    # @param payment_link [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [PaymentLinksResourceListLineItems]
    def get_payment_links_payment_link_line_items(*, payment_link : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_payment_links_payment_link_line_items_with_http_info(payment_link: payment_link, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;When retrieving a payment link, there is an includable &lt;strong&gt;line_items&lt;/strong&gt; property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.&lt;/p&gt;
    # @param payment_link [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(PaymentLinksResourceListLineItems, Integer, Hash)>] PaymentLinksResourceListLineItems data, response status code and response headers
    def get_payment_links_payment_link_line_items_with_http_info(*, payment_link : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_payment_links_payment_link_line_items(payment_link: payment_link, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_payment_links_payment_link_line_items\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentLinksResourceListLineItems.from_json(data), status_code, headers
    end

    # &lt;p&gt;When retrieving a payment link, there is an includable &lt;strong&gt;line_items&lt;/strong&gt; property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.&lt;/p&gt;
    # @param payment_link [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_payment_links_payment_link_line_items(*, payment_link : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_payment_links_payment_link_line_items(payment_link: payment_link, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_PAYMENT_LINKS_PAYMENT_LINK_LINE_ITEMS_MAX_LENGTH_FOR_PAYMENT_LINK   = 5000
    GET_PAYMENT_LINKS_PAYMENT_LINK_LINE_ITEMS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_PAYMENT_LINKS_PAYMENT_LINK_LINE_ITEMS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_payment_links_payment_link_line_items(*, payment_link : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_payment_links_payment_link_line_items ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"payment_link\" is required and cannot be null") if payment_link.nil?
        if _payment_link = payment_link
          OpenApi::PrimitiveValidator.validate_max_length("payment_link", payment_link.to_s.size, GET_PAYMENT_LINKS_PAYMENT_LINK_LINE_ITEMS_MAX_LENGTH_FOR_PAYMENT_LINK)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_PAYMENT_LINKS_PAYMENT_LINK_LINE_ITEMS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_PAYMENT_LINKS_PAYMENT_LINK_LINE_ITEMS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/payment_links/{payment_link}/line_items".sub("{" + "payment_link" + "}", URI.encode_path(payment_link.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_payment_links_payment_link_line_items",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of PaymentMethods attached to the StripeAccount. For listing a customer’s payment methods, you should use <a href=\"/docs/api/payment_methods/customer_list\">List a Customer’s PaymentMethods</a></p>
    # @param _type [String?] A required filter on the list, based on the object `type` field.
    # @optional @param customer [String?] The ID of the customer whose PaymentMethods will be retrieved.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [PaymentFlowsPaymentMethodList]
    def get_payment_methods(*, _type : String? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_payment_methods_with_http_info(_type: _type, customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of PaymentMethods attached to the StripeAccount. For listing a customer’s payment methods, you should use &lt;a href&#x3D;\&quot;/docs/api/payment_methods/customer_list\&quot;&gt;List a Customer’s PaymentMethods&lt;/a&gt;&lt;/p&gt;
    # @param _type [String?] A required filter on the list, based on the object `type` field.
    # @optional @param customer [String?] The ID of the customer whose PaymentMethods will be retrieved.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(PaymentFlowsPaymentMethodList, Integer, Hash)>] PaymentFlowsPaymentMethodList data, response status code and response headers
    def get_payment_methods_with_http_info(*, _type : String? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_payment_methods(_type: _type, customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_payment_methods\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentFlowsPaymentMethodList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of PaymentMethods attached to the StripeAccount. For listing a customer’s payment methods, you should use &lt;a href&#x3D;\&quot;/docs/api/payment_methods/customer_list\&quot;&gt;List a Customer’s PaymentMethods&lt;/a&gt;&lt;/p&gt;
    # @param _type [String?] A required filter on the list, based on the object `type` field.
    # @optional @param customer [String?] The ID of the customer whose PaymentMethods will be retrieved.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_payment_methods(*, _type : String? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_payment_methods(_type: _type, customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_PAYMENT_METHODS_VALID_VALUES_FOR__TYPE  = StaticArray["acss_debit", "affirm", "afterpay_clearpay", "alipay", "au_becs_debit", "bacs_debit", "bancontact", "blik", "boleto", "card", "customer_balance", "eps", "fpx", "giropay", "grabpay", "ideal", "klarna", "konbini", "link", "oxxo", "p24", "paynow", "pix", "promptpay", "sepa_debit", "sofort", "us_bank_account", "wechat_pay"]
    GET_PAYMENT_METHODS_MAX_LENGTH_FOR_CUSTOMER = 5000

    # @return Crest::Request
    def build_api_request_for_get_payment_methods(*, _type : String? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_payment_methods ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"_type\" is required and cannot be null") if _type.nil?
        if __type = _type
          OpenApi::EnumValidator.validate("_type", __type, GET_PAYMENT_METHODS_VALID_VALUES_FOR__TYPE)
        end
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_PAYMENT_METHODS_MAX_LENGTH_FOR_CUSTOMER)
        end
      end

      # resource path
      local_var_path = "/v1/payment_methods"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["customer"] = customer.to_s if !customer.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["type"] = _type.to_s if !_type.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_payment_methods",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a PaymentMethod object attached to the StripeAccount. To retrieve a payment method attached to a Customer, you should use <a href=\"/docs/api/payment_methods/customer\">Retrieve a Customer’s PaymentMethods</a></p>
    # @param payment_method [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [PaymentMethod]
    def get_payment_methods_payment_method(*, payment_method : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_payment_methods_payment_method_with_http_info(payment_method: payment_method, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves a PaymentMethod object attached to the StripeAccount. To retrieve a payment method attached to a Customer, you should use &lt;a href&#x3D;\&quot;/docs/api/payment_methods/customer\&quot;&gt;Retrieve a Customer’s PaymentMethods&lt;/a&gt;&lt;/p&gt;
    # @param payment_method [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(PaymentMethod, Integer, Hash)>] PaymentMethod data, response status code and response headers
    def get_payment_methods_payment_method_with_http_info(*, payment_method : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_payment_methods_payment_method(payment_method: payment_method, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_payment_methods_payment_method\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentMethod.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a PaymentMethod object attached to the StripeAccount. To retrieve a payment method attached to a Customer, you should use &lt;a href&#x3D;\&quot;/docs/api/payment_methods/customer\&quot;&gt;Retrieve a Customer’s PaymentMethods&lt;/a&gt;&lt;/p&gt;
    # @param payment_method [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_payment_methods_payment_method(*, payment_method : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_payment_methods_payment_method(payment_method: payment_method, expand: expand).execute(&block)
    end

    GET_PAYMENT_METHODS_PAYMENT_METHOD_MAX_LENGTH_FOR_PAYMENT_METHOD = 5000

    # @return Crest::Request
    def build_api_request_for_get_payment_methods_payment_method(*, payment_method : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_payment_methods_payment_method ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"payment_method\" is required and cannot be null") if payment_method.nil?
        if _payment_method = payment_method
          OpenApi::PrimitiveValidator.validate_max_length("payment_method", payment_method.to_s.size, GET_PAYMENT_METHODS_PAYMENT_METHOD_MAX_LENGTH_FOR_PAYMENT_METHOD)
        end
      end

      # resource path
      local_var_path = "/v1/payment_methods/{payment_method}".sub("{" + "payment_method" + "}", URI.encode_path(payment_method.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_payment_methods_payment_method",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of existing payouts sent to third-party bank accounts or that Stripe has sent you. The payouts are returned in sorted order, with the most recently created payouts appearing first.</p>
    # @optional @param arrival_date [Stripe::GetAccountsCreatedParameter?]
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param destination [String?] The ID of an external account - only return payouts sent to this external account.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return payouts that have the given status: `pending`, `paid`, `failed`, or `canceled`.
    # @return [PayoutList]
    def get_payouts(*, arrival_date : Stripe::GetAccountsCreatedParameter? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, destination : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil)
      data, _status_code, _headers = get_payouts_with_http_info(arrival_date: arrival_date, created: created, destination: destination, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status)
      data
    end

    # &lt;p&gt;Returns a list of existing payouts sent to third-party bank accounts or that Stripe has sent you. The payouts are returned in sorted order, with the most recently created payouts appearing first.&lt;/p&gt;
    # @optional @param arrival_date [Stripe::GetAccountsCreatedParameter?]
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param destination [String?] The ID of an external account - only return payouts sent to this external account.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return payouts that have the given status: `pending`, `paid`, `failed`, or `canceled`.
    # @return [Array<(PayoutList, Integer, Hash)>] PayoutList data, response status code and response headers
    def get_payouts_with_http_info(*, arrival_date : Stripe::GetAccountsCreatedParameter? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, destination : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil)
      request = build_api_request_for_get_payouts(arrival_date: arrival_date, created: created, destination: destination, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_payouts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PayoutList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of existing payouts sent to third-party bank accounts or that Stripe has sent you. The payouts are returned in sorted order, with the most recently created payouts appearing first.&lt;/p&gt;
    # @optional @param arrival_date [Stripe::GetAccountsCreatedParameter?]
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param destination [String?] The ID of an external account - only return payouts sent to this external account.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return payouts that have the given status: `pending`, `paid`, `failed`, or `canceled`.
    # @return nil
    def get_payouts(*, arrival_date : Stripe::GetAccountsCreatedParameter? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, destination : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_payouts(arrival_date: arrival_date, created: created, destination: destination, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status).execute(&block)
    end

    GET_PAYOUTS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_PAYOUTS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_PAYOUTS_MAX_LENGTH_FOR_STATUS         = 5000

    # @return Crest::Request
    def build_api_request_for_get_payouts(*, arrival_date : Stripe::GetAccountsCreatedParameter? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, destination : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_payouts ..." }
      end

      if client_side_validation
        if _arrival_date = arrival_date
          _arrival_date.validate if _arrival_date.is_a?(OpenApi::Validatable)
        end
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end

        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_PAYOUTS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_PAYOUTS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _status = status
          OpenApi::PrimitiveValidator.validate_max_length("status", status.to_s.size, GET_PAYOUTS_MAX_LENGTH_FOR_STATUS)
        end
      end

      # resource path
      local_var_path = "/v1/payouts"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["arrival_date"] = arrival_date.to_s if !arrival_date.nil?
      query_params["created"] = created.to_s if !created.nil?
      query_params["destination"] = destination.to_s if !destination.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["status"] = status.to_s if !status.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_payouts",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an existing payout. Supply the unique payout ID from either a payout creation request or the payout list, and Stripe will return the corresponding payout information.</p>
    # @param payout [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Payout]
    def get_payouts_payout(*, payout : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_payouts_payout_with_http_info(payout: payout, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an existing payout. Supply the unique payout ID from either a payout creation request or the payout list, and Stripe will return the corresponding payout information.&lt;/p&gt;
    # @param payout [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Payout, Integer, Hash)>] Payout data, response status code and response headers
    def get_payouts_payout_with_http_info(*, payout : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_payouts_payout(payout: payout, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_payouts_payout\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Payout.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an existing payout. Supply the unique payout ID from either a payout creation request or the payout list, and Stripe will return the corresponding payout information.&lt;/p&gt;
    # @param payout [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_payouts_payout(*, payout : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_payouts_payout(payout: payout, expand: expand).execute(&block)
    end

    GET_PAYOUTS_PAYOUT_MAX_LENGTH_FOR_PAYOUT = 5000

    # @return Crest::Request
    def build_api_request_for_get_payouts_payout(*, payout : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_payouts_payout ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"payout\" is required and cannot be null") if payout.nil?
        if _payout = payout
          OpenApi::PrimitiveValidator.validate_max_length("payout", payout.to_s.size, GET_PAYOUTS_PAYOUT_MAX_LENGTH_FOR_PAYOUT)
        end
      end

      # resource path
      local_var_path = "/v1/payouts/{payout}".sub("{" + "payout" + "}", URI.encode_path(payout.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_payouts_payout",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of your plans.</p>
    # @optional @param active [Bool?] Only return plans that are active or inactive (e.g., pass `false` to list all inactive plans).
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param product [String?] Only return plans for the given product.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [PlanList]
    def get_plans(*, active : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, product : String? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_plans_with_http_info(active: active, created: created, ending_before: ending_before, expand: expand, limit: limit, product: product, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of your plans.&lt;/p&gt;
    # @optional @param active [Bool?] Only return plans that are active or inactive (e.g., pass `false` to list all inactive plans).
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param product [String?] Only return plans for the given product.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(PlanList, Integer, Hash)>] PlanList data, response status code and response headers
    def get_plans_with_http_info(*, active : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, product : String? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_plans(active: active, created: created, ending_before: ending_before, expand: expand, limit: limit, product: product, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_plans\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PlanList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of your plans.&lt;/p&gt;
    # @optional @param active [Bool?] Only return plans that are active or inactive (e.g., pass `false` to list all inactive plans).
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param product [String?] Only return plans for the given product.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_plans(*, active : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, product : String? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_plans(active: active, created: created, ending_before: ending_before, expand: expand, limit: limit, product: product, starting_after: starting_after).execute(&block)
    end

    GET_PLANS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_PLANS_MAX_LENGTH_FOR_PRODUCT        = 5000
    GET_PLANS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_plans(*, active : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, product : String? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_plans ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_PLANS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _product = product
          OpenApi::PrimitiveValidator.validate_max_length("product", product.to_s.size, GET_PLANS_MAX_LENGTH_FOR_PRODUCT)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_PLANS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/plans"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["active"] = active.to_s if !active.nil?
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["product"] = product.to_s if !product.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_plans",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the plan with the given ID.</p>
    # @param plan [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Plan]
    def get_plans_plan(*, plan : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_plans_plan_with_http_info(plan: plan, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the plan with the given ID.&lt;/p&gt;
    # @param plan [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Plan, Integer, Hash)>] Plan data, response status code and response headers
    def get_plans_plan_with_http_info(*, plan : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_plans_plan(plan: plan, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_plans_plan\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Plan.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the plan with the given ID.&lt;/p&gt;
    # @param plan [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_plans_plan(*, plan : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_plans_plan(plan: plan, expand: expand).execute(&block)
    end

    GET_PLANS_PLAN_MAX_LENGTH_FOR_PLAN = 5000

    # @return Crest::Request
    def build_api_request_for_get_plans_plan(*, plan : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_plans_plan ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"plan\" is required and cannot be null") if plan.nil?
        if _plan = plan
          OpenApi::PrimitiveValidator.validate_max_length("plan", plan.to_s.size, GET_PLANS_PLAN_MAX_LENGTH_FOR_PLAN)
        end
      end

      # resource path
      local_var_path = "/v1/plans/{plan}".sub("{" + "plan" + "}", URI.encode_path(plan.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_plans_plan",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of your prices.</p>
    # @optional @param active [Bool?] Only return prices that are active or inactive (e.g., pass `false` to list all inactive prices).
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param currency [String?] Only return prices for the given currency.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param lookup_keys [Array(Array(String))?] Only return the price with these lookup_keys, if any exist.
    # @optional @param product [String?] Only return prices for the given product.
    # @optional @param recurring [Stripe::AllPricesRecurringParams?] Only return prices with these recurring fields.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param _type [String?] Only return prices of type `recurring` or `one_time`.
    # @return [PriceList]
    def get_prices(*, active : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, currency : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, lookup_keys : Array(Array(String))? = nil, product : String? = nil, recurring : Stripe::AllPricesRecurringParams? = nil, starting_after : String? = nil, _type : String? = nil)
      data, _status_code, _headers = get_prices_with_http_info(active: active, created: created, currency: currency, ending_before: ending_before, expand: expand, limit: limit, lookup_keys: lookup_keys, product: product, recurring: recurring, starting_after: starting_after, _type: _type)
      data
    end

    # &lt;p&gt;Returns a list of your prices.&lt;/p&gt;
    # @optional @param active [Bool?] Only return prices that are active or inactive (e.g., pass `false` to list all inactive prices).
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param currency [String?] Only return prices for the given currency.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param lookup_keys [Array(Array(String))?] Only return the price with these lookup_keys, if any exist.
    # @optional @param product [String?] Only return prices for the given product.
    # @optional @param recurring [Stripe::AllPricesRecurringParams?] Only return prices with these recurring fields.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param _type [String?] Only return prices of type `recurring` or `one_time`.
    # @return [Array<(PriceList, Integer, Hash)>] PriceList data, response status code and response headers
    def get_prices_with_http_info(*, active : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, currency : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, lookup_keys : Array(Array(String))? = nil, product : String? = nil, recurring : Stripe::AllPricesRecurringParams? = nil, starting_after : String? = nil, _type : String? = nil)
      request = build_api_request_for_get_prices(active: active, created: created, currency: currency, ending_before: ending_before, expand: expand, limit: limit, lookup_keys: lookup_keys, product: product, recurring: recurring, starting_after: starting_after, _type: _type)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_prices\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PriceList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of your prices.&lt;/p&gt;
    # @optional @param active [Bool?] Only return prices that are active or inactive (e.g., pass `false` to list all inactive prices).
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param currency [String?] Only return prices for the given currency.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param lookup_keys [Array(Array(String))?] Only return the price with these lookup_keys, if any exist.
    # @optional @param product [String?] Only return prices for the given product.
    # @optional @param recurring [Stripe::AllPricesRecurringParams?] Only return prices with these recurring fields.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param _type [String?] Only return prices of type `recurring` or `one_time`.
    # @return nil
    def get_prices(*, active : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, currency : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, lookup_keys : Array(Array(String))? = nil, product : String? = nil, recurring : Stripe::AllPricesRecurringParams? = nil, starting_after : String? = nil, _type : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_prices(active: active, created: created, currency: currency, ending_before: ending_before, expand: expand, limit: limit, lookup_keys: lookup_keys, product: product, recurring: recurring, starting_after: starting_after, _type: _type).execute(&block)
    end

    GET_PRICES_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_PRICES_MAX_LENGTH_FOR_PRODUCT        = 5000
    GET_PRICES_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_PRICES_VALID_VALUES_FOR__TYPE        = StaticArray["one_time", "recurring"]

    # @return Crest::Request
    def build_api_request_for_get_prices(*, active : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, currency : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, lookup_keys : Array(Array(String))? = nil, product : String? = nil, recurring : Stripe::AllPricesRecurringParams? = nil, starting_after : String? = nil, _type : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_prices ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end

        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_PRICES_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _product = product
          OpenApi::PrimitiveValidator.validate_max_length("product", product.to_s.size, GET_PRICES_MAX_LENGTH_FOR_PRODUCT)
        end
        if _recurring = recurring
          _recurring.validate if _recurring.is_a?(OpenApi::Validatable)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_PRICES_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if __type = _type
          OpenApi::EnumValidator.validate("_type", __type, GET_PRICES_VALID_VALUES_FOR__TYPE)
        end
      end

      # resource path
      local_var_path = "/v1/prices"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["active"] = active.to_s if !active.nil?
      query_params["created"] = created.to_s if !created.nil?
      query_params["currency"] = currency.to_s if !currency.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["lookup_keys"] = @api_client.build_collection_param(lookup_keys, "csv") if !lookup_keys.nil? && !lookup_keys.empty?
      query_params["product"] = product.to_s if !product.nil?
      query_params["recurring"] = recurring.to_s if !recurring.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["type"] = _type.to_s if !_type.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_prices",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the price with the given ID.</p>
    # @param price [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Price]
    def get_prices_price(*, price : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_prices_price_with_http_info(price: price, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the price with the given ID.&lt;/p&gt;
    # @param price [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Price, Integer, Hash)>] Price data, response status code and response headers
    def get_prices_price_with_http_info(*, price : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_prices_price(price: price, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_prices_price\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Price.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the price with the given ID.&lt;/p&gt;
    # @param price [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_prices_price(*, price : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_prices_price(price: price, expand: expand).execute(&block)
    end

    GET_PRICES_PRICE_MAX_LENGTH_FOR_PRICE = 5000

    # @return Crest::Request
    def build_api_request_for_get_prices_price(*, price : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_prices_price ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"price\" is required and cannot be null") if price.nil?
        if _price = price
          OpenApi::PrimitiveValidator.validate_max_length("price", price.to_s.size, GET_PRICES_PRICE_MAX_LENGTH_FOR_PRICE)
        end
      end

      # resource path
      local_var_path = "/v1/prices/{price}".sub("{" + "price" + "}", URI.encode_path(price.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_prices_price",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Search for prices you’ve previously created using Stripe’s <a href=\"/docs/search#search-query-language\">Search Query Language</a>. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.</p>
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for prices](https://stripe.com/docs/search#query-fields-for-prices).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return [SearchResult4]
    def get_prices_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil)
      data, _status_code, _headers = get_prices_search_with_http_info(query: query, expand: expand, limit: limit, page: page)
      data
    end

    # &lt;p&gt;Search for prices you’ve previously created using Stripe’s &lt;a href&#x3D;\&quot;/docs/search#search-query-language\&quot;&gt;Search Query Language&lt;/a&gt;. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.&lt;/p&gt;
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for prices](https://stripe.com/docs/search#query-fields-for-prices).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return [Array<(SearchResult4, Integer, Hash)>] SearchResult4 data, response status code and response headers
    def get_prices_search_with_http_info(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil)
      request = build_api_request_for_get_prices_search(query: query, expand: expand, limit: limit, page: page)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_prices_search\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SearchResult4.from_json(data), status_code, headers
    end

    # &lt;p&gt;Search for prices you’ve previously created using Stripe’s &lt;a href&#x3D;\&quot;/docs/search#search-query-language\&quot;&gt;Search Query Language&lt;/a&gt;. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.&lt;/p&gt;
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for prices](https://stripe.com/docs/search#query-fields-for-prices).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return nil
    def get_prices_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_prices_search(query: query, expand: expand, limit: limit, page: page).execute(&block)
    end

    GET_PRICES_SEARCH_MAX_LENGTH_FOR_QUERY = 5000
    GET_PRICES_SEARCH_MAX_LENGTH_FOR_PAGE  = 5000

    # @return Crest::Request
    def build_api_request_for_get_prices_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_prices_search ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"query\" is required and cannot be null") if query.nil?
        if _query = query
          OpenApi::PrimitiveValidator.validate_max_length("query", query.to_s.size, GET_PRICES_SEARCH_MAX_LENGTH_FOR_QUERY)
        end

        if _page = page
          OpenApi::PrimitiveValidator.validate_max_length("page", page.to_s.size, GET_PRICES_SEARCH_MAX_LENGTH_FOR_PAGE)
        end
      end

      # resource path
      local_var_path = "/v1/prices/search"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["page"] = page.to_s if !page.nil?
      query_params["query"] = query.to_s if !query.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_prices_search",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of your products. The products are returned sorted by creation date, with the most recently created products appearing first.</p>
    # @optional @param active [Bool?] Only return products that are active or inactive (e.g., pass `false` to list all inactive products).
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return products that were created during the given date interval.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param ids [Array(Array(String))?] Only return products with the given IDs. Cannot be used with [starting_after](https://stripe.com/docs/api#list_products-starting_after) or [ending_before](https://stripe.com/docs/api#list_products-ending_before).
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param shippable [Bool?] Only return products that can be shipped (i.e., physical, not digital products).
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param url [String?] Only return products with the given url.
    # @return [ProductList]
    def get_products(*, active : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, ids : Array(Array(String))? = nil, limit : Int64? = nil, shippable : Bool? = nil, starting_after : String? = nil, url : String? = nil)
      data, _status_code, _headers = get_products_with_http_info(active: active, created: created, ending_before: ending_before, expand: expand, ids: ids, limit: limit, shippable: shippable, starting_after: starting_after, url: url)
      data
    end

    # &lt;p&gt;Returns a list of your products. The products are returned sorted by creation date, with the most recently created products appearing first.&lt;/p&gt;
    # @optional @param active [Bool?] Only return products that are active or inactive (e.g., pass `false` to list all inactive products).
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return products that were created during the given date interval.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param ids [Array(Array(String))?] Only return products with the given IDs. Cannot be used with [starting_after](https://stripe.com/docs/api#list_products-starting_after) or [ending_before](https://stripe.com/docs/api#list_products-ending_before).
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param shippable [Bool?] Only return products that can be shipped (i.e., physical, not digital products).
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param url [String?] Only return products with the given url.
    # @return [Array<(ProductList, Integer, Hash)>] ProductList data, response status code and response headers
    def get_products_with_http_info(*, active : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, ids : Array(Array(String))? = nil, limit : Int64? = nil, shippable : Bool? = nil, starting_after : String? = nil, url : String? = nil)
      request = build_api_request_for_get_products(active: active, created: created, ending_before: ending_before, expand: expand, ids: ids, limit: limit, shippable: shippable, starting_after: starting_after, url: url)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_products\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ProductList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of your products. The products are returned sorted by creation date, with the most recently created products appearing first.&lt;/p&gt;
    # @optional @param active [Bool?] Only return products that are active or inactive (e.g., pass `false` to list all inactive products).
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return products that were created during the given date interval.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param ids [Array(Array(String))?] Only return products with the given IDs. Cannot be used with [starting_after](https://stripe.com/docs/api#list_products-starting_after) or [ending_before](https://stripe.com/docs/api#list_products-ending_before).
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param shippable [Bool?] Only return products that can be shipped (i.e., physical, not digital products).
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param url [String?] Only return products with the given url.
    # @return nil
    def get_products(*, active : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, ids : Array(Array(String))? = nil, limit : Int64? = nil, shippable : Bool? = nil, starting_after : String? = nil, url : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_products(active: active, created: created, ending_before: ending_before, expand: expand, ids: ids, limit: limit, shippable: shippable, starting_after: starting_after, url: url).execute(&block)
    end

    GET_PRODUCTS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_PRODUCTS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_PRODUCTS_MAX_LENGTH_FOR_URL            = 5000

    # @return Crest::Request
    def build_api_request_for_get_products(*, active : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, ids : Array(Array(String))? = nil, limit : Int64? = nil, shippable : Bool? = nil, starting_after : String? = nil, url : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_products ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_PRODUCTS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_PRODUCTS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _url = url
          OpenApi::PrimitiveValidator.validate_max_length("url", url.to_s.size, GET_PRODUCTS_MAX_LENGTH_FOR_URL)
        end
      end

      # resource path
      local_var_path = "/v1/products"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["active"] = active.to_s if !active.nil?
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["ids"] = @api_client.build_collection_param(ids, "csv") if !ids.nil? && !ids.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["shippable"] = shippable.to_s if !shippable.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["url"] = url.to_s if !url.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_products",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an existing product. Supply the unique product ID from either a product creation request or the product list, and Stripe will return the corresponding product information.</p>
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Product]
    def get_products_id(*, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_products_id_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an existing product. Supply the unique product ID from either a product creation request or the product list, and Stripe will return the corresponding product information.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Product, Integer, Hash)>] Product data, response status code and response headers
    def get_products_id_with_http_info(*, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_products_id(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_products_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Product.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an existing product. Supply the unique product ID from either a product creation request or the product list, and Stripe will return the corresponding product information.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_products_id(*, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_products_id(id: id, expand: expand).execute(&block)
    end

    GET_PRODUCTS_ID_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_get_products_id(*, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_products_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_PRODUCTS_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/products/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_products_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Search for products you’ve previously created using Stripe’s <a href=\"/docs/search#search-query-language\">Search Query Language</a>. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.</p>
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for products](https://stripe.com/docs/search#query-fields-for-products).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return [SearchResult5]
    def get_products_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil)
      data, _status_code, _headers = get_products_search_with_http_info(query: query, expand: expand, limit: limit, page: page)
      data
    end

    # &lt;p&gt;Search for products you’ve previously created using Stripe’s &lt;a href&#x3D;\&quot;/docs/search#search-query-language\&quot;&gt;Search Query Language&lt;/a&gt;. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.&lt;/p&gt;
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for products](https://stripe.com/docs/search#query-fields-for-products).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return [Array<(SearchResult5, Integer, Hash)>] SearchResult5 data, response status code and response headers
    def get_products_search_with_http_info(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil)
      request = build_api_request_for_get_products_search(query: query, expand: expand, limit: limit, page: page)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_products_search\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SearchResult5.from_json(data), status_code, headers
    end

    # &lt;p&gt;Search for products you’ve previously created using Stripe’s &lt;a href&#x3D;\&quot;/docs/search#search-query-language\&quot;&gt;Search Query Language&lt;/a&gt;. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.&lt;/p&gt;
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for products](https://stripe.com/docs/search#query-fields-for-products).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return nil
    def get_products_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_products_search(query: query, expand: expand, limit: limit, page: page).execute(&block)
    end

    GET_PRODUCTS_SEARCH_MAX_LENGTH_FOR_QUERY = 5000
    GET_PRODUCTS_SEARCH_MAX_LENGTH_FOR_PAGE  = 5000

    # @return Crest::Request
    def build_api_request_for_get_products_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_products_search ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"query\" is required and cannot be null") if query.nil?
        if _query = query
          OpenApi::PrimitiveValidator.validate_max_length("query", query.to_s.size, GET_PRODUCTS_SEARCH_MAX_LENGTH_FOR_QUERY)
        end

        if _page = page
          OpenApi::PrimitiveValidator.validate_max_length("page", page.to_s.size, GET_PRODUCTS_SEARCH_MAX_LENGTH_FOR_PAGE)
        end
      end

      # resource path
      local_var_path = "/v1/products/search"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["page"] = page.to_s if !page.nil?
      query_params["query"] = query.to_s if !query.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_products_search",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of your promotion codes.</p>
    # @optional @param active [Bool?] Filter promotion codes by whether they are active.
    # @optional @param code [String?] Only return promotion codes that have this case-insensitive code.
    # @optional @param coupon [String?] Only return promotion codes for this coupon.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param customer [String?] Only return promotion codes that are restricted to this customer.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [PromotionCodesResourcePromotionCodeList]
    def get_promotion_codes(*, active : Bool? = nil, code : String? = nil, coupon : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_promotion_codes_with_http_info(active: active, code: code, coupon: coupon, created: created, customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of your promotion codes.&lt;/p&gt;
    # @optional @param active [Bool?] Filter promotion codes by whether they are active.
    # @optional @param code [String?] Only return promotion codes that have this case-insensitive code.
    # @optional @param coupon [String?] Only return promotion codes for this coupon.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param customer [String?] Only return promotion codes that are restricted to this customer.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(PromotionCodesResourcePromotionCodeList, Integer, Hash)>] PromotionCodesResourcePromotionCodeList data, response status code and response headers
    def get_promotion_codes_with_http_info(*, active : Bool? = nil, code : String? = nil, coupon : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_promotion_codes(active: active, code: code, coupon: coupon, created: created, customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_promotion_codes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PromotionCodesResourcePromotionCodeList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of your promotion codes.&lt;/p&gt;
    # @optional @param active [Bool?] Filter promotion codes by whether they are active.
    # @optional @param code [String?] Only return promotion codes that have this case-insensitive code.
    # @optional @param coupon [String?] Only return promotion codes for this coupon.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param customer [String?] Only return promotion codes that are restricted to this customer.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_promotion_codes(*, active : Bool? = nil, code : String? = nil, coupon : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_promotion_codes(active: active, code: code, coupon: coupon, created: created, customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_PROMOTION_CODES_MAX_LENGTH_FOR_CODE           = 5000
    GET_PROMOTION_CODES_MAX_LENGTH_FOR_COUPON         = 5000
    GET_PROMOTION_CODES_MAX_LENGTH_FOR_CUSTOMER       = 5000
    GET_PROMOTION_CODES_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_PROMOTION_CODES_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_promotion_codes(*, active : Bool? = nil, code : String? = nil, coupon : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_promotion_codes ..." }
      end

      if client_side_validation
        if _code = code
          OpenApi::PrimitiveValidator.validate_max_length("code", code.to_s.size, GET_PROMOTION_CODES_MAX_LENGTH_FOR_CODE)
        end
        if _coupon = coupon
          OpenApi::PrimitiveValidator.validate_max_length("coupon", coupon.to_s.size, GET_PROMOTION_CODES_MAX_LENGTH_FOR_COUPON)
        end
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_PROMOTION_CODES_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_PROMOTION_CODES_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_PROMOTION_CODES_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/promotion_codes"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["active"] = active.to_s if !active.nil?
      query_params["code"] = code.to_s if !code.nil?
      query_params["coupon"] = coupon.to_s if !coupon.nil?
      query_params["created"] = created.to_s if !created.nil?
      query_params["customer"] = customer.to_s if !customer.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_promotion_codes",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the promotion code with the given ID. In order to retrieve a promotion code by the customer-facing <code>code</code> use <a href=\"/docs/api/promotion_codes/list\">list</a> with the desired <code>code</code>.</p>
    # @param promotion_code [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [PromotionCode]
    def get_promotion_codes_promotion_code(*, promotion_code : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_promotion_codes_promotion_code_with_http_info(promotion_code: promotion_code, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the promotion code with the given ID. In order to retrieve a promotion code by the customer-facing &lt;code&gt;code&lt;/code&gt; use &lt;a href&#x3D;\&quot;/docs/api/promotion_codes/list\&quot;&gt;list&lt;/a&gt; with the desired &lt;code&gt;code&lt;/code&gt;.&lt;/p&gt;
    # @param promotion_code [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(PromotionCode, Integer, Hash)>] PromotionCode data, response status code and response headers
    def get_promotion_codes_promotion_code_with_http_info(*, promotion_code : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_promotion_codes_promotion_code(promotion_code: promotion_code, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_promotion_codes_promotion_code\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PromotionCode.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the promotion code with the given ID. In order to retrieve a promotion code by the customer-facing &lt;code&gt;code&lt;/code&gt; use &lt;a href&#x3D;\&quot;/docs/api/promotion_codes/list\&quot;&gt;list&lt;/a&gt; with the desired &lt;code&gt;code&lt;/code&gt;.&lt;/p&gt;
    # @param promotion_code [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_promotion_codes_promotion_code(*, promotion_code : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_promotion_codes_promotion_code(promotion_code: promotion_code, expand: expand).execute(&block)
    end

    GET_PROMOTION_CODES_PROMOTION_CODE_MAX_LENGTH_FOR_PROMOTION_CODE = 5000

    # @return Crest::Request
    def build_api_request_for_get_promotion_codes_promotion_code(*, promotion_code : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_promotion_codes_promotion_code ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"promotion_code\" is required and cannot be null") if promotion_code.nil?
        if _promotion_code = promotion_code
          OpenApi::PrimitiveValidator.validate_max_length("promotion_code", promotion_code.to_s.size, GET_PROMOTION_CODES_PROMOTION_CODE_MAX_LENGTH_FOR_PROMOTION_CODE)
        end
      end

      # resource path
      local_var_path = "/v1/promotion_codes/{promotion_code}".sub("{" + "promotion_code" + "}", URI.encode_path(promotion_code.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_promotion_codes_promotion_code",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of your quotes.</p>
    # @optional @param customer [String?] The ID of the customer whose quotes will be retrieved.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] The status of the quote.
    # @optional @param test_clock [String?] Provides a list of quotes that are associated with the specified test clock. The response will not include quotes with test clocks if this and the customer parameter is not set.
    # @return [QuotesResourceQuoteList]
    def get_quotes(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, test_clock : String? = nil)
      data, _status_code, _headers = get_quotes_with_http_info(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status, test_clock: test_clock)
      data
    end

    # &lt;p&gt;Returns a list of your quotes.&lt;/p&gt;
    # @optional @param customer [String?] The ID of the customer whose quotes will be retrieved.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] The status of the quote.
    # @optional @param test_clock [String?] Provides a list of quotes that are associated with the specified test clock. The response will not include quotes with test clocks if this and the customer parameter is not set.
    # @return [Array<(QuotesResourceQuoteList, Integer, Hash)>] QuotesResourceQuoteList data, response status code and response headers
    def get_quotes_with_http_info(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, test_clock : String? = nil)
      request = build_api_request_for_get_quotes(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status, test_clock: test_clock)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_quotes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return QuotesResourceQuoteList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of your quotes.&lt;/p&gt;
    # @optional @param customer [String?] The ID of the customer whose quotes will be retrieved.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] The status of the quote.
    # @optional @param test_clock [String?] Provides a list of quotes that are associated with the specified test clock. The response will not include quotes with test clocks if this and the customer parameter is not set.
    # @return nil
    def get_quotes(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, test_clock : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_quotes(customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status, test_clock: test_clock).execute(&block)
    end

    GET_QUOTES_MAX_LENGTH_FOR_CUSTOMER       = 5000
    GET_QUOTES_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_QUOTES_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_QUOTES_VALID_VALUES_FOR_STATUS       = StaticArray["accepted", "canceled", "draft", "open"]
    GET_QUOTES_MAX_LENGTH_FOR_TEST_CLOCK     = 5000

    # @return Crest::Request
    def build_api_request_for_get_quotes(*, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, test_clock : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_quotes ..." }
      end

      if client_side_validation
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_QUOTES_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_QUOTES_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_QUOTES_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, GET_QUOTES_VALID_VALUES_FOR_STATUS)
        end
        if _test_clock = test_clock
          OpenApi::PrimitiveValidator.validate_max_length("test_clock", test_clock.to_s.size, GET_QUOTES_MAX_LENGTH_FOR_TEST_CLOCK)
        end
      end

      # resource path
      local_var_path = "/v1/quotes"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["customer"] = customer.to_s if !customer.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["status"] = status.to_s if !status.nil?
      query_params["test_clock"] = test_clock.to_s if !test_clock.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_quotes",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the quote with the given ID.</p>
    # @param quote [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Quote]
    def get_quotes_quote(*, quote : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_quotes_quote_with_http_info(quote: quote, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the quote with the given ID.&lt;/p&gt;
    # @param quote [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Quote, Integer, Hash)>] Quote data, response status code and response headers
    def get_quotes_quote_with_http_info(*, quote : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_quotes_quote(quote: quote, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_quotes_quote\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Quote.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the quote with the given ID.&lt;/p&gt;
    # @param quote [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_quotes_quote(*, quote : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_quotes_quote(quote: quote, expand: expand).execute(&block)
    end

    GET_QUOTES_QUOTE_MAX_LENGTH_FOR_QUOTE = 5000

    # @return Crest::Request
    def build_api_request_for_get_quotes_quote(*, quote : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_quotes_quote ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"quote\" is required and cannot be null") if quote.nil?
        if _quote = quote
          OpenApi::PrimitiveValidator.validate_max_length("quote", quote.to_s.size, GET_QUOTES_QUOTE_MAX_LENGTH_FOR_QUOTE)
        end
      end

      # resource path
      local_var_path = "/v1/quotes/{quote}".sub("{" + "quote" + "}", URI.encode_path(quote.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_quotes_quote",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>When retrieving a quote, there is an includable <a href=\"https://stripe.com/docs/api/quotes/object#quote_object-computed-upfront-line_items\"><strong>computed.upfront.line_items</strong></a> property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of upfront line items.</p>
    # @param quote [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [QuotesResourceListLineItems]
    def get_quotes_quote_computed_upfront_line_items(*, quote : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_quotes_quote_computed_upfront_line_items_with_http_info(quote: quote, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;When retrieving a quote, there is an includable &lt;a href&#x3D;\&quot;https://stripe.com/docs/api/quotes/object#quote_object-computed-upfront-line_items\&quot;&gt;&lt;strong&gt;computed.upfront.line_items&lt;/strong&gt;&lt;/a&gt; property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of upfront line items.&lt;/p&gt;
    # @param quote [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(QuotesResourceListLineItems, Integer, Hash)>] QuotesResourceListLineItems data, response status code and response headers
    def get_quotes_quote_computed_upfront_line_items_with_http_info(*, quote : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_quotes_quote_computed_upfront_line_items(quote: quote, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_quotes_quote_computed_upfront_line_items\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return QuotesResourceListLineItems.from_json(data), status_code, headers
    end

    # &lt;p&gt;When retrieving a quote, there is an includable &lt;a href&#x3D;\&quot;https://stripe.com/docs/api/quotes/object#quote_object-computed-upfront-line_items\&quot;&gt;&lt;strong&gt;computed.upfront.line_items&lt;/strong&gt;&lt;/a&gt; property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of upfront line items.&lt;/p&gt;
    # @param quote [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_quotes_quote_computed_upfront_line_items(*, quote : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_quotes_quote_computed_upfront_line_items(quote: quote, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_QUOTES_QUOTE_COMPUTED_UPFRONT_LINE_ITEMS_MAX_LENGTH_FOR_QUOTE          = 5000
    GET_QUOTES_QUOTE_COMPUTED_UPFRONT_LINE_ITEMS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_QUOTES_QUOTE_COMPUTED_UPFRONT_LINE_ITEMS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_quotes_quote_computed_upfront_line_items(*, quote : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_quotes_quote_computed_upfront_line_items ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"quote\" is required and cannot be null") if quote.nil?
        if _quote = quote
          OpenApi::PrimitiveValidator.validate_max_length("quote", quote.to_s.size, GET_QUOTES_QUOTE_COMPUTED_UPFRONT_LINE_ITEMS_MAX_LENGTH_FOR_QUOTE)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_QUOTES_QUOTE_COMPUTED_UPFRONT_LINE_ITEMS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_QUOTES_QUOTE_COMPUTED_UPFRONT_LINE_ITEMS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/quotes/{quote}/computed_upfront_line_items".sub("{" + "quote" + "}", URI.encode_path(quote.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_quotes_quote_computed_upfront_line_items",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>When retrieving a quote, there is an includable <strong>line_items</strong> property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.</p>
    # @param quote [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [QuotesResourceListLineItems]
    def get_quotes_quote_line_items(*, quote : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_quotes_quote_line_items_with_http_info(quote: quote, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;When retrieving a quote, there is an includable &lt;strong&gt;line_items&lt;/strong&gt; property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.&lt;/p&gt;
    # @param quote [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(QuotesResourceListLineItems, Integer, Hash)>] QuotesResourceListLineItems data, response status code and response headers
    def get_quotes_quote_line_items_with_http_info(*, quote : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_quotes_quote_line_items(quote: quote, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_quotes_quote_line_items\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return QuotesResourceListLineItems.from_json(data), status_code, headers
    end

    # &lt;p&gt;When retrieving a quote, there is an includable &lt;strong&gt;line_items&lt;/strong&gt; property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.&lt;/p&gt;
    # @param quote [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_quotes_quote_line_items(*, quote : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_quotes_quote_line_items(quote: quote, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_QUOTES_QUOTE_LINE_ITEMS_MAX_LENGTH_FOR_QUOTE          = 5000
    GET_QUOTES_QUOTE_LINE_ITEMS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_QUOTES_QUOTE_LINE_ITEMS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_quotes_quote_line_items(*, quote : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_quotes_quote_line_items ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"quote\" is required and cannot be null") if quote.nil?
        if _quote = quote
          OpenApi::PrimitiveValidator.validate_max_length("quote", quote.to_s.size, GET_QUOTES_QUOTE_LINE_ITEMS_MAX_LENGTH_FOR_QUOTE)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_QUOTES_QUOTE_LINE_ITEMS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_QUOTES_QUOTE_LINE_ITEMS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/quotes/{quote}/line_items".sub("{" + "quote" + "}", URI.encode_path(quote.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_quotes_quote_line_items",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Download the PDF for a finalized quote</p>
    # @param quote [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [::File]
    def get_quotes_quote_pdf(*, quote : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_quotes_quote_pdf_with_http_info(quote: quote, expand: expand)
      data
    end

    # &lt;p&gt;Download the PDF for a finalized quote&lt;/p&gt;
    # @param quote [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(::File, Integer, Hash)>] ::File data, response status code and response headers
    def get_quotes_quote_pdf_with_http_info(*, quote : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_quotes_quote_pdf(quote: quote, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_quotes_quote_pdf\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ::File.from_json(data), status_code, headers
    end

    # &lt;p&gt;Download the PDF for a finalized quote&lt;/p&gt;
    # @param quote [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_quotes_quote_pdf(*, quote : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_quotes_quote_pdf(quote: quote, expand: expand).execute(&block)
    end

    GET_QUOTES_QUOTE_PDF_MAX_LENGTH_FOR_QUOTE = 5000

    # @return Crest::Request
    def build_api_request_for_get_quotes_quote_pdf(*, quote : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_quotes_quote_pdf ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"quote\" is required and cannot be null") if quote.nil?
        if _quote = quote
          OpenApi::PrimitiveValidator.validate_max_length("quote", quote.to_s.size, GET_QUOTES_QUOTE_PDF_MAX_LENGTH_FOR_QUOTE)
        end
      end

      # resource path
      local_var_path = "/v1/quotes/{quote}/pdf".sub("{" + "quote" + "}", URI.encode_path(quote.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/pdf", "application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_quotes_quote_pdf",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of early fraud warnings.</p>
    # @optional @param charge [String?] Only return early fraud warnings for the charge specified by this charge ID.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payment_intent [String?] Only return early fraud warnings for charges that were created by the PaymentIntent specified by this PaymentIntent ID.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [RadarEarlyFraudWarningList]
    def get_radar_early_fraud_warnings(*, charge : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_intent : String? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_radar_early_fraud_warnings_with_http_info(charge: charge, ending_before: ending_before, expand: expand, limit: limit, payment_intent: payment_intent, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of early fraud warnings.&lt;/p&gt;
    # @optional @param charge [String?] Only return early fraud warnings for the charge specified by this charge ID.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payment_intent [String?] Only return early fraud warnings for charges that were created by the PaymentIntent specified by this PaymentIntent ID.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(RadarEarlyFraudWarningList, Integer, Hash)>] RadarEarlyFraudWarningList data, response status code and response headers
    def get_radar_early_fraud_warnings_with_http_info(*, charge : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_intent : String? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_radar_early_fraud_warnings(charge: charge, ending_before: ending_before, expand: expand, limit: limit, payment_intent: payment_intent, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_radar_early_fraud_warnings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return RadarEarlyFraudWarningList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of early fraud warnings.&lt;/p&gt;
    # @optional @param charge [String?] Only return early fraud warnings for the charge specified by this charge ID.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payment_intent [String?] Only return early fraud warnings for charges that were created by the PaymentIntent specified by this PaymentIntent ID.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_radar_early_fraud_warnings(*, charge : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_intent : String? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_radar_early_fraud_warnings(charge: charge, ending_before: ending_before, expand: expand, limit: limit, payment_intent: payment_intent, starting_after: starting_after).execute(&block)
    end

    GET_RADAR_EARLY_FRAUD_WARNINGS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_RADAR_EARLY_FRAUD_WARNINGS_MAX_LENGTH_FOR_PAYMENT_INTENT = 5000
    GET_RADAR_EARLY_FRAUD_WARNINGS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_radar_early_fraud_warnings(*, charge : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_intent : String? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_radar_early_fraud_warnings ..." }
      end

      if client_side_validation
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_RADAR_EARLY_FRAUD_WARNINGS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _payment_intent = payment_intent
          OpenApi::PrimitiveValidator.validate_max_length("payment_intent", payment_intent.to_s.size, GET_RADAR_EARLY_FRAUD_WARNINGS_MAX_LENGTH_FOR_PAYMENT_INTENT)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_RADAR_EARLY_FRAUD_WARNINGS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/radar/early_fraud_warnings"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["charge"] = charge.to_s if !charge.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["payment_intent"] = payment_intent.to_s if !payment_intent.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_radar_early_fraud_warnings",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an early fraud warning that has previously been created. </p>  <p>Please refer to the <a href=\"#early_fraud_warning_object\">early fraud warning</a> object reference for more details.</p>
    # @param early_fraud_warning [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [RadarEarlyFraudWarning]
    def get_radar_early_fraud_warnings_early_fraud_warning(*, early_fraud_warning : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_radar_early_fraud_warnings_early_fraud_warning_with_http_info(early_fraud_warning: early_fraud_warning, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an early fraud warning that has previously been created. &lt;/p&gt;  &lt;p&gt;Please refer to the &lt;a href&#x3D;\&quot;#early_fraud_warning_object\&quot;&gt;early fraud warning&lt;/a&gt; object reference for more details.&lt;/p&gt;
    # @param early_fraud_warning [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(RadarEarlyFraudWarning, Integer, Hash)>] RadarEarlyFraudWarning data, response status code and response headers
    def get_radar_early_fraud_warnings_early_fraud_warning_with_http_info(*, early_fraud_warning : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_radar_early_fraud_warnings_early_fraud_warning(early_fraud_warning: early_fraud_warning, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_radar_early_fraud_warnings_early_fraud_warning\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return RadarEarlyFraudWarning.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an early fraud warning that has previously been created. &lt;/p&gt;  &lt;p&gt;Please refer to the &lt;a href&#x3D;\&quot;#early_fraud_warning_object\&quot;&gt;early fraud warning&lt;/a&gt; object reference for more details.&lt;/p&gt;
    # @param early_fraud_warning [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_radar_early_fraud_warnings_early_fraud_warning(*, early_fraud_warning : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_radar_early_fraud_warnings_early_fraud_warning(early_fraud_warning: early_fraud_warning, expand: expand).execute(&block)
    end

    GET_RADAR_EARLY_FRAUD_WARNINGS_EARLY_FRAUD_WARNING_MAX_LENGTH_FOR_EARLY_FRAUD_WARNING = 5000

    # @return Crest::Request
    def build_api_request_for_get_radar_early_fraud_warnings_early_fraud_warning(*, early_fraud_warning : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_radar_early_fraud_warnings_early_fraud_warning ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"early_fraud_warning\" is required and cannot be null") if early_fraud_warning.nil?
        if _early_fraud_warning = early_fraud_warning
          OpenApi::PrimitiveValidator.validate_max_length("early_fraud_warning", early_fraud_warning.to_s.size, GET_RADAR_EARLY_FRAUD_WARNINGS_EARLY_FRAUD_WARNING_MAX_LENGTH_FOR_EARLY_FRAUD_WARNING)
        end
      end

      # resource path
      local_var_path = "/v1/radar/early_fraud_warnings/{early_fraud_warning}".sub("{" + "early_fraud_warning" + "}", URI.encode_path(early_fraud_warning.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_radar_early_fraud_warnings_early_fraud_warning",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of <code>ValueListItem</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
    # @param value_list [String?] Identifier for the parent value list this item belongs to.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param value [String?] Return items belonging to the parent list whose value matches the specified value (using an \"is like\" match).
    # @return [RadarListListItemList]
    def get_radar_value_list_items(*, value_list : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, value : String? = nil)
      data, _status_code, _headers = get_radar_value_list_items_with_http_info(value_list: value_list, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, value: value)
      data
    end

    # &lt;p&gt;Returns a list of &lt;code&gt;ValueListItem&lt;/code&gt; objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.&lt;/p&gt;
    # @param value_list [String?] Identifier for the parent value list this item belongs to.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param value [String?] Return items belonging to the parent list whose value matches the specified value (using an \"is like\" match).
    # @return [Array<(RadarListListItemList, Integer, Hash)>] RadarListListItemList data, response status code and response headers
    def get_radar_value_list_items_with_http_info(*, value_list : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, value : String? = nil)
      request = build_api_request_for_get_radar_value_list_items(value_list: value_list, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, value: value)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_radar_value_list_items\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return RadarListListItemList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of &lt;code&gt;ValueListItem&lt;/code&gt; objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.&lt;/p&gt;
    # @param value_list [String?] Identifier for the parent value list this item belongs to.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param value [String?] Return items belonging to the parent list whose value matches the specified value (using an \"is like\" match).
    # @return nil
    def get_radar_value_list_items(*, value_list : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, value : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_radar_value_list_items(value_list: value_list, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, value: value).execute(&block)
    end

    GET_RADAR_VALUE_LIST_ITEMS_MAX_LENGTH_FOR_VALUE_LIST     = 5000
    GET_RADAR_VALUE_LIST_ITEMS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_RADAR_VALUE_LIST_ITEMS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_RADAR_VALUE_LIST_ITEMS_MAX_LENGTH_FOR_VALUE          =  800

    # @return Crest::Request
    def build_api_request_for_get_radar_value_list_items(*, value_list : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, value : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_radar_value_list_items ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"value_list\" is required and cannot be null") if value_list.nil?
        if _value_list = value_list
          OpenApi::PrimitiveValidator.validate_max_length("value_list", value_list.to_s.size, GET_RADAR_VALUE_LIST_ITEMS_MAX_LENGTH_FOR_VALUE_LIST)
        end
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_RADAR_VALUE_LIST_ITEMS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_RADAR_VALUE_LIST_ITEMS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _value = value
          OpenApi::PrimitiveValidator.validate_max_length("value", value.to_s.size, GET_RADAR_VALUE_LIST_ITEMS_MAX_LENGTH_FOR_VALUE)
        end
      end

      # resource path
      local_var_path = "/v1/radar/value_list_items"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["value"] = value.to_s if !value.nil?
      query_params["value_list"] = value_list.to_s if !value_list.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_radar_value_list_items",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a <code>ValueListItem</code> object.</p>
    # @param item [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [RadarValueListItem]
    def get_radar_value_list_items_item(*, item : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_radar_value_list_items_item_with_http_info(item: item, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves a &lt;code&gt;ValueListItem&lt;/code&gt; object.&lt;/p&gt;
    # @param item [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(RadarValueListItem, Integer, Hash)>] RadarValueListItem data, response status code and response headers
    def get_radar_value_list_items_item_with_http_info(*, item : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_radar_value_list_items_item(item: item, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_radar_value_list_items_item\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return RadarValueListItem.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a &lt;code&gt;ValueListItem&lt;/code&gt; object.&lt;/p&gt;
    # @param item [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_radar_value_list_items_item(*, item : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_radar_value_list_items_item(item: item, expand: expand).execute(&block)
    end

    GET_RADAR_VALUE_LIST_ITEMS_ITEM_MAX_LENGTH_FOR_ITEM = 5000

    # @return Crest::Request
    def build_api_request_for_get_radar_value_list_items_item(*, item : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_radar_value_list_items_item ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"item\" is required and cannot be null") if item.nil?
        if _item = item
          OpenApi::PrimitiveValidator.validate_max_length("item", item.to_s.size, GET_RADAR_VALUE_LIST_ITEMS_ITEM_MAX_LENGTH_FOR_ITEM)
        end
      end

      # resource path
      local_var_path = "/v1/radar/value_list_items/{item}".sub("{" + "item" + "}", URI.encode_path(item.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_radar_value_list_items_item",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of <code>ValueList</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
    # @optional @param _alias [String?] The alias used to reference the value list when writing rules.
    # @optional @param contains [String?] A value contained within a value list - returns all value lists containing this value.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [RadarListListList]
    def get_radar_value_lists(*, _alias : String? = nil, contains : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_radar_value_lists_with_http_info(_alias: _alias, contains: contains, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of &lt;code&gt;ValueList&lt;/code&gt; objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.&lt;/p&gt;
    # @optional @param _alias [String?] The alias used to reference the value list when writing rules.
    # @optional @param contains [String?] A value contained within a value list - returns all value lists containing this value.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(RadarListListList, Integer, Hash)>] RadarListListList data, response status code and response headers
    def get_radar_value_lists_with_http_info(*, _alias : String? = nil, contains : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_radar_value_lists(_alias: _alias, contains: contains, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_radar_value_lists\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return RadarListListList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of &lt;code&gt;ValueList&lt;/code&gt; objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.&lt;/p&gt;
    # @optional @param _alias [String?] The alias used to reference the value list when writing rules.
    # @optional @param contains [String?] A value contained within a value list - returns all value lists containing this value.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_radar_value_lists(*, _alias : String? = nil, contains : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_radar_value_lists(_alias: _alias, contains: contains, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_RADAR_VALUE_LISTS_MAX_LENGTH_FOR__ALIAS         =  100
    GET_RADAR_VALUE_LISTS_MAX_LENGTH_FOR_CONTAINS       =  800
    GET_RADAR_VALUE_LISTS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_RADAR_VALUE_LISTS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_radar_value_lists(*, _alias : String? = nil, contains : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_radar_value_lists ..." }
      end

      if client_side_validation
        if __alias = _alias
          OpenApi::PrimitiveValidator.validate_max_length("_alias", _alias.to_s.size, GET_RADAR_VALUE_LISTS_MAX_LENGTH_FOR__ALIAS)
        end
        if _contains = contains
          OpenApi::PrimitiveValidator.validate_max_length("contains", contains.to_s.size, GET_RADAR_VALUE_LISTS_MAX_LENGTH_FOR_CONTAINS)
        end
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_RADAR_VALUE_LISTS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_RADAR_VALUE_LISTS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/radar/value_lists"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["alias"] = _alias.to_s if !_alias.nil?
      query_params["contains"] = contains.to_s if !contains.nil?
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_radar_value_lists",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a <code>ValueList</code> object.</p>
    # @param value_list [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [RadarValueList]
    def get_radar_value_lists_value_list(*, value_list : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_radar_value_lists_value_list_with_http_info(value_list: value_list, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves a &lt;code&gt;ValueList&lt;/code&gt; object.&lt;/p&gt;
    # @param value_list [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(RadarValueList, Integer, Hash)>] RadarValueList data, response status code and response headers
    def get_radar_value_lists_value_list_with_http_info(*, value_list : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_radar_value_lists_value_list(value_list: value_list, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_radar_value_lists_value_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return RadarValueList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a &lt;code&gt;ValueList&lt;/code&gt; object.&lt;/p&gt;
    # @param value_list [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_radar_value_lists_value_list(*, value_list : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_radar_value_lists_value_list(value_list: value_list, expand: expand).execute(&block)
    end

    GET_RADAR_VALUE_LISTS_VALUE_LIST_MAX_LENGTH_FOR_VALUE_LIST = 5000

    # @return Crest::Request
    def build_api_request_for_get_radar_value_lists_value_list(*, value_list : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_radar_value_lists_value_list ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"value_list\" is required and cannot be null") if value_list.nil?
        if _value_list = value_list
          OpenApi::PrimitiveValidator.validate_max_length("value_list", value_list.to_s.size, GET_RADAR_VALUE_LISTS_VALUE_LIST_MAX_LENGTH_FOR_VALUE_LIST)
        end
      end

      # resource path
      local_var_path = "/v1/radar/value_lists/{value_list}".sub("{" + "value_list" + "}", URI.encode_path(value_list.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_radar_value_lists_value_list",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of all refunds you’ve previously created. The refunds are returned in sorted order, with the most recent refunds appearing first. For convenience, the 10 most recent refunds are always available by default on the charge object.</p>
    # @optional @param charge [String?] Only return refunds for the charge specified by this charge ID.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payment_intent [String?] Only return refunds for the PaymentIntent specified by this ID.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [APIMethodRefundList]
    def get_refunds(*, charge : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_intent : String? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_refunds_with_http_info(charge: charge, created: created, ending_before: ending_before, expand: expand, limit: limit, payment_intent: payment_intent, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of all refunds you’ve previously created. The refunds are returned in sorted order, with the most recent refunds appearing first. For convenience, the 10 most recent refunds are always available by default on the charge object.&lt;/p&gt;
    # @optional @param charge [String?] Only return refunds for the charge specified by this charge ID.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payment_intent [String?] Only return refunds for the PaymentIntent specified by this ID.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(APIMethodRefundList, Integer, Hash)>] APIMethodRefundList data, response status code and response headers
    def get_refunds_with_http_info(*, charge : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_intent : String? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_refunds(charge: charge, created: created, ending_before: ending_before, expand: expand, limit: limit, payment_intent: payment_intent, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_refunds\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return APIMethodRefundList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of all refunds you’ve previously created. The refunds are returned in sorted order, with the most recent refunds appearing first. For convenience, the 10 most recent refunds are always available by default on the charge object.&lt;/p&gt;
    # @optional @param charge [String?] Only return refunds for the charge specified by this charge ID.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payment_intent [String?] Only return refunds for the PaymentIntent specified by this ID.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_refunds(*, charge : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_intent : String? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_refunds(charge: charge, created: created, ending_before: ending_before, expand: expand, limit: limit, payment_intent: payment_intent, starting_after: starting_after).execute(&block)
    end

    GET_REFUNDS_MAX_LENGTH_FOR_PAYMENT_INTENT = 5000

    # @return Crest::Request
    def build_api_request_for_get_refunds(*, charge : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_intent : String? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_refunds ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end

        if _payment_intent = payment_intent
          OpenApi::PrimitiveValidator.validate_max_length("payment_intent", payment_intent.to_s.size, GET_REFUNDS_MAX_LENGTH_FOR_PAYMENT_INTENT)
        end
      end

      # resource path
      local_var_path = "/v1/refunds"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["charge"] = charge.to_s if !charge.nil?
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["payment_intent"] = payment_intent.to_s if !payment_intent.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_refunds",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an existing refund.</p>
    # @param refund [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Refund]
    def get_refunds_refund(*, refund : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_refunds_refund_with_http_info(refund: refund, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an existing refund.&lt;/p&gt;
    # @param refund [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Refund, Integer, Hash)>] Refund data, response status code and response headers
    def get_refunds_refund_with_http_info(*, refund : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_refunds_refund(refund: refund, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_refunds_refund\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Refund.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an existing refund.&lt;/p&gt;
    # @param refund [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_refunds_refund(*, refund : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_refunds_refund(refund: refund, expand: expand).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_get_refunds_refund(*, refund : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_refunds_refund ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"refund\" is required and cannot be null") if refund.nil?
      end

      # resource path
      local_var_path = "/v1/refunds/{refund}".sub("{" + "refund" + "}", URI.encode_path(refund.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_refunds_refund",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of Report Runs, with the most recent appearing first.</p>
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [FinancialReportingFinanceReportRunList]
    def get_reporting_report_runs(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_reporting_report_runs_with_http_info(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of Report Runs, with the most recent appearing first.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(FinancialReportingFinanceReportRunList, Integer, Hash)>] FinancialReportingFinanceReportRunList data, response status code and response headers
    def get_reporting_report_runs_with_http_info(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_reporting_report_runs(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_reporting_report_runs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FinancialReportingFinanceReportRunList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of Report Runs, with the most recent appearing first.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_reporting_report_runs(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_reporting_report_runs(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_REPORTING_REPORT_RUNS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_REPORTING_REPORT_RUNS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_reporting_report_runs(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_reporting_report_runs ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_REPORTING_REPORT_RUNS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_REPORTING_REPORT_RUNS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/reporting/report_runs"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_reporting_report_runs",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an existing Report Run.</p>
    # @param report_run [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [ReportingReportRun]
    def get_reporting_report_runs_report_run(*, report_run : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_reporting_report_runs_report_run_with_http_info(report_run: report_run, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an existing Report Run.&lt;/p&gt;
    # @param report_run [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(ReportingReportRun, Integer, Hash)>] ReportingReportRun data, response status code and response headers
    def get_reporting_report_runs_report_run_with_http_info(*, report_run : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_reporting_report_runs_report_run(report_run: report_run, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_reporting_report_runs_report_run\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ReportingReportRun.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an existing Report Run.&lt;/p&gt;
    # @param report_run [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_reporting_report_runs_report_run(*, report_run : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_reporting_report_runs_report_run(report_run: report_run, expand: expand).execute(&block)
    end

    GET_REPORTING_REPORT_RUNS_REPORT_RUN_MAX_LENGTH_FOR_REPORT_RUN = 5000

    # @return Crest::Request
    def build_api_request_for_get_reporting_report_runs_report_run(*, report_run : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_reporting_report_runs_report_run ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"report_run\" is required and cannot be null") if report_run.nil?
        if _report_run = report_run
          OpenApi::PrimitiveValidator.validate_max_length("report_run", report_run.to_s.size, GET_REPORTING_REPORT_RUNS_REPORT_RUN_MAX_LENGTH_FOR_REPORT_RUN)
        end
      end

      # resource path
      local_var_path = "/v1/reporting/report_runs/{report_run}".sub("{" + "report_run" + "}", URI.encode_path(report_run.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_reporting_report_runs_report_run",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a full list of Report Types.</p>
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [FinancialReportingFinanceReportTypeList]
    def get_reporting_report_types(*, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_reporting_report_types_with_http_info(expand: expand)
      data
    end

    # &lt;p&gt;Returns a full list of Report Types.&lt;/p&gt;
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(FinancialReportingFinanceReportTypeList, Integer, Hash)>] FinancialReportingFinanceReportTypeList data, response status code and response headers
    def get_reporting_report_types_with_http_info(*, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_reporting_report_types(expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_reporting_report_types\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FinancialReportingFinanceReportTypeList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a full list of Report Types.&lt;/p&gt;
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_reporting_report_types(*, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_reporting_report_types(expand: expand).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_get_reporting_report_types(*, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_reporting_report_types ..." }
      end

      if client_side_validation
      end

      # resource path
      local_var_path = "/v1/reporting/report_types"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_reporting_report_types",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of a Report Type. (Certain report types require a <a href=\"https://stripe.com/docs/keys#test-live-modes\">live-mode API key</a>.)</p>
    # @param report_type [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [ReportingReportType]
    def get_reporting_report_types_report_type(*, report_type : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_reporting_report_types_report_type_with_http_info(report_type: report_type, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of a Report Type. (Certain report types require a &lt;a href&#x3D;\&quot;https://stripe.com/docs/keys#test-live-modes\&quot;&gt;live-mode API key&lt;/a&gt;.)&lt;/p&gt;
    # @param report_type [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(ReportingReportType, Integer, Hash)>] ReportingReportType data, response status code and response headers
    def get_reporting_report_types_report_type_with_http_info(*, report_type : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_reporting_report_types_report_type(report_type: report_type, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_reporting_report_types_report_type\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ReportingReportType.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of a Report Type. (Certain report types require a &lt;a href&#x3D;\&quot;https://stripe.com/docs/keys#test-live-modes\&quot;&gt;live-mode API key&lt;/a&gt;.)&lt;/p&gt;
    # @param report_type [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_reporting_report_types_report_type(*, report_type : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_reporting_report_types_report_type(report_type: report_type, expand: expand).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_get_reporting_report_types_report_type(*, report_type : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_reporting_report_types_report_type ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"report_type\" is required and cannot be null") if report_type.nil?
      end

      # resource path
      local_var_path = "/v1/reporting/report_types/{report_type}".sub("{" + "report_type" + "}", URI.encode_path(report_type.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_reporting_report_types_report_type",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of <code>Review</code> objects that have <code>open</code> set to <code>true</code>. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [RadarReviewList]
    def get_reviews(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_reviews_with_http_info(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of &lt;code&gt;Review&lt;/code&gt; objects that have &lt;code&gt;open&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;. The objects are sorted in descending order by creation date, with the most recently created object appearing first.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(RadarReviewList, Integer, Hash)>] RadarReviewList data, response status code and response headers
    def get_reviews_with_http_info(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_reviews(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_reviews\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return RadarReviewList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of &lt;code&gt;Review&lt;/code&gt; objects that have &lt;code&gt;open&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;. The objects are sorted in descending order by creation date, with the most recently created object appearing first.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_reviews(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_reviews(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_REVIEWS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_REVIEWS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_reviews(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_reviews ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_REVIEWS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_REVIEWS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/reviews"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_reviews",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a <code>Review</code> object.</p>
    # @param review [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Review]
    def get_reviews_review(*, review : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_reviews_review_with_http_info(review: review, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves a &lt;code&gt;Review&lt;/code&gt; object.&lt;/p&gt;
    # @param review [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Review, Integer, Hash)>] Review data, response status code and response headers
    def get_reviews_review_with_http_info(*, review : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_reviews_review(review: review, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_reviews_review\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Review.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a &lt;code&gt;Review&lt;/code&gt; object.&lt;/p&gt;
    # @param review [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_reviews_review(*, review : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_reviews_review(review: review, expand: expand).execute(&block)
    end

    GET_REVIEWS_REVIEW_MAX_LENGTH_FOR_REVIEW = 5000

    # @return Crest::Request
    def build_api_request_for_get_reviews_review(*, review : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_reviews_review ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"review\" is required and cannot be null") if review.nil?
        if _review = review
          OpenApi::PrimitiveValidator.validate_max_length("review", review.to_s.size, GET_REVIEWS_REVIEW_MAX_LENGTH_FOR_REVIEW)
        end
      end

      # resource path
      local_var_path = "/v1/reviews/{review}".sub("{" + "review" + "}", URI.encode_path(review.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_reviews_review",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of SetupAttempts associated with a provided SetupIntent.</p>
    # @param setup_intent [String?] Only return SetupAttempts created by the SetupIntent specified by this ID.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [PaymentFlowsSetupIntentSetupAttemptList]
    def get_setup_attempts(*, setup_intent : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_setup_attempts_with_http_info(setup_intent: setup_intent, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of SetupAttempts associated with a provided SetupIntent.&lt;/p&gt;
    # @param setup_intent [String?] Only return SetupAttempts created by the SetupIntent specified by this ID.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(PaymentFlowsSetupIntentSetupAttemptList, Integer, Hash)>] PaymentFlowsSetupIntentSetupAttemptList data, response status code and response headers
    def get_setup_attempts_with_http_info(*, setup_intent : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_setup_attempts(setup_intent: setup_intent, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_setup_attempts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentFlowsSetupIntentSetupAttemptList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of SetupAttempts associated with a provided SetupIntent.&lt;/p&gt;
    # @param setup_intent [String?] Only return SetupAttempts created by the SetupIntent specified by this ID.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_setup_attempts(*, setup_intent : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_setup_attempts(setup_intent: setup_intent, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_SETUP_ATTEMPTS_MAX_LENGTH_FOR_SETUP_INTENT   = 5000
    GET_SETUP_ATTEMPTS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_SETUP_ATTEMPTS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_setup_attempts(*, setup_intent : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_setup_attempts ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"setup_intent\" is required and cannot be null") if setup_intent.nil?
        if _setup_intent = setup_intent
          OpenApi::PrimitiveValidator.validate_max_length("setup_intent", setup_intent.to_s.size, GET_SETUP_ATTEMPTS_MAX_LENGTH_FOR_SETUP_INTENT)
        end
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_SETUP_ATTEMPTS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_SETUP_ATTEMPTS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/setup_attempts"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["setup_intent"] = setup_intent.to_s if !setup_intent.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_setup_attempts",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of SetupIntents.</p>
    # @optional @param attach_to_self [Bool?] If present, the SetupIntent's payment method will be attached to the in-context Stripe Account.  It can only be used for this Stripe Account’s own money movement flows like InboundTransfer and OutboundTransfers. It cannot be set to true when setting up a PaymentMethod for a Customer, and defaults to false when attaching a PaymentMethod to a Customer.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param customer [String?] Only return SetupIntents for the customer specified by this customer ID.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payment_method [String?] Only return SetupIntents associated with the specified payment method.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [PaymentFlowsSetupIntentList]
    def get_setup_intents(*, attach_to_self : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_method : String? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_setup_intents_with_http_info(attach_to_self: attach_to_self, created: created, customer: customer, ending_before: ending_before, expand: expand, limit: limit, payment_method: payment_method, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of SetupIntents.&lt;/p&gt;
    # @optional @param attach_to_self [Bool?] If present, the SetupIntent's payment method will be attached to the in-context Stripe Account.  It can only be used for this Stripe Account’s own money movement flows like InboundTransfer and OutboundTransfers. It cannot be set to true when setting up a PaymentMethod for a Customer, and defaults to false when attaching a PaymentMethod to a Customer.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param customer [String?] Only return SetupIntents for the customer specified by this customer ID.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payment_method [String?] Only return SetupIntents associated with the specified payment method.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(PaymentFlowsSetupIntentList, Integer, Hash)>] PaymentFlowsSetupIntentList data, response status code and response headers
    def get_setup_intents_with_http_info(*, attach_to_self : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_method : String? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_setup_intents(attach_to_self: attach_to_self, created: created, customer: customer, ending_before: ending_before, expand: expand, limit: limit, payment_method: payment_method, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_setup_intents\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentFlowsSetupIntentList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of SetupIntents.&lt;/p&gt;
    # @optional @param attach_to_self [Bool?] If present, the SetupIntent's payment method will be attached to the in-context Stripe Account.  It can only be used for this Stripe Account’s own money movement flows like InboundTransfer and OutboundTransfers. It cannot be set to true when setting up a PaymentMethod for a Customer, and defaults to false when attaching a PaymentMethod to a Customer.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param customer [String?] Only return SetupIntents for the customer specified by this customer ID.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param payment_method [String?] Only return SetupIntents associated with the specified payment method.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_setup_intents(*, attach_to_self : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_method : String? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_setup_intents(attach_to_self: attach_to_self, created: created, customer: customer, ending_before: ending_before, expand: expand, limit: limit, payment_method: payment_method, starting_after: starting_after).execute(&block)
    end

    GET_SETUP_INTENTS_MAX_LENGTH_FOR_CUSTOMER       = 5000
    GET_SETUP_INTENTS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_SETUP_INTENTS_MAX_LENGTH_FOR_PAYMENT_METHOD = 5000
    GET_SETUP_INTENTS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_setup_intents(*, attach_to_self : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, payment_method : String? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_setup_intents ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_SETUP_INTENTS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_SETUP_INTENTS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _payment_method = payment_method
          OpenApi::PrimitiveValidator.validate_max_length("payment_method", payment_method.to_s.size, GET_SETUP_INTENTS_MAX_LENGTH_FOR_PAYMENT_METHOD)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_SETUP_INTENTS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/setup_intents"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["attach_to_self"] = attach_to_self.to_s if !attach_to_self.nil?
      query_params["created"] = created.to_s if !created.nil?
      query_params["customer"] = customer.to_s if !customer.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["payment_method"] = payment_method.to_s if !payment_method.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_setup_intents",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of a SetupIntent that has previously been created. </p>  <p>Client-side retrieval using a publishable key is allowed when the <code>client_secret</code> is provided in the query string. </p>  <p>When retrieved with a publishable key, only a subset of properties will be returned. Please refer to the <a href=\"#setup_intent_object\">SetupIntent</a> object reference for more details.</p>
    # @param intent [String?]
    # @optional @param client_secret [String?] The client secret of the SetupIntent. Required if a publishable key is used to retrieve the SetupIntent.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [SetupIntent]
    def get_setup_intents_intent(*, intent : String? = nil, client_secret : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_setup_intents_intent_with_http_info(intent: intent, client_secret: client_secret, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of a SetupIntent that has previously been created. &lt;/p&gt;  &lt;p&gt;Client-side retrieval using a publishable key is allowed when the &lt;code&gt;client_secret&lt;/code&gt; is provided in the query string. &lt;/p&gt;  &lt;p&gt;When retrieved with a publishable key, only a subset of properties will be returned. Please refer to the &lt;a href&#x3D;\&quot;#setup_intent_object\&quot;&gt;SetupIntent&lt;/a&gt; object reference for more details.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param client_secret [String?] The client secret of the SetupIntent. Required if a publishable key is used to retrieve the SetupIntent.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(SetupIntent, Integer, Hash)>] SetupIntent data, response status code and response headers
    def get_setup_intents_intent_with_http_info(*, intent : String? = nil, client_secret : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_setup_intents_intent(intent: intent, client_secret: client_secret, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_setup_intents_intent\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SetupIntent.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of a SetupIntent that has previously been created. &lt;/p&gt;  &lt;p&gt;Client-side retrieval using a publishable key is allowed when the &lt;code&gt;client_secret&lt;/code&gt; is provided in the query string. &lt;/p&gt;  &lt;p&gt;When retrieved with a publishable key, only a subset of properties will be returned. Please refer to the &lt;a href&#x3D;\&quot;#setup_intent_object\&quot;&gt;SetupIntent&lt;/a&gt; object reference for more details.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param client_secret [String?] The client secret of the SetupIntent. Required if a publishable key is used to retrieve the SetupIntent.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_setup_intents_intent(*, intent : String? = nil, client_secret : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_setup_intents_intent(intent: intent, client_secret: client_secret, expand: expand).execute(&block)
    end

    GET_SETUP_INTENTS_INTENT_MAX_LENGTH_FOR_INTENT        = 5000
    GET_SETUP_INTENTS_INTENT_MAX_LENGTH_FOR_CLIENT_SECRET = 5000

    # @return Crest::Request
    def build_api_request_for_get_setup_intents_intent(*, intent : String? = nil, client_secret : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_setup_intents_intent ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"intent\" is required and cannot be null") if intent.nil?
        if _intent = intent
          OpenApi::PrimitiveValidator.validate_max_length("intent", intent.to_s.size, GET_SETUP_INTENTS_INTENT_MAX_LENGTH_FOR_INTENT)
        end
        if _client_secret = client_secret
          OpenApi::PrimitiveValidator.validate_max_length("client_secret", client_secret.to_s.size, GET_SETUP_INTENTS_INTENT_MAX_LENGTH_FOR_CLIENT_SECRET)
        end
      end

      # resource path
      local_var_path = "/v1/setup_intents/{intent}".sub("{" + "intent" + "}", URI.encode_path(intent.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["client_secret"] = client_secret.to_s if !client_secret.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_setup_intents_intent",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of your shipping rates.</p>
    # @optional @param active [Bool?] Only return shipping rates that are active or inactive.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param currency [String?] Only return shipping rates for the given currency.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [ShippingResourcesShippingRateList]
    def get_shipping_rates(*, active : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, currency : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_shipping_rates_with_http_info(active: active, created: created, currency: currency, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of your shipping rates.&lt;/p&gt;
    # @optional @param active [Bool?] Only return shipping rates that are active or inactive.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param currency [String?] Only return shipping rates for the given currency.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(ShippingResourcesShippingRateList, Integer, Hash)>] ShippingResourcesShippingRateList data, response status code and response headers
    def get_shipping_rates_with_http_info(*, active : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, currency : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_shipping_rates(active: active, created: created, currency: currency, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_shipping_rates\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ShippingResourcesShippingRateList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of your shipping rates.&lt;/p&gt;
    # @optional @param active [Bool?] Only return shipping rates that are active or inactive.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param currency [String?] Only return shipping rates for the given currency.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_shipping_rates(*, active : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, currency : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_shipping_rates(active: active, created: created, currency: currency, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_SHIPPING_RATES_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_SHIPPING_RATES_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_shipping_rates(*, active : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, currency : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_shipping_rates ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end

        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_SHIPPING_RATES_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_SHIPPING_RATES_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/shipping_rates"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["active"] = active.to_s if !active.nil?
      query_params["created"] = created.to_s if !created.nil?
      query_params["currency"] = currency.to_s if !currency.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_shipping_rates",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns the shipping rate object with the given ID.</p>
    # @param shipping_rate_token [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [ShippingRate]
    def get_shipping_rates_shipping_rate_token(*, shipping_rate_token : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_shipping_rates_shipping_rate_token_with_http_info(shipping_rate_token: shipping_rate_token, expand: expand)
      data
    end

    # &lt;p&gt;Returns the shipping rate object with the given ID.&lt;/p&gt;
    # @param shipping_rate_token [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(ShippingRate, Integer, Hash)>] ShippingRate data, response status code and response headers
    def get_shipping_rates_shipping_rate_token_with_http_info(*, shipping_rate_token : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_shipping_rates_shipping_rate_token(shipping_rate_token: shipping_rate_token, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_shipping_rates_shipping_rate_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ShippingRate.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns the shipping rate object with the given ID.&lt;/p&gt;
    # @param shipping_rate_token [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_shipping_rates_shipping_rate_token(*, shipping_rate_token : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_shipping_rates_shipping_rate_token(shipping_rate_token: shipping_rate_token, expand: expand).execute(&block)
    end

    GET_SHIPPING_RATES_SHIPPING_RATE_TOKEN_MAX_LENGTH_FOR_SHIPPING_RATE_TOKEN = 5000

    # @return Crest::Request
    def build_api_request_for_get_shipping_rates_shipping_rate_token(*, shipping_rate_token : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_shipping_rates_shipping_rate_token ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"shipping_rate_token\" is required and cannot be null") if shipping_rate_token.nil?
        if _shipping_rate_token = shipping_rate_token
          OpenApi::PrimitiveValidator.validate_max_length("shipping_rate_token", shipping_rate_token.to_s.size, GET_SHIPPING_RATES_SHIPPING_RATE_TOKEN_MAX_LENGTH_FOR_SHIPPING_RATE_TOKEN)
        end
      end

      # resource path
      local_var_path = "/v1/shipping_rates/{shipping_rate_token}".sub("{" + "shipping_rate_token" + "}", URI.encode_path(shipping_rate_token.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_shipping_rates_shipping_rate_token",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of scheduled query runs.</p>
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [SigmaScheduledQueryRunList]
    def get_sigma_scheduled_query_runs(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_sigma_scheduled_query_runs_with_http_info(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of scheduled query runs.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(SigmaScheduledQueryRunList, Integer, Hash)>] SigmaScheduledQueryRunList data, response status code and response headers
    def get_sigma_scheduled_query_runs_with_http_info(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_sigma_scheduled_query_runs(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_sigma_scheduled_query_runs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SigmaScheduledQueryRunList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of scheduled query runs.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_sigma_scheduled_query_runs(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_sigma_scheduled_query_runs(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_SIGMA_SCHEDULED_QUERY_RUNS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_SIGMA_SCHEDULED_QUERY_RUNS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_sigma_scheduled_query_runs(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_sigma_scheduled_query_runs ..." }
      end

      if client_side_validation
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_SIGMA_SCHEDULED_QUERY_RUNS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_SIGMA_SCHEDULED_QUERY_RUNS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/sigma/scheduled_query_runs"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_sigma_scheduled_query_runs",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an scheduled query run.</p>
    # @param scheduled_query_run [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [ScheduledQueryRun]
    def get_sigma_scheduled_query_runs_scheduled_query_run(*, scheduled_query_run : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_sigma_scheduled_query_runs_scheduled_query_run_with_http_info(scheduled_query_run: scheduled_query_run, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an scheduled query run.&lt;/p&gt;
    # @param scheduled_query_run [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(ScheduledQueryRun, Integer, Hash)>] ScheduledQueryRun data, response status code and response headers
    def get_sigma_scheduled_query_runs_scheduled_query_run_with_http_info(*, scheduled_query_run : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_sigma_scheduled_query_runs_scheduled_query_run(scheduled_query_run: scheduled_query_run, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_sigma_scheduled_query_runs_scheduled_query_run\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ScheduledQueryRun.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an scheduled query run.&lt;/p&gt;
    # @param scheduled_query_run [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_sigma_scheduled_query_runs_scheduled_query_run(*, scheduled_query_run : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_sigma_scheduled_query_runs_scheduled_query_run(scheduled_query_run: scheduled_query_run, expand: expand).execute(&block)
    end

    GET_SIGMA_SCHEDULED_QUERY_RUNS_SCHEDULED_QUERY_RUN_MAX_LENGTH_FOR_SCHEDULED_QUERY_RUN = 5000

    # @return Crest::Request
    def build_api_request_for_get_sigma_scheduled_query_runs_scheduled_query_run(*, scheduled_query_run : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_sigma_scheduled_query_runs_scheduled_query_run ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"scheduled_query_run\" is required and cannot be null") if scheduled_query_run.nil?
        if _scheduled_query_run = scheduled_query_run
          OpenApi::PrimitiveValidator.validate_max_length("scheduled_query_run", scheduled_query_run.to_s.size, GET_SIGMA_SCHEDULED_QUERY_RUNS_SCHEDULED_QUERY_RUN_MAX_LENGTH_FOR_SCHEDULED_QUERY_RUN)
        end
      end

      # resource path
      local_var_path = "/v1/sigma/scheduled_query_runs/{scheduled_query_run}".sub("{" + "scheduled_query_run" + "}", URI.encode_path(scheduled_query_run.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_sigma_scheduled_query_runs_scheduled_query_run",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of your SKUs. The SKUs are returned sorted by creation date, with the most recently created SKUs appearing first.</p>
    # @optional @param active [Bool?] Only return SKUs that are active or inactive (e.g., pass `false` to list all inactive products).
    # @optional @param attributes [Hash(String, Hash(String, String))?] Only return SKUs that have the specified key-value pairs in this partially constructed dictionary. Can be specified only if `product` is also supplied. For instance, if the associated product has attributes `[\"color\", \"size\"]`, passing in `attributes[color]=red` returns all the SKUs for this product that have `color` set to `red`.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param ids [Array(Array(String))?] Only return SKUs with the given IDs.
    # @optional @param in_stock [Bool?] Only return SKUs that are either in stock or out of stock (e.g., pass `false` to list all SKUs that are out of stock). If no value is provided, all SKUs are returned.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param product [String?] The ID of the product whose SKUs will be retrieved. Must be a product with type `good`.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [ProductsMethodSKUList]
    def get_skus(*, active : Bool? = nil, attributes : Hash(String, Hash(String, String))? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, ids : Array(Array(String))? = nil, in_stock : Bool? = nil, limit : Int64? = nil, product : String? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_skus_with_http_info(active: active, attributes: attributes, ending_before: ending_before, expand: expand, ids: ids, in_stock: in_stock, limit: limit, product: product, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of your SKUs. The SKUs are returned sorted by creation date, with the most recently created SKUs appearing first.&lt;/p&gt;
    # @optional @param active [Bool?] Only return SKUs that are active or inactive (e.g., pass `false` to list all inactive products).
    # @optional @param attributes [Hash(String, Hash(String, String))?] Only return SKUs that have the specified key-value pairs in this partially constructed dictionary. Can be specified only if `product` is also supplied. For instance, if the associated product has attributes `[\"color\", \"size\"]`, passing in `attributes[color]=red` returns all the SKUs for this product that have `color` set to `red`.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param ids [Array(Array(String))?] Only return SKUs with the given IDs.
    # @optional @param in_stock [Bool?] Only return SKUs that are either in stock or out of stock (e.g., pass `false` to list all SKUs that are out of stock). If no value is provided, all SKUs are returned.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param product [String?] The ID of the product whose SKUs will be retrieved. Must be a product with type `good`.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(ProductsMethodSKUList, Integer, Hash)>] ProductsMethodSKUList data, response status code and response headers
    def get_skus_with_http_info(*, active : Bool? = nil, attributes : Hash(String, Hash(String, String))? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, ids : Array(Array(String))? = nil, in_stock : Bool? = nil, limit : Int64? = nil, product : String? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_skus(active: active, attributes: attributes, ending_before: ending_before, expand: expand, ids: ids, in_stock: in_stock, limit: limit, product: product, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_skus\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ProductsMethodSKUList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of your SKUs. The SKUs are returned sorted by creation date, with the most recently created SKUs appearing first.&lt;/p&gt;
    # @optional @param active [Bool?] Only return SKUs that are active or inactive (e.g., pass `false` to list all inactive products).
    # @optional @param attributes [Hash(String, Hash(String, String))?] Only return SKUs that have the specified key-value pairs in this partially constructed dictionary. Can be specified only if `product` is also supplied. For instance, if the associated product has attributes `[\"color\", \"size\"]`, passing in `attributes[color]=red` returns all the SKUs for this product that have `color` set to `red`.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param ids [Array(Array(String))?] Only return SKUs with the given IDs.
    # @optional @param in_stock [Bool?] Only return SKUs that are either in stock or out of stock (e.g., pass `false` to list all SKUs that are out of stock). If no value is provided, all SKUs are returned.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param product [String?] The ID of the product whose SKUs will be retrieved. Must be a product with type `good`.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_skus(*, active : Bool? = nil, attributes : Hash(String, Hash(String, String))? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, ids : Array(Array(String))? = nil, in_stock : Bool? = nil, limit : Int64? = nil, product : String? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_skus(active: active, attributes: attributes, ending_before: ending_before, expand: expand, ids: ids, in_stock: in_stock, limit: limit, product: product, starting_after: starting_after).execute(&block)
    end

    GET_SKUS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_SKUS_MAX_LENGTH_FOR_PRODUCT        = 5000
    GET_SKUS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_skus(*, active : Bool? = nil, attributes : Hash(String, Hash(String, String))? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, ids : Array(Array(String))? = nil, in_stock : Bool? = nil, limit : Int64? = nil, product : String? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_skus ..." }
      end

      if client_side_validation
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_SKUS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _product = product
          OpenApi::PrimitiveValidator.validate_max_length("product", product.to_s.size, GET_SKUS_MAX_LENGTH_FOR_PRODUCT)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_SKUS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/skus"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["active"] = active.to_s if !active.nil?
      query_params["attributes"] = attributes.to_s if !attributes.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["ids"] = @api_client.build_collection_param(ids, "csv") if !ids.nil? && !ids.empty?
      query_params["in_stock"] = in_stock.to_s if !in_stock.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["product"] = product.to_s if !product.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_skus",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an existing SKU. Supply the unique SKU identifier from either a SKU creation request or from the product, and Stripe will return the corresponding SKU information.</p>
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [GetSkusId200Response]
    def get_skus_id(*, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_skus_id_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an existing SKU. Supply the unique SKU identifier from either a SKU creation request or from the product, and Stripe will return the corresponding SKU information.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(GetSkusId200Response, Integer, Hash)>] GetSkusId200Response data, response status code and response headers
    def get_skus_id_with_http_info(*, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_skus_id(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_skus_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return GetSkusId200Response.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an existing SKU. Supply the unique SKU identifier from either a SKU creation request or from the product, and Stripe will return the corresponding SKU information.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_skus_id(*, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_skus_id(id: id, expand: expand).execute(&block)
    end

    GET_SKUS_ID_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_get_skus_id(*, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_skus_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_SKUS_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/skus/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_skus_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves an existing source object. Supply the unique source ID from a source creation request and Stripe will return the corresponding up-to-date source object information.</p>
    # @param source [String?]
    # @optional @param client_secret [String?] The client secret of the source. Required if a publishable key is used to retrieve the source.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Source]
    def get_sources_source(*, source : String? = nil, client_secret : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_sources_source_with_http_info(source: source, client_secret: client_secret, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves an existing source object. Supply the unique source ID from a source creation request and Stripe will return the corresponding up-to-date source object information.&lt;/p&gt;
    # @param source [String?]
    # @optional @param client_secret [String?] The client secret of the source. Required if a publishable key is used to retrieve the source.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Source, Integer, Hash)>] Source data, response status code and response headers
    def get_sources_source_with_http_info(*, source : String? = nil, client_secret : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_sources_source(source: source, client_secret: client_secret, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_sources_source\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Source.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves an existing source object. Supply the unique source ID from a source creation request and Stripe will return the corresponding up-to-date source object information.&lt;/p&gt;
    # @param source [String?]
    # @optional @param client_secret [String?] The client secret of the source. Required if a publishable key is used to retrieve the source.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_sources_source(*, source : String? = nil, client_secret : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_sources_source(source: source, client_secret: client_secret, expand: expand).execute(&block)
    end

    GET_SOURCES_SOURCE_MAX_LENGTH_FOR_SOURCE        = 5000
    GET_SOURCES_SOURCE_MAX_LENGTH_FOR_CLIENT_SECRET = 5000

    # @return Crest::Request
    def build_api_request_for_get_sources_source(*, source : String? = nil, client_secret : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_sources_source ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"source\" is required and cannot be null") if source.nil?
        if _source = source
          OpenApi::PrimitiveValidator.validate_max_length("source", source.to_s.size, GET_SOURCES_SOURCE_MAX_LENGTH_FOR_SOURCE)
        end
        if _client_secret = client_secret
          OpenApi::PrimitiveValidator.validate_max_length("client_secret", client_secret.to_s.size, GET_SOURCES_SOURCE_MAX_LENGTH_FOR_CLIENT_SECRET)
        end
      end

      # resource path
      local_var_path = "/v1/sources/{source}".sub("{" + "source" + "}", URI.encode_path(source.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["client_secret"] = client_secret.to_s if !client_secret.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_sources_source",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a new Source MandateNotification.</p>
    # @param mandate_notification [String?]
    # @param source [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [SourceMandateNotification]
    def get_sources_source_mandate_notifications_mandate_notification(*, mandate_notification : String? = nil, source : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_sources_source_mandate_notifications_mandate_notification_with_http_info(mandate_notification: mandate_notification, source: source, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves a new Source MandateNotification.&lt;/p&gt;
    # @param mandate_notification [String?]
    # @param source [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(SourceMandateNotification, Integer, Hash)>] SourceMandateNotification data, response status code and response headers
    def get_sources_source_mandate_notifications_mandate_notification_with_http_info(*, mandate_notification : String? = nil, source : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_sources_source_mandate_notifications_mandate_notification(mandate_notification: mandate_notification, source: source, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_sources_source_mandate_notifications_mandate_notification\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SourceMandateNotification.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a new Source MandateNotification.&lt;/p&gt;
    # @param mandate_notification [String?]
    # @param source [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_sources_source_mandate_notifications_mandate_notification(*, mandate_notification : String? = nil, source : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_sources_source_mandate_notifications_mandate_notification(mandate_notification: mandate_notification, source: source, expand: expand).execute(&block)
    end

    GET_SOURCES_SOURCE_MANDATE_NOTIFICATIONS_MANDATE_NOTIFICATION_MAX_LENGTH_FOR_MANDATE_NOTIFICATION = 5000
    GET_SOURCES_SOURCE_MANDATE_NOTIFICATIONS_MANDATE_NOTIFICATION_MAX_LENGTH_FOR_SOURCE               = 5000

    # @return Crest::Request
    def build_api_request_for_get_sources_source_mandate_notifications_mandate_notification(*, mandate_notification : String? = nil, source : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_sources_source_mandate_notifications_mandate_notification ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"mandate_notification\" is required and cannot be null") if mandate_notification.nil?
        if _mandate_notification = mandate_notification
          OpenApi::PrimitiveValidator.validate_max_length("mandate_notification", mandate_notification.to_s.size, GET_SOURCES_SOURCE_MANDATE_NOTIFICATIONS_MANDATE_NOTIFICATION_MAX_LENGTH_FOR_MANDATE_NOTIFICATION)
        end
        raise ArgumentError.new("\"source\" is required and cannot be null") if source.nil?
        if _source = source
          OpenApi::PrimitiveValidator.validate_max_length("source", source.to_s.size, GET_SOURCES_SOURCE_MANDATE_NOTIFICATIONS_MANDATE_NOTIFICATION_MAX_LENGTH_FOR_SOURCE)
        end
      end

      # resource path
      local_var_path = "/v1/sources/{source}/mandate_notifications/{mandate_notification}".sub("{" + "mandate_notification" + "}", URI.encode_path(mandate_notification.to_s)).sub("{" + "source" + "}", URI.encode_path(source.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_sources_source_mandate_notifications_mandate_notification",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>List source transactions for a given source.</p>
    # @param source [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [ApmsSourcesSourceTransactionList]
    def get_sources_source_source_transactions(*, source : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_sources_source_source_transactions_with_http_info(source: source, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;List source transactions for a given source.&lt;/p&gt;
    # @param source [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(ApmsSourcesSourceTransactionList, Integer, Hash)>] ApmsSourcesSourceTransactionList data, response status code and response headers
    def get_sources_source_source_transactions_with_http_info(*, source : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_sources_source_source_transactions(source: source, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_sources_source_source_transactions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ApmsSourcesSourceTransactionList.from_json(data), status_code, headers
    end

    # &lt;p&gt;List source transactions for a given source.&lt;/p&gt;
    # @param source [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_sources_source_source_transactions(*, source : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_sources_source_source_transactions(source: source, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_SOURCES_SOURCE_SOURCE_TRANSACTIONS_MAX_LENGTH_FOR_SOURCE         = 5000
    GET_SOURCES_SOURCE_SOURCE_TRANSACTIONS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_SOURCES_SOURCE_SOURCE_TRANSACTIONS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_sources_source_source_transactions(*, source : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_sources_source_source_transactions ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"source\" is required and cannot be null") if source.nil?
        if _source = source
          OpenApi::PrimitiveValidator.validate_max_length("source", source.to_s.size, GET_SOURCES_SOURCE_SOURCE_TRANSACTIONS_MAX_LENGTH_FOR_SOURCE)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_SOURCES_SOURCE_SOURCE_TRANSACTIONS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_SOURCES_SOURCE_SOURCE_TRANSACTIONS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/sources/{source}/source_transactions".sub("{" + "source" + "}", URI.encode_path(source.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_sources_source_source_transactions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieve an existing source transaction object. Supply the unique source ID from a source creation request and the source transaction ID and Stripe will return the corresponding up-to-date source object information.</p>
    # @param source [String?]
    # @param source_transaction [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [SourceTransaction]
    def get_sources_source_source_transactions_source_transaction(*, source : String? = nil, source_transaction : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_sources_source_source_transactions_source_transaction_with_http_info(source: source, source_transaction: source_transaction, expand: expand)
      data
    end

    # &lt;p&gt;Retrieve an existing source transaction object. Supply the unique source ID from a source creation request and the source transaction ID and Stripe will return the corresponding up-to-date source object information.&lt;/p&gt;
    # @param source [String?]
    # @param source_transaction [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(SourceTransaction, Integer, Hash)>] SourceTransaction data, response status code and response headers
    def get_sources_source_source_transactions_source_transaction_with_http_info(*, source : String? = nil, source_transaction : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_sources_source_source_transactions_source_transaction(source: source, source_transaction: source_transaction, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_sources_source_source_transactions_source_transaction\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SourceTransaction.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieve an existing source transaction object. Supply the unique source ID from a source creation request and the source transaction ID and Stripe will return the corresponding up-to-date source object information.&lt;/p&gt;
    # @param source [String?]
    # @param source_transaction [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_sources_source_source_transactions_source_transaction(*, source : String? = nil, source_transaction : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_sources_source_source_transactions_source_transaction(source: source, source_transaction: source_transaction, expand: expand).execute(&block)
    end

    GET_SOURCES_SOURCE_SOURCE_TRANSACTIONS_SOURCE_TRANSACTION_MAX_LENGTH_FOR_SOURCE             = 5000
    GET_SOURCES_SOURCE_SOURCE_TRANSACTIONS_SOURCE_TRANSACTION_MAX_LENGTH_FOR_SOURCE_TRANSACTION = 5000

    # @return Crest::Request
    def build_api_request_for_get_sources_source_source_transactions_source_transaction(*, source : String? = nil, source_transaction : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_sources_source_source_transactions_source_transaction ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"source\" is required and cannot be null") if source.nil?
        if _source = source
          OpenApi::PrimitiveValidator.validate_max_length("source", source.to_s.size, GET_SOURCES_SOURCE_SOURCE_TRANSACTIONS_SOURCE_TRANSACTION_MAX_LENGTH_FOR_SOURCE)
        end
        raise ArgumentError.new("\"source_transaction\" is required and cannot be null") if source_transaction.nil?
        if _source_transaction = source_transaction
          OpenApi::PrimitiveValidator.validate_max_length("source_transaction", source_transaction.to_s.size, GET_SOURCES_SOURCE_SOURCE_TRANSACTIONS_SOURCE_TRANSACTION_MAX_LENGTH_FOR_SOURCE_TRANSACTION)
        end
      end

      # resource path
      local_var_path = "/v1/sources/{source}/source_transactions/{source_transaction}".sub("{" + "source" + "}", URI.encode_path(source.to_s)).sub("{" + "source_transaction" + "}", URI.encode_path(source_transaction.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_sources_source_source_transactions_source_transaction",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of your subscription items for a given subscription.</p>
    # @param subscription [String?] The ID of the subscription whose items will be retrieved.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [SubscriptionsItemsSubscriptionItemList]
    def get_subscription_items(*, subscription : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_subscription_items_with_http_info(subscription: subscription, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of your subscription items for a given subscription.&lt;/p&gt;
    # @param subscription [String?] The ID of the subscription whose items will be retrieved.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(SubscriptionsItemsSubscriptionItemList, Integer, Hash)>] SubscriptionsItemsSubscriptionItemList data, response status code and response headers
    def get_subscription_items_with_http_info(*, subscription : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_subscription_items(subscription: subscription, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_subscription_items\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SubscriptionsItemsSubscriptionItemList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of your subscription items for a given subscription.&lt;/p&gt;
    # @param subscription [String?] The ID of the subscription whose items will be retrieved.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_subscription_items(*, subscription : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_subscription_items(subscription: subscription, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_SUBSCRIPTION_ITEMS_MAX_LENGTH_FOR_SUBSCRIPTION = 5000

    # @return Crest::Request
    def build_api_request_for_get_subscription_items(*, subscription : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_subscription_items ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"subscription\" is required and cannot be null") if subscription.nil?
        if _subscription = subscription
          OpenApi::PrimitiveValidator.validate_max_length("subscription", subscription.to_s.size, GET_SUBSCRIPTION_ITEMS_MAX_LENGTH_FOR_SUBSCRIPTION)
        end
      end

      # resource path
      local_var_path = "/v1/subscription_items"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["subscription"] = subscription.to_s if !subscription.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_subscription_items",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the subscription item with the given ID.</p>
    # @param item [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [SubscriptionItem]
    def get_subscription_items_item(*, item : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_subscription_items_item_with_http_info(item: item, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the subscription item with the given ID.&lt;/p&gt;
    # @param item [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(SubscriptionItem, Integer, Hash)>] SubscriptionItem data, response status code and response headers
    def get_subscription_items_item_with_http_info(*, item : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_subscription_items_item(item: item, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_subscription_items_item\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SubscriptionItem.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the subscription item with the given ID.&lt;/p&gt;
    # @param item [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_subscription_items_item(*, item : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_subscription_items_item(item: item, expand: expand).execute(&block)
    end

    GET_SUBSCRIPTION_ITEMS_ITEM_MAX_LENGTH_FOR_ITEM = 5000

    # @return Crest::Request
    def build_api_request_for_get_subscription_items_item(*, item : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_subscription_items_item ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"item\" is required and cannot be null") if item.nil?
        if _item = item
          OpenApi::PrimitiveValidator.validate_max_length("item", item.to_s.size, GET_SUBSCRIPTION_ITEMS_ITEM_MAX_LENGTH_FOR_ITEM)
        end
      end

      # resource path
      local_var_path = "/v1/subscription_items/{item}".sub("{" + "item" + "}", URI.encode_path(item.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_subscription_items_item",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>For the specified subscription item, returns a list of summary objects. Each object in the list provides usage information that’s been summarized from multiple usage records and over a subscription billing period (e.g., 15 usage records in the month of September).</p>  <p>The list is sorted in reverse-chronological order (newest first). The first list item represents the most current usage period that hasn’t ended yet. Since new usage records can still be added, the returned summary information for the subscription item’s ID should be seen as unstable until the subscription billing period ends.</p>
    # @param subscription_item [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [UsageEventsResourceUsageRecordSummaryList]
    def get_subscription_items_subscription_item_usage_record_summaries(*, subscription_item : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_subscription_items_subscription_item_usage_record_summaries_with_http_info(subscription_item: subscription_item, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;For the specified subscription item, returns a list of summary objects. Each object in the list provides usage information that’s been summarized from multiple usage records and over a subscription billing period (e.g., 15 usage records in the month of September).&lt;/p&gt;  &lt;p&gt;The list is sorted in reverse-chronological order (newest first). The first list item represents the most current usage period that hasn’t ended yet. Since new usage records can still be added, the returned summary information for the subscription item’s ID should be seen as unstable until the subscription billing period ends.&lt;/p&gt;
    # @param subscription_item [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(UsageEventsResourceUsageRecordSummaryList, Integer, Hash)>] UsageEventsResourceUsageRecordSummaryList data, response status code and response headers
    def get_subscription_items_subscription_item_usage_record_summaries_with_http_info(*, subscription_item : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_subscription_items_subscription_item_usage_record_summaries(subscription_item: subscription_item, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_subscription_items_subscription_item_usage_record_summaries\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return UsageEventsResourceUsageRecordSummaryList.from_json(data), status_code, headers
    end

    # &lt;p&gt;For the specified subscription item, returns a list of summary objects. Each object in the list provides usage information that’s been summarized from multiple usage records and over a subscription billing period (e.g., 15 usage records in the month of September).&lt;/p&gt;  &lt;p&gt;The list is sorted in reverse-chronological order (newest first). The first list item represents the most current usage period that hasn’t ended yet. Since new usage records can still be added, the returned summary information for the subscription item’s ID should be seen as unstable until the subscription billing period ends.&lt;/p&gt;
    # @param subscription_item [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_subscription_items_subscription_item_usage_record_summaries(*, subscription_item : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_subscription_items_subscription_item_usage_record_summaries(subscription_item: subscription_item, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_SUBSCRIPTION_ITEMS_SUBSCRIPTION_ITEM_USAGE_RECORD_SUMMARIES_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_SUBSCRIPTION_ITEMS_SUBSCRIPTION_ITEM_USAGE_RECORD_SUMMARIES_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_subscription_items_subscription_item_usage_record_summaries(*, subscription_item : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_subscription_items_subscription_item_usage_record_summaries ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"subscription_item\" is required and cannot be null") if subscription_item.nil?

        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_SUBSCRIPTION_ITEMS_SUBSCRIPTION_ITEM_USAGE_RECORD_SUMMARIES_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_SUBSCRIPTION_ITEMS_SUBSCRIPTION_ITEM_USAGE_RECORD_SUMMARIES_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/subscription_items/{subscription_item}/usage_record_summaries".sub("{" + "subscription_item" + "}", URI.encode_path(subscription_item.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_subscription_items_subscription_item_usage_record_summaries",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the list of your subscription schedules.</p>
    # @optional @param canceled_at [Stripe::GetAccountsCreatedParameter?] Only return subscription schedules that were created canceled the given date interval.
    # @optional @param completed_at [Stripe::GetAccountsCreatedParameter?] Only return subscription schedules that completed during the given date interval.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return subscription schedules that were created during the given date interval.
    # @optional @param customer [String?] Only return subscription schedules for the given customer.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param released_at [Stripe::GetAccountsCreatedParameter?] Only return subscription schedules that were released during the given date interval.
    # @optional @param scheduled [Bool?] Only return subscription schedules that have not started yet.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [SubscriptionSchedulesResourceScheduleList]
    def get_subscription_schedules(*, canceled_at : Stripe::GetAccountsCreatedParameter? = nil, completed_at : Stripe::GetAccountsCreatedParameter? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, released_at : Stripe::GetAccountsCreatedParameter? = nil, scheduled : Bool? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_subscription_schedules_with_http_info(canceled_at: canceled_at, completed_at: completed_at, created: created, customer: customer, ending_before: ending_before, expand: expand, limit: limit, released_at: released_at, scheduled: scheduled, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Retrieves the list of your subscription schedules.&lt;/p&gt;
    # @optional @param canceled_at [Stripe::GetAccountsCreatedParameter?] Only return subscription schedules that were created canceled the given date interval.
    # @optional @param completed_at [Stripe::GetAccountsCreatedParameter?] Only return subscription schedules that completed during the given date interval.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return subscription schedules that were created during the given date interval.
    # @optional @param customer [String?] Only return subscription schedules for the given customer.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param released_at [Stripe::GetAccountsCreatedParameter?] Only return subscription schedules that were released during the given date interval.
    # @optional @param scheduled [Bool?] Only return subscription schedules that have not started yet.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(SubscriptionSchedulesResourceScheduleList, Integer, Hash)>] SubscriptionSchedulesResourceScheduleList data, response status code and response headers
    def get_subscription_schedules_with_http_info(*, canceled_at : Stripe::GetAccountsCreatedParameter? = nil, completed_at : Stripe::GetAccountsCreatedParameter? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, released_at : Stripe::GetAccountsCreatedParameter? = nil, scheduled : Bool? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_subscription_schedules(canceled_at: canceled_at, completed_at: completed_at, created: created, customer: customer, ending_before: ending_before, expand: expand, limit: limit, released_at: released_at, scheduled: scheduled, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_subscription_schedules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SubscriptionSchedulesResourceScheduleList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the list of your subscription schedules.&lt;/p&gt;
    # @optional @param canceled_at [Stripe::GetAccountsCreatedParameter?] Only return subscription schedules that were created canceled the given date interval.
    # @optional @param completed_at [Stripe::GetAccountsCreatedParameter?] Only return subscription schedules that completed during the given date interval.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Only return subscription schedules that were created during the given date interval.
    # @optional @param customer [String?] Only return subscription schedules for the given customer.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param released_at [Stripe::GetAccountsCreatedParameter?] Only return subscription schedules that were released during the given date interval.
    # @optional @param scheduled [Bool?] Only return subscription schedules that have not started yet.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_subscription_schedules(*, canceled_at : Stripe::GetAccountsCreatedParameter? = nil, completed_at : Stripe::GetAccountsCreatedParameter? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, released_at : Stripe::GetAccountsCreatedParameter? = nil, scheduled : Bool? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_subscription_schedules(canceled_at: canceled_at, completed_at: completed_at, created: created, customer: customer, ending_before: ending_before, expand: expand, limit: limit, released_at: released_at, scheduled: scheduled, starting_after: starting_after).execute(&block)
    end

    GET_SUBSCRIPTION_SCHEDULES_MAX_LENGTH_FOR_CUSTOMER       = 5000
    GET_SUBSCRIPTION_SCHEDULES_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_SUBSCRIPTION_SCHEDULES_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_subscription_schedules(*, canceled_at : Stripe::GetAccountsCreatedParameter? = nil, completed_at : Stripe::GetAccountsCreatedParameter? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, released_at : Stripe::GetAccountsCreatedParameter? = nil, scheduled : Bool? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_subscription_schedules ..." }
      end

      if client_side_validation
        if _canceled_at = canceled_at
          _canceled_at.validate if _canceled_at.is_a?(OpenApi::Validatable)
        end
        if _completed_at = completed_at
          _completed_at.validate if _completed_at.is_a?(OpenApi::Validatable)
        end
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_SUBSCRIPTION_SCHEDULES_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_SUBSCRIPTION_SCHEDULES_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _released_at = released_at
          _released_at.validate if _released_at.is_a?(OpenApi::Validatable)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_SUBSCRIPTION_SCHEDULES_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/subscription_schedules"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["canceled_at"] = canceled_at.to_s if !canceled_at.nil?
      query_params["completed_at"] = completed_at.to_s if !completed_at.nil?
      query_params["created"] = created.to_s if !created.nil?
      query_params["customer"] = customer.to_s if !customer.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["released_at"] = released_at.to_s if !released_at.nil?
      query_params["scheduled"] = scheduled.to_s if !scheduled.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_subscription_schedules",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an existing subscription schedule. You only need to supply the unique subscription schedule identifier that was returned upon subscription schedule creation.</p>
    # @param schedule [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [SubscriptionSchedule]
    def get_subscription_schedules_schedule(*, schedule : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_subscription_schedules_schedule_with_http_info(schedule: schedule, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an existing subscription schedule. You only need to supply the unique subscription schedule identifier that was returned upon subscription schedule creation.&lt;/p&gt;
    # @param schedule [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(SubscriptionSchedule, Integer, Hash)>] SubscriptionSchedule data, response status code and response headers
    def get_subscription_schedules_schedule_with_http_info(*, schedule : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_subscription_schedules_schedule(schedule: schedule, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_subscription_schedules_schedule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SubscriptionSchedule.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an existing subscription schedule. You only need to supply the unique subscription schedule identifier that was returned upon subscription schedule creation.&lt;/p&gt;
    # @param schedule [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_subscription_schedules_schedule(*, schedule : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_subscription_schedules_schedule(schedule: schedule, expand: expand).execute(&block)
    end

    GET_SUBSCRIPTION_SCHEDULES_SCHEDULE_MAX_LENGTH_FOR_SCHEDULE = 5000

    # @return Crest::Request
    def build_api_request_for_get_subscription_schedules_schedule(*, schedule : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_subscription_schedules_schedule ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"schedule\" is required and cannot be null") if schedule.nil?
        if _schedule = schedule
          OpenApi::PrimitiveValidator.validate_max_length("schedule", schedule.to_s.size, GET_SUBSCRIPTION_SCHEDULES_SCHEDULE_MAX_LENGTH_FOR_SCHEDULE)
        end
      end

      # resource path
      local_var_path = "/v1/subscription_schedules/{schedule}".sub("{" + "schedule" + "}", URI.encode_path(schedule.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_subscription_schedules_schedule",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>By default, returns a list of subscriptions that have not been canceled. In order to list canceled subscriptions, specify <code>status=canceled</code>.</p>
    # @optional @param collection_method [String?] The collection method of the subscriptions to retrieve. Either `charge_automatically` or `send_invoice`.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param current_period_end [Stripe::GetAccountsCreatedParameter?]
    # @optional @param current_period_start [Stripe::GetAccountsCreatedParameter?]
    # @optional @param customer [String?] The ID of the customer whose subscriptions will be retrieved.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param price [String?] Filter for subscriptions that contain this recurring price ID.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] The status of the subscriptions to retrieve. Passing in a value of `canceled` will return all canceled subscriptions, including those belonging to deleted customers. Pass `ended` to find subscriptions that are canceled and subscriptions that are expired due to [incomplete payment](https://stripe.com/docs/billing/subscriptions/overview#subscription-statuses). Passing in a value of `all` will return subscriptions of all statuses. If no value is supplied, all subscriptions that have not been canceled are returned.
    # @optional @param test_clock [String?] Filter for subscriptions that are associated with the specified test clock. The response will not include subscriptions with test clocks if this and the customer parameter is not set.
    # @return [SubscriptionsSubscriptionList]
    def get_subscriptions(*, collection_method : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, current_period_end : Stripe::GetAccountsCreatedParameter? = nil, current_period_start : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, price : String? = nil, starting_after : String? = nil, status : String? = nil, test_clock : String? = nil)
      data, _status_code, _headers = get_subscriptions_with_http_info(collection_method: collection_method, created: created, current_period_end: current_period_end, current_period_start: current_period_start, customer: customer, ending_before: ending_before, expand: expand, limit: limit, price: price, starting_after: starting_after, status: status, test_clock: test_clock)
      data
    end

    # &lt;p&gt;By default, returns a list of subscriptions that have not been canceled. In order to list canceled subscriptions, specify &lt;code&gt;status&#x3D;canceled&lt;/code&gt;.&lt;/p&gt;
    # @optional @param collection_method [String?] The collection method of the subscriptions to retrieve. Either `charge_automatically` or `send_invoice`.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param current_period_end [Stripe::GetAccountsCreatedParameter?]
    # @optional @param current_period_start [Stripe::GetAccountsCreatedParameter?]
    # @optional @param customer [String?] The ID of the customer whose subscriptions will be retrieved.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param price [String?] Filter for subscriptions that contain this recurring price ID.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] The status of the subscriptions to retrieve. Passing in a value of `canceled` will return all canceled subscriptions, including those belonging to deleted customers. Pass `ended` to find subscriptions that are canceled and subscriptions that are expired due to [incomplete payment](https://stripe.com/docs/billing/subscriptions/overview#subscription-statuses). Passing in a value of `all` will return subscriptions of all statuses. If no value is supplied, all subscriptions that have not been canceled are returned.
    # @optional @param test_clock [String?] Filter for subscriptions that are associated with the specified test clock. The response will not include subscriptions with test clocks if this and the customer parameter is not set.
    # @return [Array<(SubscriptionsSubscriptionList, Integer, Hash)>] SubscriptionsSubscriptionList data, response status code and response headers
    def get_subscriptions_with_http_info(*, collection_method : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, current_period_end : Stripe::GetAccountsCreatedParameter? = nil, current_period_start : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, price : String? = nil, starting_after : String? = nil, status : String? = nil, test_clock : String? = nil)
      request = build_api_request_for_get_subscriptions(collection_method: collection_method, created: created, current_period_end: current_period_end, current_period_start: current_period_start, customer: customer, ending_before: ending_before, expand: expand, limit: limit, price: price, starting_after: starting_after, status: status, test_clock: test_clock)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_subscriptions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SubscriptionsSubscriptionList.from_json(data), status_code, headers
    end

    # &lt;p&gt;By default, returns a list of subscriptions that have not been canceled. In order to list canceled subscriptions, specify &lt;code&gt;status&#x3D;canceled&lt;/code&gt;.&lt;/p&gt;
    # @optional @param collection_method [String?] The collection method of the subscriptions to retrieve. Either `charge_automatically` or `send_invoice`.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param current_period_end [Stripe::GetAccountsCreatedParameter?]
    # @optional @param current_period_start [Stripe::GetAccountsCreatedParameter?]
    # @optional @param customer [String?] The ID of the customer whose subscriptions will be retrieved.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param price [String?] Filter for subscriptions that contain this recurring price ID.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] The status of the subscriptions to retrieve. Passing in a value of `canceled` will return all canceled subscriptions, including those belonging to deleted customers. Pass `ended` to find subscriptions that are canceled and subscriptions that are expired due to [incomplete payment](https://stripe.com/docs/billing/subscriptions/overview#subscription-statuses). Passing in a value of `all` will return subscriptions of all statuses. If no value is supplied, all subscriptions that have not been canceled are returned.
    # @optional @param test_clock [String?] Filter for subscriptions that are associated with the specified test clock. The response will not include subscriptions with test clocks if this and the customer parameter is not set.
    # @return nil
    def get_subscriptions(*, collection_method : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, current_period_end : Stripe::GetAccountsCreatedParameter? = nil, current_period_start : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, price : String? = nil, starting_after : String? = nil, status : String? = nil, test_clock : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_subscriptions(collection_method: collection_method, created: created, current_period_end: current_period_end, current_period_start: current_period_start, customer: customer, ending_before: ending_before, expand: expand, limit: limit, price: price, starting_after: starting_after, status: status, test_clock: test_clock).execute(&block)
    end

    GET_SUBSCRIPTIONS_VALID_VALUES_FOR_COLLECTION_METHOD = StaticArray["charge_automatically", "send_invoice"]
    GET_SUBSCRIPTIONS_MAX_LENGTH_FOR_CUSTOMER            = 5000
    GET_SUBSCRIPTIONS_MAX_LENGTH_FOR_ENDING_BEFORE       = 5000
    GET_SUBSCRIPTIONS_MAX_LENGTH_FOR_PRICE               = 5000
    GET_SUBSCRIPTIONS_MAX_LENGTH_FOR_STARTING_AFTER      = 5000
    GET_SUBSCRIPTIONS_VALID_VALUES_FOR_STATUS            = StaticArray["active", "all", "canceled", "ended", "incomplete", "incomplete_expired", "past_due", "trialing", "unpaid"]
    GET_SUBSCRIPTIONS_MAX_LENGTH_FOR_TEST_CLOCK          = 5000

    # @return Crest::Request
    def build_api_request_for_get_subscriptions(*, collection_method : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, current_period_end : Stripe::GetAccountsCreatedParameter? = nil, current_period_start : Stripe::GetAccountsCreatedParameter? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, price : String? = nil, starting_after : String? = nil, status : String? = nil, test_clock : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_subscriptions ..." }
      end

      if client_side_validation
        if _collection_method = collection_method
          OpenApi::EnumValidator.validate("collection_method", _collection_method, GET_SUBSCRIPTIONS_VALID_VALUES_FOR_COLLECTION_METHOD)
        end
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _current_period_end = current_period_end
          _current_period_end.validate if _current_period_end.is_a?(OpenApi::Validatable)
        end
        if _current_period_start = current_period_start
          _current_period_start.validate if _current_period_start.is_a?(OpenApi::Validatable)
        end
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_SUBSCRIPTIONS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_SUBSCRIPTIONS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _price = price
          OpenApi::PrimitiveValidator.validate_max_length("price", price.to_s.size, GET_SUBSCRIPTIONS_MAX_LENGTH_FOR_PRICE)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_SUBSCRIPTIONS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, GET_SUBSCRIPTIONS_VALID_VALUES_FOR_STATUS)
        end
        if _test_clock = test_clock
          OpenApi::PrimitiveValidator.validate_max_length("test_clock", test_clock.to_s.size, GET_SUBSCRIPTIONS_MAX_LENGTH_FOR_TEST_CLOCK)
        end
      end

      # resource path
      local_var_path = "/v1/subscriptions"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["collection_method"] = collection_method.to_s if !collection_method.nil?
      query_params["created"] = created.to_s if !created.nil?
      query_params["current_period_end"] = current_period_end.to_s if !current_period_end.nil?
      query_params["current_period_start"] = current_period_start.to_s if !current_period_start.nil?
      query_params["customer"] = customer.to_s if !customer.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["price"] = price.to_s if !price.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["status"] = status.to_s if !status.nil?
      query_params["test_clock"] = test_clock.to_s if !test_clock.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_subscriptions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Search for subscriptions you’ve previously created using Stripe’s <a href=\"/docs/search#search-query-language\">Search Query Language</a>. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.</p>
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for subscriptions](https://stripe.com/docs/search#query-fields-for-subscriptions).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return [SearchResult6]
    def get_subscriptions_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil)
      data, _status_code, _headers = get_subscriptions_search_with_http_info(query: query, expand: expand, limit: limit, page: page)
      data
    end

    # &lt;p&gt;Search for subscriptions you’ve previously created using Stripe’s &lt;a href&#x3D;\&quot;/docs/search#search-query-language\&quot;&gt;Search Query Language&lt;/a&gt;. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.&lt;/p&gt;
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for subscriptions](https://stripe.com/docs/search#query-fields-for-subscriptions).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return [Array<(SearchResult6, Integer, Hash)>] SearchResult6 data, response status code and response headers
    def get_subscriptions_search_with_http_info(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil)
      request = build_api_request_for_get_subscriptions_search(query: query, expand: expand, limit: limit, page: page)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_subscriptions_search\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SearchResult6.from_json(data), status_code, headers
    end

    # &lt;p&gt;Search for subscriptions you’ve previously created using Stripe’s &lt;a href&#x3D;\&quot;/docs/search#search-query-language\&quot;&gt;Search Query Language&lt;/a&gt;. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.&lt;/p&gt;
    # @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for subscriptions](https://stripe.com/docs/search#query-fields-for-subscriptions).
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @return nil
    def get_subscriptions_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_subscriptions_search(query: query, expand: expand, limit: limit, page: page).execute(&block)
    end

    GET_SUBSCRIPTIONS_SEARCH_MAX_LENGTH_FOR_QUERY = 5000
    GET_SUBSCRIPTIONS_SEARCH_MAX_LENGTH_FOR_PAGE  = 5000

    # @return Crest::Request
    def build_api_request_for_get_subscriptions_search(*, query : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, page : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_subscriptions_search ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"query\" is required and cannot be null") if query.nil?
        if _query = query
          OpenApi::PrimitiveValidator.validate_max_length("query", query.to_s.size, GET_SUBSCRIPTIONS_SEARCH_MAX_LENGTH_FOR_QUERY)
        end

        if _page = page
          OpenApi::PrimitiveValidator.validate_max_length("page", page.to_s.size, GET_SUBSCRIPTIONS_SEARCH_MAX_LENGTH_FOR_PAGE)
        end
      end

      # resource path
      local_var_path = "/v1/subscriptions/search"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["page"] = page.to_s if !page.nil?
      query_params["query"] = query.to_s if !query.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_subscriptions_search",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the subscription with the given ID.</p>
    # @param subscription_exposed_id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Subscription]
    def get_subscriptions_subscription_exposed_id(*, subscription_exposed_id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_subscriptions_subscription_exposed_id_with_http_info(subscription_exposed_id: subscription_exposed_id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the subscription with the given ID.&lt;/p&gt;
    # @param subscription_exposed_id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Subscription, Integer, Hash)>] Subscription data, response status code and response headers
    def get_subscriptions_subscription_exposed_id_with_http_info(*, subscription_exposed_id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_subscriptions_subscription_exposed_id(subscription_exposed_id: subscription_exposed_id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_subscriptions_subscription_exposed_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Subscription.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the subscription with the given ID.&lt;/p&gt;
    # @param subscription_exposed_id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_subscriptions_subscription_exposed_id(*, subscription_exposed_id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_subscriptions_subscription_exposed_id(subscription_exposed_id: subscription_exposed_id, expand: expand).execute(&block)
    end

    GET_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID = 5000

    # @return Crest::Request
    def build_api_request_for_get_subscriptions_subscription_exposed_id(*, subscription_exposed_id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_subscriptions_subscription_exposed_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"subscription_exposed_id\" is required and cannot be null") if subscription_exposed_id.nil?
        if _subscription_exposed_id = subscription_exposed_id
          OpenApi::PrimitiveValidator.validate_max_length("subscription_exposed_id", subscription_exposed_id.to_s.size, GET_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID)
        end
      end

      # resource path
      local_var_path = "/v1/subscriptions/{subscription_exposed_id}".sub("{" + "subscription_exposed_id" + "}", URI.encode_path(subscription_exposed_id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_subscriptions_subscription_exposed_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>A list of <a href=\"https://stripe.com/docs/tax/tax-categories\">all tax codes available</a> to add to Products in order to allow specific tax calculations.</p>
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [TaxProductResourceTaxCodeList]
    def get_tax_codes(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_tax_codes_with_http_info(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;A list of &lt;a href&#x3D;\&quot;https://stripe.com/docs/tax/tax-categories\&quot;&gt;all tax codes available&lt;/a&gt; to add to Products in order to allow specific tax calculations.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(TaxProductResourceTaxCodeList, Integer, Hash)>] TaxProductResourceTaxCodeList data, response status code and response headers
    def get_tax_codes_with_http_info(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_tax_codes(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_tax_codes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TaxProductResourceTaxCodeList.from_json(data), status_code, headers
    end

    # &lt;p&gt;A list of &lt;a href&#x3D;\&quot;https://stripe.com/docs/tax/tax-categories\&quot;&gt;all tax codes available&lt;/a&gt; to add to Products in order to allow specific tax calculations.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_tax_codes(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_tax_codes(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_get_tax_codes(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_tax_codes ..." }
      end

      if client_side_validation
      end

      # resource path
      local_var_path = "/v1/tax_codes"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_tax_codes",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an existing tax code. Supply the unique tax code ID and Stripe will return the corresponding tax code information.</p>
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [TaxCode]
    def get_tax_codes_id(*, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_tax_codes_id_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an existing tax code. Supply the unique tax code ID and Stripe will return the corresponding tax code information.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(TaxCode, Integer, Hash)>] TaxCode data, response status code and response headers
    def get_tax_codes_id_with_http_info(*, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_tax_codes_id(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_tax_codes_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TaxCode.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an existing tax code. Supply the unique tax code ID and Stripe will return the corresponding tax code information.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_tax_codes_id(*, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_tax_codes_id(id: id, expand: expand).execute(&block)
    end

    GET_TAX_CODES_ID_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_get_tax_codes_id(*, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_tax_codes_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_TAX_CODES_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/tax_codes/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_tax_codes_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of your tax rates. Tax rates are returned sorted by creation date, with the most recently created tax rates appearing first.</p>
    # @optional @param active [Bool?] Optional flag to filter by tax rates that are either active or inactive (archived).
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Optional range for filtering created date.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param inclusive [Bool?] Optional flag to filter by tax rates that are inclusive (or those that are not inclusive).
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [TaxRatesList]
    def get_tax_rates(*, active : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, inclusive : Bool? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_tax_rates_with_http_info(active: active, created: created, ending_before: ending_before, expand: expand, inclusive: inclusive, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of your tax rates. Tax rates are returned sorted by creation date, with the most recently created tax rates appearing first.&lt;/p&gt;
    # @optional @param active [Bool?] Optional flag to filter by tax rates that are either active or inactive (archived).
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Optional range for filtering created date.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param inclusive [Bool?] Optional flag to filter by tax rates that are inclusive (or those that are not inclusive).
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(TaxRatesList, Integer, Hash)>] TaxRatesList data, response status code and response headers
    def get_tax_rates_with_http_info(*, active : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, inclusive : Bool? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_tax_rates(active: active, created: created, ending_before: ending_before, expand: expand, inclusive: inclusive, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_tax_rates\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TaxRatesList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of your tax rates. Tax rates are returned sorted by creation date, with the most recently created tax rates appearing first.&lt;/p&gt;
    # @optional @param active [Bool?] Optional flag to filter by tax rates that are either active or inactive (archived).
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] Optional range for filtering created date.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param inclusive [Bool?] Optional flag to filter by tax rates that are inclusive (or those that are not inclusive).
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_tax_rates(*, active : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, inclusive : Bool? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_tax_rates(active: active, created: created, ending_before: ending_before, expand: expand, inclusive: inclusive, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_TAX_RATES_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_TAX_RATES_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_tax_rates(*, active : Bool? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, inclusive : Bool? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_tax_rates ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_TAX_RATES_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_TAX_RATES_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/tax_rates"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["active"] = active.to_s if !active.nil?
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["inclusive"] = inclusive.to_s if !inclusive.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_tax_rates",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a tax rate with the given ID</p>
    # @param tax_rate [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [TaxRate]
    def get_tax_rates_tax_rate(*, tax_rate : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_tax_rates_tax_rate_with_http_info(tax_rate: tax_rate, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves a tax rate with the given ID&lt;/p&gt;
    # @param tax_rate [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(TaxRate, Integer, Hash)>] TaxRate data, response status code and response headers
    def get_tax_rates_tax_rate_with_http_info(*, tax_rate : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_tax_rates_tax_rate(tax_rate: tax_rate, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_tax_rates_tax_rate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TaxRate.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a tax rate with the given ID&lt;/p&gt;
    # @param tax_rate [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_tax_rates_tax_rate(*, tax_rate : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_tax_rates_tax_rate(tax_rate: tax_rate, expand: expand).execute(&block)
    end

    GET_TAX_RATES_TAX_RATE_MAX_LENGTH_FOR_TAX_RATE = 5000

    # @return Crest::Request
    def build_api_request_for_get_tax_rates_tax_rate(*, tax_rate : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_tax_rates_tax_rate ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"tax_rate\" is required and cannot be null") if tax_rate.nil?
        if _tax_rate = tax_rate
          OpenApi::PrimitiveValidator.validate_max_length("tax_rate", tax_rate.to_s.size, GET_TAX_RATES_TAX_RATE_MAX_LENGTH_FOR_TAX_RATE)
        end
      end

      # resource path
      local_var_path = "/v1/tax_rates/{tax_rate}".sub("{" + "tax_rate" + "}", URI.encode_path(tax_rate.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_tax_rates_tax_rate",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of <code>Configuration</code> objects.</p>
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param is_account_default [Bool?] if present, only return the account default or non-default configurations.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [TerminalConfigurationConfigurationList]
    def get_terminal_configurations(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, is_account_default : Bool? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_terminal_configurations_with_http_info(ending_before: ending_before, expand: expand, is_account_default: is_account_default, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of &lt;code&gt;Configuration&lt;/code&gt; objects.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param is_account_default [Bool?] if present, only return the account default or non-default configurations.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(TerminalConfigurationConfigurationList, Integer, Hash)>] TerminalConfigurationConfigurationList data, response status code and response headers
    def get_terminal_configurations_with_http_info(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, is_account_default : Bool? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_terminal_configurations(ending_before: ending_before, expand: expand, is_account_default: is_account_default, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_terminal_configurations\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TerminalConfigurationConfigurationList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of &lt;code&gt;Configuration&lt;/code&gt; objects.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param is_account_default [Bool?] if present, only return the account default or non-default configurations.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_terminal_configurations(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, is_account_default : Bool? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_terminal_configurations(ending_before: ending_before, expand: expand, is_account_default: is_account_default, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_TERMINAL_CONFIGURATIONS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_TERMINAL_CONFIGURATIONS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_terminal_configurations(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, is_account_default : Bool? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_terminal_configurations ..." }
      end

      if client_side_validation
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_TERMINAL_CONFIGURATIONS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_TERMINAL_CONFIGURATIONS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/terminal/configurations"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["is_account_default"] = is_account_default.to_s if !is_account_default.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_terminal_configurations",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a <code>Configuration</code> object.</p>
    # @param configuration [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [GetTerminalConfigurationsConfiguration200Response]
    def get_terminal_configurations_configuration(*, configuration : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_terminal_configurations_configuration_with_http_info(configuration: configuration, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves a &lt;code&gt;Configuration&lt;/code&gt; object.&lt;/p&gt;
    # @param configuration [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(GetTerminalConfigurationsConfiguration200Response, Integer, Hash)>] GetTerminalConfigurationsConfiguration200Response data, response status code and response headers
    def get_terminal_configurations_configuration_with_http_info(*, configuration : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_terminal_configurations_configuration(configuration: configuration, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_terminal_configurations_configuration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return GetTerminalConfigurationsConfiguration200Response.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a &lt;code&gt;Configuration&lt;/code&gt; object.&lt;/p&gt;
    # @param configuration [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_terminal_configurations_configuration(*, configuration : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_terminal_configurations_configuration(configuration: configuration, expand: expand).execute(&block)
    end

    GET_TERMINAL_CONFIGURATIONS_CONFIGURATION_MAX_LENGTH_FOR_CONFIGURATION = 5000

    # @return Crest::Request
    def build_api_request_for_get_terminal_configurations_configuration(*, configuration : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_terminal_configurations_configuration ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"configuration\" is required and cannot be null") if configuration.nil?
        if _configuration = configuration
          OpenApi::PrimitiveValidator.validate_max_length("configuration", configuration.to_s.size, GET_TERMINAL_CONFIGURATIONS_CONFIGURATION_MAX_LENGTH_FOR_CONFIGURATION)
        end
      end

      # resource path
      local_var_path = "/v1/terminal/configurations/{configuration}".sub("{" + "configuration" + "}", URI.encode_path(configuration.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_terminal_configurations_configuration",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of <code>Location</code> objects.</p>
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [TerminalLocationLocationList]
    def get_terminal_locations(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_terminal_locations_with_http_info(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of &lt;code&gt;Location&lt;/code&gt; objects.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(TerminalLocationLocationList, Integer, Hash)>] TerminalLocationLocationList data, response status code and response headers
    def get_terminal_locations_with_http_info(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_terminal_locations(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_terminal_locations\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TerminalLocationLocationList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of &lt;code&gt;Location&lt;/code&gt; objects.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_terminal_locations(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_terminal_locations(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_TERMINAL_LOCATIONS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_TERMINAL_LOCATIONS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_terminal_locations(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_terminal_locations ..." }
      end

      if client_side_validation
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_TERMINAL_LOCATIONS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_TERMINAL_LOCATIONS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/terminal/locations"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_terminal_locations",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a <code>Location</code> object.</p>
    # @param location [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [GetTerminalLocationsLocation200Response]
    def get_terminal_locations_location(*, location : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_terminal_locations_location_with_http_info(location: location, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves a &lt;code&gt;Location&lt;/code&gt; object.&lt;/p&gt;
    # @param location [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(GetTerminalLocationsLocation200Response, Integer, Hash)>] GetTerminalLocationsLocation200Response data, response status code and response headers
    def get_terminal_locations_location_with_http_info(*, location : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_terminal_locations_location(location: location, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_terminal_locations_location\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return GetTerminalLocationsLocation200Response.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a &lt;code&gt;Location&lt;/code&gt; object.&lt;/p&gt;
    # @param location [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_terminal_locations_location(*, location : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_terminal_locations_location(location: location, expand: expand).execute(&block)
    end

    GET_TERMINAL_LOCATIONS_LOCATION_MAX_LENGTH_FOR_LOCATION = 5000

    # @return Crest::Request
    def build_api_request_for_get_terminal_locations_location(*, location : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_terminal_locations_location ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"location\" is required and cannot be null") if location.nil?
        if _location = location
          OpenApi::PrimitiveValidator.validate_max_length("location", location.to_s.size, GET_TERMINAL_LOCATIONS_LOCATION_MAX_LENGTH_FOR_LOCATION)
        end
      end

      # resource path
      local_var_path = "/v1/terminal/locations/{location}".sub("{" + "location" + "}", URI.encode_path(location.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_terminal_locations_location",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of <code>Reader</code> objects.</p>
    # @optional @param device_type [String?] Filters readers by device type
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param location [String?] A location ID to filter the response list to only readers at the specific location
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] A status filter to filter readers to only offline or online readers
    # @return [TerminalReaderRetrieveReader]
    def get_terminal_readers(*, device_type : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, location : String? = nil, starting_after : String? = nil, status : String? = nil)
      data, _status_code, _headers = get_terminal_readers_with_http_info(device_type: device_type, ending_before: ending_before, expand: expand, limit: limit, location: location, starting_after: starting_after, status: status)
      data
    end

    # &lt;p&gt;Returns a list of &lt;code&gt;Reader&lt;/code&gt; objects.&lt;/p&gt;
    # @optional @param device_type [String?] Filters readers by device type
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param location [String?] A location ID to filter the response list to only readers at the specific location
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] A status filter to filter readers to only offline or online readers
    # @return [Array<(TerminalReaderRetrieveReader, Integer, Hash)>] TerminalReaderRetrieveReader data, response status code and response headers
    def get_terminal_readers_with_http_info(*, device_type : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, location : String? = nil, starting_after : String? = nil, status : String? = nil)
      request = build_api_request_for_get_terminal_readers(device_type: device_type, ending_before: ending_before, expand: expand, limit: limit, location: location, starting_after: starting_after, status: status)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_terminal_readers\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TerminalReaderRetrieveReader.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of &lt;code&gt;Reader&lt;/code&gt; objects.&lt;/p&gt;
    # @optional @param device_type [String?] Filters readers by device type
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param location [String?] A location ID to filter the response list to only readers at the specific location
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] A status filter to filter readers to only offline or online readers
    # @return nil
    def get_terminal_readers(*, device_type : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, location : String? = nil, starting_after : String? = nil, status : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_terminal_readers(device_type: device_type, ending_before: ending_before, expand: expand, limit: limit, location: location, starting_after: starting_after, status: status).execute(&block)
    end

    GET_TERMINAL_READERS_VALID_VALUES_FOR_DEVICE_TYPE  = StaticArray["bbpos_chipper2x", "bbpos_wisepad3", "bbpos_wisepos_e", "simulated_wisepos_e", "stripe_m2", "verifone_P400"]
    GET_TERMINAL_READERS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_TERMINAL_READERS_MAX_LENGTH_FOR_LOCATION       = 5000
    GET_TERMINAL_READERS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_TERMINAL_READERS_VALID_VALUES_FOR_STATUS       = StaticArray["offline", "online"]

    # @return Crest::Request
    def build_api_request_for_get_terminal_readers(*, device_type : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, location : String? = nil, starting_after : String? = nil, status : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_terminal_readers ..." }
      end

      if client_side_validation
        if _device_type = device_type
          OpenApi::EnumValidator.validate("device_type", _device_type, GET_TERMINAL_READERS_VALID_VALUES_FOR_DEVICE_TYPE)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_TERMINAL_READERS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _location = location
          OpenApi::PrimitiveValidator.validate_max_length("location", location.to_s.size, GET_TERMINAL_READERS_MAX_LENGTH_FOR_LOCATION)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_TERMINAL_READERS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, GET_TERMINAL_READERS_VALID_VALUES_FOR_STATUS)
        end
      end

      # resource path
      local_var_path = "/v1/terminal/readers"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["device_type"] = device_type.to_s if !device_type.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["location"] = location.to_s if !location.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["status"] = status.to_s if !status.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_terminal_readers",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a <code>Reader</code> object.</p>
    # @param reader [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [GetTerminalReadersReader200Response]
    def get_terminal_readers_reader(*, reader : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_terminal_readers_reader_with_http_info(reader: reader, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves a &lt;code&gt;Reader&lt;/code&gt; object.&lt;/p&gt;
    # @param reader [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(GetTerminalReadersReader200Response, Integer, Hash)>] GetTerminalReadersReader200Response data, response status code and response headers
    def get_terminal_readers_reader_with_http_info(*, reader : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_terminal_readers_reader(reader: reader, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_terminal_readers_reader\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return GetTerminalReadersReader200Response.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a &lt;code&gt;Reader&lt;/code&gt; object.&lt;/p&gt;
    # @param reader [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_terminal_readers_reader(*, reader : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_terminal_readers_reader(reader: reader, expand: expand).execute(&block)
    end

    GET_TERMINAL_READERS_READER_MAX_LENGTH_FOR_READER = 5000

    # @return Crest::Request
    def build_api_request_for_get_terminal_readers_reader(*, reader : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_terminal_readers_reader ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"reader\" is required and cannot be null") if reader.nil?
        if _reader = reader
          OpenApi::PrimitiveValidator.validate_max_length("reader", reader.to_s.size, GET_TERMINAL_READERS_READER_MAX_LENGTH_FOR_READER)
        end
      end

      # resource path
      local_var_path = "/v1/terminal/readers/{reader}".sub("{" + "reader" + "}", URI.encode_path(reader.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_terminal_readers_reader",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of your test clocks.</p>
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [BillingClocksResourceBillingClockList]
    def get_test_helpers_test_clocks(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_test_helpers_test_clocks_with_http_info(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of your test clocks.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(BillingClocksResourceBillingClockList, Integer, Hash)>] BillingClocksResourceBillingClockList data, response status code and response headers
    def get_test_helpers_test_clocks_with_http_info(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_test_helpers_test_clocks(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_test_helpers_test_clocks\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return BillingClocksResourceBillingClockList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of your test clocks.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_test_helpers_test_clocks(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_test_helpers_test_clocks(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_TEST_HELPERS_TEST_CLOCKS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_TEST_HELPERS_TEST_CLOCKS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_test_helpers_test_clocks(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_test_helpers_test_clocks ..." }
      end

      if client_side_validation
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_TEST_HELPERS_TEST_CLOCKS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_TEST_HELPERS_TEST_CLOCKS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/test_clocks"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_test_helpers_test_clocks",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a test clock.</p>
    # @param test_clock [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [TestHelpersTestClock]
    def get_test_helpers_test_clocks_test_clock(*, test_clock : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_test_helpers_test_clocks_test_clock_with_http_info(test_clock: test_clock, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves a test clock.&lt;/p&gt;
    # @param test_clock [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(TestHelpersTestClock, Integer, Hash)>] TestHelpersTestClock data, response status code and response headers
    def get_test_helpers_test_clocks_test_clock_with_http_info(*, test_clock : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_test_helpers_test_clocks_test_clock(test_clock: test_clock, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_test_helpers_test_clocks_test_clock\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TestHelpersTestClock.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a test clock.&lt;/p&gt;
    # @param test_clock [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_test_helpers_test_clocks_test_clock(*, test_clock : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_test_helpers_test_clocks_test_clock(test_clock: test_clock, expand: expand).execute(&block)
    end

    GET_TEST_HELPERS_TEST_CLOCKS_TEST_CLOCK_MAX_LENGTH_FOR_TEST_CLOCK = 5000

    # @return Crest::Request
    def build_api_request_for_get_test_helpers_test_clocks_test_clock(*, test_clock : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_test_helpers_test_clocks_test_clock ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"test_clock\" is required and cannot be null") if test_clock.nil?
        if _test_clock = test_clock
          OpenApi::PrimitiveValidator.validate_max_length("test_clock", test_clock.to_s.size, GET_TEST_HELPERS_TEST_CLOCKS_TEST_CLOCK_MAX_LENGTH_FOR_TEST_CLOCK)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/test_clocks/{test_clock}".sub("{" + "test_clock" + "}", URI.encode_path(test_clock.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_test_helpers_test_clocks_test_clock",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the token with the given ID.</p>
    # @param token [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Token]
    def get_tokens_token(*, token : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_tokens_token_with_http_info(token: token, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the token with the given ID.&lt;/p&gt;
    # @param token [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Token, Integer, Hash)>] Token data, response status code and response headers
    def get_tokens_token_with_http_info(*, token : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_tokens_token(token: token, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_tokens_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Token.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the token with the given ID.&lt;/p&gt;
    # @param token [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_tokens_token(*, token : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_tokens_token(token: token, expand: expand).execute(&block)
    end

    GET_TOKENS_TOKEN_MAX_LENGTH_FOR_TOKEN = 5000

    # @return Crest::Request
    def build_api_request_for_get_tokens_token(*, token : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_tokens_token ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"token\" is required and cannot be null") if token.nil?
        if _token = token
          OpenApi::PrimitiveValidator.validate_max_length("token", token.to_s.size, GET_TOKENS_TOKEN_MAX_LENGTH_FOR_TOKEN)
        end
      end

      # resource path
      local_var_path = "/v1/tokens/{token}".sub("{" + "token" + "}", URI.encode_path(token.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_tokens_token",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of top-ups.</p>
    # @optional @param amount [Stripe::GetAccountsCreatedParameter?] A positive integer representing how much to transfer.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return top-ups that have the given status. One of `canceled`, `failed`, `pending` or `succeeded`.
    # @return [TopupList]
    def get_topups(*, amount : Stripe::GetAccountsCreatedParameter? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil)
      data, _status_code, _headers = get_topups_with_http_info(amount: amount, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status)
      data
    end

    # &lt;p&gt;Returns a list of top-ups.&lt;/p&gt;
    # @optional @param amount [Stripe::GetAccountsCreatedParameter?] A positive integer representing how much to transfer.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return top-ups that have the given status. One of `canceled`, `failed`, `pending` or `succeeded`.
    # @return [Array<(TopupList, Integer, Hash)>] TopupList data, response status code and response headers
    def get_topups_with_http_info(*, amount : Stripe::GetAccountsCreatedParameter? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil)
      request = build_api_request_for_get_topups(amount: amount, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_topups\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TopupList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of top-ups.&lt;/p&gt;
    # @optional @param amount [Stripe::GetAccountsCreatedParameter?] A positive integer representing how much to transfer.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?] A filter on the list, based on the object `created` field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return top-ups that have the given status. One of `canceled`, `failed`, `pending` or `succeeded`.
    # @return nil
    def get_topups(*, amount : Stripe::GetAccountsCreatedParameter? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_topups(amount: amount, created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status).execute(&block)
    end

    GET_TOPUPS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_TOPUPS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_TOPUPS_MAX_LENGTH_FOR_STATUS         = 5000
    GET_TOPUPS_VALID_VALUES_FOR_STATUS       = StaticArray["canceled", "failed", "pending", "succeeded"]

    # @return Crest::Request
    def build_api_request_for_get_topups(*, amount : Stripe::GetAccountsCreatedParameter? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_topups ..." }
      end

      if client_side_validation
        if _amount = amount
          _amount.validate if _amount.is_a?(OpenApi::Validatable)
        end
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_TOPUPS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_TOPUPS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, GET_TOPUPS_VALID_VALUES_FOR_STATUS)
        end
      end

      # resource path
      local_var_path = "/v1/topups"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["amount"] = amount.to_s if !amount.nil?
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["status"] = status.to_s if !status.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_topups",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of a top-up that has previously been created. Supply the unique top-up ID that was returned from your previous request, and Stripe will return the corresponding top-up information.</p>
    # @param topup [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Topup]
    def get_topups_topup(*, topup : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_topups_topup_with_http_info(topup: topup, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of a top-up that has previously been created. Supply the unique top-up ID that was returned from your previous request, and Stripe will return the corresponding top-up information.&lt;/p&gt;
    # @param topup [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Topup, Integer, Hash)>] Topup data, response status code and response headers
    def get_topups_topup_with_http_info(*, topup : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_topups_topup(topup: topup, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_topups_topup\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Topup.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of a top-up that has previously been created. Supply the unique top-up ID that was returned from your previous request, and Stripe will return the corresponding top-up information.&lt;/p&gt;
    # @param topup [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_topups_topup(*, topup : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_topups_topup(topup: topup, expand: expand).execute(&block)
    end

    GET_TOPUPS_TOPUP_MAX_LENGTH_FOR_TOPUP = 5000

    # @return Crest::Request
    def build_api_request_for_get_topups_topup(*, topup : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_topups_topup ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"topup\" is required and cannot be null") if topup.nil?
        if _topup = topup
          OpenApi::PrimitiveValidator.validate_max_length("topup", topup.to_s.size, GET_TOPUPS_TOPUP_MAX_LENGTH_FOR_TOPUP)
        end
      end

      # resource path
      local_var_path = "/v1/topups/{topup}".sub("{" + "topup" + "}", URI.encode_path(topup.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_topups_topup",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of existing transfers sent to connected accounts. The transfers are returned in sorted order, with the most recently created transfers appearing first.</p>
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param destination [String?] Only return transfers for the destination specified by this account ID.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param transfer_group [String?] Only return transfers with the specified transfer group.
    # @return [TransferList]
    def get_transfers(*, created : Stripe::GetAccountsCreatedParameter? = nil, destination : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, transfer_group : String? = nil)
      data, _status_code, _headers = get_transfers_with_http_info(created: created, destination: destination, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, transfer_group: transfer_group)
      data
    end

    # &lt;p&gt;Returns a list of existing transfers sent to connected accounts. The transfers are returned in sorted order, with the most recently created transfers appearing first.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param destination [String?] Only return transfers for the destination specified by this account ID.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param transfer_group [String?] Only return transfers with the specified transfer group.
    # @return [Array<(TransferList, Integer, Hash)>] TransferList data, response status code and response headers
    def get_transfers_with_http_info(*, created : Stripe::GetAccountsCreatedParameter? = nil, destination : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, transfer_group : String? = nil)
      request = build_api_request_for_get_transfers(created: created, destination: destination, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, transfer_group: transfer_group)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_transfers\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TransferList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of existing transfers sent to connected accounts. The transfers are returned in sorted order, with the most recently created transfers appearing first.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param destination [String?] Only return transfers for the destination specified by this account ID.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param transfer_group [String?] Only return transfers with the specified transfer group.
    # @return nil
    def get_transfers(*, created : Stripe::GetAccountsCreatedParameter? = nil, destination : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, transfer_group : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_transfers(created: created, destination: destination, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, transfer_group: transfer_group).execute(&block)
    end

    GET_TRANSFERS_MAX_LENGTH_FOR_DESTINATION    = 5000
    GET_TRANSFERS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_TRANSFERS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_TRANSFERS_MAX_LENGTH_FOR_TRANSFER_GROUP = 5000

    # @return Crest::Request
    def build_api_request_for_get_transfers(*, created : Stripe::GetAccountsCreatedParameter? = nil, destination : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, transfer_group : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_transfers ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _destination = destination
          OpenApi::PrimitiveValidator.validate_max_length("destination", destination.to_s.size, GET_TRANSFERS_MAX_LENGTH_FOR_DESTINATION)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_TRANSFERS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_TRANSFERS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _transfer_group = transfer_group
          OpenApi::PrimitiveValidator.validate_max_length("transfer_group", transfer_group.to_s.size, GET_TRANSFERS_MAX_LENGTH_FOR_TRANSFER_GROUP)
        end
      end

      # resource path
      local_var_path = "/v1/transfers"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["destination"] = destination.to_s if !destination.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["transfer_group"] = transfer_group.to_s if !transfer_group.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_transfers",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>You can see a list of the reversals belonging to a specific transfer. Note that the 10 most recent reversals are always available by default on the transfer object. If you need more than those 10, you can use this API method and the <code>limit</code> and <code>starting_after</code> parameters to page through additional reversals.</p>
    # @param id [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [TransferReversalList]
    def get_transfers_id_reversals(*, id : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_transfers_id_reversals_with_http_info(id: id, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;You can see a list of the reversals belonging to a specific transfer. Note that the 10 most recent reversals are always available by default on the transfer object. If you need more than those 10, you can use this API method and the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;starting_after&lt;/code&gt; parameters to page through additional reversals.&lt;/p&gt;
    # @param id [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(TransferReversalList, Integer, Hash)>] TransferReversalList data, response status code and response headers
    def get_transfers_id_reversals_with_http_info(*, id : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_transfers_id_reversals(id: id, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_transfers_id_reversals\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TransferReversalList.from_json(data), status_code, headers
    end

    # &lt;p&gt;You can see a list of the reversals belonging to a specific transfer. Note that the 10 most recent reversals are always available by default on the transfer object. If you need more than those 10, you can use this API method and the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;starting_after&lt;/code&gt; parameters to page through additional reversals.&lt;/p&gt;
    # @param id [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_transfers_id_reversals(*, id : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_transfers_id_reversals(id: id, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_TRANSFERS_ID_REVERSALS_MAX_LENGTH_FOR_ID             = 5000
    GET_TRANSFERS_ID_REVERSALS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_TRANSFERS_ID_REVERSALS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_transfers_id_reversals(*, id : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_transfers_id_reversals ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_TRANSFERS_ID_REVERSALS_MAX_LENGTH_FOR_ID)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_TRANSFERS_ID_REVERSALS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_TRANSFERS_ID_REVERSALS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/transfers/{id}/reversals".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_transfers_id_reversals",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an existing transfer. Supply the unique transfer ID from either a transfer creation request or the transfer list, and Stripe will return the corresponding transfer information.</p>
    # @param transfer [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Transfer]
    def get_transfers_transfer(*, transfer : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_transfers_transfer_with_http_info(transfer: transfer, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an existing transfer. Supply the unique transfer ID from either a transfer creation request or the transfer list, and Stripe will return the corresponding transfer information.&lt;/p&gt;
    # @param transfer [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(Transfer, Integer, Hash)>] Transfer data, response status code and response headers
    def get_transfers_transfer_with_http_info(*, transfer : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_transfers_transfer(transfer: transfer, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_transfers_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Transfer.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an existing transfer. Supply the unique transfer ID from either a transfer creation request or the transfer list, and Stripe will return the corresponding transfer information.&lt;/p&gt;
    # @param transfer [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_transfers_transfer(*, transfer : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_transfers_transfer(transfer: transfer, expand: expand).execute(&block)
    end

    GET_TRANSFERS_TRANSFER_MAX_LENGTH_FOR_TRANSFER = 5000

    # @return Crest::Request
    def build_api_request_for_get_transfers_transfer(*, transfer : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_transfers_transfer ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"transfer\" is required and cannot be null") if transfer.nil?
        if _transfer = transfer
          OpenApi::PrimitiveValidator.validate_max_length("transfer", transfer.to_s.size, GET_TRANSFERS_TRANSFER_MAX_LENGTH_FOR_TRANSFER)
        end
      end

      # resource path
      local_var_path = "/v1/transfers/{transfer}".sub("{" + "transfer" + "}", URI.encode_path(transfer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_transfers_transfer",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>By default, you can see the 10 most recent reversals stored directly on the transfer object, but you can also retrieve details about a specific reversal stored on the transfer.</p>
    # @param id [String?]
    # @param transfer [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [TransferReversal]
    def get_transfers_transfer_reversals_id(*, id : String? = nil, transfer : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_transfers_transfer_reversals_id_with_http_info(id: id, transfer: transfer, expand: expand)
      data
    end

    # &lt;p&gt;By default, you can see the 10 most recent reversals stored directly on the transfer object, but you can also retrieve details about a specific reversal stored on the transfer.&lt;/p&gt;
    # @param id [String?]
    # @param transfer [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(TransferReversal, Integer, Hash)>] TransferReversal data, response status code and response headers
    def get_transfers_transfer_reversals_id_with_http_info(*, id : String? = nil, transfer : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_transfers_transfer_reversals_id(id: id, transfer: transfer, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_transfers_transfer_reversals_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TransferReversal.from_json(data), status_code, headers
    end

    # &lt;p&gt;By default, you can see the 10 most recent reversals stored directly on the transfer object, but you can also retrieve details about a specific reversal stored on the transfer.&lt;/p&gt;
    # @param id [String?]
    # @param transfer [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_transfers_transfer_reversals_id(*, id : String? = nil, transfer : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_transfers_transfer_reversals_id(id: id, transfer: transfer, expand: expand).execute(&block)
    end

    GET_TRANSFERS_TRANSFER_REVERSALS_ID_MAX_LENGTH_FOR_ID       = 5000
    GET_TRANSFERS_TRANSFER_REVERSALS_ID_MAX_LENGTH_FOR_TRANSFER = 5000

    # @return Crest::Request
    def build_api_request_for_get_transfers_transfer_reversals_id(*, id : String? = nil, transfer : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_transfers_transfer_reversals_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_TRANSFERS_TRANSFER_REVERSALS_ID_MAX_LENGTH_FOR_ID)
        end
        raise ArgumentError.new("\"transfer\" is required and cannot be null") if transfer.nil?
        if _transfer = transfer
          OpenApi::PrimitiveValidator.validate_max_length("transfer", transfer.to_s.size, GET_TRANSFERS_TRANSFER_REVERSALS_ID_MAX_LENGTH_FOR_TRANSFER)
        end
      end

      # resource path
      local_var_path = "/v1/transfers/{transfer}/reversals/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s)).sub("{" + "transfer" + "}", URI.encode_path(transfer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_transfers_transfer_reversals_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of CreditReversals.</p>
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param received_credit [String?] Only return CreditReversals for the ReceivedCredit ID.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return CreditReversals for a given status.
    # @return [TreasuryReceivedCreditsResourceCreditReversalList]
    def get_treasury_credit_reversals(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, received_credit : String? = nil, starting_after : String? = nil, status : String? = nil)
      data, _status_code, _headers = get_treasury_credit_reversals_with_http_info(financial_account: financial_account, ending_before: ending_before, expand: expand, limit: limit, received_credit: received_credit, starting_after: starting_after, status: status)
      data
    end

    # &lt;p&gt;Returns a list of CreditReversals.&lt;/p&gt;
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param received_credit [String?] Only return CreditReversals for the ReceivedCredit ID.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return CreditReversals for a given status.
    # @return [Array<(TreasuryReceivedCreditsResourceCreditReversalList, Integer, Hash)>] TreasuryReceivedCreditsResourceCreditReversalList data, response status code and response headers
    def get_treasury_credit_reversals_with_http_info(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, received_credit : String? = nil, starting_after : String? = nil, status : String? = nil)
      request = build_api_request_for_get_treasury_credit_reversals(financial_account: financial_account, ending_before: ending_before, expand: expand, limit: limit, received_credit: received_credit, starting_after: starting_after, status: status)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_credit_reversals\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryReceivedCreditsResourceCreditReversalList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of CreditReversals.&lt;/p&gt;
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param received_credit [String?] Only return CreditReversals for the ReceivedCredit ID.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return CreditReversals for a given status.
    # @return nil
    def get_treasury_credit_reversals(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, received_credit : String? = nil, starting_after : String? = nil, status : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_credit_reversals(financial_account: financial_account, ending_before: ending_before, expand: expand, limit: limit, received_credit: received_credit, starting_after: starting_after, status: status).execute(&block)
    end

    GET_TREASURY_CREDIT_REVERSALS_MAX_LENGTH_FOR_ENDING_BEFORE   = 5000
    GET_TREASURY_CREDIT_REVERSALS_MAX_LENGTH_FOR_RECEIVED_CREDIT = 5000
    GET_TREASURY_CREDIT_REVERSALS_MAX_LENGTH_FOR_STARTING_AFTER  = 5000
    GET_TREASURY_CREDIT_REVERSALS_VALID_VALUES_FOR_STATUS        = StaticArray["canceled", "posted", "processing"]

    # @return Crest::Request
    def build_api_request_for_get_treasury_credit_reversals(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, received_credit : String? = nil, starting_after : String? = nil, status : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_credit_reversals ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"financial_account\" is required and cannot be null") if financial_account.nil?

        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_TREASURY_CREDIT_REVERSALS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _received_credit = received_credit
          OpenApi::PrimitiveValidator.validate_max_length("received_credit", received_credit.to_s.size, GET_TREASURY_CREDIT_REVERSALS_MAX_LENGTH_FOR_RECEIVED_CREDIT)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_TREASURY_CREDIT_REVERSALS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, GET_TREASURY_CREDIT_REVERSALS_VALID_VALUES_FOR_STATUS)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/credit_reversals"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["financial_account"] = financial_account.to_s if !financial_account.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["received_credit"] = received_credit.to_s if !received_credit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["status"] = status.to_s if !status.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_credit_reversals",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an existing CreditReversal by passing the unique CreditReversal ID from either the CreditReversal creation request or CreditReversal list</p>
    # @param credit_reversal [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [TreasuryCreditReversal]
    def get_treasury_credit_reversals_credit_reversal(*, credit_reversal : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_treasury_credit_reversals_credit_reversal_with_http_info(credit_reversal: credit_reversal, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an existing CreditReversal by passing the unique CreditReversal ID from either the CreditReversal creation request or CreditReversal list&lt;/p&gt;
    # @param credit_reversal [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryCreditReversal, Integer, Hash)>] TreasuryCreditReversal data, response status code and response headers
    def get_treasury_credit_reversals_credit_reversal_with_http_info(*, credit_reversal : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_treasury_credit_reversals_credit_reversal(credit_reversal: credit_reversal, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_credit_reversals_credit_reversal\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryCreditReversal.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an existing CreditReversal by passing the unique CreditReversal ID from either the CreditReversal creation request or CreditReversal list&lt;/p&gt;
    # @param credit_reversal [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_treasury_credit_reversals_credit_reversal(*, credit_reversal : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_credit_reversals_credit_reversal(credit_reversal: credit_reversal, expand: expand).execute(&block)
    end

    GET_TREASURY_CREDIT_REVERSALS_CREDIT_REVERSAL_MAX_LENGTH_FOR_CREDIT_REVERSAL = 5000

    # @return Crest::Request
    def build_api_request_for_get_treasury_credit_reversals_credit_reversal(*, credit_reversal : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_credit_reversals_credit_reversal ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"credit_reversal\" is required and cannot be null") if credit_reversal.nil?
        if _credit_reversal = credit_reversal
          OpenApi::PrimitiveValidator.validate_max_length("credit_reversal", credit_reversal.to_s.size, GET_TREASURY_CREDIT_REVERSALS_CREDIT_REVERSAL_MAX_LENGTH_FOR_CREDIT_REVERSAL)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/credit_reversals/{credit_reversal}".sub("{" + "credit_reversal" + "}", URI.encode_path(credit_reversal.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_credit_reversals_credit_reversal",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of DebitReversals.</p>
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param received_debit [String?] Only return DebitReversals for the ReceivedDebit ID.
    # @optional @param resolution [String?] Only return DebitReversals for a given resolution.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return DebitReversals for a given status.
    # @return [TreasuryReceivedDebitsResourceDebitReversalList]
    def get_treasury_debit_reversals(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, received_debit : String? = nil, resolution : String? = nil, starting_after : String? = nil, status : String? = nil)
      data, _status_code, _headers = get_treasury_debit_reversals_with_http_info(financial_account: financial_account, ending_before: ending_before, expand: expand, limit: limit, received_debit: received_debit, resolution: resolution, starting_after: starting_after, status: status)
      data
    end

    # &lt;p&gt;Returns a list of DebitReversals.&lt;/p&gt;
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param received_debit [String?] Only return DebitReversals for the ReceivedDebit ID.
    # @optional @param resolution [String?] Only return DebitReversals for a given resolution.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return DebitReversals for a given status.
    # @return [Array<(TreasuryReceivedDebitsResourceDebitReversalList, Integer, Hash)>] TreasuryReceivedDebitsResourceDebitReversalList data, response status code and response headers
    def get_treasury_debit_reversals_with_http_info(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, received_debit : String? = nil, resolution : String? = nil, starting_after : String? = nil, status : String? = nil)
      request = build_api_request_for_get_treasury_debit_reversals(financial_account: financial_account, ending_before: ending_before, expand: expand, limit: limit, received_debit: received_debit, resolution: resolution, starting_after: starting_after, status: status)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_debit_reversals\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryReceivedDebitsResourceDebitReversalList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of DebitReversals.&lt;/p&gt;
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param received_debit [String?] Only return DebitReversals for the ReceivedDebit ID.
    # @optional @param resolution [String?] Only return DebitReversals for a given resolution.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return DebitReversals for a given status.
    # @return nil
    def get_treasury_debit_reversals(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, received_debit : String? = nil, resolution : String? = nil, starting_after : String? = nil, status : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_debit_reversals(financial_account: financial_account, ending_before: ending_before, expand: expand, limit: limit, received_debit: received_debit, resolution: resolution, starting_after: starting_after, status: status).execute(&block)
    end

    GET_TREASURY_DEBIT_REVERSALS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_TREASURY_DEBIT_REVERSALS_MAX_LENGTH_FOR_RECEIVED_DEBIT = 5000
    GET_TREASURY_DEBIT_REVERSALS_VALID_VALUES_FOR_RESOLUTION   = StaticArray["lost", "won"]
    GET_TREASURY_DEBIT_REVERSALS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_TREASURY_DEBIT_REVERSALS_VALID_VALUES_FOR_STATUS       = StaticArray["canceled", "completed", "processing"]

    # @return Crest::Request
    def build_api_request_for_get_treasury_debit_reversals(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, received_debit : String? = nil, resolution : String? = nil, starting_after : String? = nil, status : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_debit_reversals ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"financial_account\" is required and cannot be null") if financial_account.nil?

        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_TREASURY_DEBIT_REVERSALS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _received_debit = received_debit
          OpenApi::PrimitiveValidator.validate_max_length("received_debit", received_debit.to_s.size, GET_TREASURY_DEBIT_REVERSALS_MAX_LENGTH_FOR_RECEIVED_DEBIT)
        end
        if _resolution = resolution
          OpenApi::EnumValidator.validate("resolution", _resolution, GET_TREASURY_DEBIT_REVERSALS_VALID_VALUES_FOR_RESOLUTION)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_TREASURY_DEBIT_REVERSALS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, GET_TREASURY_DEBIT_REVERSALS_VALID_VALUES_FOR_STATUS)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/debit_reversals"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["financial_account"] = financial_account.to_s if !financial_account.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["received_debit"] = received_debit.to_s if !received_debit.nil?
      query_params["resolution"] = resolution.to_s if !resolution.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["status"] = status.to_s if !status.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_debit_reversals",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a DebitReversal object.</p>
    # @param debit_reversal [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [TreasuryDebitReversal]
    def get_treasury_debit_reversals_debit_reversal(*, debit_reversal : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_treasury_debit_reversals_debit_reversal_with_http_info(debit_reversal: debit_reversal, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves a DebitReversal object.&lt;/p&gt;
    # @param debit_reversal [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryDebitReversal, Integer, Hash)>] TreasuryDebitReversal data, response status code and response headers
    def get_treasury_debit_reversals_debit_reversal_with_http_info(*, debit_reversal : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_treasury_debit_reversals_debit_reversal(debit_reversal: debit_reversal, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_debit_reversals_debit_reversal\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryDebitReversal.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a DebitReversal object.&lt;/p&gt;
    # @param debit_reversal [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_treasury_debit_reversals_debit_reversal(*, debit_reversal : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_debit_reversals_debit_reversal(debit_reversal: debit_reversal, expand: expand).execute(&block)
    end

    GET_TREASURY_DEBIT_REVERSALS_DEBIT_REVERSAL_MAX_LENGTH_FOR_DEBIT_REVERSAL = 5000

    # @return Crest::Request
    def build_api_request_for_get_treasury_debit_reversals_debit_reversal(*, debit_reversal : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_debit_reversals_debit_reversal ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"debit_reversal\" is required and cannot be null") if debit_reversal.nil?
        if _debit_reversal = debit_reversal
          OpenApi::PrimitiveValidator.validate_max_length("debit_reversal", debit_reversal.to_s.size, GET_TREASURY_DEBIT_REVERSALS_DEBIT_REVERSAL_MAX_LENGTH_FOR_DEBIT_REVERSAL)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/debit_reversals/{debit_reversal}".sub("{" + "debit_reversal" + "}", URI.encode_path(debit_reversal.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_debit_reversals_debit_reversal",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of FinancialAccounts.</p>
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] An object ID cursor for use in pagination.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit ranging from 1 to 100 (defaults to 10).
    # @optional @param starting_after [String?] An object ID cursor for use in pagination.
    # @return [TreasuryFinancialAccountsResourceFinancialAccountList]
    def get_treasury_financial_accounts(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_treasury_financial_accounts_with_http_info(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of FinancialAccounts.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] An object ID cursor for use in pagination.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit ranging from 1 to 100 (defaults to 10).
    # @optional @param starting_after [String?] An object ID cursor for use in pagination.
    # @return [Array<(TreasuryFinancialAccountsResourceFinancialAccountList, Integer, Hash)>] TreasuryFinancialAccountsResourceFinancialAccountList data, response status code and response headers
    def get_treasury_financial_accounts_with_http_info(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_treasury_financial_accounts(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_financial_accounts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryFinancialAccountsResourceFinancialAccountList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of FinancialAccounts.&lt;/p&gt;
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] An object ID cursor for use in pagination.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit ranging from 1 to 100 (defaults to 10).
    # @optional @param starting_after [String?] An object ID cursor for use in pagination.
    # @return nil
    def get_treasury_financial_accounts(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_financial_accounts(created: created, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_TREASURY_FINANCIAL_ACCOUNTS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_TREASURY_FINANCIAL_ACCOUNTS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_treasury_financial_accounts(*, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_financial_accounts ..." }
      end

      if client_side_validation
        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_TREASURY_FINANCIAL_ACCOUNTS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_TREASURY_FINANCIAL_ACCOUNTS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/financial_accounts"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_financial_accounts",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of a FinancialAccount.</p>
    # @param financial_account [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [TreasuryFinancialAccount]
    def get_treasury_financial_accounts_financial_account(*, financial_account : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_treasury_financial_accounts_financial_account_with_http_info(financial_account: financial_account, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of a FinancialAccount.&lt;/p&gt;
    # @param financial_account [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryFinancialAccount, Integer, Hash)>] TreasuryFinancialAccount data, response status code and response headers
    def get_treasury_financial_accounts_financial_account_with_http_info(*, financial_account : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_treasury_financial_accounts_financial_account(financial_account: financial_account, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_financial_accounts_financial_account\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryFinancialAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of a FinancialAccount.&lt;/p&gt;
    # @param financial_account [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_treasury_financial_accounts_financial_account(*, financial_account : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_financial_accounts_financial_account(financial_account: financial_account, expand: expand).execute(&block)
    end

    GET_TREASURY_FINANCIAL_ACCOUNTS_FINANCIAL_ACCOUNT_MAX_LENGTH_FOR_FINANCIAL_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_get_treasury_financial_accounts_financial_account(*, financial_account : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_financial_accounts_financial_account ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"financial_account\" is required and cannot be null") if financial_account.nil?
        if _financial_account = financial_account
          OpenApi::PrimitiveValidator.validate_max_length("financial_account", financial_account.to_s.size, GET_TREASURY_FINANCIAL_ACCOUNTS_FINANCIAL_ACCOUNT_MAX_LENGTH_FOR_FINANCIAL_ACCOUNT)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/financial_accounts/{financial_account}".sub("{" + "financial_account" + "}", URI.encode_path(financial_account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_financial_accounts_financial_account",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves Features information associated with the FinancialAccount.</p>
    # @param financial_account [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [TreasuryFinancialAccountFeatures]
    def get_treasury_financial_accounts_financial_account_features(*, financial_account : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_treasury_financial_accounts_financial_account_features_with_http_info(financial_account: financial_account, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves Features information associated with the FinancialAccount.&lt;/p&gt;
    # @param financial_account [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryFinancialAccountFeatures, Integer, Hash)>] TreasuryFinancialAccountFeatures data, response status code and response headers
    def get_treasury_financial_accounts_financial_account_features_with_http_info(*, financial_account : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_treasury_financial_accounts_financial_account_features(financial_account: financial_account, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_financial_accounts_financial_account_features\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryFinancialAccountFeatures.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves Features information associated with the FinancialAccount.&lt;/p&gt;
    # @param financial_account [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_treasury_financial_accounts_financial_account_features(*, financial_account : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_financial_accounts_financial_account_features(financial_account: financial_account, expand: expand).execute(&block)
    end

    GET_TREASURY_FINANCIAL_ACCOUNTS_FINANCIAL_ACCOUNT_FEATURES_MAX_LENGTH_FOR_FINANCIAL_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_get_treasury_financial_accounts_financial_account_features(*, financial_account : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_financial_accounts_financial_account_features ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"financial_account\" is required and cannot be null") if financial_account.nil?
        if _financial_account = financial_account
          OpenApi::PrimitiveValidator.validate_max_length("financial_account", financial_account.to_s.size, GET_TREASURY_FINANCIAL_ACCOUNTS_FINANCIAL_ACCOUNT_FEATURES_MAX_LENGTH_FOR_FINANCIAL_ACCOUNT)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/financial_accounts/{financial_account}/features".sub("{" + "financial_account" + "}", URI.encode_path(financial_account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_financial_accounts_financial_account_features",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of InboundTransfers sent from the specified FinancialAccount.</p>
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return InboundTransfers that have the given status: `processing`, `succeeded`, `failed` or `canceled`.
    # @return [TreasuryInboundTransfersResourceInboundTransferList]
    def get_treasury_inbound_transfers(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil)
      data, _status_code, _headers = get_treasury_inbound_transfers_with_http_info(financial_account: financial_account, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status)
      data
    end

    # &lt;p&gt;Returns a list of InboundTransfers sent from the specified FinancialAccount.&lt;/p&gt;
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return InboundTransfers that have the given status: `processing`, `succeeded`, `failed` or `canceled`.
    # @return [Array<(TreasuryInboundTransfersResourceInboundTransferList, Integer, Hash)>] TreasuryInboundTransfersResourceInboundTransferList data, response status code and response headers
    def get_treasury_inbound_transfers_with_http_info(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil)
      request = build_api_request_for_get_treasury_inbound_transfers(financial_account: financial_account, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_inbound_transfers\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryInboundTransfersResourceInboundTransferList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of InboundTransfers sent from the specified FinancialAccount.&lt;/p&gt;
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return InboundTransfers that have the given status: `processing`, `succeeded`, `failed` or `canceled`.
    # @return nil
    def get_treasury_inbound_transfers(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_inbound_transfers(financial_account: financial_account, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status).execute(&block)
    end

    GET_TREASURY_INBOUND_TRANSFERS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_TREASURY_INBOUND_TRANSFERS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_TREASURY_INBOUND_TRANSFERS_VALID_VALUES_FOR_STATUS       = StaticArray["canceled", "failed", "processing", "succeeded"]

    # @return Crest::Request
    def build_api_request_for_get_treasury_inbound_transfers(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_inbound_transfers ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"financial_account\" is required and cannot be null") if financial_account.nil?

        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_TREASURY_INBOUND_TRANSFERS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_TREASURY_INBOUND_TRANSFERS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, GET_TREASURY_INBOUND_TRANSFERS_VALID_VALUES_FOR_STATUS)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/inbound_transfers"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["financial_account"] = financial_account.to_s if !financial_account.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["status"] = status.to_s if !status.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_inbound_transfers",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an existing InboundTransfer.</p>
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [TreasuryInboundTransfer]
    def get_treasury_inbound_transfers_id(*, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_treasury_inbound_transfers_id_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an existing InboundTransfer.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryInboundTransfer, Integer, Hash)>] TreasuryInboundTransfer data, response status code and response headers
    def get_treasury_inbound_transfers_id_with_http_info(*, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_treasury_inbound_transfers_id(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_inbound_transfers_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryInboundTransfer.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an existing InboundTransfer.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_treasury_inbound_transfers_id(*, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_inbound_transfers_id(id: id, expand: expand).execute(&block)
    end

    GET_TREASURY_INBOUND_TRANSFERS_ID_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_get_treasury_inbound_transfers_id(*, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_inbound_transfers_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_TREASURY_INBOUND_TRANSFERS_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/inbound_transfers/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_inbound_transfers_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of OutboundPayments sent from the specified FinancialAccount.</p>
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param customer [String?] Only return OutboundPayments sent to this customer.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return OutboundPayments that have the given status: `processing`, `failed`, `posted`, `returned`, or `canceled`.
    # @return [TreasuryOutboundPaymentsResourceOutboundPaymentList]
    def get_treasury_outbound_payments(*, financial_account : String? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil)
      data, _status_code, _headers = get_treasury_outbound_payments_with_http_info(financial_account: financial_account, customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status)
      data
    end

    # &lt;p&gt;Returns a list of OutboundPayments sent from the specified FinancialAccount.&lt;/p&gt;
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param customer [String?] Only return OutboundPayments sent to this customer.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return OutboundPayments that have the given status: `processing`, `failed`, `posted`, `returned`, or `canceled`.
    # @return [Array<(TreasuryOutboundPaymentsResourceOutboundPaymentList, Integer, Hash)>] TreasuryOutboundPaymentsResourceOutboundPaymentList data, response status code and response headers
    def get_treasury_outbound_payments_with_http_info(*, financial_account : String? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil)
      request = build_api_request_for_get_treasury_outbound_payments(financial_account: financial_account, customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_outbound_payments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryOutboundPaymentsResourceOutboundPaymentList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of OutboundPayments sent from the specified FinancialAccount.&lt;/p&gt;
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param customer [String?] Only return OutboundPayments sent to this customer.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return OutboundPayments that have the given status: `processing`, `failed`, `posted`, `returned`, or `canceled`.
    # @return nil
    def get_treasury_outbound_payments(*, financial_account : String? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_outbound_payments(financial_account: financial_account, customer: customer, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status).execute(&block)
    end

    GET_TREASURY_OUTBOUND_PAYMENTS_MAX_LENGTH_FOR_CUSTOMER       = 5000
    GET_TREASURY_OUTBOUND_PAYMENTS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_TREASURY_OUTBOUND_PAYMENTS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_TREASURY_OUTBOUND_PAYMENTS_VALID_VALUES_FOR_STATUS       = StaticArray["canceled", "failed", "posted", "processing", "returned"]

    # @return Crest::Request
    def build_api_request_for_get_treasury_outbound_payments(*, financial_account : String? = nil, customer : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_outbound_payments ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"financial_account\" is required and cannot be null") if financial_account.nil?

        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_TREASURY_OUTBOUND_PAYMENTS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_TREASURY_OUTBOUND_PAYMENTS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_TREASURY_OUTBOUND_PAYMENTS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, GET_TREASURY_OUTBOUND_PAYMENTS_VALID_VALUES_FOR_STATUS)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/outbound_payments"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["customer"] = customer.to_s if !customer.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["financial_account"] = financial_account.to_s if !financial_account.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["status"] = status.to_s if !status.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_outbound_payments",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an existing OutboundPayment by passing the unique OutboundPayment ID from either the OutboundPayment creation request or OutboundPayment list.</p>
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [TreasuryOutboundPayment]
    def get_treasury_outbound_payments_id(*, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_treasury_outbound_payments_id_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an existing OutboundPayment by passing the unique OutboundPayment ID from either the OutboundPayment creation request or OutboundPayment list.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryOutboundPayment, Integer, Hash)>] TreasuryOutboundPayment data, response status code and response headers
    def get_treasury_outbound_payments_id_with_http_info(*, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_treasury_outbound_payments_id(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_outbound_payments_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryOutboundPayment.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an existing OutboundPayment by passing the unique OutboundPayment ID from either the OutboundPayment creation request or OutboundPayment list.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_treasury_outbound_payments_id(*, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_outbound_payments_id(id: id, expand: expand).execute(&block)
    end

    GET_TREASURY_OUTBOUND_PAYMENTS_ID_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_get_treasury_outbound_payments_id(*, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_outbound_payments_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_TREASURY_OUTBOUND_PAYMENTS_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/outbound_payments/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_outbound_payments_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of OutboundTransfers sent from the specified FinancialAccount.</p>
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return OutboundTransfers that have the given status: `processing`, `canceled`, `failed`, `posted`, or `returned`.
    # @return [TreasuryOutboundTransfersResourceOutboundTransferList]
    def get_treasury_outbound_transfers(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil)
      data, _status_code, _headers = get_treasury_outbound_transfers_with_http_info(financial_account: financial_account, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status)
      data
    end

    # &lt;p&gt;Returns a list of OutboundTransfers sent from the specified FinancialAccount.&lt;/p&gt;
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return OutboundTransfers that have the given status: `processing`, `canceled`, `failed`, `posted`, or `returned`.
    # @return [Array<(TreasuryOutboundTransfersResourceOutboundTransferList, Integer, Hash)>] TreasuryOutboundTransfersResourceOutboundTransferList data, response status code and response headers
    def get_treasury_outbound_transfers_with_http_info(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil)
      request = build_api_request_for_get_treasury_outbound_transfers(financial_account: financial_account, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_outbound_transfers\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryOutboundTransfersResourceOutboundTransferList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of OutboundTransfers sent from the specified FinancialAccount.&lt;/p&gt;
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return OutboundTransfers that have the given status: `processing`, `canceled`, `failed`, `posted`, or `returned`.
    # @return nil
    def get_treasury_outbound_transfers(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_outbound_transfers(financial_account: financial_account, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status).execute(&block)
    end

    GET_TREASURY_OUTBOUND_TRANSFERS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_TREASURY_OUTBOUND_TRANSFERS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_TREASURY_OUTBOUND_TRANSFERS_VALID_VALUES_FOR_STATUS       = StaticArray["canceled", "failed", "posted", "processing", "returned"]

    # @return Crest::Request
    def build_api_request_for_get_treasury_outbound_transfers(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_outbound_transfers ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"financial_account\" is required and cannot be null") if financial_account.nil?

        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_TREASURY_OUTBOUND_TRANSFERS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_TREASURY_OUTBOUND_TRANSFERS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, GET_TREASURY_OUTBOUND_TRANSFERS_VALID_VALUES_FOR_STATUS)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/outbound_transfers"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["financial_account"] = financial_account.to_s if !financial_account.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["status"] = status.to_s if !status.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_outbound_transfers",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an existing OutboundTransfer by passing the unique OutboundTransfer ID from either the OutboundTransfer creation request or OutboundTransfer list.</p>
    # @param outbound_transfer [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [TreasuryOutboundTransfer]
    def get_treasury_outbound_transfers_outbound_transfer(*, outbound_transfer : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_treasury_outbound_transfers_outbound_transfer_with_http_info(outbound_transfer: outbound_transfer, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an existing OutboundTransfer by passing the unique OutboundTransfer ID from either the OutboundTransfer creation request or OutboundTransfer list.&lt;/p&gt;
    # @param outbound_transfer [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryOutboundTransfer, Integer, Hash)>] TreasuryOutboundTransfer data, response status code and response headers
    def get_treasury_outbound_transfers_outbound_transfer_with_http_info(*, outbound_transfer : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_treasury_outbound_transfers_outbound_transfer(outbound_transfer: outbound_transfer, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_outbound_transfers_outbound_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryOutboundTransfer.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an existing OutboundTransfer by passing the unique OutboundTransfer ID from either the OutboundTransfer creation request or OutboundTransfer list.&lt;/p&gt;
    # @param outbound_transfer [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_treasury_outbound_transfers_outbound_transfer(*, outbound_transfer : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_outbound_transfers_outbound_transfer(outbound_transfer: outbound_transfer, expand: expand).execute(&block)
    end

    GET_TREASURY_OUTBOUND_TRANSFERS_OUTBOUND_TRANSFER_MAX_LENGTH_FOR_OUTBOUND_TRANSFER = 5000

    # @return Crest::Request
    def build_api_request_for_get_treasury_outbound_transfers_outbound_transfer(*, outbound_transfer : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_outbound_transfers_outbound_transfer ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"outbound_transfer\" is required and cannot be null") if outbound_transfer.nil?
        if _outbound_transfer = outbound_transfer
          OpenApi::PrimitiveValidator.validate_max_length("outbound_transfer", outbound_transfer.to_s.size, GET_TREASURY_OUTBOUND_TRANSFERS_OUTBOUND_TRANSFER_MAX_LENGTH_FOR_OUTBOUND_TRANSFER)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/outbound_transfers/{outbound_transfer}".sub("{" + "outbound_transfer" + "}", URI.encode_path(outbound_transfer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_outbound_transfers_outbound_transfer",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of ReceivedCredits.</p>
    # @param financial_account [String?] The FinancialAccount that received the funds.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param linked_flows [Stripe::LinkedFlowsParam?] Only return ReceivedCredits described by the flow.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return ReceivedCredits that have the given status: `succeeded` or `failed`.
    # @return [TreasuryReceivedCreditsResourceReceivedCreditList]
    def get_treasury_received_credits(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, linked_flows : Stripe::LinkedFlowsParam? = nil, starting_after : String? = nil, status : String? = nil)
      data, _status_code, _headers = get_treasury_received_credits_with_http_info(financial_account: financial_account, ending_before: ending_before, expand: expand, limit: limit, linked_flows: linked_flows, starting_after: starting_after, status: status)
      data
    end

    # &lt;p&gt;Returns a list of ReceivedCredits.&lt;/p&gt;
    # @param financial_account [String?] The FinancialAccount that received the funds.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param linked_flows [Stripe::LinkedFlowsParam?] Only return ReceivedCredits described by the flow.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return ReceivedCredits that have the given status: `succeeded` or `failed`.
    # @return [Array<(TreasuryReceivedCreditsResourceReceivedCreditList, Integer, Hash)>] TreasuryReceivedCreditsResourceReceivedCreditList data, response status code and response headers
    def get_treasury_received_credits_with_http_info(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, linked_flows : Stripe::LinkedFlowsParam? = nil, starting_after : String? = nil, status : String? = nil)
      request = build_api_request_for_get_treasury_received_credits(financial_account: financial_account, ending_before: ending_before, expand: expand, limit: limit, linked_flows: linked_flows, starting_after: starting_after, status: status)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_received_credits\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryReceivedCreditsResourceReceivedCreditList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of ReceivedCredits.&lt;/p&gt;
    # @param financial_account [String?] The FinancialAccount that received the funds.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param linked_flows [Stripe::LinkedFlowsParam?] Only return ReceivedCredits described by the flow.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return ReceivedCredits that have the given status: `succeeded` or `failed`.
    # @return nil
    def get_treasury_received_credits(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, linked_flows : Stripe::LinkedFlowsParam? = nil, starting_after : String? = nil, status : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_received_credits(financial_account: financial_account, ending_before: ending_before, expand: expand, limit: limit, linked_flows: linked_flows, starting_after: starting_after, status: status).execute(&block)
    end

    GET_TREASURY_RECEIVED_CREDITS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_TREASURY_RECEIVED_CREDITS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_TREASURY_RECEIVED_CREDITS_VALID_VALUES_FOR_STATUS       = StaticArray["failed", "succeeded"]

    # @return Crest::Request
    def build_api_request_for_get_treasury_received_credits(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, linked_flows : Stripe::LinkedFlowsParam? = nil, starting_after : String? = nil, status : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_received_credits ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"financial_account\" is required and cannot be null") if financial_account.nil?

        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_TREASURY_RECEIVED_CREDITS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _linked_flows = linked_flows
          _linked_flows.validate if _linked_flows.is_a?(OpenApi::Validatable)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_TREASURY_RECEIVED_CREDITS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, GET_TREASURY_RECEIVED_CREDITS_VALID_VALUES_FOR_STATUS)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/received_credits"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["financial_account"] = financial_account.to_s if !financial_account.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["linked_flows"] = linked_flows.to_s if !linked_flows.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["status"] = status.to_s if !status.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_received_credits",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an existing ReceivedCredit by passing the unique ReceivedCredit ID from the ReceivedCredit list.</p>
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [TreasuryReceivedCredit]
    def get_treasury_received_credits_id(*, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_treasury_received_credits_id_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an existing ReceivedCredit by passing the unique ReceivedCredit ID from the ReceivedCredit list.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryReceivedCredit, Integer, Hash)>] TreasuryReceivedCredit data, response status code and response headers
    def get_treasury_received_credits_id_with_http_info(*, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_treasury_received_credits_id(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_received_credits_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryReceivedCredit.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an existing ReceivedCredit by passing the unique ReceivedCredit ID from the ReceivedCredit list.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_treasury_received_credits_id(*, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_received_credits_id(id: id, expand: expand).execute(&block)
    end

    GET_TREASURY_RECEIVED_CREDITS_ID_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_get_treasury_received_credits_id(*, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_received_credits_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_TREASURY_RECEIVED_CREDITS_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/received_credits/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_received_credits_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of ReceivedDebits.</p>
    # @param financial_account [String?] The FinancialAccount that funds were pulled from.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return ReceivedDebits that have the given status: `succeeded` or `failed`.
    # @return [TreasuryReceivedDebitsResourceReceivedDebitList]
    def get_treasury_received_debits(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil)
      data, _status_code, _headers = get_treasury_received_debits_with_http_info(financial_account: financial_account, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status)
      data
    end

    # &lt;p&gt;Returns a list of ReceivedDebits.&lt;/p&gt;
    # @param financial_account [String?] The FinancialAccount that funds were pulled from.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return ReceivedDebits that have the given status: `succeeded` or `failed`.
    # @return [Array<(TreasuryReceivedDebitsResourceReceivedDebitList, Integer, Hash)>] TreasuryReceivedDebitsResourceReceivedDebitList data, response status code and response headers
    def get_treasury_received_debits_with_http_info(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil)
      request = build_api_request_for_get_treasury_received_debits(financial_account: financial_account, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_received_debits\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryReceivedDebitsResourceReceivedDebitList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of ReceivedDebits.&lt;/p&gt;
    # @param financial_account [String?] The FinancialAccount that funds were pulled from.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return ReceivedDebits that have the given status: `succeeded` or `failed`.
    # @return nil
    def get_treasury_received_debits(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_received_debits(financial_account: financial_account, ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after, status: status).execute(&block)
    end

    GET_TREASURY_RECEIVED_DEBITS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_TREASURY_RECEIVED_DEBITS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_TREASURY_RECEIVED_DEBITS_VALID_VALUES_FOR_STATUS       = StaticArray["failed", "succeeded"]

    # @return Crest::Request
    def build_api_request_for_get_treasury_received_debits(*, financial_account : String? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, status : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_received_debits ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"financial_account\" is required and cannot be null") if financial_account.nil?

        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_TREASURY_RECEIVED_DEBITS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_TREASURY_RECEIVED_DEBITS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, GET_TREASURY_RECEIVED_DEBITS_VALID_VALUES_FOR_STATUS)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/received_debits"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["financial_account"] = financial_account.to_s if !financial_account.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["status"] = status.to_s if !status.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_received_debits",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an existing ReceivedDebit by passing the unique ReceivedDebit ID from the ReceivedDebit list</p>
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [TreasuryReceivedDebit]
    def get_treasury_received_debits_id(*, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_treasury_received_debits_id_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an existing ReceivedDebit by passing the unique ReceivedDebit ID from the ReceivedDebit list&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryReceivedDebit, Integer, Hash)>] TreasuryReceivedDebit data, response status code and response headers
    def get_treasury_received_debits_id_with_http_info(*, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_treasury_received_debits_id(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_received_debits_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryReceivedDebit.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an existing ReceivedDebit by passing the unique ReceivedDebit ID from the ReceivedDebit list&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_treasury_received_debits_id(*, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_received_debits_id(id: id, expand: expand).execute(&block)
    end

    GET_TREASURY_RECEIVED_DEBITS_ID_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_get_treasury_received_debits_id(*, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_received_debits_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_TREASURY_RECEIVED_DEBITS_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/received_debits/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_received_debits_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a list of TransactionEntry objects.</p>
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param effective_at [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param order_by [String?] The results are in reverse chronological order by `created` or `effective_at`. The default is `created`.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param transaction [String?] Only return TransactionEntries associated with this Transaction.
    # @return [TreasuryTransactionsResourceTransactionEntryList]
    def get_treasury_transaction_entries(*, financial_account : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, effective_at : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, order_by : String? = nil, starting_after : String? = nil, transaction : String? = nil)
      data, _status_code, _headers = get_treasury_transaction_entries_with_http_info(financial_account: financial_account, created: created, effective_at: effective_at, ending_before: ending_before, expand: expand, limit: limit, order_by: order_by, starting_after: starting_after, transaction: transaction)
      data
    end

    # &lt;p&gt;Retrieves a list of TransactionEntry objects.&lt;/p&gt;
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param effective_at [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param order_by [String?] The results are in reverse chronological order by `created` or `effective_at`. The default is `created`.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param transaction [String?] Only return TransactionEntries associated with this Transaction.
    # @return [Array<(TreasuryTransactionsResourceTransactionEntryList, Integer, Hash)>] TreasuryTransactionsResourceTransactionEntryList data, response status code and response headers
    def get_treasury_transaction_entries_with_http_info(*, financial_account : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, effective_at : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, order_by : String? = nil, starting_after : String? = nil, transaction : String? = nil)
      request = build_api_request_for_get_treasury_transaction_entries(financial_account: financial_account, created: created, effective_at: effective_at, ending_before: ending_before, expand: expand, limit: limit, order_by: order_by, starting_after: starting_after, transaction: transaction)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_transaction_entries\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryTransactionsResourceTransactionEntryList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a list of TransactionEntry objects.&lt;/p&gt;
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param effective_at [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param order_by [String?] The results are in reverse chronological order by `created` or `effective_at`. The default is `created`.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param transaction [String?] Only return TransactionEntries associated with this Transaction.
    # @return nil
    def get_treasury_transaction_entries(*, financial_account : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, effective_at : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, order_by : String? = nil, starting_after : String? = nil, transaction : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_transaction_entries(financial_account: financial_account, created: created, effective_at: effective_at, ending_before: ending_before, expand: expand, limit: limit, order_by: order_by, starting_after: starting_after, transaction: transaction).execute(&block)
    end

    GET_TREASURY_TRANSACTION_ENTRIES_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_TREASURY_TRANSACTION_ENTRIES_VALID_VALUES_FOR_ORDER_BY     = StaticArray["created", "effective_at"]
    GET_TREASURY_TRANSACTION_ENTRIES_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_TREASURY_TRANSACTION_ENTRIES_MAX_LENGTH_FOR_TRANSACTION    = 5000

    # @return Crest::Request
    def build_api_request_for_get_treasury_transaction_entries(*, financial_account : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, effective_at : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, order_by : String? = nil, starting_after : String? = nil, transaction : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_transaction_entries ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"financial_account\" is required and cannot be null") if financial_account.nil?

        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _effective_at = effective_at
          _effective_at.validate if _effective_at.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_TREASURY_TRANSACTION_ENTRIES_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _order_by = order_by
          OpenApi::EnumValidator.validate("order_by", _order_by, GET_TREASURY_TRANSACTION_ENTRIES_VALID_VALUES_FOR_ORDER_BY)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_TREASURY_TRANSACTION_ENTRIES_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _transaction = transaction
          OpenApi::PrimitiveValidator.validate_max_length("transaction", transaction.to_s.size, GET_TREASURY_TRANSACTION_ENTRIES_MAX_LENGTH_FOR_TRANSACTION)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/transaction_entries"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["effective_at"] = effective_at.to_s if !effective_at.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["financial_account"] = financial_account.to_s if !financial_account.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["order_by"] = order_by.to_s if !order_by.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["transaction"] = transaction.to_s if !transaction.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_transaction_entries",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a TransactionEntry object.</p>
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [TreasuryTransactionEntry]
    def get_treasury_transaction_entries_id(*, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_treasury_transaction_entries_id_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves a TransactionEntry object.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryTransactionEntry, Integer, Hash)>] TreasuryTransactionEntry data, response status code and response headers
    def get_treasury_transaction_entries_id_with_http_info(*, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_treasury_transaction_entries_id(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_transaction_entries_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryTransactionEntry.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a TransactionEntry object.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_treasury_transaction_entries_id(*, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_transaction_entries_id(id: id, expand: expand).execute(&block)
    end

    GET_TREASURY_TRANSACTION_ENTRIES_ID_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_get_treasury_transaction_entries_id(*, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_transaction_entries_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_TREASURY_TRANSACTION_ENTRIES_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/transaction_entries/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_transaction_entries_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves a list of Transaction objects.</p>
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param order_by [String?] The results are in reverse chronological order by `created` or `posted_at`. The default is `created`.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return Transactions that have the given status: `open`, `posted`, or `void`.
    # @optional @param status_transitions [Stripe::StatusTransitionTimestampSpecs?] A filter for the `status_transitions.posted_at` timestamp. When using this filter, `status=posted` and `order_by=posted_at` must also be specified.
    # @return [TreasuryTransactionsResourceTransactionList]
    def get_treasury_transactions(*, financial_account : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, order_by : String? = nil, starting_after : String? = nil, status : String? = nil, status_transitions : Stripe::StatusTransitionTimestampSpecs? = nil)
      data, _status_code, _headers = get_treasury_transactions_with_http_info(financial_account: financial_account, created: created, ending_before: ending_before, expand: expand, limit: limit, order_by: order_by, starting_after: starting_after, status: status, status_transitions: status_transitions)
      data
    end

    # &lt;p&gt;Retrieves a list of Transaction objects.&lt;/p&gt;
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param order_by [String?] The results are in reverse chronological order by `created` or `posted_at`. The default is `created`.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return Transactions that have the given status: `open`, `posted`, or `void`.
    # @optional @param status_transitions [Stripe::StatusTransitionTimestampSpecs?] A filter for the `status_transitions.posted_at` timestamp. When using this filter, `status=posted` and `order_by=posted_at` must also be specified.
    # @return [Array<(TreasuryTransactionsResourceTransactionList, Integer, Hash)>] TreasuryTransactionsResourceTransactionList data, response status code and response headers
    def get_treasury_transactions_with_http_info(*, financial_account : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, order_by : String? = nil, starting_after : String? = nil, status : String? = nil, status_transitions : Stripe::StatusTransitionTimestampSpecs? = nil)
      request = build_api_request_for_get_treasury_transactions(financial_account: financial_account, created: created, ending_before: ending_before, expand: expand, limit: limit, order_by: order_by, starting_after: starting_after, status: status, status_transitions: status_transitions)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_transactions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryTransactionsResourceTransactionList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves a list of Transaction objects.&lt;/p&gt;
    # @param financial_account [String?] Returns objects associated with this FinancialAccount.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param order_by [String?] The results are in reverse chronological order by `created` or `posted_at`. The default is `created`.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param status [String?] Only return Transactions that have the given status: `open`, `posted`, or `void`.
    # @optional @param status_transitions [Stripe::StatusTransitionTimestampSpecs?] A filter for the `status_transitions.posted_at` timestamp. When using this filter, `status=posted` and `order_by=posted_at` must also be specified.
    # @return nil
    def get_treasury_transactions(*, financial_account : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, order_by : String? = nil, starting_after : String? = nil, status : String? = nil, status_transitions : Stripe::StatusTransitionTimestampSpecs? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_transactions(financial_account: financial_account, created: created, ending_before: ending_before, expand: expand, limit: limit, order_by: order_by, starting_after: starting_after, status: status, status_transitions: status_transitions).execute(&block)
    end

    GET_TREASURY_TRANSACTIONS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_TREASURY_TRANSACTIONS_VALID_VALUES_FOR_ORDER_BY     = StaticArray["created", "posted_at"]
    GET_TREASURY_TRANSACTIONS_MAX_LENGTH_FOR_STARTING_AFTER = 5000
    GET_TREASURY_TRANSACTIONS_VALID_VALUES_FOR_STATUS       = StaticArray["open", "posted", "void"]

    # @return Crest::Request
    def build_api_request_for_get_treasury_transactions(*, financial_account : String? = nil, created : Stripe::GetAccountsCreatedParameter? = nil, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, order_by : String? = nil, starting_after : String? = nil, status : String? = nil, status_transitions : Stripe::StatusTransitionTimestampSpecs? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_transactions ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"financial_account\" is required and cannot be null") if financial_account.nil?

        if _created = created
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_TREASURY_TRANSACTIONS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _order_by = order_by
          OpenApi::EnumValidator.validate("order_by", _order_by, GET_TREASURY_TRANSACTIONS_VALID_VALUES_FOR_ORDER_BY)
        end
        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_TREASURY_TRANSACTIONS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, GET_TREASURY_TRANSACTIONS_VALID_VALUES_FOR_STATUS)
        end
        if _status_transitions = status_transitions
          _status_transitions.validate if _status_transitions.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/transactions"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["created"] = created.to_s if !created.nil?
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["financial_account"] = financial_account.to_s if !financial_account.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["order_by"] = order_by.to_s if !order_by.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["status"] = status.to_s if !status.nil?
      query_params["status_transitions"] = status_transitions.to_s if !status_transitions.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_transactions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the details of an existing Transaction.</p>
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [TreasuryTransaction]
    def get_treasury_transactions_id(*, id : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_treasury_transactions_id_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the details of an existing Transaction.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryTransaction, Integer, Hash)>] TreasuryTransaction data, response status code and response headers
    def get_treasury_transactions_id_with_http_info(*, id : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_treasury_transactions_id(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_treasury_transactions_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryTransaction.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the details of an existing Transaction.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_treasury_transactions_id(*, id : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_treasury_transactions_id(id: id, expand: expand).execute(&block)
    end

    GET_TREASURY_TRANSACTIONS_ID_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_get_treasury_transactions_id(*, id : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_treasury_transactions_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, GET_TREASURY_TRANSACTIONS_ID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/transactions/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_treasury_transactions_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of your webhook endpoints.</p>
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [NotificationWebhookEndpointList]
    def get_webhook_endpoints(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      data, _status_code, _headers = get_webhook_endpoints_with_http_info(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)
      data
    end

    # &lt;p&gt;Returns a list of your webhook endpoints.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return [Array<(NotificationWebhookEndpointList, Integer, Hash)>] NotificationWebhookEndpointList data, response status code and response headers
    def get_webhook_endpoints_with_http_info(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil)
      request = build_api_request_for_get_webhook_endpoints(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_webhook_endpoints\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return NotificationWebhookEndpointList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Returns a list of your webhook endpoints.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param limit [Int64?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @return nil
    def get_webhook_endpoints(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil, &block : Crest::Response ->)
      build_api_request_for_get_webhook_endpoints(ending_before: ending_before, expand: expand, limit: limit, starting_after: starting_after).execute(&block)
    end

    GET_WEBHOOK_ENDPOINTS_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_WEBHOOK_ENDPOINTS_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_webhook_endpoints(*, ending_before : String? = nil, expand : Array(Array(String))? = nil, limit : Int64? = nil, starting_after : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_webhook_endpoints ..." }
      end

      if client_side_validation
        if _ending_before = ending_before
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_WEBHOOK_ENDPOINTS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end

        if _starting_after = starting_after
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_WEBHOOK_ENDPOINTS_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/webhook_endpoints"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_webhook_endpoints",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the webhook endpoint with the given ID.</p>
    # @param webhook_endpoint [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [WebhookEndpoint]
    def get_webhook_endpoints_webhook_endpoint(*, webhook_endpoint : String? = nil, expand : Array(Array(String))? = nil)
      data, _status_code, _headers = get_webhook_endpoints_webhook_endpoint_with_http_info(webhook_endpoint: webhook_endpoint, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the webhook endpoint with the given ID.&lt;/p&gt;
    # @param webhook_endpoint [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Array<(WebhookEndpoint, Integer, Hash)>] WebhookEndpoint data, response status code and response headers
    def get_webhook_endpoints_webhook_endpoint_with_http_info(*, webhook_endpoint : String? = nil, expand : Array(Array(String))? = nil)
      request = build_api_request_for_get_webhook_endpoints_webhook_endpoint(webhook_endpoint: webhook_endpoint, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#get_webhook_endpoints_webhook_endpoint\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return WebhookEndpoint.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieves the webhook endpoint with the given ID.&lt;/p&gt;
    # @param webhook_endpoint [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_webhook_endpoints_webhook_endpoint(*, webhook_endpoint : String? = nil, expand : Array(Array(String))? = nil, &block : Crest::Response ->)
      build_api_request_for_get_webhook_endpoints_webhook_endpoint(webhook_endpoint: webhook_endpoint, expand: expand).execute(&block)
    end

    GET_WEBHOOK_ENDPOINTS_WEBHOOK_ENDPOINT_MAX_LENGTH_FOR_WEBHOOK_ENDPOINT = 5000

    # @return Crest::Request
    def build_api_request_for_get_webhook_endpoints_webhook_endpoint(*, webhook_endpoint : String? = nil, expand : Array(Array(String))? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.get_webhook_endpoints_webhook_endpoint ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"webhook_endpoint\" is required and cannot be null") if webhook_endpoint.nil?
        if _webhook_endpoint = webhook_endpoint
          OpenApi::PrimitiveValidator.validate_max_length("webhook_endpoint", webhook_endpoint.to_s.size, GET_WEBHOOK_ENDPOINTS_WEBHOOK_ENDPOINT_MAX_LENGTH_FOR_WEBHOOK_ENDPOINT)
        end
      end

      # resource path
      local_var_path = "/v1/webhook_endpoints/{webhook_endpoint}".sub("{" + "webhook_endpoint" + "}", URI.encode_path(webhook_endpoint.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "DefaultApi.get_webhook_endpoints_webhook_endpoint",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates a <a href=\"/docs/connect/accounts\">connected account</a> by setting the values of the parameters passed. Any parameters not provided are left unchanged. Most parameters can be changed only for Custom accounts. (These are marked <strong>Custom Only</strong> below.) Parameters marked <strong>Custom and Express</strong> are not supported for Standard accounts.</p>  <p>To update your own account, use the <a href=\"https://dashboard.stripe.com/account\">Dashboard</a>. Refer to our <a href=\"/docs/connect/updating-accounts\">Connect</a> documentation to learn more about updating accounts.</p>
    # @optional @param account_token [String?] An [account token](https://stripe.com/docs/api#create_account_token), used to securely provide details to the account.
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param business_profile [Stripe::BusinessProfileSpecs?]
    # @optional @param business_type [String?] The business type.
    # @optional @param capabilities [Stripe::CapabilitiesParam?]
    # @optional @param company [Stripe::CompanySpecs?]
    # @optional @param default_currency [String?] Three-letter ISO currency code representing the default currency for the account. This must be a currency that [Stripe supports in the account's country](https://stripe.com/docs/payouts).
    # @optional @param documents [Stripe::DocumentsSpecs?]
    # @optional @param email [String?] The email address of the account holder. This is only to make the account easier to identify to you. Stripe only emails Custom accounts with your consent.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] A card or bank account to attach to the account for receiving [payouts](https://stripe.com/docs/connect/bank-debit-card-payouts) (you won’t be able to use it for top-ups). You can provide either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary, as documented in the `external_account` parameter for [bank account](https://stripe.com/docs/api#account_create_bank_account) creation. <br><br>By default, providing an external account sets it as the new default external account for its currency, and deletes the old default if one exists. To add additional external accounts without replacing the existing default for the currency, use the [bank account](https://stripe.com/docs/api#account_create_bank_account) or [card creation](https://stripe.com/docs/api#account_create_card) APIs.
    # @optional @param individual [Stripe::IndividualSpecs?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param settings [Stripe::SettingsSpecsUpdate?]
    # @optional @param tos_acceptance [Stripe::TosAcceptanceSpecs?]
    # @return [Account]
    def post_account(*, account_token : String? = nil, bank_account : Stripe::PostAccountRequestBankAccount? = nil, business_profile : Stripe::BusinessProfileSpecs? = nil, business_type : String? = nil, capabilities : Stripe::CapabilitiesParam? = nil, company : Stripe::CompanySpecs? = nil, default_currency : String? = nil, documents : Stripe::DocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, external_account : String? = nil, individual : Stripe::IndividualSpecs? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, settings : Stripe::SettingsSpecsUpdate? = nil, tos_acceptance : Stripe::TosAcceptanceSpecs? = nil)
      data, _status_code, _headers = post_account_with_http_info(account_token: account_token, bank_account: bank_account, business_profile: business_profile, business_type: business_type, capabilities: capabilities, company: company, default_currency: default_currency, documents: documents, email: email, expand: expand, external_account: external_account, individual: individual, metadata: metadata, settings: settings, tos_acceptance: tos_acceptance)
      data
    end

    # &lt;p&gt;Updates a &lt;a href&#x3D;\&quot;/docs/connect/accounts\&quot;&gt;connected account&lt;/a&gt; by setting the values of the parameters passed. Any parameters not provided are left unchanged. Most parameters can be changed only for Custom accounts. (These are marked &lt;strong&gt;Custom Only&lt;/strong&gt; below.) Parameters marked &lt;strong&gt;Custom and Express&lt;/strong&gt; are not supported for Standard accounts.&lt;/p&gt;  &lt;p&gt;To update your own account, use the &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/account\&quot;&gt;Dashboard&lt;/a&gt;. Refer to our &lt;a href&#x3D;\&quot;/docs/connect/updating-accounts\&quot;&gt;Connect&lt;/a&gt; documentation to learn more about updating accounts.&lt;/p&gt;
    # @optional @param account_token [String?] An [account token](https://stripe.com/docs/api#create_account_token), used to securely provide details to the account.
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param business_profile [Stripe::BusinessProfileSpecs?]
    # @optional @param business_type [String?] The business type.
    # @optional @param capabilities [Stripe::CapabilitiesParam?]
    # @optional @param company [Stripe::CompanySpecs?]
    # @optional @param default_currency [String?] Three-letter ISO currency code representing the default currency for the account. This must be a currency that [Stripe supports in the account's country](https://stripe.com/docs/payouts).
    # @optional @param documents [Stripe::DocumentsSpecs?]
    # @optional @param email [String?] The email address of the account holder. This is only to make the account easier to identify to you. Stripe only emails Custom accounts with your consent.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] A card or bank account to attach to the account for receiving [payouts](https://stripe.com/docs/connect/bank-debit-card-payouts) (you won’t be able to use it for top-ups). You can provide either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary, as documented in the `external_account` parameter for [bank account](https://stripe.com/docs/api#account_create_bank_account) creation. <br><br>By default, providing an external account sets it as the new default external account for its currency, and deletes the old default if one exists. To add additional external accounts without replacing the existing default for the currency, use the [bank account](https://stripe.com/docs/api#account_create_bank_account) or [card creation](https://stripe.com/docs/api#account_create_card) APIs.
    # @optional @param individual [Stripe::IndividualSpecs?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param settings [Stripe::SettingsSpecsUpdate?]
    # @optional @param tos_acceptance [Stripe::TosAcceptanceSpecs?]
    # @return [Array<(Account, Integer, Hash)>] Account data, response status code and response headers
    def post_account_with_http_info(*, account_token : String? = nil, bank_account : Stripe::PostAccountRequestBankAccount? = nil, business_profile : Stripe::BusinessProfileSpecs? = nil, business_type : String? = nil, capabilities : Stripe::CapabilitiesParam? = nil, company : Stripe::CompanySpecs? = nil, default_currency : String? = nil, documents : Stripe::DocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, external_account : String? = nil, individual : Stripe::IndividualSpecs? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, settings : Stripe::SettingsSpecsUpdate? = nil, tos_acceptance : Stripe::TosAcceptanceSpecs? = nil)
      request = build_api_request_for_post_account(account_token: account_token, bank_account: bank_account, business_profile: business_profile, business_type: business_type, capabilities: capabilities, company: company, default_currency: default_currency, documents: documents, email: email, expand: expand, external_account: external_account, individual: individual, metadata: metadata, settings: settings, tos_acceptance: tos_acceptance)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_account\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Account.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates a &lt;a href&#x3D;\&quot;/docs/connect/accounts\&quot;&gt;connected account&lt;/a&gt; by setting the values of the parameters passed. Any parameters not provided are left unchanged. Most parameters can be changed only for Custom accounts. (These are marked &lt;strong&gt;Custom Only&lt;/strong&gt; below.) Parameters marked &lt;strong&gt;Custom and Express&lt;/strong&gt; are not supported for Standard accounts.&lt;/p&gt;  &lt;p&gt;To update your own account, use the &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/account\&quot;&gt;Dashboard&lt;/a&gt;. Refer to our &lt;a href&#x3D;\&quot;/docs/connect/updating-accounts\&quot;&gt;Connect&lt;/a&gt; documentation to learn more about updating accounts.&lt;/p&gt;
    # @optional @param account_token [String?] An [account token](https://stripe.com/docs/api#create_account_token), used to securely provide details to the account.
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param business_profile [Stripe::BusinessProfileSpecs?]
    # @optional @param business_type [String?] The business type.
    # @optional @param capabilities [Stripe::CapabilitiesParam?]
    # @optional @param company [Stripe::CompanySpecs?]
    # @optional @param default_currency [String?] Three-letter ISO currency code representing the default currency for the account. This must be a currency that [Stripe supports in the account's country](https://stripe.com/docs/payouts).
    # @optional @param documents [Stripe::DocumentsSpecs?]
    # @optional @param email [String?] The email address of the account holder. This is only to make the account easier to identify to you. Stripe only emails Custom accounts with your consent.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] A card or bank account to attach to the account for receiving [payouts](https://stripe.com/docs/connect/bank-debit-card-payouts) (you won’t be able to use it for top-ups). You can provide either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary, as documented in the `external_account` parameter for [bank account](https://stripe.com/docs/api#account_create_bank_account) creation. <br><br>By default, providing an external account sets it as the new default external account for its currency, and deletes the old default if one exists. To add additional external accounts without replacing the existing default for the currency, use the [bank account](https://stripe.com/docs/api#account_create_bank_account) or [card creation](https://stripe.com/docs/api#account_create_card) APIs.
    # @optional @param individual [Stripe::IndividualSpecs?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param settings [Stripe::SettingsSpecsUpdate?]
    # @optional @param tos_acceptance [Stripe::TosAcceptanceSpecs?]
    # @return nil
    def post_account(*, account_token : String? = nil, bank_account : Stripe::PostAccountRequestBankAccount? = nil, business_profile : Stripe::BusinessProfileSpecs? = nil, business_type : String? = nil, capabilities : Stripe::CapabilitiesParam? = nil, company : Stripe::CompanySpecs? = nil, default_currency : String? = nil, documents : Stripe::DocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, external_account : String? = nil, individual : Stripe::IndividualSpecs? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, settings : Stripe::SettingsSpecsUpdate? = nil, tos_acceptance : Stripe::TosAcceptanceSpecs? = nil, &block : Crest::Response ->)
      build_api_request_for_post_account(account_token: account_token, bank_account: bank_account, business_profile: business_profile, business_type: business_type, capabilities: capabilities, company: company, default_currency: default_currency, documents: documents, email: email, expand: expand, external_account: external_account, individual: individual, metadata: metadata, settings: settings, tos_acceptance: tos_acceptance).execute(&block)
    end

    POST_ACCOUNT_MAX_LENGTH_FOR_ACCOUNT_TOKEN    = 5000
    POST_ACCOUNT_VALID_VALUES_FOR_BUSINESS_TYPE  = StaticArray["company", "government_entity", "individual", "non_profit"]
    POST_ACCOUNT_MAX_LENGTH_FOR_EXTERNAL_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_post_account(*, account_token : String? = nil, bank_account : Stripe::PostAccountRequestBankAccount? = nil, business_profile : Stripe::BusinessProfileSpecs? = nil, business_type : String? = nil, capabilities : Stripe::CapabilitiesParam? = nil, company : Stripe::CompanySpecs? = nil, default_currency : String? = nil, documents : Stripe::DocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, external_account : String? = nil, individual : Stripe::IndividualSpecs? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, settings : Stripe::SettingsSpecsUpdate? = nil, tos_acceptance : Stripe::TosAcceptanceSpecs? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_account ..." }
      end

      if client_side_validation
        if _account_token = account_token
          OpenApi::PrimitiveValidator.validate_max_length("account_token", account_token.to_s.size, POST_ACCOUNT_MAX_LENGTH_FOR_ACCOUNT_TOKEN)
        end
        if _bank_account = bank_account
          _bank_account.validate if _bank_account.is_a?(OpenApi::Validatable)
        end
        if _business_profile = business_profile
          _business_profile.validate if _business_profile.is_a?(OpenApi::Validatable)
        end
        if _business_type = business_type
          OpenApi::EnumValidator.validate("business_type", _business_type, POST_ACCOUNT_VALID_VALUES_FOR_BUSINESS_TYPE)
        end
        if _capabilities = capabilities
          _capabilities.validate if _capabilities.is_a?(OpenApi::Validatable)
        end
        if _company = company
          _company.validate if _company.is_a?(OpenApi::Validatable)
        end

        if _documents = documents
          _documents.validate if _documents.is_a?(OpenApi::Validatable)
        end

        if _external_account = external_account
          OpenApi::PrimitiveValidator.validate_max_length("external_account", external_account.to_s.size, POST_ACCOUNT_MAX_LENGTH_FOR_EXTERNAL_ACCOUNT)
        end
        if _individual = individual
          _individual.validate if _individual.is_a?(OpenApi::Validatable)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _settings = settings
          _settings.validate if _settings.is_a?(OpenApi::Validatable)
        end
        if _tos_acceptance = tos_acceptance
          _tos_acceptance.validate if _tos_acceptance.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/account"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account_token"] = account_token.to_s if !account_token.nil?
      form_params["bank_account"] = bank_account.to_s if !bank_account.nil?
      form_params["business_profile"] = business_profile.to_s if !business_profile.nil?
      form_params["business_type"] = business_type.to_s if !business_type.nil?
      form_params["capabilities"] = capabilities.to_s if !capabilities.nil?
      form_params["company"] = company.to_s if !company.nil?
      form_params["default_currency"] = default_currency.to_s if !default_currency.nil?
      form_params["documents"] = documents.to_s if !documents.nil?
      form_params["email"] = email.to_s if !email.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["external_account"] = external_account.to_s if !external_account.nil?
      form_params["individual"] = individual.to_s if !individual.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["settings"] = settings.to_s if !settings.nil?
      form_params["tos_acceptance"] = tos_acceptance.to_s if !tos_acceptance.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_account",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Create an external account for a given account.</p>
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param default_for_currency [Bool?] When set to true, or if this is the first external account added in this currency, this account becomes the default external account for its currency.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return [ExternalAccount]
    def post_account_bank_accounts(*, bank_account : Stripe::PostAccountRequestBankAccount? = nil, default_for_currency : Bool? = nil, expand : Array(String)? = nil, external_account : String? = nil)
      data, _status_code, _headers = post_account_bank_accounts_with_http_info(bank_account: bank_account, default_for_currency: default_for_currency, expand: expand, external_account: external_account)
      data
    end

    # &lt;p&gt;Create an external account for a given account.&lt;/p&gt;
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param default_for_currency [Bool?] When set to true, or if this is the first external account added in this currency, this account becomes the default external account for its currency.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return [Array<(ExternalAccount, Integer, Hash)>] ExternalAccount data, response status code and response headers
    def post_account_bank_accounts_with_http_info(*, bank_account : Stripe::PostAccountRequestBankAccount? = nil, default_for_currency : Bool? = nil, expand : Array(String)? = nil, external_account : String? = nil)
      request = build_api_request_for_post_account_bank_accounts(bank_account: bank_account, default_for_currency: default_for_currency, expand: expand, external_account: external_account)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_account_bank_accounts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ExternalAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Create an external account for a given account.&lt;/p&gt;
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param default_for_currency [Bool?] When set to true, or if this is the first external account added in this currency, this account becomes the default external account for its currency.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return nil
    def post_account_bank_accounts(*, bank_account : Stripe::PostAccountRequestBankAccount? = nil, default_for_currency : Bool? = nil, expand : Array(String)? = nil, external_account : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_account_bank_accounts(bank_account: bank_account, default_for_currency: default_for_currency, expand: expand, external_account: external_account).execute(&block)
    end

    POST_ACCOUNT_BANK_ACCOUNTS_MAX_LENGTH_FOR_EXTERNAL_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_post_account_bank_accounts(*, bank_account : Stripe::PostAccountRequestBankAccount? = nil, default_for_currency : Bool? = nil, expand : Array(String)? = nil, external_account : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_account_bank_accounts ..." }
      end

      if client_side_validation
        if _bank_account = bank_account
          _bank_account.validate if _bank_account.is_a?(OpenApi::Validatable)
        end

        if _external_account = external_account
          OpenApi::PrimitiveValidator.validate_max_length("external_account", external_account.to_s.size, POST_ACCOUNT_BANK_ACCOUNTS_MAX_LENGTH_FOR_EXTERNAL_ACCOUNT)
        end
      end

      # resource path
      local_var_path = "/v1/account/bank_accounts"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["bank_account"] = bank_account.to_s if !bank_account.nil?
      form_params["default_for_currency"] = default_for_currency.to_s if !default_for_currency.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["external_account"] = external_account.to_s if !external_account.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_account_bank_accounts",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the metadata, account holder name, account holder type of a bank account belonging to a <a href=\"/docs/connect/custom-accounts\">Custom account</a>, and optionally sets it as the default for its currency. Other bank account details are not editable by design.</p>  <p>You can re-enable a disabled bank account by performing an update call without providing any arguments or changes.</p>
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param account_type [String?] The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param default_for_currency [Bool?] When set to true, this becomes the default external account for its currency.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @return [ExternalAccount]
    def post_account_bank_accounts_id(*, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, account_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, default_for_currency : Bool? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil)
      data, _status_code, _headers = post_account_bank_accounts_id_with_http_info(id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, account_type: account_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, default_for_currency: default_for_currency, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name)
      data
    end

    # &lt;p&gt;Updates the metadata, account holder name, account holder type of a bank account belonging to a &lt;a href&#x3D;\&quot;/docs/connect/custom-accounts\&quot;&gt;Custom account&lt;/a&gt;, and optionally sets it as the default for its currency. Other bank account details are not editable by design.&lt;/p&gt;  &lt;p&gt;You can re-enable a disabled bank account by performing an update call without providing any arguments or changes.&lt;/p&gt;
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param account_type [String?] The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param default_for_currency [Bool?] When set to true, this becomes the default external account for its currency.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @return [Array<(ExternalAccount, Integer, Hash)>] ExternalAccount data, response status code and response headers
    def post_account_bank_accounts_id_with_http_info(*, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, account_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, default_for_currency : Bool? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil)
      request = build_api_request_for_post_account_bank_accounts_id(id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, account_type: account_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, default_for_currency: default_for_currency, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_account_bank_accounts_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ExternalAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the metadata, account holder name, account holder type of a bank account belonging to a &lt;a href&#x3D;\&quot;/docs/connect/custom-accounts\&quot;&gt;Custom account&lt;/a&gt;, and optionally sets it as the default for its currency. Other bank account details are not editable by design.&lt;/p&gt;  &lt;p&gt;You can re-enable a disabled bank account by performing an update call without providing any arguments or changes.&lt;/p&gt;
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param account_type [String?] The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param default_for_currency [Bool?] When set to true, this becomes the default external account for its currency.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @return nil
    def post_account_bank_accounts_id(*, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, account_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, default_for_currency : Bool? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_account_bank_accounts_id(id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, account_type: account_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, default_for_currency: default_for_currency, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name).execute(&block)
    end

    POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_NAME   = 5000
    POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_TYPE   = 5000
    POST_ACCOUNT_BANK_ACCOUNTS_ID_VALID_VALUES_FOR_ACCOUNT_HOLDER_TYPE = StaticArray["", "company", "individual"]
    POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT_TYPE          = 5000
    POST_ACCOUNT_BANK_ACCOUNTS_ID_VALID_VALUES_FOR_ACCOUNT_TYPE        = StaticArray["checking", "futsu", "savings", "toza"]
    POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_CITY          = 5000
    POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_COUNTRY       = 5000
    POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_LINE1         = 5000
    POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_LINE2         = 5000
    POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_STATE         = 5000
    POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_ZIP           = 5000
    POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_EXP_MONTH             = 5000
    POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_EXP_YEAR              = 5000
    POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_NAME                  = 5000

    # @return Crest::Request
    def build_api_request_for_post_account_bank_accounts_id(*, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, account_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, default_for_currency : Bool? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_account_bank_accounts_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?

        if _account_holder_name = account_holder_name
          OpenApi::PrimitiveValidator.validate_max_length("account_holder_name", account_holder_name.to_s.size, POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_NAME)
        end
        if _account_holder_type = account_holder_type
          OpenApi::EnumValidator.validate("account_holder_type", _account_holder_type, POST_ACCOUNT_BANK_ACCOUNTS_ID_VALID_VALUES_FOR_ACCOUNT_HOLDER_TYPE)
        end
        if _account_type = account_type
          OpenApi::EnumValidator.validate("account_type", _account_type, POST_ACCOUNT_BANK_ACCOUNTS_ID_VALID_VALUES_FOR_ACCOUNT_TYPE)
        end
        if _address_city = address_city
          OpenApi::PrimitiveValidator.validate_max_length("address_city", address_city.to_s.size, POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_CITY)
        end
        if _address_country = address_country
          OpenApi::PrimitiveValidator.validate_max_length("address_country", address_country.to_s.size, POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_COUNTRY)
        end
        if _address_line1 = address_line1
          OpenApi::PrimitiveValidator.validate_max_length("address_line1", address_line1.to_s.size, POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_LINE1)
        end
        if _address_line2 = address_line2
          OpenApi::PrimitiveValidator.validate_max_length("address_line2", address_line2.to_s.size, POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_LINE2)
        end
        if _address_state = address_state
          OpenApi::PrimitiveValidator.validate_max_length("address_state", address_state.to_s.size, POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_STATE)
        end
        if _address_zip = address_zip
          OpenApi::PrimitiveValidator.validate_max_length("address_zip", address_zip.to_s.size, POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_ZIP)
        end

        if _exp_month = exp_month
          OpenApi::PrimitiveValidator.validate_max_length("exp_month", exp_month.to_s.size, POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_EXP_MONTH)
        end
        if _exp_year = exp_year
          OpenApi::PrimitiveValidator.validate_max_length("exp_year", exp_year.to_s.size, POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_EXP_YEAR)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _name = name
          OpenApi::PrimitiveValidator.validate_max_length("name", name.to_s.size, POST_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_NAME)
        end
      end

      # resource path
      local_var_path = "/v1/account/bank_accounts/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account_holder_name"] = account_holder_name.to_s if !account_holder_name.nil?
      form_params["account_holder_type"] = account_holder_type.to_s if !account_holder_type.nil?
      form_params["account_type"] = account_type.to_s if !account_type.nil?
      form_params["address_city"] = address_city.to_s if !address_city.nil?
      form_params["address_country"] = address_country.to_s if !address_country.nil?
      form_params["address_line1"] = address_line1.to_s if !address_line1.nil?
      form_params["address_line2"] = address_line2.to_s if !address_line2.nil?
      form_params["address_state"] = address_state.to_s if !address_state.nil?
      form_params["address_zip"] = address_zip.to_s if !address_zip.nil?
      form_params["default_for_currency"] = default_for_currency.to_s if !default_for_currency.nil?
      form_params["exp_month"] = exp_month.to_s if !exp_month.nil?
      form_params["exp_year"] = exp_year.to_s if !exp_year.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["name"] = name.to_s if !name.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_account_bank_accounts_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates an existing Account Capability.</p>
    # @param capability [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param requested [Bool?] Passing true requests the capability for the account, if it is not already requested. A requested capability may not immediately become active. Any requirements to activate the capability are returned in the `requirements` arrays.
    # @return [Capability]
    def post_account_capabilities_capability(*, capability : String? = nil, expand : Array(String)? = nil, requested : Bool? = nil)
      data, _status_code, _headers = post_account_capabilities_capability_with_http_info(capability: capability, expand: expand, requested: requested)
      data
    end

    # &lt;p&gt;Updates an existing Account Capability.&lt;/p&gt;
    # @param capability [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param requested [Bool?] Passing true requests the capability for the account, if it is not already requested. A requested capability may not immediately become active. Any requirements to activate the capability are returned in the `requirements` arrays.
    # @return [Array<(Capability, Integer, Hash)>] Capability data, response status code and response headers
    def post_account_capabilities_capability_with_http_info(*, capability : String? = nil, expand : Array(String)? = nil, requested : Bool? = nil)
      request = build_api_request_for_post_account_capabilities_capability(capability: capability, expand: expand, requested: requested)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_account_capabilities_capability\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Capability.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates an existing Account Capability.&lt;/p&gt;
    # @param capability [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param requested [Bool?] Passing true requests the capability for the account, if it is not already requested. A requested capability may not immediately become active. Any requirements to activate the capability are returned in the `requirements` arrays.
    # @return nil
    def post_account_capabilities_capability(*, capability : String? = nil, expand : Array(String)? = nil, requested : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_post_account_capabilities_capability(capability: capability, expand: expand, requested: requested).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_post_account_capabilities_capability(*, capability : String? = nil, expand : Array(String)? = nil, requested : Bool? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_account_capabilities_capability ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"capability\" is required and cannot be null") if capability.nil?
      end

      # resource path
      local_var_path = "/v1/account/capabilities/{capability}".sub("{" + "capability" + "}", URI.encode_path(capability.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["requested"] = requested.to_s if !requested.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_account_capabilities_capability",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Create an external account for a given account.</p>
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param default_for_currency [Bool?] When set to true, or if this is the first external account added in this currency, this account becomes the default external account for its currency.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return [ExternalAccount]
    def post_account_external_accounts(*, bank_account : Stripe::PostAccountRequestBankAccount? = nil, default_for_currency : Bool? = nil, expand : Array(String)? = nil, external_account : String? = nil)
      data, _status_code, _headers = post_account_external_accounts_with_http_info(bank_account: bank_account, default_for_currency: default_for_currency, expand: expand, external_account: external_account)
      data
    end

    # &lt;p&gt;Create an external account for a given account.&lt;/p&gt;
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param default_for_currency [Bool?] When set to true, or if this is the first external account added in this currency, this account becomes the default external account for its currency.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return [Array<(ExternalAccount, Integer, Hash)>] ExternalAccount data, response status code and response headers
    def post_account_external_accounts_with_http_info(*, bank_account : Stripe::PostAccountRequestBankAccount? = nil, default_for_currency : Bool? = nil, expand : Array(String)? = nil, external_account : String? = nil)
      request = build_api_request_for_post_account_external_accounts(bank_account: bank_account, default_for_currency: default_for_currency, expand: expand, external_account: external_account)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_account_external_accounts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ExternalAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Create an external account for a given account.&lt;/p&gt;
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param default_for_currency [Bool?] When set to true, or if this is the first external account added in this currency, this account becomes the default external account for its currency.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return nil
    def post_account_external_accounts(*, bank_account : Stripe::PostAccountRequestBankAccount? = nil, default_for_currency : Bool? = nil, expand : Array(String)? = nil, external_account : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_account_external_accounts(bank_account: bank_account, default_for_currency: default_for_currency, expand: expand, external_account: external_account).execute(&block)
    end

    POST_ACCOUNT_EXTERNAL_ACCOUNTS_MAX_LENGTH_FOR_EXTERNAL_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_post_account_external_accounts(*, bank_account : Stripe::PostAccountRequestBankAccount? = nil, default_for_currency : Bool? = nil, expand : Array(String)? = nil, external_account : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_account_external_accounts ..." }
      end

      if client_side_validation
        if _bank_account = bank_account
          _bank_account.validate if _bank_account.is_a?(OpenApi::Validatable)
        end

        if _external_account = external_account
          OpenApi::PrimitiveValidator.validate_max_length("external_account", external_account.to_s.size, POST_ACCOUNT_EXTERNAL_ACCOUNTS_MAX_LENGTH_FOR_EXTERNAL_ACCOUNT)
        end
      end

      # resource path
      local_var_path = "/v1/account/external_accounts"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["bank_account"] = bank_account.to_s if !bank_account.nil?
      form_params["default_for_currency"] = default_for_currency.to_s if !default_for_currency.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["external_account"] = external_account.to_s if !external_account.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_account_external_accounts",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the metadata, account holder name, account holder type of a bank account belonging to a <a href=\"/docs/connect/custom-accounts\">Custom account</a>, and optionally sets it as the default for its currency. Other bank account details are not editable by design.</p>  <p>You can re-enable a disabled bank account by performing an update call without providing any arguments or changes.</p>
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param account_type [String?] The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param default_for_currency [Bool?] When set to true, this becomes the default external account for its currency.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @return [ExternalAccount]
    def post_account_external_accounts_id(*, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, account_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, default_for_currency : Bool? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil)
      data, _status_code, _headers = post_account_external_accounts_id_with_http_info(id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, account_type: account_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, default_for_currency: default_for_currency, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name)
      data
    end

    # &lt;p&gt;Updates the metadata, account holder name, account holder type of a bank account belonging to a &lt;a href&#x3D;\&quot;/docs/connect/custom-accounts\&quot;&gt;Custom account&lt;/a&gt;, and optionally sets it as the default for its currency. Other bank account details are not editable by design.&lt;/p&gt;  &lt;p&gt;You can re-enable a disabled bank account by performing an update call without providing any arguments or changes.&lt;/p&gt;
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param account_type [String?] The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param default_for_currency [Bool?] When set to true, this becomes the default external account for its currency.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @return [Array<(ExternalAccount, Integer, Hash)>] ExternalAccount data, response status code and response headers
    def post_account_external_accounts_id_with_http_info(*, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, account_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, default_for_currency : Bool? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil)
      request = build_api_request_for_post_account_external_accounts_id(id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, account_type: account_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, default_for_currency: default_for_currency, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_account_external_accounts_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ExternalAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the metadata, account holder name, account holder type of a bank account belonging to a &lt;a href&#x3D;\&quot;/docs/connect/custom-accounts\&quot;&gt;Custom account&lt;/a&gt;, and optionally sets it as the default for its currency. Other bank account details are not editable by design.&lt;/p&gt;  &lt;p&gt;You can re-enable a disabled bank account by performing an update call without providing any arguments or changes.&lt;/p&gt;
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param account_type [String?] The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param default_for_currency [Bool?] When set to true, this becomes the default external account for its currency.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @return nil
    def post_account_external_accounts_id(*, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, account_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, default_for_currency : Bool? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_account_external_accounts_id(id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, account_type: account_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, default_for_currency: default_for_currency, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name).execute(&block)
    end

    POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_NAME   = 5000
    POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_TYPE   = 5000
    POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_VALID_VALUES_FOR_ACCOUNT_HOLDER_TYPE = StaticArray["", "company", "individual"]
    POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT_TYPE          = 5000
    POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_VALID_VALUES_FOR_ACCOUNT_TYPE        = StaticArray["checking", "futsu", "savings", "toza"]
    POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_CITY          = 5000
    POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_COUNTRY       = 5000
    POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_LINE1         = 5000
    POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_LINE2         = 5000
    POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_STATE         = 5000
    POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_ZIP           = 5000
    POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_EXP_MONTH             = 5000
    POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_EXP_YEAR              = 5000
    POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_NAME                  = 5000

    # @return Crest::Request
    def build_api_request_for_post_account_external_accounts_id(*, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, account_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, default_for_currency : Bool? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_account_external_accounts_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?

        if _account_holder_name = account_holder_name
          OpenApi::PrimitiveValidator.validate_max_length("account_holder_name", account_holder_name.to_s.size, POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_NAME)
        end
        if _account_holder_type = account_holder_type
          OpenApi::EnumValidator.validate("account_holder_type", _account_holder_type, POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_VALID_VALUES_FOR_ACCOUNT_HOLDER_TYPE)
        end
        if _account_type = account_type
          OpenApi::EnumValidator.validate("account_type", _account_type, POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_VALID_VALUES_FOR_ACCOUNT_TYPE)
        end
        if _address_city = address_city
          OpenApi::PrimitiveValidator.validate_max_length("address_city", address_city.to_s.size, POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_CITY)
        end
        if _address_country = address_country
          OpenApi::PrimitiveValidator.validate_max_length("address_country", address_country.to_s.size, POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_COUNTRY)
        end
        if _address_line1 = address_line1
          OpenApi::PrimitiveValidator.validate_max_length("address_line1", address_line1.to_s.size, POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_LINE1)
        end
        if _address_line2 = address_line2
          OpenApi::PrimitiveValidator.validate_max_length("address_line2", address_line2.to_s.size, POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_LINE2)
        end
        if _address_state = address_state
          OpenApi::PrimitiveValidator.validate_max_length("address_state", address_state.to_s.size, POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_STATE)
        end
        if _address_zip = address_zip
          OpenApi::PrimitiveValidator.validate_max_length("address_zip", address_zip.to_s.size, POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_ZIP)
        end

        if _exp_month = exp_month
          OpenApi::PrimitiveValidator.validate_max_length("exp_month", exp_month.to_s.size, POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_EXP_MONTH)
        end
        if _exp_year = exp_year
          OpenApi::PrimitiveValidator.validate_max_length("exp_year", exp_year.to_s.size, POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_EXP_YEAR)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _name = name
          OpenApi::PrimitiveValidator.validate_max_length("name", name.to_s.size, POST_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_NAME)
        end
      end

      # resource path
      local_var_path = "/v1/account/external_accounts/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account_holder_name"] = account_holder_name.to_s if !account_holder_name.nil?
      form_params["account_holder_type"] = account_holder_type.to_s if !account_holder_type.nil?
      form_params["account_type"] = account_type.to_s if !account_type.nil?
      form_params["address_city"] = address_city.to_s if !address_city.nil?
      form_params["address_country"] = address_country.to_s if !address_country.nil?
      form_params["address_line1"] = address_line1.to_s if !address_line1.nil?
      form_params["address_line2"] = address_line2.to_s if !address_line2.nil?
      form_params["address_state"] = address_state.to_s if !address_state.nil?
      form_params["address_zip"] = address_zip.to_s if !address_zip.nil?
      form_params["default_for_currency"] = default_for_currency.to_s if !default_for_currency.nil?
      form_params["exp_month"] = exp_month.to_s if !exp_month.nil?
      form_params["exp_year"] = exp_year.to_s if !exp_year.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["name"] = name.to_s if !name.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_account_external_accounts_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates an AccountLink object that includes a single-use Stripe URL that the platform can redirect their user to in order to take them through the Connect Onboarding flow.</p>
    # @param account [String?] The identifier of the account to create an account link for.
    # @param _type [String?] The type of account link the user is requesting. Possible values are `account_onboarding` or `account_update`.
    # @optional @param collect [String?] Which information the platform needs to collect from the user. One of `currently_due` or `eventually_due`. Default is `currently_due`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param refresh_url [String?] The URL the user will be redirected to if the account link is expired, has been previously-visited, or is otherwise invalid. The URL you specify should attempt to generate a new account link with the same parameters used to create the original account link, then redirect the user to the new account link's URL so they can continue with Connect Onboarding. If a new account link cannot be generated or the redirect fails you should display a useful error to the user.
    # @optional @param return_url [String?] The URL that the user will be redirected to upon leaving or completing the linked flow.
    # @return [AccountLink]
    def post_account_links(*, account : String? = nil, _type : String? = nil, collect : String? = nil, expand : Array(String)? = nil, refresh_url : String? = nil, return_url : String? = nil)
      data, _status_code, _headers = post_account_links_with_http_info(account: account, _type: _type, collect: collect, expand: expand, refresh_url: refresh_url, return_url: return_url)
      data
    end

    # &lt;p&gt;Creates an AccountLink object that includes a single-use Stripe URL that the platform can redirect their user to in order to take them through the Connect Onboarding flow.&lt;/p&gt;
    # @param account [String?] The identifier of the account to create an account link for.
    # @param _type [String?] The type of account link the user is requesting. Possible values are `account_onboarding` or `account_update`.
    # @optional @param collect [String?] Which information the platform needs to collect from the user. One of `currently_due` or `eventually_due`. Default is `currently_due`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param refresh_url [String?] The URL the user will be redirected to if the account link is expired, has been previously-visited, or is otherwise invalid. The URL you specify should attempt to generate a new account link with the same parameters used to create the original account link, then redirect the user to the new account link's URL so they can continue with Connect Onboarding. If a new account link cannot be generated or the redirect fails you should display a useful error to the user.
    # @optional @param return_url [String?] The URL that the user will be redirected to upon leaving or completing the linked flow.
    # @return [Array<(AccountLink, Integer, Hash)>] AccountLink data, response status code and response headers
    def post_account_links_with_http_info(*, account : String? = nil, _type : String? = nil, collect : String? = nil, expand : Array(String)? = nil, refresh_url : String? = nil, return_url : String? = nil)
      request = build_api_request_for_post_account_links(account: account, _type: _type, collect: collect, expand: expand, refresh_url: refresh_url, return_url: return_url)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_account_links\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return AccountLink.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates an AccountLink object that includes a single-use Stripe URL that the platform can redirect their user to in order to take them through the Connect Onboarding flow.&lt;/p&gt;
    # @param account [String?] The identifier of the account to create an account link for.
    # @param _type [String?] The type of account link the user is requesting. Possible values are `account_onboarding` or `account_update`.
    # @optional @param collect [String?] Which information the platform needs to collect from the user. One of `currently_due` or `eventually_due`. Default is `currently_due`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param refresh_url [String?] The URL the user will be redirected to if the account link is expired, has been previously-visited, or is otherwise invalid. The URL you specify should attempt to generate a new account link with the same parameters used to create the original account link, then redirect the user to the new account link's URL so they can continue with Connect Onboarding. If a new account link cannot be generated or the redirect fails you should display a useful error to the user.
    # @optional @param return_url [String?] The URL that the user will be redirected to upon leaving or completing the linked flow.
    # @return nil
    def post_account_links(*, account : String? = nil, _type : String? = nil, collect : String? = nil, expand : Array(String)? = nil, refresh_url : String? = nil, return_url : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_account_links(account: account, _type: _type, collect: collect, expand: expand, refresh_url: refresh_url, return_url: return_url).execute(&block)
    end

    POST_ACCOUNT_LINKS_MAX_LENGTH_FOR_ACCOUNT   = 5000
    POST_ACCOUNT_LINKS_VALID_VALUES_FOR__TYPE   = StaticArray["account_onboarding", "account_update"]
    POST_ACCOUNT_LINKS_VALID_VALUES_FOR_COLLECT = StaticArray["currently_due", "eventually_due"]

    # @return Crest::Request
    def build_api_request_for_post_account_links(*, account : String? = nil, _type : String? = nil, collect : String? = nil, expand : Array(String)? = nil, refresh_url : String? = nil, return_url : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_account_links ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_ACCOUNT_LINKS_MAX_LENGTH_FOR_ACCOUNT)
        end
        raise ArgumentError.new("\"_type\" is required and cannot be null") if _type.nil?
        if __type = _type
          OpenApi::EnumValidator.validate("_type", __type, POST_ACCOUNT_LINKS_VALID_VALUES_FOR__TYPE)
        end
        if _collect = collect
          OpenApi::EnumValidator.validate("collect", _collect, POST_ACCOUNT_LINKS_VALID_VALUES_FOR_COLLECT)
        end
      end

      # resource path
      local_var_path = "/v1/account_links"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account"] = account.to_s if !account.nil?
      form_params["collect"] = collect.to_s if !collect.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["refresh_url"] = refresh_url.to_s if !refresh_url.nil?
      form_params["return_url"] = return_url.to_s if !return_url.nil?
      form_params["type"] = _type.to_s if !_type.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_account_links",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a single-use login link for an Express account to access their Stripe dashboard.</p>  <p><strong>You may only create login links for <a href=\"/docs/connect/express-accounts\">Express accounts</a> connected to your platform</strong>.</p>
    # @param account [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [LoginLink]
    def post_account_login_links(*, account : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_account_login_links_with_http_info(account: account, expand: expand)
      data
    end

    # &lt;p&gt;Creates a single-use login link for an Express account to access their Stripe dashboard.&lt;/p&gt;  &lt;p&gt;&lt;strong&gt;You may only create login links for &lt;a href&#x3D;\&quot;/docs/connect/express-accounts\&quot;&gt;Express accounts&lt;/a&gt; connected to your platform&lt;/strong&gt;.&lt;/p&gt;
    # @param account [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(LoginLink, Integer, Hash)>] LoginLink data, response status code and response headers
    def post_account_login_links_with_http_info(*, account : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_account_login_links(account: account, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_account_login_links\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return LoginLink.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a single-use login link for an Express account to access their Stripe dashboard.&lt;/p&gt;  &lt;p&gt;&lt;strong&gt;You may only create login links for &lt;a href&#x3D;\&quot;/docs/connect/express-accounts\&quot;&gt;Express accounts&lt;/a&gt; connected to your platform&lt;/strong&gt;.&lt;/p&gt;
    # @param account [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_account_login_links(*, account : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_account_login_links(account: account, expand: expand).execute(&block)
    end

    POST_ACCOUNT_LOGIN_LINKS_MAX_LENGTH_FOR_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_post_account_login_links(*, account : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_account_login_links ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_ACCOUNT_LOGIN_LINKS_MAX_LENGTH_FOR_ACCOUNT)
        end
      end

      # resource path
      local_var_path = "/v1/account/login_links"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account"] = account.to_s if !account.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_account_login_links",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new person.</p>
    # @optional @param account [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return [Person]
    def post_account_people(*, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil)
      data, _status_code, _headers = post_account_people_with_http_info(account: account, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification)
      data
    end

    # &lt;p&gt;Creates a new person.&lt;/p&gt;
    # @optional @param account [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return [Array<(Person, Integer, Hash)>] Person data, response status code and response headers
    def post_account_people_with_http_info(*, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil)
      request = build_api_request_for_post_account_people(account: account, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_account_people\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Person.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new person.&lt;/p&gt;
    # @optional @param account [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return nil
    def post_account_people(*, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil, &block : Crest::Response ->)
      build_api_request_for_post_account_people(account: account, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification).execute(&block)
    end

    POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_ACCOUNT             = 5000
    POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_FIRST_NAME          = 5000
    POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_FIRST_NAME_KANA     = 5000
    POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_FIRST_NAME_KANJI    = 5000
    POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_ID_NUMBER           = 5000
    POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_ID_NUMBER_SECONDARY = 5000
    POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_LAST_NAME           = 5000
    POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_LAST_NAME_KANA      = 5000
    POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_LAST_NAME_KANJI     = 5000
    POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_MAIDEN_NAME         = 5000
    POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_NATIONALITY         = 5000
    POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_PERSON_TOKEN        = 5000
    POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_POLITICAL_EXPOSURE  = 5000

    # @return Crest::Request
    def build_api_request_for_post_account_people(*, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_account_people ..." }
      end

      if client_side_validation
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_ACCOUNT)
        end
        if _address = address
          _address.validate if _address.is_a?(OpenApi::Validatable)
        end
        if _address_kana = address_kana
          _address_kana.validate if _address_kana.is_a?(OpenApi::Validatable)
        end
        if _address_kanji = address_kanji
          _address_kanji.validate if _address_kanji.is_a?(OpenApi::Validatable)
        end
        if _dob = dob
          _dob.validate if _dob.is_a?(OpenApi::Validatable)
        end
        if _documents = documents
          _documents.validate if _documents.is_a?(OpenApi::Validatable)
        end

        if _first_name = first_name
          OpenApi::PrimitiveValidator.validate_max_length("first_name", first_name.to_s.size, POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_FIRST_NAME)
        end
        if _first_name_kana = first_name_kana
          OpenApi::PrimitiveValidator.validate_max_length("first_name_kana", first_name_kana.to_s.size, POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_FIRST_NAME_KANA)
        end
        if _first_name_kanji = first_name_kanji
          OpenApi::PrimitiveValidator.validate_max_length("first_name_kanji", first_name_kanji.to_s.size, POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_FIRST_NAME_KANJI)
        end
        if _full_name_aliases = full_name_aliases
          _full_name_aliases.validate if _full_name_aliases.is_a?(OpenApi::Validatable)
        end

        if _id_number = id_number
          OpenApi::PrimitiveValidator.validate_max_length("id_number", id_number.to_s.size, POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_ID_NUMBER)
        end
        if _id_number_secondary = id_number_secondary
          OpenApi::PrimitiveValidator.validate_max_length("id_number_secondary", id_number_secondary.to_s.size, POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_ID_NUMBER_SECONDARY)
        end
        if _last_name = last_name
          OpenApi::PrimitiveValidator.validate_max_length("last_name", last_name.to_s.size, POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_LAST_NAME)
        end
        if _last_name_kana = last_name_kana
          OpenApi::PrimitiveValidator.validate_max_length("last_name_kana", last_name_kana.to_s.size, POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_LAST_NAME_KANA)
        end
        if _last_name_kanji = last_name_kanji
          OpenApi::PrimitiveValidator.validate_max_length("last_name_kanji", last_name_kanji.to_s.size, POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_LAST_NAME_KANJI)
        end
        if _maiden_name = maiden_name
          OpenApi::PrimitiveValidator.validate_max_length("maiden_name", maiden_name.to_s.size, POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_MAIDEN_NAME)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _nationality = nationality
          OpenApi::PrimitiveValidator.validate_max_length("nationality", nationality.to_s.size, POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_NATIONALITY)
        end
        if _person_token = person_token
          OpenApi::PrimitiveValidator.validate_max_length("person_token", person_token.to_s.size, POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_PERSON_TOKEN)
        end

        if _political_exposure = political_exposure
          OpenApi::PrimitiveValidator.validate_max_length("political_exposure", political_exposure.to_s.size, POST_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_POLITICAL_EXPOSURE)
        end
        if _registered_address = registered_address
          _registered_address.validate if _registered_address.is_a?(OpenApi::Validatable)
        end
        if _relationship = relationship
          _relationship.validate if _relationship.is_a?(OpenApi::Validatable)
        end

        if _verification = verification
          _verification.validate if _verification.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/account/people"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account"] = account.to_s if !account.nil?
      form_params["address"] = address.to_s if !address.nil?
      form_params["address_kana"] = address_kana.to_s if !address_kana.nil?
      form_params["address_kanji"] = address_kanji.to_s if !address_kanji.nil?
      form_params["dob"] = dob.to_s if !dob.nil?
      form_params["documents"] = documents.to_s if !documents.nil?
      form_params["email"] = email.to_s if !email.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["first_name"] = first_name.to_s if !first_name.nil?
      form_params["first_name_kana"] = first_name_kana.to_s if !first_name_kana.nil?
      form_params["first_name_kanji"] = first_name_kanji.to_s if !first_name_kanji.nil?
      form_params["full_name_aliases"] = full_name_aliases.to_s if !full_name_aliases.nil?
      form_params["gender"] = gender.to_s if !gender.nil?
      form_params["id_number"] = id_number.to_s if !id_number.nil?
      form_params["id_number_secondary"] = id_number_secondary.to_s if !id_number_secondary.nil?
      form_params["last_name"] = last_name.to_s if !last_name.nil?
      form_params["last_name_kana"] = last_name_kana.to_s if !last_name_kana.nil?
      form_params["last_name_kanji"] = last_name_kanji.to_s if !last_name_kanji.nil?
      form_params["maiden_name"] = maiden_name.to_s if !maiden_name.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["nationality"] = nationality.to_s if !nationality.nil?
      form_params["person_token"] = person_token.to_s if !person_token.nil?
      form_params["phone"] = phone.to_s if !phone.nil?
      form_params["political_exposure"] = political_exposure.to_s if !political_exposure.nil?
      form_params["registered_address"] = registered_address.to_s if !registered_address.nil?
      form_params["relationship"] = relationship.to_s if !relationship.nil?
      form_params["ssn_last_4"] = ssn_last_4.to_s if !ssn_last_4.nil?
      form_params["verification"] = verification.to_s if !verification.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_account_people",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates an existing person.</p>
    # @param person [String?]
    # @optional @param account [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return [Person]
    def post_account_people_person(*, person : String? = nil, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil)
      data, _status_code, _headers = post_account_people_person_with_http_info(person: person, account: account, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification)
      data
    end

    # &lt;p&gt;Updates an existing person.&lt;/p&gt;
    # @param person [String?]
    # @optional @param account [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return [Array<(Person, Integer, Hash)>] Person data, response status code and response headers
    def post_account_people_person_with_http_info(*, person : String? = nil, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil)
      request = build_api_request_for_post_account_people_person(person: person, account: account, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_account_people_person\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Person.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates an existing person.&lt;/p&gt;
    # @param person [String?]
    # @optional @param account [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return nil
    def post_account_people_person(*, person : String? = nil, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil, &block : Crest::Response ->)
      build_api_request_for_post_account_people_person(person: person, account: account, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification).execute(&block)
    end

    POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_PERSON              = 5000
    POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_ACCOUNT             = 5000
    POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_FIRST_NAME          = 5000
    POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_FIRST_NAME_KANA     = 5000
    POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_FIRST_NAME_KANJI    = 5000
    POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_ID_NUMBER           = 5000
    POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_ID_NUMBER_SECONDARY = 5000
    POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_LAST_NAME           = 5000
    POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_LAST_NAME_KANA      = 5000
    POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_LAST_NAME_KANJI     = 5000
    POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_MAIDEN_NAME         = 5000
    POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_NATIONALITY         = 5000
    POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_PERSON_TOKEN        = 5000
    POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_POLITICAL_EXPOSURE  = 5000

    # @return Crest::Request
    def build_api_request_for_post_account_people_person(*, person : String? = nil, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_account_people_person ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"person\" is required and cannot be null") if person.nil?
        if _person = person
          OpenApi::PrimitiveValidator.validate_max_length("person", person.to_s.size, POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_PERSON)
        end
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_ACCOUNT)
        end
        if _address = address
          _address.validate if _address.is_a?(OpenApi::Validatable)
        end
        if _address_kana = address_kana
          _address_kana.validate if _address_kana.is_a?(OpenApi::Validatable)
        end
        if _address_kanji = address_kanji
          _address_kanji.validate if _address_kanji.is_a?(OpenApi::Validatable)
        end
        if _dob = dob
          _dob.validate if _dob.is_a?(OpenApi::Validatable)
        end
        if _documents = documents
          _documents.validate if _documents.is_a?(OpenApi::Validatable)
        end

        if _first_name = first_name
          OpenApi::PrimitiveValidator.validate_max_length("first_name", first_name.to_s.size, POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_FIRST_NAME)
        end
        if _first_name_kana = first_name_kana
          OpenApi::PrimitiveValidator.validate_max_length("first_name_kana", first_name_kana.to_s.size, POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_FIRST_NAME_KANA)
        end
        if _first_name_kanji = first_name_kanji
          OpenApi::PrimitiveValidator.validate_max_length("first_name_kanji", first_name_kanji.to_s.size, POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_FIRST_NAME_KANJI)
        end
        if _full_name_aliases = full_name_aliases
          _full_name_aliases.validate if _full_name_aliases.is_a?(OpenApi::Validatable)
        end

        if _id_number = id_number
          OpenApi::PrimitiveValidator.validate_max_length("id_number", id_number.to_s.size, POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_ID_NUMBER)
        end
        if _id_number_secondary = id_number_secondary
          OpenApi::PrimitiveValidator.validate_max_length("id_number_secondary", id_number_secondary.to_s.size, POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_ID_NUMBER_SECONDARY)
        end
        if _last_name = last_name
          OpenApi::PrimitiveValidator.validate_max_length("last_name", last_name.to_s.size, POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_LAST_NAME)
        end
        if _last_name_kana = last_name_kana
          OpenApi::PrimitiveValidator.validate_max_length("last_name_kana", last_name_kana.to_s.size, POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_LAST_NAME_KANA)
        end
        if _last_name_kanji = last_name_kanji
          OpenApi::PrimitiveValidator.validate_max_length("last_name_kanji", last_name_kanji.to_s.size, POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_LAST_NAME_KANJI)
        end
        if _maiden_name = maiden_name
          OpenApi::PrimitiveValidator.validate_max_length("maiden_name", maiden_name.to_s.size, POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_MAIDEN_NAME)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _nationality = nationality
          OpenApi::PrimitiveValidator.validate_max_length("nationality", nationality.to_s.size, POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_NATIONALITY)
        end
        if _person_token = person_token
          OpenApi::PrimitiveValidator.validate_max_length("person_token", person_token.to_s.size, POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_PERSON_TOKEN)
        end

        if _political_exposure = political_exposure
          OpenApi::PrimitiveValidator.validate_max_length("political_exposure", political_exposure.to_s.size, POST_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_POLITICAL_EXPOSURE)
        end
        if _registered_address = registered_address
          _registered_address.validate if _registered_address.is_a?(OpenApi::Validatable)
        end
        if _relationship = relationship
          _relationship.validate if _relationship.is_a?(OpenApi::Validatable)
        end

        if _verification = verification
          _verification.validate if _verification.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/account/people/{person}".sub("{" + "person" + "}", URI.encode_path(person.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account"] = account.to_s if !account.nil?
      form_params["address"] = address.to_s if !address.nil?
      form_params["address_kana"] = address_kana.to_s if !address_kana.nil?
      form_params["address_kanji"] = address_kanji.to_s if !address_kanji.nil?
      form_params["dob"] = dob.to_s if !dob.nil?
      form_params["documents"] = documents.to_s if !documents.nil?
      form_params["email"] = email.to_s if !email.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["first_name"] = first_name.to_s if !first_name.nil?
      form_params["first_name_kana"] = first_name_kana.to_s if !first_name_kana.nil?
      form_params["first_name_kanji"] = first_name_kanji.to_s if !first_name_kanji.nil?
      form_params["full_name_aliases"] = full_name_aliases.to_s if !full_name_aliases.nil?
      form_params["gender"] = gender.to_s if !gender.nil?
      form_params["id_number"] = id_number.to_s if !id_number.nil?
      form_params["id_number_secondary"] = id_number_secondary.to_s if !id_number_secondary.nil?
      form_params["last_name"] = last_name.to_s if !last_name.nil?
      form_params["last_name_kana"] = last_name_kana.to_s if !last_name_kana.nil?
      form_params["last_name_kanji"] = last_name_kanji.to_s if !last_name_kanji.nil?
      form_params["maiden_name"] = maiden_name.to_s if !maiden_name.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["nationality"] = nationality.to_s if !nationality.nil?
      form_params["person_token"] = person_token.to_s if !person_token.nil?
      form_params["phone"] = phone.to_s if !phone.nil?
      form_params["political_exposure"] = political_exposure.to_s if !political_exposure.nil?
      form_params["registered_address"] = registered_address.to_s if !registered_address.nil?
      form_params["relationship"] = relationship.to_s if !relationship.nil?
      form_params["ssn_last_4"] = ssn_last_4.to_s if !ssn_last_4.nil?
      form_params["verification"] = verification.to_s if !verification.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_account_people_person",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new person.</p>
    # @optional @param account [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return [Person]
    def post_account_persons(*, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil)
      data, _status_code, _headers = post_account_persons_with_http_info(account: account, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification)
      data
    end

    # &lt;p&gt;Creates a new person.&lt;/p&gt;
    # @optional @param account [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return [Array<(Person, Integer, Hash)>] Person data, response status code and response headers
    def post_account_persons_with_http_info(*, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil)
      request = build_api_request_for_post_account_persons(account: account, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_account_persons\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Person.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new person.&lt;/p&gt;
    # @optional @param account [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return nil
    def post_account_persons(*, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil, &block : Crest::Response ->)
      build_api_request_for_post_account_persons(account: account, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification).execute(&block)
    end

    POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_ACCOUNT             = 5000
    POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_FIRST_NAME          = 5000
    POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_FIRST_NAME_KANA     = 5000
    POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_FIRST_NAME_KANJI    = 5000
    POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_ID_NUMBER           = 5000
    POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_ID_NUMBER_SECONDARY = 5000
    POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_LAST_NAME           = 5000
    POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_LAST_NAME_KANA      = 5000
    POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_LAST_NAME_KANJI     = 5000
    POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_MAIDEN_NAME         = 5000
    POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_NATIONALITY         = 5000
    POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_PERSON_TOKEN        = 5000
    POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_POLITICAL_EXPOSURE  = 5000

    # @return Crest::Request
    def build_api_request_for_post_account_persons(*, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_account_persons ..." }
      end

      if client_side_validation
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_ACCOUNT)
        end
        if _address = address
          _address.validate if _address.is_a?(OpenApi::Validatable)
        end
        if _address_kana = address_kana
          _address_kana.validate if _address_kana.is_a?(OpenApi::Validatable)
        end
        if _address_kanji = address_kanji
          _address_kanji.validate if _address_kanji.is_a?(OpenApi::Validatable)
        end
        if _dob = dob
          _dob.validate if _dob.is_a?(OpenApi::Validatable)
        end
        if _documents = documents
          _documents.validate if _documents.is_a?(OpenApi::Validatable)
        end

        if _first_name = first_name
          OpenApi::PrimitiveValidator.validate_max_length("first_name", first_name.to_s.size, POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_FIRST_NAME)
        end
        if _first_name_kana = first_name_kana
          OpenApi::PrimitiveValidator.validate_max_length("first_name_kana", first_name_kana.to_s.size, POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_FIRST_NAME_KANA)
        end
        if _first_name_kanji = first_name_kanji
          OpenApi::PrimitiveValidator.validate_max_length("first_name_kanji", first_name_kanji.to_s.size, POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_FIRST_NAME_KANJI)
        end
        if _full_name_aliases = full_name_aliases
          _full_name_aliases.validate if _full_name_aliases.is_a?(OpenApi::Validatable)
        end

        if _id_number = id_number
          OpenApi::PrimitiveValidator.validate_max_length("id_number", id_number.to_s.size, POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_ID_NUMBER)
        end
        if _id_number_secondary = id_number_secondary
          OpenApi::PrimitiveValidator.validate_max_length("id_number_secondary", id_number_secondary.to_s.size, POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_ID_NUMBER_SECONDARY)
        end
        if _last_name = last_name
          OpenApi::PrimitiveValidator.validate_max_length("last_name", last_name.to_s.size, POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_LAST_NAME)
        end
        if _last_name_kana = last_name_kana
          OpenApi::PrimitiveValidator.validate_max_length("last_name_kana", last_name_kana.to_s.size, POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_LAST_NAME_KANA)
        end
        if _last_name_kanji = last_name_kanji
          OpenApi::PrimitiveValidator.validate_max_length("last_name_kanji", last_name_kanji.to_s.size, POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_LAST_NAME_KANJI)
        end
        if _maiden_name = maiden_name
          OpenApi::PrimitiveValidator.validate_max_length("maiden_name", maiden_name.to_s.size, POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_MAIDEN_NAME)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _nationality = nationality
          OpenApi::PrimitiveValidator.validate_max_length("nationality", nationality.to_s.size, POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_NATIONALITY)
        end
        if _person_token = person_token
          OpenApi::PrimitiveValidator.validate_max_length("person_token", person_token.to_s.size, POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_PERSON_TOKEN)
        end

        if _political_exposure = political_exposure
          OpenApi::PrimitiveValidator.validate_max_length("political_exposure", political_exposure.to_s.size, POST_ACCOUNT_PERSONS_MAX_LENGTH_FOR_POLITICAL_EXPOSURE)
        end
        if _registered_address = registered_address
          _registered_address.validate if _registered_address.is_a?(OpenApi::Validatable)
        end
        if _relationship = relationship
          _relationship.validate if _relationship.is_a?(OpenApi::Validatable)
        end

        if _verification = verification
          _verification.validate if _verification.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/account/persons"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account"] = account.to_s if !account.nil?
      form_params["address"] = address.to_s if !address.nil?
      form_params["address_kana"] = address_kana.to_s if !address_kana.nil?
      form_params["address_kanji"] = address_kanji.to_s if !address_kanji.nil?
      form_params["dob"] = dob.to_s if !dob.nil?
      form_params["documents"] = documents.to_s if !documents.nil?
      form_params["email"] = email.to_s if !email.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["first_name"] = first_name.to_s if !first_name.nil?
      form_params["first_name_kana"] = first_name_kana.to_s if !first_name_kana.nil?
      form_params["first_name_kanji"] = first_name_kanji.to_s if !first_name_kanji.nil?
      form_params["full_name_aliases"] = full_name_aliases.to_s if !full_name_aliases.nil?
      form_params["gender"] = gender.to_s if !gender.nil?
      form_params["id_number"] = id_number.to_s if !id_number.nil?
      form_params["id_number_secondary"] = id_number_secondary.to_s if !id_number_secondary.nil?
      form_params["last_name"] = last_name.to_s if !last_name.nil?
      form_params["last_name_kana"] = last_name_kana.to_s if !last_name_kana.nil?
      form_params["last_name_kanji"] = last_name_kanji.to_s if !last_name_kanji.nil?
      form_params["maiden_name"] = maiden_name.to_s if !maiden_name.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["nationality"] = nationality.to_s if !nationality.nil?
      form_params["person_token"] = person_token.to_s if !person_token.nil?
      form_params["phone"] = phone.to_s if !phone.nil?
      form_params["political_exposure"] = political_exposure.to_s if !political_exposure.nil?
      form_params["registered_address"] = registered_address.to_s if !registered_address.nil?
      form_params["relationship"] = relationship.to_s if !relationship.nil?
      form_params["ssn_last_4"] = ssn_last_4.to_s if !ssn_last_4.nil?
      form_params["verification"] = verification.to_s if !verification.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_account_persons",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates an existing person.</p>
    # @param person [String?]
    # @optional @param account [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return [Person]
    def post_account_persons_person(*, person : String? = nil, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil)
      data, _status_code, _headers = post_account_persons_person_with_http_info(person: person, account: account, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification)
      data
    end

    # &lt;p&gt;Updates an existing person.&lt;/p&gt;
    # @param person [String?]
    # @optional @param account [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return [Array<(Person, Integer, Hash)>] Person data, response status code and response headers
    def post_account_persons_person_with_http_info(*, person : String? = nil, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil)
      request = build_api_request_for_post_account_persons_person(person: person, account: account, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_account_persons_person\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Person.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates an existing person.&lt;/p&gt;
    # @param person [String?]
    # @optional @param account [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return nil
    def post_account_persons_person(*, person : String? = nil, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil, &block : Crest::Response ->)
      build_api_request_for_post_account_persons_person(person: person, account: account, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification).execute(&block)
    end

    POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_PERSON              = 5000
    POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_ACCOUNT             = 5000
    POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_FIRST_NAME          = 5000
    POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_FIRST_NAME_KANA     = 5000
    POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_FIRST_NAME_KANJI    = 5000
    POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_ID_NUMBER           = 5000
    POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_ID_NUMBER_SECONDARY = 5000
    POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_LAST_NAME           = 5000
    POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_LAST_NAME_KANA      = 5000
    POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_LAST_NAME_KANJI     = 5000
    POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_MAIDEN_NAME         = 5000
    POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_NATIONALITY         = 5000
    POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_PERSON_TOKEN        = 5000
    POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_POLITICAL_EXPOSURE  = 5000

    # @return Crest::Request
    def build_api_request_for_post_account_persons_person(*, person : String? = nil, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_account_persons_person ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"person\" is required and cannot be null") if person.nil?
        if _person = person
          OpenApi::PrimitiveValidator.validate_max_length("person", person.to_s.size, POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_PERSON)
        end
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_ACCOUNT)
        end
        if _address = address
          _address.validate if _address.is_a?(OpenApi::Validatable)
        end
        if _address_kana = address_kana
          _address_kana.validate if _address_kana.is_a?(OpenApi::Validatable)
        end
        if _address_kanji = address_kanji
          _address_kanji.validate if _address_kanji.is_a?(OpenApi::Validatable)
        end
        if _dob = dob
          _dob.validate if _dob.is_a?(OpenApi::Validatable)
        end
        if _documents = documents
          _documents.validate if _documents.is_a?(OpenApi::Validatable)
        end

        if _first_name = first_name
          OpenApi::PrimitiveValidator.validate_max_length("first_name", first_name.to_s.size, POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_FIRST_NAME)
        end
        if _first_name_kana = first_name_kana
          OpenApi::PrimitiveValidator.validate_max_length("first_name_kana", first_name_kana.to_s.size, POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_FIRST_NAME_KANA)
        end
        if _first_name_kanji = first_name_kanji
          OpenApi::PrimitiveValidator.validate_max_length("first_name_kanji", first_name_kanji.to_s.size, POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_FIRST_NAME_KANJI)
        end
        if _full_name_aliases = full_name_aliases
          _full_name_aliases.validate if _full_name_aliases.is_a?(OpenApi::Validatable)
        end

        if _id_number = id_number
          OpenApi::PrimitiveValidator.validate_max_length("id_number", id_number.to_s.size, POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_ID_NUMBER)
        end
        if _id_number_secondary = id_number_secondary
          OpenApi::PrimitiveValidator.validate_max_length("id_number_secondary", id_number_secondary.to_s.size, POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_ID_NUMBER_SECONDARY)
        end
        if _last_name = last_name
          OpenApi::PrimitiveValidator.validate_max_length("last_name", last_name.to_s.size, POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_LAST_NAME)
        end
        if _last_name_kana = last_name_kana
          OpenApi::PrimitiveValidator.validate_max_length("last_name_kana", last_name_kana.to_s.size, POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_LAST_NAME_KANA)
        end
        if _last_name_kanji = last_name_kanji
          OpenApi::PrimitiveValidator.validate_max_length("last_name_kanji", last_name_kanji.to_s.size, POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_LAST_NAME_KANJI)
        end
        if _maiden_name = maiden_name
          OpenApi::PrimitiveValidator.validate_max_length("maiden_name", maiden_name.to_s.size, POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_MAIDEN_NAME)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _nationality = nationality
          OpenApi::PrimitiveValidator.validate_max_length("nationality", nationality.to_s.size, POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_NATIONALITY)
        end
        if _person_token = person_token
          OpenApi::PrimitiveValidator.validate_max_length("person_token", person_token.to_s.size, POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_PERSON_TOKEN)
        end

        if _political_exposure = political_exposure
          OpenApi::PrimitiveValidator.validate_max_length("political_exposure", political_exposure.to_s.size, POST_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_POLITICAL_EXPOSURE)
        end
        if _registered_address = registered_address
          _registered_address.validate if _registered_address.is_a?(OpenApi::Validatable)
        end
        if _relationship = relationship
          _relationship.validate if _relationship.is_a?(OpenApi::Validatable)
        end

        if _verification = verification
          _verification.validate if _verification.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/account/persons/{person}".sub("{" + "person" + "}", URI.encode_path(person.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account"] = account.to_s if !account.nil?
      form_params["address"] = address.to_s if !address.nil?
      form_params["address_kana"] = address_kana.to_s if !address_kana.nil?
      form_params["address_kanji"] = address_kanji.to_s if !address_kanji.nil?
      form_params["dob"] = dob.to_s if !dob.nil?
      form_params["documents"] = documents.to_s if !documents.nil?
      form_params["email"] = email.to_s if !email.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["first_name"] = first_name.to_s if !first_name.nil?
      form_params["first_name_kana"] = first_name_kana.to_s if !first_name_kana.nil?
      form_params["first_name_kanji"] = first_name_kanji.to_s if !first_name_kanji.nil?
      form_params["full_name_aliases"] = full_name_aliases.to_s if !full_name_aliases.nil?
      form_params["gender"] = gender.to_s if !gender.nil?
      form_params["id_number"] = id_number.to_s if !id_number.nil?
      form_params["id_number_secondary"] = id_number_secondary.to_s if !id_number_secondary.nil?
      form_params["last_name"] = last_name.to_s if !last_name.nil?
      form_params["last_name_kana"] = last_name_kana.to_s if !last_name_kana.nil?
      form_params["last_name_kanji"] = last_name_kanji.to_s if !last_name_kanji.nil?
      form_params["maiden_name"] = maiden_name.to_s if !maiden_name.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["nationality"] = nationality.to_s if !nationality.nil?
      form_params["person_token"] = person_token.to_s if !person_token.nil?
      form_params["phone"] = phone.to_s if !phone.nil?
      form_params["political_exposure"] = political_exposure.to_s if !political_exposure.nil?
      form_params["registered_address"] = registered_address.to_s if !registered_address.nil?
      form_params["relationship"] = relationship.to_s if !relationship.nil?
      form_params["ssn_last_4"] = ssn_last_4.to_s if !ssn_last_4.nil?
      form_params["verification"] = verification.to_s if !verification.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_account_persons_person",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>With <a href=\"/docs/connect\">Connect</a>, you can create Stripe accounts for your users. To do this, you’ll first need to <a href=\"https://dashboard.stripe.com/account/applications/settings\">register your platform</a>.</p>
    # @optional @param account_token [String?] An [account token](https://stripe.com/docs/api#create_account_token), used to securely provide details to the account.
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param business_profile [Stripe::BusinessProfileSpecs?]
    # @optional @param business_type [String?] The business type.
    # @optional @param capabilities [Stripe::CapabilitiesParam?]
    # @optional @param company [Stripe::CompanySpecs?]
    # @optional @param country [String?] The country in which the account holder resides, or in which the business is legally established. This should be an ISO 3166-1 alpha-2 country code. For example, if you are in the United States and the business for which you're creating an account is legally represented in Canada, you would use `CA` as the country for the account being created. Available countries include [Stripe's global markets](https://stripe.com/global) as well as countries where [cross-border payouts](https://stripe.com/docs/connect/cross-border-payouts) are supported.
    # @optional @param default_currency [String?] Three-letter ISO currency code representing the default currency for the account. This must be a currency that [Stripe supports in the account's country](https://stripe.com/docs/payouts).
    # @optional @param documents [Stripe::DocumentsSpecs?]
    # @optional @param email [String?] The email address of the account holder. This is only to make the account easier to identify to you. Stripe only emails Custom accounts with your consent.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] A card or bank account to attach to the account for receiving [payouts](https://stripe.com/docs/connect/bank-debit-card-payouts) (you won’t be able to use it for top-ups). You can provide either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary, as documented in the `external_account` parameter for [bank account](https://stripe.com/docs/api#account_create_bank_account) creation. <br><br>By default, providing an external account sets it as the new default external account for its currency, and deletes the old default if one exists. To add additional external accounts without replacing the existing default for the currency, use the [bank account](https://stripe.com/docs/api#account_create_bank_account) or [card creation](https://stripe.com/docs/api#account_create_card) APIs.
    # @optional @param individual [Stripe::IndividualSpecs?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param settings [Stripe::SettingsSpecs?]
    # @optional @param tos_acceptance [Stripe::TosAcceptanceSpecs?]
    # @optional @param _type [String?] The type of Stripe account to create. May be one of `custom`, `express` or `standard`.
    # @return [Account]
    def post_accounts(*, account_token : String? = nil, bank_account : Stripe::PostAccountRequestBankAccount? = nil, business_profile : Stripe::BusinessProfileSpecs? = nil, business_type : String? = nil, capabilities : Stripe::CapabilitiesParam? = nil, company : Stripe::CompanySpecs? = nil, country : String? = nil, default_currency : String? = nil, documents : Stripe::DocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, external_account : String? = nil, individual : Stripe::IndividualSpecs? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, settings : Stripe::SettingsSpecs? = nil, tos_acceptance : Stripe::TosAcceptanceSpecs? = nil, _type : String? = nil)
      data, _status_code, _headers = post_accounts_with_http_info(account_token: account_token, bank_account: bank_account, business_profile: business_profile, business_type: business_type, capabilities: capabilities, company: company, country: country, default_currency: default_currency, documents: documents, email: email, expand: expand, external_account: external_account, individual: individual, metadata: metadata, settings: settings, tos_acceptance: tos_acceptance, _type: _type)
      data
    end

    # &lt;p&gt;With &lt;a href&#x3D;\&quot;/docs/connect\&quot;&gt;Connect&lt;/a&gt;, you can create Stripe accounts for your users. To do this, you’ll first need to &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/account/applications/settings\&quot;&gt;register your platform&lt;/a&gt;.&lt;/p&gt;
    # @optional @param account_token [String?] An [account token](https://stripe.com/docs/api#create_account_token), used to securely provide details to the account.
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param business_profile [Stripe::BusinessProfileSpecs?]
    # @optional @param business_type [String?] The business type.
    # @optional @param capabilities [Stripe::CapabilitiesParam?]
    # @optional @param company [Stripe::CompanySpecs?]
    # @optional @param country [String?] The country in which the account holder resides, or in which the business is legally established. This should be an ISO 3166-1 alpha-2 country code. For example, if you are in the United States and the business for which you're creating an account is legally represented in Canada, you would use `CA` as the country for the account being created. Available countries include [Stripe's global markets](https://stripe.com/global) as well as countries where [cross-border payouts](https://stripe.com/docs/connect/cross-border-payouts) are supported.
    # @optional @param default_currency [String?] Three-letter ISO currency code representing the default currency for the account. This must be a currency that [Stripe supports in the account's country](https://stripe.com/docs/payouts).
    # @optional @param documents [Stripe::DocumentsSpecs?]
    # @optional @param email [String?] The email address of the account holder. This is only to make the account easier to identify to you. Stripe only emails Custom accounts with your consent.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] A card or bank account to attach to the account for receiving [payouts](https://stripe.com/docs/connect/bank-debit-card-payouts) (you won’t be able to use it for top-ups). You can provide either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary, as documented in the `external_account` parameter for [bank account](https://stripe.com/docs/api#account_create_bank_account) creation. <br><br>By default, providing an external account sets it as the new default external account for its currency, and deletes the old default if one exists. To add additional external accounts without replacing the existing default for the currency, use the [bank account](https://stripe.com/docs/api#account_create_bank_account) or [card creation](https://stripe.com/docs/api#account_create_card) APIs.
    # @optional @param individual [Stripe::IndividualSpecs?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param settings [Stripe::SettingsSpecs?]
    # @optional @param tos_acceptance [Stripe::TosAcceptanceSpecs?]
    # @optional @param _type [String?] The type of Stripe account to create. May be one of `custom`, `express` or `standard`.
    # @return [Array<(Account, Integer, Hash)>] Account data, response status code and response headers
    def post_accounts_with_http_info(*, account_token : String? = nil, bank_account : Stripe::PostAccountRequestBankAccount? = nil, business_profile : Stripe::BusinessProfileSpecs? = nil, business_type : String? = nil, capabilities : Stripe::CapabilitiesParam? = nil, company : Stripe::CompanySpecs? = nil, country : String? = nil, default_currency : String? = nil, documents : Stripe::DocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, external_account : String? = nil, individual : Stripe::IndividualSpecs? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, settings : Stripe::SettingsSpecs? = nil, tos_acceptance : Stripe::TosAcceptanceSpecs? = nil, _type : String? = nil)
      request = build_api_request_for_post_accounts(account_token: account_token, bank_account: bank_account, business_profile: business_profile, business_type: business_type, capabilities: capabilities, company: company, country: country, default_currency: default_currency, documents: documents, email: email, expand: expand, external_account: external_account, individual: individual, metadata: metadata, settings: settings, tos_acceptance: tos_acceptance, _type: _type)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_accounts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Account.from_json(data), status_code, headers
    end

    # &lt;p&gt;With &lt;a href&#x3D;\&quot;/docs/connect\&quot;&gt;Connect&lt;/a&gt;, you can create Stripe accounts for your users. To do this, you’ll first need to &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/account/applications/settings\&quot;&gt;register your platform&lt;/a&gt;.&lt;/p&gt;
    # @optional @param account_token [String?] An [account token](https://stripe.com/docs/api#create_account_token), used to securely provide details to the account.
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param business_profile [Stripe::BusinessProfileSpecs?]
    # @optional @param business_type [String?] The business type.
    # @optional @param capabilities [Stripe::CapabilitiesParam?]
    # @optional @param company [Stripe::CompanySpecs?]
    # @optional @param country [String?] The country in which the account holder resides, or in which the business is legally established. This should be an ISO 3166-1 alpha-2 country code. For example, if you are in the United States and the business for which you're creating an account is legally represented in Canada, you would use `CA` as the country for the account being created. Available countries include [Stripe's global markets](https://stripe.com/global) as well as countries where [cross-border payouts](https://stripe.com/docs/connect/cross-border-payouts) are supported.
    # @optional @param default_currency [String?] Three-letter ISO currency code representing the default currency for the account. This must be a currency that [Stripe supports in the account's country](https://stripe.com/docs/payouts).
    # @optional @param documents [Stripe::DocumentsSpecs?]
    # @optional @param email [String?] The email address of the account holder. This is only to make the account easier to identify to you. Stripe only emails Custom accounts with your consent.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] A card or bank account to attach to the account for receiving [payouts](https://stripe.com/docs/connect/bank-debit-card-payouts) (you won’t be able to use it for top-ups). You can provide either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary, as documented in the `external_account` parameter for [bank account](https://stripe.com/docs/api#account_create_bank_account) creation. <br><br>By default, providing an external account sets it as the new default external account for its currency, and deletes the old default if one exists. To add additional external accounts without replacing the existing default for the currency, use the [bank account](https://stripe.com/docs/api#account_create_bank_account) or [card creation](https://stripe.com/docs/api#account_create_card) APIs.
    # @optional @param individual [Stripe::IndividualSpecs?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param settings [Stripe::SettingsSpecs?]
    # @optional @param tos_acceptance [Stripe::TosAcceptanceSpecs?]
    # @optional @param _type [String?] The type of Stripe account to create. May be one of `custom`, `express` or `standard`.
    # @return nil
    def post_accounts(*, account_token : String? = nil, bank_account : Stripe::PostAccountRequestBankAccount? = nil, business_profile : Stripe::BusinessProfileSpecs? = nil, business_type : String? = nil, capabilities : Stripe::CapabilitiesParam? = nil, company : Stripe::CompanySpecs? = nil, country : String? = nil, default_currency : String? = nil, documents : Stripe::DocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, external_account : String? = nil, individual : Stripe::IndividualSpecs? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, settings : Stripe::SettingsSpecs? = nil, tos_acceptance : Stripe::TosAcceptanceSpecs? = nil, _type : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_accounts(account_token: account_token, bank_account: bank_account, business_profile: business_profile, business_type: business_type, capabilities: capabilities, company: company, country: country, default_currency: default_currency, documents: documents, email: email, expand: expand, external_account: external_account, individual: individual, metadata: metadata, settings: settings, tos_acceptance: tos_acceptance, _type: _type).execute(&block)
    end

    POST_ACCOUNTS_MAX_LENGTH_FOR_ACCOUNT_TOKEN    = 5000
    POST_ACCOUNTS_VALID_VALUES_FOR_BUSINESS_TYPE  = StaticArray["company", "government_entity", "individual", "non_profit"]
    POST_ACCOUNTS_MAX_LENGTH_FOR_COUNTRY          = 5000
    POST_ACCOUNTS_MAX_LENGTH_FOR_EXTERNAL_ACCOUNT = 5000
    POST_ACCOUNTS_VALID_VALUES_FOR__TYPE          = StaticArray["custom", "express", "standard"]

    # @return Crest::Request
    def build_api_request_for_post_accounts(*, account_token : String? = nil, bank_account : Stripe::PostAccountRequestBankAccount? = nil, business_profile : Stripe::BusinessProfileSpecs? = nil, business_type : String? = nil, capabilities : Stripe::CapabilitiesParam? = nil, company : Stripe::CompanySpecs? = nil, country : String? = nil, default_currency : String? = nil, documents : Stripe::DocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, external_account : String? = nil, individual : Stripe::IndividualSpecs? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, settings : Stripe::SettingsSpecs? = nil, tos_acceptance : Stripe::TosAcceptanceSpecs? = nil, _type : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_accounts ..." }
      end

      if client_side_validation
        if _account_token = account_token
          OpenApi::PrimitiveValidator.validate_max_length("account_token", account_token.to_s.size, POST_ACCOUNTS_MAX_LENGTH_FOR_ACCOUNT_TOKEN)
        end
        if _bank_account = bank_account
          _bank_account.validate if _bank_account.is_a?(OpenApi::Validatable)
        end
        if _business_profile = business_profile
          _business_profile.validate if _business_profile.is_a?(OpenApi::Validatable)
        end
        if _business_type = business_type
          OpenApi::EnumValidator.validate("business_type", _business_type, POST_ACCOUNTS_VALID_VALUES_FOR_BUSINESS_TYPE)
        end
        if _capabilities = capabilities
          _capabilities.validate if _capabilities.is_a?(OpenApi::Validatable)
        end
        if _company = company
          _company.validate if _company.is_a?(OpenApi::Validatable)
        end
        if _country = country
          OpenApi::PrimitiveValidator.validate_max_length("country", country.to_s.size, POST_ACCOUNTS_MAX_LENGTH_FOR_COUNTRY)
        end

        if _documents = documents
          _documents.validate if _documents.is_a?(OpenApi::Validatable)
        end

        if _external_account = external_account
          OpenApi::PrimitiveValidator.validate_max_length("external_account", external_account.to_s.size, POST_ACCOUNTS_MAX_LENGTH_FOR_EXTERNAL_ACCOUNT)
        end
        if _individual = individual
          _individual.validate if _individual.is_a?(OpenApi::Validatable)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _settings = settings
          _settings.validate if _settings.is_a?(OpenApi::Validatable)
        end
        if _tos_acceptance = tos_acceptance
          _tos_acceptance.validate if _tos_acceptance.is_a?(OpenApi::Validatable)
        end
        if __type = _type
          OpenApi::EnumValidator.validate("_type", __type, POST_ACCOUNTS_VALID_VALUES_FOR__TYPE)
        end
      end

      # resource path
      local_var_path = "/v1/accounts"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account_token"] = account_token.to_s if !account_token.nil?
      form_params["bank_account"] = bank_account.to_s if !bank_account.nil?
      form_params["business_profile"] = business_profile.to_s if !business_profile.nil?
      form_params["business_type"] = business_type.to_s if !business_type.nil?
      form_params["capabilities"] = capabilities.to_s if !capabilities.nil?
      form_params["company"] = company.to_s if !company.nil?
      form_params["country"] = country.to_s if !country.nil?
      form_params["default_currency"] = default_currency.to_s if !default_currency.nil?
      form_params["documents"] = documents.to_s if !documents.nil?
      form_params["email"] = email.to_s if !email.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["external_account"] = external_account.to_s if !external_account.nil?
      form_params["individual"] = individual.to_s if !individual.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["settings"] = settings.to_s if !settings.nil?
      form_params["tos_acceptance"] = tos_acceptance.to_s if !tos_acceptance.nil?
      form_params["type"] = _type.to_s if !_type.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_accounts",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates a <a href=\"/docs/connect/accounts\">connected account</a> by setting the values of the parameters passed. Any parameters not provided are left unchanged. Most parameters can be changed only for Custom accounts. (These are marked <strong>Custom Only</strong> below.) Parameters marked <strong>Custom and Express</strong> are not supported for Standard accounts.</p>  <p>To update your own account, use the <a href=\"https://dashboard.stripe.com/account\">Dashboard</a>. Refer to our <a href=\"/docs/connect/updating-accounts\">Connect</a> documentation to learn more about updating accounts.</p>
    # @param account [String?]
    # @optional @param account_token [String?] An [account token](https://stripe.com/docs/api#create_account_token), used to securely provide details to the account.
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param business_profile [Stripe::BusinessProfileSpecs?]
    # @optional @param business_type [String?] The business type.
    # @optional @param capabilities [Stripe::CapabilitiesParam?]
    # @optional @param company [Stripe::CompanySpecs?]
    # @optional @param default_currency [String?] Three-letter ISO currency code representing the default currency for the account. This must be a currency that [Stripe supports in the account's country](https://stripe.com/docs/payouts).
    # @optional @param documents [Stripe::DocumentsSpecs?]
    # @optional @param email [String?] The email address of the account holder. This is only to make the account easier to identify to you. Stripe only emails Custom accounts with your consent.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] A card or bank account to attach to the account for receiving [payouts](https://stripe.com/docs/connect/bank-debit-card-payouts) (you won’t be able to use it for top-ups). You can provide either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary, as documented in the `external_account` parameter for [bank account](https://stripe.com/docs/api#account_create_bank_account) creation. <br><br>By default, providing an external account sets it as the new default external account for its currency, and deletes the old default if one exists. To add additional external accounts without replacing the existing default for the currency, use the [bank account](https://stripe.com/docs/api#account_create_bank_account) or [card creation](https://stripe.com/docs/api#account_create_card) APIs.
    # @optional @param individual [Stripe::IndividualSpecs?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param settings [Stripe::SettingsSpecsUpdate?]
    # @optional @param tos_acceptance [Stripe::TosAcceptanceSpecs?]
    # @return [Account]
    def post_accounts_account(*, account : String? = nil, account_token : String? = nil, bank_account : Stripe::PostAccountRequestBankAccount? = nil, business_profile : Stripe::BusinessProfileSpecs? = nil, business_type : String? = nil, capabilities : Stripe::CapabilitiesParam? = nil, company : Stripe::CompanySpecs? = nil, default_currency : String? = nil, documents : Stripe::DocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, external_account : String? = nil, individual : Stripe::IndividualSpecs? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, settings : Stripe::SettingsSpecsUpdate? = nil, tos_acceptance : Stripe::TosAcceptanceSpecs? = nil)
      data, _status_code, _headers = post_accounts_account_with_http_info(account: account, account_token: account_token, bank_account: bank_account, business_profile: business_profile, business_type: business_type, capabilities: capabilities, company: company, default_currency: default_currency, documents: documents, email: email, expand: expand, external_account: external_account, individual: individual, metadata: metadata, settings: settings, tos_acceptance: tos_acceptance)
      data
    end

    # &lt;p&gt;Updates a &lt;a href&#x3D;\&quot;/docs/connect/accounts\&quot;&gt;connected account&lt;/a&gt; by setting the values of the parameters passed. Any parameters not provided are left unchanged. Most parameters can be changed only for Custom accounts. (These are marked &lt;strong&gt;Custom Only&lt;/strong&gt; below.) Parameters marked &lt;strong&gt;Custom and Express&lt;/strong&gt; are not supported for Standard accounts.&lt;/p&gt;  &lt;p&gt;To update your own account, use the &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/account\&quot;&gt;Dashboard&lt;/a&gt;. Refer to our &lt;a href&#x3D;\&quot;/docs/connect/updating-accounts\&quot;&gt;Connect&lt;/a&gt; documentation to learn more about updating accounts.&lt;/p&gt;
    # @param account [String?]
    # @optional @param account_token [String?] An [account token](https://stripe.com/docs/api#create_account_token), used to securely provide details to the account.
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param business_profile [Stripe::BusinessProfileSpecs?]
    # @optional @param business_type [String?] The business type.
    # @optional @param capabilities [Stripe::CapabilitiesParam?]
    # @optional @param company [Stripe::CompanySpecs?]
    # @optional @param default_currency [String?] Three-letter ISO currency code representing the default currency for the account. This must be a currency that [Stripe supports in the account's country](https://stripe.com/docs/payouts).
    # @optional @param documents [Stripe::DocumentsSpecs?]
    # @optional @param email [String?] The email address of the account holder. This is only to make the account easier to identify to you. Stripe only emails Custom accounts with your consent.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] A card or bank account to attach to the account for receiving [payouts](https://stripe.com/docs/connect/bank-debit-card-payouts) (you won’t be able to use it for top-ups). You can provide either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary, as documented in the `external_account` parameter for [bank account](https://stripe.com/docs/api#account_create_bank_account) creation. <br><br>By default, providing an external account sets it as the new default external account for its currency, and deletes the old default if one exists. To add additional external accounts without replacing the existing default for the currency, use the [bank account](https://stripe.com/docs/api#account_create_bank_account) or [card creation](https://stripe.com/docs/api#account_create_card) APIs.
    # @optional @param individual [Stripe::IndividualSpecs?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param settings [Stripe::SettingsSpecsUpdate?]
    # @optional @param tos_acceptance [Stripe::TosAcceptanceSpecs?]
    # @return [Array<(Account, Integer, Hash)>] Account data, response status code and response headers
    def post_accounts_account_with_http_info(*, account : String? = nil, account_token : String? = nil, bank_account : Stripe::PostAccountRequestBankAccount? = nil, business_profile : Stripe::BusinessProfileSpecs? = nil, business_type : String? = nil, capabilities : Stripe::CapabilitiesParam? = nil, company : Stripe::CompanySpecs? = nil, default_currency : String? = nil, documents : Stripe::DocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, external_account : String? = nil, individual : Stripe::IndividualSpecs? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, settings : Stripe::SettingsSpecsUpdate? = nil, tos_acceptance : Stripe::TosAcceptanceSpecs? = nil)
      request = build_api_request_for_post_accounts_account(account: account, account_token: account_token, bank_account: bank_account, business_profile: business_profile, business_type: business_type, capabilities: capabilities, company: company, default_currency: default_currency, documents: documents, email: email, expand: expand, external_account: external_account, individual: individual, metadata: metadata, settings: settings, tos_acceptance: tos_acceptance)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_accounts_account\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Account.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates a &lt;a href&#x3D;\&quot;/docs/connect/accounts\&quot;&gt;connected account&lt;/a&gt; by setting the values of the parameters passed. Any parameters not provided are left unchanged. Most parameters can be changed only for Custom accounts. (These are marked &lt;strong&gt;Custom Only&lt;/strong&gt; below.) Parameters marked &lt;strong&gt;Custom and Express&lt;/strong&gt; are not supported for Standard accounts.&lt;/p&gt;  &lt;p&gt;To update your own account, use the &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/account\&quot;&gt;Dashboard&lt;/a&gt;. Refer to our &lt;a href&#x3D;\&quot;/docs/connect/updating-accounts\&quot;&gt;Connect&lt;/a&gt; documentation to learn more about updating accounts.&lt;/p&gt;
    # @param account [String?]
    # @optional @param account_token [String?] An [account token](https://stripe.com/docs/api#create_account_token), used to securely provide details to the account.
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param business_profile [Stripe::BusinessProfileSpecs?]
    # @optional @param business_type [String?] The business type.
    # @optional @param capabilities [Stripe::CapabilitiesParam?]
    # @optional @param company [Stripe::CompanySpecs?]
    # @optional @param default_currency [String?] Three-letter ISO currency code representing the default currency for the account. This must be a currency that [Stripe supports in the account's country](https://stripe.com/docs/payouts).
    # @optional @param documents [Stripe::DocumentsSpecs?]
    # @optional @param email [String?] The email address of the account holder. This is only to make the account easier to identify to you. Stripe only emails Custom accounts with your consent.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] A card or bank account to attach to the account for receiving [payouts](https://stripe.com/docs/connect/bank-debit-card-payouts) (you won’t be able to use it for top-ups). You can provide either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary, as documented in the `external_account` parameter for [bank account](https://stripe.com/docs/api#account_create_bank_account) creation. <br><br>By default, providing an external account sets it as the new default external account for its currency, and deletes the old default if one exists. To add additional external accounts without replacing the existing default for the currency, use the [bank account](https://stripe.com/docs/api#account_create_bank_account) or [card creation](https://stripe.com/docs/api#account_create_card) APIs.
    # @optional @param individual [Stripe::IndividualSpecs?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param settings [Stripe::SettingsSpecsUpdate?]
    # @optional @param tos_acceptance [Stripe::TosAcceptanceSpecs?]
    # @return nil
    def post_accounts_account(*, account : String? = nil, account_token : String? = nil, bank_account : Stripe::PostAccountRequestBankAccount? = nil, business_profile : Stripe::BusinessProfileSpecs? = nil, business_type : String? = nil, capabilities : Stripe::CapabilitiesParam? = nil, company : Stripe::CompanySpecs? = nil, default_currency : String? = nil, documents : Stripe::DocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, external_account : String? = nil, individual : Stripe::IndividualSpecs? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, settings : Stripe::SettingsSpecsUpdate? = nil, tos_acceptance : Stripe::TosAcceptanceSpecs? = nil, &block : Crest::Response ->)
      build_api_request_for_post_accounts_account(account: account, account_token: account_token, bank_account: bank_account, business_profile: business_profile, business_type: business_type, capabilities: capabilities, company: company, default_currency: default_currency, documents: documents, email: email, expand: expand, external_account: external_account, individual: individual, metadata: metadata, settings: settings, tos_acceptance: tos_acceptance).execute(&block)
    end

    POST_ACCOUNTS_ACCOUNT_MAX_LENGTH_FOR_ACCOUNT          = 5000
    POST_ACCOUNTS_ACCOUNT_MAX_LENGTH_FOR_ACCOUNT_TOKEN    = 5000
    POST_ACCOUNTS_ACCOUNT_VALID_VALUES_FOR_BUSINESS_TYPE  = StaticArray["company", "government_entity", "individual", "non_profit"]
    POST_ACCOUNTS_ACCOUNT_MAX_LENGTH_FOR_EXTERNAL_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_post_accounts_account(*, account : String? = nil, account_token : String? = nil, bank_account : Stripe::PostAccountRequestBankAccount? = nil, business_profile : Stripe::BusinessProfileSpecs? = nil, business_type : String? = nil, capabilities : Stripe::CapabilitiesParam? = nil, company : Stripe::CompanySpecs? = nil, default_currency : String? = nil, documents : Stripe::DocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, external_account : String? = nil, individual : Stripe::IndividualSpecs? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, settings : Stripe::SettingsSpecsUpdate? = nil, tos_acceptance : Stripe::TosAcceptanceSpecs? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_accounts_account ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_ACCOUNTS_ACCOUNT_MAX_LENGTH_FOR_ACCOUNT)
        end
        if _account_token = account_token
          OpenApi::PrimitiveValidator.validate_max_length("account_token", account_token.to_s.size, POST_ACCOUNTS_ACCOUNT_MAX_LENGTH_FOR_ACCOUNT_TOKEN)
        end
        if _bank_account = bank_account
          _bank_account.validate if _bank_account.is_a?(OpenApi::Validatable)
        end
        if _business_profile = business_profile
          _business_profile.validate if _business_profile.is_a?(OpenApi::Validatable)
        end
        if _business_type = business_type
          OpenApi::EnumValidator.validate("business_type", _business_type, POST_ACCOUNTS_ACCOUNT_VALID_VALUES_FOR_BUSINESS_TYPE)
        end
        if _capabilities = capabilities
          _capabilities.validate if _capabilities.is_a?(OpenApi::Validatable)
        end
        if _company = company
          _company.validate if _company.is_a?(OpenApi::Validatable)
        end

        if _documents = documents
          _documents.validate if _documents.is_a?(OpenApi::Validatable)
        end

        if _external_account = external_account
          OpenApi::PrimitiveValidator.validate_max_length("external_account", external_account.to_s.size, POST_ACCOUNTS_ACCOUNT_MAX_LENGTH_FOR_EXTERNAL_ACCOUNT)
        end
        if _individual = individual
          _individual.validate if _individual.is_a?(OpenApi::Validatable)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _settings = settings
          _settings.validate if _settings.is_a?(OpenApi::Validatable)
        end
        if _tos_acceptance = tos_acceptance
          _tos_acceptance.validate if _tos_acceptance.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account_token"] = account_token.to_s if !account_token.nil?
      form_params["bank_account"] = bank_account.to_s if !bank_account.nil?
      form_params["business_profile"] = business_profile.to_s if !business_profile.nil?
      form_params["business_type"] = business_type.to_s if !business_type.nil?
      form_params["capabilities"] = capabilities.to_s if !capabilities.nil?
      form_params["company"] = company.to_s if !company.nil?
      form_params["default_currency"] = default_currency.to_s if !default_currency.nil?
      form_params["documents"] = documents.to_s if !documents.nil?
      form_params["email"] = email.to_s if !email.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["external_account"] = external_account.to_s if !external_account.nil?
      form_params["individual"] = individual.to_s if !individual.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["settings"] = settings.to_s if !settings.nil?
      form_params["tos_acceptance"] = tos_acceptance.to_s if !tos_acceptance.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_accounts_account",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Create an external account for a given account.</p>
    # @param account [String?]
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param default_for_currency [Bool?] When set to true, or if this is the first external account added in this currency, this account becomes the default external account for its currency.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return [ExternalAccount]
    def post_accounts_account_bank_accounts(*, account : String? = nil, bank_account : Stripe::PostAccountRequestBankAccount? = nil, default_for_currency : Bool? = nil, expand : Array(String)? = nil, external_account : String? = nil)
      data, _status_code, _headers = post_accounts_account_bank_accounts_with_http_info(account: account, bank_account: bank_account, default_for_currency: default_for_currency, expand: expand, external_account: external_account)
      data
    end

    # &lt;p&gt;Create an external account for a given account.&lt;/p&gt;
    # @param account [String?]
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param default_for_currency [Bool?] When set to true, or if this is the first external account added in this currency, this account becomes the default external account for its currency.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return [Array<(ExternalAccount, Integer, Hash)>] ExternalAccount data, response status code and response headers
    def post_accounts_account_bank_accounts_with_http_info(*, account : String? = nil, bank_account : Stripe::PostAccountRequestBankAccount? = nil, default_for_currency : Bool? = nil, expand : Array(String)? = nil, external_account : String? = nil)
      request = build_api_request_for_post_accounts_account_bank_accounts(account: account, bank_account: bank_account, default_for_currency: default_for_currency, expand: expand, external_account: external_account)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_accounts_account_bank_accounts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ExternalAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Create an external account for a given account.&lt;/p&gt;
    # @param account [String?]
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param default_for_currency [Bool?] When set to true, or if this is the first external account added in this currency, this account becomes the default external account for its currency.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return nil
    def post_accounts_account_bank_accounts(*, account : String? = nil, bank_account : Stripe::PostAccountRequestBankAccount? = nil, default_for_currency : Bool? = nil, expand : Array(String)? = nil, external_account : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_accounts_account_bank_accounts(account: account, bank_account: bank_account, default_for_currency: default_for_currency, expand: expand, external_account: external_account).execute(&block)
    end

    POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_MAX_LENGTH_FOR_ACCOUNT          = 5000
    POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_MAX_LENGTH_FOR_EXTERNAL_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_post_accounts_account_bank_accounts(*, account : String? = nil, bank_account : Stripe::PostAccountRequestBankAccount? = nil, default_for_currency : Bool? = nil, expand : Array(String)? = nil, external_account : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_accounts_account_bank_accounts ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_MAX_LENGTH_FOR_ACCOUNT)
        end
        if _bank_account = bank_account
          _bank_account.validate if _bank_account.is_a?(OpenApi::Validatable)
        end

        if _external_account = external_account
          OpenApi::PrimitiveValidator.validate_max_length("external_account", external_account.to_s.size, POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_MAX_LENGTH_FOR_EXTERNAL_ACCOUNT)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/bank_accounts".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["bank_account"] = bank_account.to_s if !bank_account.nil?
      form_params["default_for_currency"] = default_for_currency.to_s if !default_for_currency.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["external_account"] = external_account.to_s if !external_account.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_accounts_account_bank_accounts",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the metadata, account holder name, account holder type of a bank account belonging to a <a href=\"/docs/connect/custom-accounts\">Custom account</a>, and optionally sets it as the default for its currency. Other bank account details are not editable by design.</p>  <p>You can re-enable a disabled bank account by performing an update call without providing any arguments or changes.</p>
    # @param account [String?]
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param account_type [String?] The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param default_for_currency [Bool?] When set to true, this becomes the default external account for its currency.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @return [ExternalAccount]
    def post_accounts_account_bank_accounts_id(*, account : String? = nil, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, account_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, default_for_currency : Bool? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil)
      data, _status_code, _headers = post_accounts_account_bank_accounts_id_with_http_info(account: account, id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, account_type: account_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, default_for_currency: default_for_currency, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name)
      data
    end

    # &lt;p&gt;Updates the metadata, account holder name, account holder type of a bank account belonging to a &lt;a href&#x3D;\&quot;/docs/connect/custom-accounts\&quot;&gt;Custom account&lt;/a&gt;, and optionally sets it as the default for its currency. Other bank account details are not editable by design.&lt;/p&gt;  &lt;p&gt;You can re-enable a disabled bank account by performing an update call without providing any arguments or changes.&lt;/p&gt;
    # @param account [String?]
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param account_type [String?] The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param default_for_currency [Bool?] When set to true, this becomes the default external account for its currency.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @return [Array<(ExternalAccount, Integer, Hash)>] ExternalAccount data, response status code and response headers
    def post_accounts_account_bank_accounts_id_with_http_info(*, account : String? = nil, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, account_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, default_for_currency : Bool? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil)
      request = build_api_request_for_post_accounts_account_bank_accounts_id(account: account, id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, account_type: account_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, default_for_currency: default_for_currency, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_accounts_account_bank_accounts_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ExternalAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the metadata, account holder name, account holder type of a bank account belonging to a &lt;a href&#x3D;\&quot;/docs/connect/custom-accounts\&quot;&gt;Custom account&lt;/a&gt;, and optionally sets it as the default for its currency. Other bank account details are not editable by design.&lt;/p&gt;  &lt;p&gt;You can re-enable a disabled bank account by performing an update call without providing any arguments or changes.&lt;/p&gt;
    # @param account [String?]
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param account_type [String?] The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param default_for_currency [Bool?] When set to true, this becomes the default external account for its currency.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @return nil
    def post_accounts_account_bank_accounts_id(*, account : String? = nil, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, account_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, default_for_currency : Bool? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_accounts_account_bank_accounts_id(account: account, id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, account_type: account_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, default_for_currency: default_for_currency, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name).execute(&block)
    end

    POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT               = 5000
    POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_NAME   = 5000
    POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_TYPE   = 5000
    POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_VALID_VALUES_FOR_ACCOUNT_HOLDER_TYPE = StaticArray["", "company", "individual"]
    POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT_TYPE          = 5000
    POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_VALID_VALUES_FOR_ACCOUNT_TYPE        = StaticArray["checking", "futsu", "savings", "toza"]
    POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_CITY          = 5000
    POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_COUNTRY       = 5000
    POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_LINE1         = 5000
    POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_LINE2         = 5000
    POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_STATE         = 5000
    POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_ZIP           = 5000
    POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_EXP_MONTH             = 5000
    POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_EXP_YEAR              = 5000
    POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_NAME                  = 5000

    # @return Crest::Request
    def build_api_request_for_post_accounts_account_bank_accounts_id(*, account : String? = nil, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, account_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, default_for_currency : Bool? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_accounts_account_bank_accounts_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?

        if _account_holder_name = account_holder_name
          OpenApi::PrimitiveValidator.validate_max_length("account_holder_name", account_holder_name.to_s.size, POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_NAME)
        end
        if _account_holder_type = account_holder_type
          OpenApi::EnumValidator.validate("account_holder_type", _account_holder_type, POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_VALID_VALUES_FOR_ACCOUNT_HOLDER_TYPE)
        end
        if _account_type = account_type
          OpenApi::EnumValidator.validate("account_type", _account_type, POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_VALID_VALUES_FOR_ACCOUNT_TYPE)
        end
        if _address_city = address_city
          OpenApi::PrimitiveValidator.validate_max_length("address_city", address_city.to_s.size, POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_CITY)
        end
        if _address_country = address_country
          OpenApi::PrimitiveValidator.validate_max_length("address_country", address_country.to_s.size, POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_COUNTRY)
        end
        if _address_line1 = address_line1
          OpenApi::PrimitiveValidator.validate_max_length("address_line1", address_line1.to_s.size, POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_LINE1)
        end
        if _address_line2 = address_line2
          OpenApi::PrimitiveValidator.validate_max_length("address_line2", address_line2.to_s.size, POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_LINE2)
        end
        if _address_state = address_state
          OpenApi::PrimitiveValidator.validate_max_length("address_state", address_state.to_s.size, POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_STATE)
        end
        if _address_zip = address_zip
          OpenApi::PrimitiveValidator.validate_max_length("address_zip", address_zip.to_s.size, POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_ZIP)
        end

        if _exp_month = exp_month
          OpenApi::PrimitiveValidator.validate_max_length("exp_month", exp_month.to_s.size, POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_EXP_MONTH)
        end
        if _exp_year = exp_year
          OpenApi::PrimitiveValidator.validate_max_length("exp_year", exp_year.to_s.size, POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_EXP_YEAR)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _name = name
          OpenApi::PrimitiveValidator.validate_max_length("name", name.to_s.size, POST_ACCOUNTS_ACCOUNT_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_NAME)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/bank_accounts/{id}".sub("{" + "account" + "}", URI.encode_path(account.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account_holder_name"] = account_holder_name.to_s if !account_holder_name.nil?
      form_params["account_holder_type"] = account_holder_type.to_s if !account_holder_type.nil?
      form_params["account_type"] = account_type.to_s if !account_type.nil?
      form_params["address_city"] = address_city.to_s if !address_city.nil?
      form_params["address_country"] = address_country.to_s if !address_country.nil?
      form_params["address_line1"] = address_line1.to_s if !address_line1.nil?
      form_params["address_line2"] = address_line2.to_s if !address_line2.nil?
      form_params["address_state"] = address_state.to_s if !address_state.nil?
      form_params["address_zip"] = address_zip.to_s if !address_zip.nil?
      form_params["default_for_currency"] = default_for_currency.to_s if !default_for_currency.nil?
      form_params["exp_month"] = exp_month.to_s if !exp_month.nil?
      form_params["exp_year"] = exp_year.to_s if !exp_year.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["name"] = name.to_s if !name.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_accounts_account_bank_accounts_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates an existing Account Capability.</p>
    # @param account [String?]
    # @param capability [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param requested [Bool?] Passing true requests the capability for the account, if it is not already requested. A requested capability may not immediately become active. Any requirements to activate the capability are returned in the `requirements` arrays.
    # @return [Capability]
    def post_accounts_account_capabilities_capability(*, account : String? = nil, capability : String? = nil, expand : Array(String)? = nil, requested : Bool? = nil)
      data, _status_code, _headers = post_accounts_account_capabilities_capability_with_http_info(account: account, capability: capability, expand: expand, requested: requested)
      data
    end

    # &lt;p&gt;Updates an existing Account Capability.&lt;/p&gt;
    # @param account [String?]
    # @param capability [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param requested [Bool?] Passing true requests the capability for the account, if it is not already requested. A requested capability may not immediately become active. Any requirements to activate the capability are returned in the `requirements` arrays.
    # @return [Array<(Capability, Integer, Hash)>] Capability data, response status code and response headers
    def post_accounts_account_capabilities_capability_with_http_info(*, account : String? = nil, capability : String? = nil, expand : Array(String)? = nil, requested : Bool? = nil)
      request = build_api_request_for_post_accounts_account_capabilities_capability(account: account, capability: capability, expand: expand, requested: requested)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_accounts_account_capabilities_capability\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Capability.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates an existing Account Capability.&lt;/p&gt;
    # @param account [String?]
    # @param capability [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param requested [Bool?] Passing true requests the capability for the account, if it is not already requested. A requested capability may not immediately become active. Any requirements to activate the capability are returned in the `requirements` arrays.
    # @return nil
    def post_accounts_account_capabilities_capability(*, account : String? = nil, capability : String? = nil, expand : Array(String)? = nil, requested : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_post_accounts_account_capabilities_capability(account: account, capability: capability, expand: expand, requested: requested).execute(&block)
    end

    POST_ACCOUNTS_ACCOUNT_CAPABILITIES_CAPABILITY_MAX_LENGTH_FOR_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_post_accounts_account_capabilities_capability(*, account : String? = nil, capability : String? = nil, expand : Array(String)? = nil, requested : Bool? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_accounts_account_capabilities_capability ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_ACCOUNTS_ACCOUNT_CAPABILITIES_CAPABILITY_MAX_LENGTH_FOR_ACCOUNT)
        end
        raise ArgumentError.new("\"capability\" is required and cannot be null") if capability.nil?
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/capabilities/{capability}".sub("{" + "account" + "}", URI.encode_path(account.to_s)).sub("{" + "capability" + "}", URI.encode_path(capability.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["requested"] = requested.to_s if !requested.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_accounts_account_capabilities_capability",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Create an external account for a given account.</p>
    # @param account [String?]
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param default_for_currency [Bool?] When set to true, or if this is the first external account added in this currency, this account becomes the default external account for its currency.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return [ExternalAccount]
    def post_accounts_account_external_accounts(*, account : String? = nil, bank_account : Stripe::PostAccountRequestBankAccount? = nil, default_for_currency : Bool? = nil, expand : Array(String)? = nil, external_account : String? = nil)
      data, _status_code, _headers = post_accounts_account_external_accounts_with_http_info(account: account, bank_account: bank_account, default_for_currency: default_for_currency, expand: expand, external_account: external_account)
      data
    end

    # &lt;p&gt;Create an external account for a given account.&lt;/p&gt;
    # @param account [String?]
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param default_for_currency [Bool?] When set to true, or if this is the first external account added in this currency, this account becomes the default external account for its currency.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return [Array<(ExternalAccount, Integer, Hash)>] ExternalAccount data, response status code and response headers
    def post_accounts_account_external_accounts_with_http_info(*, account : String? = nil, bank_account : Stripe::PostAccountRequestBankAccount? = nil, default_for_currency : Bool? = nil, expand : Array(String)? = nil, external_account : String? = nil)
      request = build_api_request_for_post_accounts_account_external_accounts(account: account, bank_account: bank_account, default_for_currency: default_for_currency, expand: expand, external_account: external_account)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_accounts_account_external_accounts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ExternalAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Create an external account for a given account.&lt;/p&gt;
    # @param account [String?]
    # @optional @param bank_account [Stripe::PostAccountRequestBankAccount?]
    # @optional @param default_for_currency [Bool?] When set to true, or if this is the first external account added in this currency, this account becomes the default external account for its currency.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param external_account [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return nil
    def post_accounts_account_external_accounts(*, account : String? = nil, bank_account : Stripe::PostAccountRequestBankAccount? = nil, default_for_currency : Bool? = nil, expand : Array(String)? = nil, external_account : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_accounts_account_external_accounts(account: account, bank_account: bank_account, default_for_currency: default_for_currency, expand: expand, external_account: external_account).execute(&block)
    end

    POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_MAX_LENGTH_FOR_ACCOUNT          = 5000
    POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_MAX_LENGTH_FOR_EXTERNAL_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_post_accounts_account_external_accounts(*, account : String? = nil, bank_account : Stripe::PostAccountRequestBankAccount? = nil, default_for_currency : Bool? = nil, expand : Array(String)? = nil, external_account : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_accounts_account_external_accounts ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_MAX_LENGTH_FOR_ACCOUNT)
        end
        if _bank_account = bank_account
          _bank_account.validate if _bank_account.is_a?(OpenApi::Validatable)
        end

        if _external_account = external_account
          OpenApi::PrimitiveValidator.validate_max_length("external_account", external_account.to_s.size, POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_MAX_LENGTH_FOR_EXTERNAL_ACCOUNT)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/external_accounts".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["bank_account"] = bank_account.to_s if !bank_account.nil?
      form_params["default_for_currency"] = default_for_currency.to_s if !default_for_currency.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["external_account"] = external_account.to_s if !external_account.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_accounts_account_external_accounts",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the metadata, account holder name, account holder type of a bank account belonging to a <a href=\"/docs/connect/custom-accounts\">Custom account</a>, and optionally sets it as the default for its currency. Other bank account details are not editable by design.</p>  <p>You can re-enable a disabled bank account by performing an update call without providing any arguments or changes.</p>
    # @param account [String?]
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param account_type [String?] The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param default_for_currency [Bool?] When set to true, this becomes the default external account for its currency.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @return [ExternalAccount]
    def post_accounts_account_external_accounts_id(*, account : String? = nil, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, account_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, default_for_currency : Bool? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil)
      data, _status_code, _headers = post_accounts_account_external_accounts_id_with_http_info(account: account, id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, account_type: account_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, default_for_currency: default_for_currency, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name)
      data
    end

    # &lt;p&gt;Updates the metadata, account holder name, account holder type of a bank account belonging to a &lt;a href&#x3D;\&quot;/docs/connect/custom-accounts\&quot;&gt;Custom account&lt;/a&gt;, and optionally sets it as the default for its currency. Other bank account details are not editable by design.&lt;/p&gt;  &lt;p&gt;You can re-enable a disabled bank account by performing an update call without providing any arguments or changes.&lt;/p&gt;
    # @param account [String?]
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param account_type [String?] The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param default_for_currency [Bool?] When set to true, this becomes the default external account for its currency.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @return [Array<(ExternalAccount, Integer, Hash)>] ExternalAccount data, response status code and response headers
    def post_accounts_account_external_accounts_id_with_http_info(*, account : String? = nil, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, account_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, default_for_currency : Bool? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil)
      request = build_api_request_for_post_accounts_account_external_accounts_id(account: account, id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, account_type: account_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, default_for_currency: default_for_currency, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_accounts_account_external_accounts_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ExternalAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the metadata, account holder name, account holder type of a bank account belonging to a &lt;a href&#x3D;\&quot;/docs/connect/custom-accounts\&quot;&gt;Custom account&lt;/a&gt;, and optionally sets it as the default for its currency. Other bank account details are not editable by design.&lt;/p&gt;  &lt;p&gt;You can re-enable a disabled bank account by performing an update call without providing any arguments or changes.&lt;/p&gt;
    # @param account [String?]
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param account_type [String?] The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param default_for_currency [Bool?] When set to true, this becomes the default external account for its currency.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @return nil
    def post_accounts_account_external_accounts_id(*, account : String? = nil, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, account_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, default_for_currency : Bool? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_accounts_account_external_accounts_id(account: account, id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, account_type: account_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, default_for_currency: default_for_currency, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name).execute(&block)
    end

    POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT               = 5000
    POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_NAME   = 5000
    POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_TYPE   = 5000
    POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_VALID_VALUES_FOR_ACCOUNT_HOLDER_TYPE = StaticArray["", "company", "individual"]
    POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT_TYPE          = 5000
    POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_VALID_VALUES_FOR_ACCOUNT_TYPE        = StaticArray["checking", "futsu", "savings", "toza"]
    POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_CITY          = 5000
    POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_COUNTRY       = 5000
    POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_LINE1         = 5000
    POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_LINE2         = 5000
    POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_STATE         = 5000
    POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_ZIP           = 5000
    POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_EXP_MONTH             = 5000
    POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_EXP_YEAR              = 5000
    POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_NAME                  = 5000

    # @return Crest::Request
    def build_api_request_for_post_accounts_account_external_accounts_id(*, account : String? = nil, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, account_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, default_for_currency : Bool? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_accounts_account_external_accounts_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?

        if _account_holder_name = account_holder_name
          OpenApi::PrimitiveValidator.validate_max_length("account_holder_name", account_holder_name.to_s.size, POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_NAME)
        end
        if _account_holder_type = account_holder_type
          OpenApi::EnumValidator.validate("account_holder_type", _account_holder_type, POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_VALID_VALUES_FOR_ACCOUNT_HOLDER_TYPE)
        end
        if _account_type = account_type
          OpenApi::EnumValidator.validate("account_type", _account_type, POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_VALID_VALUES_FOR_ACCOUNT_TYPE)
        end
        if _address_city = address_city
          OpenApi::PrimitiveValidator.validate_max_length("address_city", address_city.to_s.size, POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_CITY)
        end
        if _address_country = address_country
          OpenApi::PrimitiveValidator.validate_max_length("address_country", address_country.to_s.size, POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_COUNTRY)
        end
        if _address_line1 = address_line1
          OpenApi::PrimitiveValidator.validate_max_length("address_line1", address_line1.to_s.size, POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_LINE1)
        end
        if _address_line2 = address_line2
          OpenApi::PrimitiveValidator.validate_max_length("address_line2", address_line2.to_s.size, POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_LINE2)
        end
        if _address_state = address_state
          OpenApi::PrimitiveValidator.validate_max_length("address_state", address_state.to_s.size, POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_STATE)
        end
        if _address_zip = address_zip
          OpenApi::PrimitiveValidator.validate_max_length("address_zip", address_zip.to_s.size, POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_ZIP)
        end

        if _exp_month = exp_month
          OpenApi::PrimitiveValidator.validate_max_length("exp_month", exp_month.to_s.size, POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_EXP_MONTH)
        end
        if _exp_year = exp_year
          OpenApi::PrimitiveValidator.validate_max_length("exp_year", exp_year.to_s.size, POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_EXP_YEAR)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _name = name
          OpenApi::PrimitiveValidator.validate_max_length("name", name.to_s.size, POST_ACCOUNTS_ACCOUNT_EXTERNAL_ACCOUNTS_ID_MAX_LENGTH_FOR_NAME)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/external_accounts/{id}".sub("{" + "account" + "}", URI.encode_path(account.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account_holder_name"] = account_holder_name.to_s if !account_holder_name.nil?
      form_params["account_holder_type"] = account_holder_type.to_s if !account_holder_type.nil?
      form_params["account_type"] = account_type.to_s if !account_type.nil?
      form_params["address_city"] = address_city.to_s if !address_city.nil?
      form_params["address_country"] = address_country.to_s if !address_country.nil?
      form_params["address_line1"] = address_line1.to_s if !address_line1.nil?
      form_params["address_line2"] = address_line2.to_s if !address_line2.nil?
      form_params["address_state"] = address_state.to_s if !address_state.nil?
      form_params["address_zip"] = address_zip.to_s if !address_zip.nil?
      form_params["default_for_currency"] = default_for_currency.to_s if !default_for_currency.nil?
      form_params["exp_month"] = exp_month.to_s if !exp_month.nil?
      form_params["exp_year"] = exp_year.to_s if !exp_year.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["name"] = name.to_s if !name.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_accounts_account_external_accounts_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a single-use login link for an Express account to access their Stripe dashboard.</p>  <p><strong>You may only create login links for <a href=\"/docs/connect/express-accounts\">Express accounts</a> connected to your platform</strong>.</p>
    # @param account [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [LoginLink]
    def post_accounts_account_login_links(*, account : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_accounts_account_login_links_with_http_info(account: account, expand: expand)
      data
    end

    # &lt;p&gt;Creates a single-use login link for an Express account to access their Stripe dashboard.&lt;/p&gt;  &lt;p&gt;&lt;strong&gt;You may only create login links for &lt;a href&#x3D;\&quot;/docs/connect/express-accounts\&quot;&gt;Express accounts&lt;/a&gt; connected to your platform&lt;/strong&gt;.&lt;/p&gt;
    # @param account [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(LoginLink, Integer, Hash)>] LoginLink data, response status code and response headers
    def post_accounts_account_login_links_with_http_info(*, account : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_accounts_account_login_links(account: account, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_accounts_account_login_links\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return LoginLink.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a single-use login link for an Express account to access their Stripe dashboard.&lt;/p&gt;  &lt;p&gt;&lt;strong&gt;You may only create login links for &lt;a href&#x3D;\&quot;/docs/connect/express-accounts\&quot;&gt;Express accounts&lt;/a&gt; connected to your platform&lt;/strong&gt;.&lt;/p&gt;
    # @param account [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_accounts_account_login_links(*, account : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_accounts_account_login_links(account: account, expand: expand).execute(&block)
    end

    POST_ACCOUNTS_ACCOUNT_LOGIN_LINKS_MAX_LENGTH_FOR_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_post_accounts_account_login_links(*, account : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_accounts_account_login_links ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_ACCOUNTS_ACCOUNT_LOGIN_LINKS_MAX_LENGTH_FOR_ACCOUNT)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/login_links".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_accounts_account_login_links",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new person.</p>
    # @param account [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return [Person]
    def post_accounts_account_people(*, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil)
      data, _status_code, _headers = post_accounts_account_people_with_http_info(account: account, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification)
      data
    end

    # &lt;p&gt;Creates a new person.&lt;/p&gt;
    # @param account [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return [Array<(Person, Integer, Hash)>] Person data, response status code and response headers
    def post_accounts_account_people_with_http_info(*, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil)
      request = build_api_request_for_post_accounts_account_people(account: account, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_accounts_account_people\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Person.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new person.&lt;/p&gt;
    # @param account [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return nil
    def post_accounts_account_people(*, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil, &block : Crest::Response ->)
      build_api_request_for_post_accounts_account_people(account: account, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification).execute(&block)
    end

    POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_ACCOUNT             = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_FIRST_NAME          = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_FIRST_NAME_KANA     = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_FIRST_NAME_KANJI    = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_ID_NUMBER           = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_ID_NUMBER_SECONDARY = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_LAST_NAME           = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_LAST_NAME_KANA      = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_LAST_NAME_KANJI     = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_MAIDEN_NAME         = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_NATIONALITY         = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_PERSON_TOKEN        = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_POLITICAL_EXPOSURE  = 5000

    # @return Crest::Request
    def build_api_request_for_post_accounts_account_people(*, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_accounts_account_people ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_ACCOUNT)
        end
        if _address = address
          _address.validate if _address.is_a?(OpenApi::Validatable)
        end
        if _address_kana = address_kana
          _address_kana.validate if _address_kana.is_a?(OpenApi::Validatable)
        end
        if _address_kanji = address_kanji
          _address_kanji.validate if _address_kanji.is_a?(OpenApi::Validatable)
        end
        if _dob = dob
          _dob.validate if _dob.is_a?(OpenApi::Validatable)
        end
        if _documents = documents
          _documents.validate if _documents.is_a?(OpenApi::Validatable)
        end

        if _first_name = first_name
          OpenApi::PrimitiveValidator.validate_max_length("first_name", first_name.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_FIRST_NAME)
        end
        if _first_name_kana = first_name_kana
          OpenApi::PrimitiveValidator.validate_max_length("first_name_kana", first_name_kana.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_FIRST_NAME_KANA)
        end
        if _first_name_kanji = first_name_kanji
          OpenApi::PrimitiveValidator.validate_max_length("first_name_kanji", first_name_kanji.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_FIRST_NAME_KANJI)
        end
        if _full_name_aliases = full_name_aliases
          _full_name_aliases.validate if _full_name_aliases.is_a?(OpenApi::Validatable)
        end

        if _id_number = id_number
          OpenApi::PrimitiveValidator.validate_max_length("id_number", id_number.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_ID_NUMBER)
        end
        if _id_number_secondary = id_number_secondary
          OpenApi::PrimitiveValidator.validate_max_length("id_number_secondary", id_number_secondary.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_ID_NUMBER_SECONDARY)
        end
        if _last_name = last_name
          OpenApi::PrimitiveValidator.validate_max_length("last_name", last_name.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_LAST_NAME)
        end
        if _last_name_kana = last_name_kana
          OpenApi::PrimitiveValidator.validate_max_length("last_name_kana", last_name_kana.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_LAST_NAME_KANA)
        end
        if _last_name_kanji = last_name_kanji
          OpenApi::PrimitiveValidator.validate_max_length("last_name_kanji", last_name_kanji.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_LAST_NAME_KANJI)
        end
        if _maiden_name = maiden_name
          OpenApi::PrimitiveValidator.validate_max_length("maiden_name", maiden_name.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_MAIDEN_NAME)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _nationality = nationality
          OpenApi::PrimitiveValidator.validate_max_length("nationality", nationality.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_NATIONALITY)
        end
        if _person_token = person_token
          OpenApi::PrimitiveValidator.validate_max_length("person_token", person_token.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_PERSON_TOKEN)
        end

        if _political_exposure = political_exposure
          OpenApi::PrimitiveValidator.validate_max_length("political_exposure", political_exposure.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_MAX_LENGTH_FOR_POLITICAL_EXPOSURE)
        end
        if _registered_address = registered_address
          _registered_address.validate if _registered_address.is_a?(OpenApi::Validatable)
        end
        if _relationship = relationship
          _relationship.validate if _relationship.is_a?(OpenApi::Validatable)
        end

        if _verification = verification
          _verification.validate if _verification.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/people".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["address"] = address.to_s if !address.nil?
      form_params["address_kana"] = address_kana.to_s if !address_kana.nil?
      form_params["address_kanji"] = address_kanji.to_s if !address_kanji.nil?
      form_params["dob"] = dob.to_s if !dob.nil?
      form_params["documents"] = documents.to_s if !documents.nil?
      form_params["email"] = email.to_s if !email.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["first_name"] = first_name.to_s if !first_name.nil?
      form_params["first_name_kana"] = first_name_kana.to_s if !first_name_kana.nil?
      form_params["first_name_kanji"] = first_name_kanji.to_s if !first_name_kanji.nil?
      form_params["full_name_aliases"] = full_name_aliases.to_s if !full_name_aliases.nil?
      form_params["gender"] = gender.to_s if !gender.nil?
      form_params["id_number"] = id_number.to_s if !id_number.nil?
      form_params["id_number_secondary"] = id_number_secondary.to_s if !id_number_secondary.nil?
      form_params["last_name"] = last_name.to_s if !last_name.nil?
      form_params["last_name_kana"] = last_name_kana.to_s if !last_name_kana.nil?
      form_params["last_name_kanji"] = last_name_kanji.to_s if !last_name_kanji.nil?
      form_params["maiden_name"] = maiden_name.to_s if !maiden_name.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["nationality"] = nationality.to_s if !nationality.nil?
      form_params["person_token"] = person_token.to_s if !person_token.nil?
      form_params["phone"] = phone.to_s if !phone.nil?
      form_params["political_exposure"] = political_exposure.to_s if !political_exposure.nil?
      form_params["registered_address"] = registered_address.to_s if !registered_address.nil?
      form_params["relationship"] = relationship.to_s if !relationship.nil?
      form_params["ssn_last_4"] = ssn_last_4.to_s if !ssn_last_4.nil?
      form_params["verification"] = verification.to_s if !verification.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_accounts_account_people",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates an existing person.</p>
    # @param account [String?]
    # @param person [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return [Person]
    def post_accounts_account_people_person(*, account : String? = nil, person : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil)
      data, _status_code, _headers = post_accounts_account_people_person_with_http_info(account: account, person: person, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification)
      data
    end

    # &lt;p&gt;Updates an existing person.&lt;/p&gt;
    # @param account [String?]
    # @param person [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return [Array<(Person, Integer, Hash)>] Person data, response status code and response headers
    def post_accounts_account_people_person_with_http_info(*, account : String? = nil, person : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil)
      request = build_api_request_for_post_accounts_account_people_person(account: account, person: person, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_accounts_account_people_person\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Person.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates an existing person.&lt;/p&gt;
    # @param account [String?]
    # @param person [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return nil
    def post_accounts_account_people_person(*, account : String? = nil, person : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil, &block : Crest::Response ->)
      build_api_request_for_post_accounts_account_people_person(account: account, person: person, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification).execute(&block)
    end

    POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_ACCOUNT             = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_PERSON              = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_FIRST_NAME          = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_FIRST_NAME_KANA     = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_FIRST_NAME_KANJI    = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_ID_NUMBER           = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_ID_NUMBER_SECONDARY = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_LAST_NAME           = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_LAST_NAME_KANA      = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_LAST_NAME_KANJI     = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_MAIDEN_NAME         = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_NATIONALITY         = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_PERSON_TOKEN        = 5000
    POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_POLITICAL_EXPOSURE  = 5000

    # @return Crest::Request
    def build_api_request_for_post_accounts_account_people_person(*, account : String? = nil, person : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_accounts_account_people_person ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_ACCOUNT)
        end
        raise ArgumentError.new("\"person\" is required and cannot be null") if person.nil?
        if _person = person
          OpenApi::PrimitiveValidator.validate_max_length("person", person.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_PERSON)
        end
        if _address = address
          _address.validate if _address.is_a?(OpenApi::Validatable)
        end
        if _address_kana = address_kana
          _address_kana.validate if _address_kana.is_a?(OpenApi::Validatable)
        end
        if _address_kanji = address_kanji
          _address_kanji.validate if _address_kanji.is_a?(OpenApi::Validatable)
        end
        if _dob = dob
          _dob.validate if _dob.is_a?(OpenApi::Validatable)
        end
        if _documents = documents
          _documents.validate if _documents.is_a?(OpenApi::Validatable)
        end

        if _first_name = first_name
          OpenApi::PrimitiveValidator.validate_max_length("first_name", first_name.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_FIRST_NAME)
        end
        if _first_name_kana = first_name_kana
          OpenApi::PrimitiveValidator.validate_max_length("first_name_kana", first_name_kana.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_FIRST_NAME_KANA)
        end
        if _first_name_kanji = first_name_kanji
          OpenApi::PrimitiveValidator.validate_max_length("first_name_kanji", first_name_kanji.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_FIRST_NAME_KANJI)
        end
        if _full_name_aliases = full_name_aliases
          _full_name_aliases.validate if _full_name_aliases.is_a?(OpenApi::Validatable)
        end

        if _id_number = id_number
          OpenApi::PrimitiveValidator.validate_max_length("id_number", id_number.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_ID_NUMBER)
        end
        if _id_number_secondary = id_number_secondary
          OpenApi::PrimitiveValidator.validate_max_length("id_number_secondary", id_number_secondary.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_ID_NUMBER_SECONDARY)
        end
        if _last_name = last_name
          OpenApi::PrimitiveValidator.validate_max_length("last_name", last_name.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_LAST_NAME)
        end
        if _last_name_kana = last_name_kana
          OpenApi::PrimitiveValidator.validate_max_length("last_name_kana", last_name_kana.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_LAST_NAME_KANA)
        end
        if _last_name_kanji = last_name_kanji
          OpenApi::PrimitiveValidator.validate_max_length("last_name_kanji", last_name_kanji.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_LAST_NAME_KANJI)
        end
        if _maiden_name = maiden_name
          OpenApi::PrimitiveValidator.validate_max_length("maiden_name", maiden_name.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_MAIDEN_NAME)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _nationality = nationality
          OpenApi::PrimitiveValidator.validate_max_length("nationality", nationality.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_NATIONALITY)
        end
        if _person_token = person_token
          OpenApi::PrimitiveValidator.validate_max_length("person_token", person_token.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_PERSON_TOKEN)
        end

        if _political_exposure = political_exposure
          OpenApi::PrimitiveValidator.validate_max_length("political_exposure", political_exposure.to_s.size, POST_ACCOUNTS_ACCOUNT_PEOPLE_PERSON_MAX_LENGTH_FOR_POLITICAL_EXPOSURE)
        end
        if _registered_address = registered_address
          _registered_address.validate if _registered_address.is_a?(OpenApi::Validatable)
        end
        if _relationship = relationship
          _relationship.validate if _relationship.is_a?(OpenApi::Validatable)
        end

        if _verification = verification
          _verification.validate if _verification.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/people/{person}".sub("{" + "account" + "}", URI.encode_path(account.to_s)).sub("{" + "person" + "}", URI.encode_path(person.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["address"] = address.to_s if !address.nil?
      form_params["address_kana"] = address_kana.to_s if !address_kana.nil?
      form_params["address_kanji"] = address_kanji.to_s if !address_kanji.nil?
      form_params["dob"] = dob.to_s if !dob.nil?
      form_params["documents"] = documents.to_s if !documents.nil?
      form_params["email"] = email.to_s if !email.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["first_name"] = first_name.to_s if !first_name.nil?
      form_params["first_name_kana"] = first_name_kana.to_s if !first_name_kana.nil?
      form_params["first_name_kanji"] = first_name_kanji.to_s if !first_name_kanji.nil?
      form_params["full_name_aliases"] = full_name_aliases.to_s if !full_name_aliases.nil?
      form_params["gender"] = gender.to_s if !gender.nil?
      form_params["id_number"] = id_number.to_s if !id_number.nil?
      form_params["id_number_secondary"] = id_number_secondary.to_s if !id_number_secondary.nil?
      form_params["last_name"] = last_name.to_s if !last_name.nil?
      form_params["last_name_kana"] = last_name_kana.to_s if !last_name_kana.nil?
      form_params["last_name_kanji"] = last_name_kanji.to_s if !last_name_kanji.nil?
      form_params["maiden_name"] = maiden_name.to_s if !maiden_name.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["nationality"] = nationality.to_s if !nationality.nil?
      form_params["person_token"] = person_token.to_s if !person_token.nil?
      form_params["phone"] = phone.to_s if !phone.nil?
      form_params["political_exposure"] = political_exposure.to_s if !political_exposure.nil?
      form_params["registered_address"] = registered_address.to_s if !registered_address.nil?
      form_params["relationship"] = relationship.to_s if !relationship.nil?
      form_params["ssn_last_4"] = ssn_last_4.to_s if !ssn_last_4.nil?
      form_params["verification"] = verification.to_s if !verification.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_accounts_account_people_person",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new person.</p>
    # @param account [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return [Person]
    def post_accounts_account_persons(*, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil)
      data, _status_code, _headers = post_accounts_account_persons_with_http_info(account: account, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification)
      data
    end

    # &lt;p&gt;Creates a new person.&lt;/p&gt;
    # @param account [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return [Array<(Person, Integer, Hash)>] Person data, response status code and response headers
    def post_accounts_account_persons_with_http_info(*, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil)
      request = build_api_request_for_post_accounts_account_persons(account: account, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_accounts_account_persons\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Person.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new person.&lt;/p&gt;
    # @param account [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return nil
    def post_accounts_account_persons(*, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil, &block : Crest::Response ->)
      build_api_request_for_post_accounts_account_persons(account: account, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification).execute(&block)
    end

    POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_ACCOUNT             = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_FIRST_NAME          = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_FIRST_NAME_KANA     = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_FIRST_NAME_KANJI    = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_ID_NUMBER           = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_ID_NUMBER_SECONDARY = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_LAST_NAME           = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_LAST_NAME_KANA      = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_LAST_NAME_KANJI     = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_MAIDEN_NAME         = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_NATIONALITY         = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_PERSON_TOKEN        = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_POLITICAL_EXPOSURE  = 5000

    # @return Crest::Request
    def build_api_request_for_post_accounts_account_persons(*, account : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_accounts_account_persons ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_ACCOUNT)
        end
        if _address = address
          _address.validate if _address.is_a?(OpenApi::Validatable)
        end
        if _address_kana = address_kana
          _address_kana.validate if _address_kana.is_a?(OpenApi::Validatable)
        end
        if _address_kanji = address_kanji
          _address_kanji.validate if _address_kanji.is_a?(OpenApi::Validatable)
        end
        if _dob = dob
          _dob.validate if _dob.is_a?(OpenApi::Validatable)
        end
        if _documents = documents
          _documents.validate if _documents.is_a?(OpenApi::Validatable)
        end

        if _first_name = first_name
          OpenApi::PrimitiveValidator.validate_max_length("first_name", first_name.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_FIRST_NAME)
        end
        if _first_name_kana = first_name_kana
          OpenApi::PrimitiveValidator.validate_max_length("first_name_kana", first_name_kana.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_FIRST_NAME_KANA)
        end
        if _first_name_kanji = first_name_kanji
          OpenApi::PrimitiveValidator.validate_max_length("first_name_kanji", first_name_kanji.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_FIRST_NAME_KANJI)
        end
        if _full_name_aliases = full_name_aliases
          _full_name_aliases.validate if _full_name_aliases.is_a?(OpenApi::Validatable)
        end

        if _id_number = id_number
          OpenApi::PrimitiveValidator.validate_max_length("id_number", id_number.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_ID_NUMBER)
        end
        if _id_number_secondary = id_number_secondary
          OpenApi::PrimitiveValidator.validate_max_length("id_number_secondary", id_number_secondary.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_ID_NUMBER_SECONDARY)
        end
        if _last_name = last_name
          OpenApi::PrimitiveValidator.validate_max_length("last_name", last_name.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_LAST_NAME)
        end
        if _last_name_kana = last_name_kana
          OpenApi::PrimitiveValidator.validate_max_length("last_name_kana", last_name_kana.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_LAST_NAME_KANA)
        end
        if _last_name_kanji = last_name_kanji
          OpenApi::PrimitiveValidator.validate_max_length("last_name_kanji", last_name_kanji.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_LAST_NAME_KANJI)
        end
        if _maiden_name = maiden_name
          OpenApi::PrimitiveValidator.validate_max_length("maiden_name", maiden_name.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_MAIDEN_NAME)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _nationality = nationality
          OpenApi::PrimitiveValidator.validate_max_length("nationality", nationality.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_NATIONALITY)
        end
        if _person_token = person_token
          OpenApi::PrimitiveValidator.validate_max_length("person_token", person_token.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_PERSON_TOKEN)
        end

        if _political_exposure = political_exposure
          OpenApi::PrimitiveValidator.validate_max_length("political_exposure", political_exposure.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_MAX_LENGTH_FOR_POLITICAL_EXPOSURE)
        end
        if _registered_address = registered_address
          _registered_address.validate if _registered_address.is_a?(OpenApi::Validatable)
        end
        if _relationship = relationship
          _relationship.validate if _relationship.is_a?(OpenApi::Validatable)
        end

        if _verification = verification
          _verification.validate if _verification.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/persons".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["address"] = address.to_s if !address.nil?
      form_params["address_kana"] = address_kana.to_s if !address_kana.nil?
      form_params["address_kanji"] = address_kanji.to_s if !address_kanji.nil?
      form_params["dob"] = dob.to_s if !dob.nil?
      form_params["documents"] = documents.to_s if !documents.nil?
      form_params["email"] = email.to_s if !email.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["first_name"] = first_name.to_s if !first_name.nil?
      form_params["first_name_kana"] = first_name_kana.to_s if !first_name_kana.nil?
      form_params["first_name_kanji"] = first_name_kanji.to_s if !first_name_kanji.nil?
      form_params["full_name_aliases"] = full_name_aliases.to_s if !full_name_aliases.nil?
      form_params["gender"] = gender.to_s if !gender.nil?
      form_params["id_number"] = id_number.to_s if !id_number.nil?
      form_params["id_number_secondary"] = id_number_secondary.to_s if !id_number_secondary.nil?
      form_params["last_name"] = last_name.to_s if !last_name.nil?
      form_params["last_name_kana"] = last_name_kana.to_s if !last_name_kana.nil?
      form_params["last_name_kanji"] = last_name_kanji.to_s if !last_name_kanji.nil?
      form_params["maiden_name"] = maiden_name.to_s if !maiden_name.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["nationality"] = nationality.to_s if !nationality.nil?
      form_params["person_token"] = person_token.to_s if !person_token.nil?
      form_params["phone"] = phone.to_s if !phone.nil?
      form_params["political_exposure"] = political_exposure.to_s if !political_exposure.nil?
      form_params["registered_address"] = registered_address.to_s if !registered_address.nil?
      form_params["relationship"] = relationship.to_s if !relationship.nil?
      form_params["ssn_last_4"] = ssn_last_4.to_s if !ssn_last_4.nil?
      form_params["verification"] = verification.to_s if !verification.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_accounts_account_persons",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates an existing person.</p>
    # @param account [String?]
    # @param person [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return [Person]
    def post_accounts_account_persons_person(*, account : String? = nil, person : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil)
      data, _status_code, _headers = post_accounts_account_persons_person_with_http_info(account: account, person: person, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification)
      data
    end

    # &lt;p&gt;Updates an existing person.&lt;/p&gt;
    # @param account [String?]
    # @param person [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return [Array<(Person, Integer, Hash)>] Person data, response status code and response headers
    def post_accounts_account_persons_person_with_http_info(*, account : String? = nil, person : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil)
      request = build_api_request_for_post_accounts_account_persons_person(account: account, person: person, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_accounts_account_persons_person\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Person.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates an existing person.&lt;/p&gt;
    # @param account [String?]
    # @param person [String?]
    # @optional @param address [Stripe::AddressSpecs1?]
    # @optional @param address_kana [Stripe::JapanAddressKanaSpecs1?]
    # @optional @param address_kanji [Stripe::JapanAddressKanjiSpecs1?]
    # @optional @param dob [Stripe::PostAccountPeopleRequestDob?]
    # @optional @param documents [Stripe::PersonDocumentsSpecs?]
    # @optional @param email [String?] The person's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param first_name [String?] The person's first name.
    # @optional @param first_name_kana [String?] The Kana variation of the person's first name (Japan only).
    # @optional @param first_name_kanji [String?] The Kanji variation of the person's first name (Japan only).
    # @optional @param full_name_aliases [Stripe::PostAccountPeopleRequestFullNameAliases?]
    # @optional @param gender [String?] The person's gender (International regulations require either \\\"male\\\" or \\\"female\\\").
    # @optional @param id_number [String?] The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param id_number_secondary [String?] The person's secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
    # @optional @param last_name [String?] The person's last name.
    # @optional @param last_name_kana [String?] The Kana variation of the person's last name (Japan only).
    # @optional @param last_name_kanji [String?] The Kanji variation of the person's last name (Japan only).
    # @optional @param maiden_name [String?] The person's maiden name.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nationality [String?] The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\"XX\\\" if unavailable.
    # @optional @param person_token [String?] A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
    # @optional @param phone [String?] The person's phone number.
    # @optional @param political_exposure [String?] Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
    # @optional @param registered_address [Stripe::AddressSpecs2?]
    # @optional @param relationship [Stripe::RelationshipSpecs?]
    # @optional @param ssn_last_4 [String?] The last four digits of the person's Social Security number (U.S. only).
    # @optional @param verification [Stripe::PersonVerificationSpecs1?]
    # @return nil
    def post_accounts_account_persons_person(*, account : String? = nil, person : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil, &block : Crest::Response ->)
      build_api_request_for_post_accounts_account_persons_person(account: account, person: person, address: address, address_kana: address_kana, address_kanji: address_kanji, dob: dob, documents: documents, email: email, expand: expand, first_name: first_name, first_name_kana: first_name_kana, first_name_kanji: first_name_kanji, full_name_aliases: full_name_aliases, gender: gender, id_number: id_number, id_number_secondary: id_number_secondary, last_name: last_name, last_name_kana: last_name_kana, last_name_kanji: last_name_kanji, maiden_name: maiden_name, metadata: metadata, nationality: nationality, person_token: person_token, phone: phone, political_exposure: political_exposure, registered_address: registered_address, relationship: relationship, ssn_last_4: ssn_last_4, verification: verification).execute(&block)
    end

    POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_ACCOUNT             = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_PERSON              = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_FIRST_NAME          = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_FIRST_NAME_KANA     = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_FIRST_NAME_KANJI    = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_ID_NUMBER           = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_ID_NUMBER_SECONDARY = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_LAST_NAME           = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_LAST_NAME_KANA      = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_LAST_NAME_KANJI     = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_MAIDEN_NAME         = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_NATIONALITY         = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_PERSON_TOKEN        = 5000
    POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_POLITICAL_EXPOSURE  = 5000

    # @return Crest::Request
    def build_api_request_for_post_accounts_account_persons_person(*, account : String? = nil, person : String? = nil, address : Stripe::AddressSpecs1? = nil, address_kana : Stripe::JapanAddressKanaSpecs1? = nil, address_kanji : Stripe::JapanAddressKanjiSpecs1? = nil, dob : Stripe::PostAccountPeopleRequestDob? = nil, documents : Stripe::PersonDocumentsSpecs? = nil, email : String? = nil, expand : Array(String)? = nil, first_name : String? = nil, first_name_kana : String? = nil, first_name_kanji : String? = nil, full_name_aliases : Stripe::PostAccountPeopleRequestFullNameAliases? = nil, gender : String? = nil, id_number : String? = nil, id_number_secondary : String? = nil, last_name : String? = nil, last_name_kana : String? = nil, last_name_kanji : String? = nil, maiden_name : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nationality : String? = nil, person_token : String? = nil, phone : String? = nil, political_exposure : String? = nil, registered_address : Stripe::AddressSpecs2? = nil, relationship : Stripe::RelationshipSpecs? = nil, ssn_last_4 : String? = nil, verification : Stripe::PersonVerificationSpecs1? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_accounts_account_persons_person ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_ACCOUNT)
        end
        raise ArgumentError.new("\"person\" is required and cannot be null") if person.nil?
        if _person = person
          OpenApi::PrimitiveValidator.validate_max_length("person", person.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_PERSON)
        end
        if _address = address
          _address.validate if _address.is_a?(OpenApi::Validatable)
        end
        if _address_kana = address_kana
          _address_kana.validate if _address_kana.is_a?(OpenApi::Validatable)
        end
        if _address_kanji = address_kanji
          _address_kanji.validate if _address_kanji.is_a?(OpenApi::Validatable)
        end
        if _dob = dob
          _dob.validate if _dob.is_a?(OpenApi::Validatable)
        end
        if _documents = documents
          _documents.validate if _documents.is_a?(OpenApi::Validatable)
        end

        if _first_name = first_name
          OpenApi::PrimitiveValidator.validate_max_length("first_name", first_name.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_FIRST_NAME)
        end
        if _first_name_kana = first_name_kana
          OpenApi::PrimitiveValidator.validate_max_length("first_name_kana", first_name_kana.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_FIRST_NAME_KANA)
        end
        if _first_name_kanji = first_name_kanji
          OpenApi::PrimitiveValidator.validate_max_length("first_name_kanji", first_name_kanji.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_FIRST_NAME_KANJI)
        end
        if _full_name_aliases = full_name_aliases
          _full_name_aliases.validate if _full_name_aliases.is_a?(OpenApi::Validatable)
        end

        if _id_number = id_number
          OpenApi::PrimitiveValidator.validate_max_length("id_number", id_number.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_ID_NUMBER)
        end
        if _id_number_secondary = id_number_secondary
          OpenApi::PrimitiveValidator.validate_max_length("id_number_secondary", id_number_secondary.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_ID_NUMBER_SECONDARY)
        end
        if _last_name = last_name
          OpenApi::PrimitiveValidator.validate_max_length("last_name", last_name.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_LAST_NAME)
        end
        if _last_name_kana = last_name_kana
          OpenApi::PrimitiveValidator.validate_max_length("last_name_kana", last_name_kana.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_LAST_NAME_KANA)
        end
        if _last_name_kanji = last_name_kanji
          OpenApi::PrimitiveValidator.validate_max_length("last_name_kanji", last_name_kanji.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_LAST_NAME_KANJI)
        end
        if _maiden_name = maiden_name
          OpenApi::PrimitiveValidator.validate_max_length("maiden_name", maiden_name.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_MAIDEN_NAME)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _nationality = nationality
          OpenApi::PrimitiveValidator.validate_max_length("nationality", nationality.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_NATIONALITY)
        end
        if _person_token = person_token
          OpenApi::PrimitiveValidator.validate_max_length("person_token", person_token.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_PERSON_TOKEN)
        end

        if _political_exposure = political_exposure
          OpenApi::PrimitiveValidator.validate_max_length("political_exposure", political_exposure.to_s.size, POST_ACCOUNTS_ACCOUNT_PERSONS_PERSON_MAX_LENGTH_FOR_POLITICAL_EXPOSURE)
        end
        if _registered_address = registered_address
          _registered_address.validate if _registered_address.is_a?(OpenApi::Validatable)
        end
        if _relationship = relationship
          _relationship.validate if _relationship.is_a?(OpenApi::Validatable)
        end

        if _verification = verification
          _verification.validate if _verification.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/persons/{person}".sub("{" + "account" + "}", URI.encode_path(account.to_s)).sub("{" + "person" + "}", URI.encode_path(person.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["address"] = address.to_s if !address.nil?
      form_params["address_kana"] = address_kana.to_s if !address_kana.nil?
      form_params["address_kanji"] = address_kanji.to_s if !address_kanji.nil?
      form_params["dob"] = dob.to_s if !dob.nil?
      form_params["documents"] = documents.to_s if !documents.nil?
      form_params["email"] = email.to_s if !email.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["first_name"] = first_name.to_s if !first_name.nil?
      form_params["first_name_kana"] = first_name_kana.to_s if !first_name_kana.nil?
      form_params["first_name_kanji"] = first_name_kanji.to_s if !first_name_kanji.nil?
      form_params["full_name_aliases"] = full_name_aliases.to_s if !full_name_aliases.nil?
      form_params["gender"] = gender.to_s if !gender.nil?
      form_params["id_number"] = id_number.to_s if !id_number.nil?
      form_params["id_number_secondary"] = id_number_secondary.to_s if !id_number_secondary.nil?
      form_params["last_name"] = last_name.to_s if !last_name.nil?
      form_params["last_name_kana"] = last_name_kana.to_s if !last_name_kana.nil?
      form_params["last_name_kanji"] = last_name_kanji.to_s if !last_name_kanji.nil?
      form_params["maiden_name"] = maiden_name.to_s if !maiden_name.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["nationality"] = nationality.to_s if !nationality.nil?
      form_params["person_token"] = person_token.to_s if !person_token.nil?
      form_params["phone"] = phone.to_s if !phone.nil?
      form_params["political_exposure"] = political_exposure.to_s if !political_exposure.nil?
      form_params["registered_address"] = registered_address.to_s if !registered_address.nil?
      form_params["relationship"] = relationship.to_s if !relationship.nil?
      form_params["ssn_last_4"] = ssn_last_4.to_s if !ssn_last_4.nil?
      form_params["verification"] = verification.to_s if !verification.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_accounts_account_persons_person",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>With <a href=\"/docs/connect\">Connect</a>, you may flag accounts as suspicious.</p>  <p>Test-mode Custom and Express accounts can be rejected at any time. Accounts created using live-mode keys may only be rejected once all balances are zero.</p>
    # @param account [String?]
    # @param reason [String?] The reason for rejecting the account. Can be `fraud`, `terms_of_service`, or `other`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Account]
    def post_accounts_account_reject(*, account : String? = nil, reason : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_accounts_account_reject_with_http_info(account: account, reason: reason, expand: expand)
      data
    end

    # &lt;p&gt;With &lt;a href&#x3D;\&quot;/docs/connect\&quot;&gt;Connect&lt;/a&gt;, you may flag accounts as suspicious.&lt;/p&gt;  &lt;p&gt;Test-mode Custom and Express accounts can be rejected at any time. Accounts created using live-mode keys may only be rejected once all balances are zero.&lt;/p&gt;
    # @param account [String?]
    # @param reason [String?] The reason for rejecting the account. Can be `fraud`, `terms_of_service`, or `other`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(Account, Integer, Hash)>] Account data, response status code and response headers
    def post_accounts_account_reject_with_http_info(*, account : String? = nil, reason : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_accounts_account_reject(account: account, reason: reason, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_accounts_account_reject\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Account.from_json(data), status_code, headers
    end

    # &lt;p&gt;With &lt;a href&#x3D;\&quot;/docs/connect\&quot;&gt;Connect&lt;/a&gt;, you may flag accounts as suspicious.&lt;/p&gt;  &lt;p&gt;Test-mode Custom and Express accounts can be rejected at any time. Accounts created using live-mode keys may only be rejected once all balances are zero.&lt;/p&gt;
    # @param account [String?]
    # @param reason [String?] The reason for rejecting the account. Can be `fraud`, `terms_of_service`, or `other`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_accounts_account_reject(*, account : String? = nil, reason : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_accounts_account_reject(account: account, reason: reason, expand: expand).execute(&block)
    end

    POST_ACCOUNTS_ACCOUNT_REJECT_MAX_LENGTH_FOR_ACCOUNT = 5000
    POST_ACCOUNTS_ACCOUNT_REJECT_MAX_LENGTH_FOR_REASON  = 5000

    # @return Crest::Request
    def build_api_request_for_post_accounts_account_reject(*, account : String? = nil, reason : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_accounts_account_reject ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_ACCOUNTS_ACCOUNT_REJECT_MAX_LENGTH_FOR_ACCOUNT)
        end
        raise ArgumentError.new("\"reason\" is required and cannot be null") if reason.nil?
        if _reason = reason
          OpenApi::PrimitiveValidator.validate_max_length("reason", reason.to_s.size, POST_ACCOUNTS_ACCOUNT_REJECT_MAX_LENGTH_FOR_REASON)
        end
      end

      # resource path
      local_var_path = "/v1/accounts/{account}/reject".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["reason"] = reason.to_s if !reason.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_accounts_account_reject",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Create an apple pay domain.</p>
    # @param domain_name [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [ApplePayDomain]
    def post_apple_pay_domains(*, domain_name : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_apple_pay_domains_with_http_info(domain_name: domain_name, expand: expand)
      data
    end

    # &lt;p&gt;Create an apple pay domain.&lt;/p&gt;
    # @param domain_name [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(ApplePayDomain, Integer, Hash)>] ApplePayDomain data, response status code and response headers
    def post_apple_pay_domains_with_http_info(*, domain_name : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_apple_pay_domains(domain_name: domain_name, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_apple_pay_domains\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ApplePayDomain.from_json(data), status_code, headers
    end

    # &lt;p&gt;Create an apple pay domain.&lt;/p&gt;
    # @param domain_name [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_apple_pay_domains(*, domain_name : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_apple_pay_domains(domain_name: domain_name, expand: expand).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_post_apple_pay_domains(*, domain_name : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_apple_pay_domains ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"domain_name\" is required and cannot be null") if domain_name.nil?
      end

      # resource path
      local_var_path = "/v1/apple_pay/domains"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["domain_name"] = domain_name.to_s if !domain_name.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_apple_pay_domains",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the specified application fee refund by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>  <p>This request only accepts metadata as an argument.</p>
    # @param fee [String?]
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [FeeRefund]
    def post_application_fees_fee_refunds_id(*, fee : String? = nil, id : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_application_fees_fee_refunds_id_with_http_info(fee: fee, id: id, expand: expand, metadata: metadata)
      data
    end

    # &lt;p&gt;Updates the specified application fee refund by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;  &lt;p&gt;This request only accepts metadata as an argument.&lt;/p&gt;
    # @param fee [String?]
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(FeeRefund, Integer, Hash)>] FeeRefund data, response status code and response headers
    def post_application_fees_fee_refunds_id_with_http_info(*, fee : String? = nil, id : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_application_fees_fee_refunds_id(fee: fee, id: id, expand: expand, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_application_fees_fee_refunds_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FeeRefund.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the specified application fee refund by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;  &lt;p&gt;This request only accepts metadata as an argument.&lt;/p&gt;
    # @param fee [String?]
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_application_fees_fee_refunds_id(*, fee : String? = nil, id : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_application_fees_fee_refunds_id(fee: fee, id: id, expand: expand, metadata: metadata).execute(&block)
    end

    POST_APPLICATION_FEES_FEE_REFUNDS_ID_MAX_LENGTH_FOR_FEE = 5000
    POST_APPLICATION_FEES_FEE_REFUNDS_ID_MAX_LENGTH_FOR_ID  = 5000

    # @return Crest::Request
    def build_api_request_for_post_application_fees_fee_refunds_id(*, fee : String? = nil, id : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_application_fees_fee_refunds_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"fee\" is required and cannot be null") if fee.nil?
        if _fee = fee
          OpenApi::PrimitiveValidator.validate_max_length("fee", fee.to_s.size, POST_APPLICATION_FEES_FEE_REFUNDS_ID_MAX_LENGTH_FOR_FEE)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_APPLICATION_FEES_FEE_REFUNDS_ID_MAX_LENGTH_FOR_ID)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/application_fees/{fee}/refunds/{id}".sub("{" + "fee" + "}", URI.encode_path(fee.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_application_fees_fee_refunds_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    #
    # @param id [String?]
    # @optional @param amount [Int64?]
    # @optional @param directive [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [ApplicationFee]
    def post_application_fees_id_refund(*, id : String? = nil, amount : Int64? = nil, directive : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_application_fees_id_refund_with_http_info(id: id, amount: amount, directive: directive, expand: expand)
      data
    end

    #
    # @param id [String?]
    # @optional @param amount [Int64?]
    # @optional @param directive [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(ApplicationFee, Integer, Hash)>] ApplicationFee data, response status code and response headers
    def post_application_fees_id_refund_with_http_info(*, id : String? = nil, amount : Int64? = nil, directive : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_application_fees_id_refund(id: id, amount: amount, directive: directive, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_application_fees_id_refund\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ApplicationFee.from_json(data), status_code, headers
    end

    #
    # @param id [String?]
    # @optional @param amount [Int64?]
    # @optional @param directive [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_application_fees_id_refund(*, id : String? = nil, amount : Int64? = nil, directive : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_application_fees_id_refund(id: id, amount: amount, directive: directive, expand: expand).execute(&block)
    end

    POST_APPLICATION_FEES_ID_REFUND_MAX_LENGTH_FOR_ID        = 5000
    POST_APPLICATION_FEES_ID_REFUND_MAX_LENGTH_FOR_DIRECTIVE = 5000

    # @return Crest::Request
    def build_api_request_for_post_application_fees_id_refund(*, id : String? = nil, amount : Int64? = nil, directive : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_application_fees_id_refund ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_APPLICATION_FEES_ID_REFUND_MAX_LENGTH_FOR_ID)
        end

        if _directive = directive
          OpenApi::PrimitiveValidator.validate_max_length("directive", directive.to_s.size, POST_APPLICATION_FEES_ID_REFUND_MAX_LENGTH_FOR_DIRECTIVE)
        end
      end

      # resource path
      local_var_path = "/v1/application_fees/{id}/refund".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["directive"] = directive.to_s if !directive.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_application_fees_id_refund",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Refunds an application fee that has previously been collected but not yet refunded. Funds will be refunded to the Stripe account from which the fee was originally collected.</p>  <p>You can optionally refund only part of an application fee. You can do so multiple times, until the entire fee has been refunded.</p>  <p>Once entirely refunded, an application fee can’t be refunded again. This method will raise an error when called on an already-refunded application fee, or when trying to refund more money than is left on an application fee.</p>
    # @param id [String?]
    # @optional @param amount [Int64?] A positive integer, in _cents (or local equivalent)_, representing how much of this fee to refund. Can refund only up to the remaining unrefunded amount of the fee.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [FeeRefund]
    def post_application_fees_id_refunds(*, id : String? = nil, amount : Int64? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_application_fees_id_refunds_with_http_info(id: id, amount: amount, expand: expand)
      data
    end

    # &lt;p&gt;Refunds an application fee that has previously been collected but not yet refunded. Funds will be refunded to the Stripe account from which the fee was originally collected.&lt;/p&gt;  &lt;p&gt;You can optionally refund only part of an application fee. You can do so multiple times, until the entire fee has been refunded.&lt;/p&gt;  &lt;p&gt;Once entirely refunded, an application fee can’t be refunded again. This method will raise an error when called on an already-refunded application fee, or when trying to refund more money than is left on an application fee.&lt;/p&gt;
    # @param id [String?]
    # @optional @param amount [Int64?] A positive integer, in _cents (or local equivalent)_, representing how much of this fee to refund. Can refund only up to the remaining unrefunded amount of the fee.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(FeeRefund, Integer, Hash)>] FeeRefund data, response status code and response headers
    def post_application_fees_id_refunds_with_http_info(*, id : String? = nil, amount : Int64? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_application_fees_id_refunds(id: id, amount: amount, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_application_fees_id_refunds\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FeeRefund.from_json(data), status_code, headers
    end

    # &lt;p&gt;Refunds an application fee that has previously been collected but not yet refunded. Funds will be refunded to the Stripe account from which the fee was originally collected.&lt;/p&gt;  &lt;p&gt;You can optionally refund only part of an application fee. You can do so multiple times, until the entire fee has been refunded.&lt;/p&gt;  &lt;p&gt;Once entirely refunded, an application fee can’t be refunded again. This method will raise an error when called on an already-refunded application fee, or when trying to refund more money than is left on an application fee.&lt;/p&gt;
    # @param id [String?]
    # @optional @param amount [Int64?] A positive integer, in _cents (or local equivalent)_, representing how much of this fee to refund. Can refund only up to the remaining unrefunded amount of the fee.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_application_fees_id_refunds(*, id : String? = nil, amount : Int64? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_application_fees_id_refunds(id: id, amount: amount, expand: expand).execute(&block)
    end

    POST_APPLICATION_FEES_ID_REFUNDS_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_post_application_fees_id_refunds(*, id : String? = nil, amount : Int64? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_application_fees_id_refunds ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_APPLICATION_FEES_ID_REFUNDS_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/application_fees/{id}/refunds".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_application_fees_id_refunds",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Create or replace a secret in the secret store.</p>
    # @param name [String?] A name for the secret that's unique within the scope.
    # @param payload [String?] The plaintext secret value to be stored.
    # @param scope [Stripe::ScopeParam1?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] The Unix timestamp for the expiry time of the secret, after which the secret deletes.
    # @return [AppsSecret]
    def post_apps_secrets(*, name : String? = nil, payload : String? = nil, scope : Stripe::ScopeParam1? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil)
      data, _status_code, _headers = post_apps_secrets_with_http_info(name: name, payload: payload, scope: scope, expand: expand, expires_at: expires_at)
      data
    end

    # &lt;p&gt;Create or replace a secret in the secret store.&lt;/p&gt;
    # @param name [String?] A name for the secret that's unique within the scope.
    # @param payload [String?] The plaintext secret value to be stored.
    # @param scope [Stripe::ScopeParam1?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] The Unix timestamp for the expiry time of the secret, after which the secret deletes.
    # @return [Array<(AppsSecret, Integer, Hash)>] AppsSecret data, response status code and response headers
    def post_apps_secrets_with_http_info(*, name : String? = nil, payload : String? = nil, scope : Stripe::ScopeParam1? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil)
      request = build_api_request_for_post_apps_secrets(name: name, payload: payload, scope: scope, expand: expand, expires_at: expires_at)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_apps_secrets\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return AppsSecret.from_json(data), status_code, headers
    end

    # &lt;p&gt;Create or replace a secret in the secret store.&lt;/p&gt;
    # @param name [String?] A name for the secret that's unique within the scope.
    # @param payload [String?] The plaintext secret value to be stored.
    # @param scope [Stripe::ScopeParam1?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] The Unix timestamp for the expiry time of the secret, after which the secret deletes.
    # @return nil
    def post_apps_secrets(*, name : String? = nil, payload : String? = nil, scope : Stripe::ScopeParam1? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, &block : Crest::Response ->)
      build_api_request_for_post_apps_secrets(name: name, payload: payload, scope: scope, expand: expand, expires_at: expires_at).execute(&block)
    end

    POST_APPS_SECRETS_MAX_LENGTH_FOR_NAME    = 5000
    POST_APPS_SECRETS_MAX_LENGTH_FOR_PAYLOAD = 5000

    # @return Crest::Request
    def build_api_request_for_post_apps_secrets(*, name : String? = nil, payload : String? = nil, scope : Stripe::ScopeParam1? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_apps_secrets ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"name\" is required and cannot be null") if name.nil?
        if _name = name
          OpenApi::PrimitiveValidator.validate_max_length("name", name.to_s.size, POST_APPS_SECRETS_MAX_LENGTH_FOR_NAME)
        end
        raise ArgumentError.new("\"payload\" is required and cannot be null") if payload.nil?
        if _payload = payload
          OpenApi::PrimitiveValidator.validate_max_length("payload", payload.to_s.size, POST_APPS_SECRETS_MAX_LENGTH_FOR_PAYLOAD)
        end
        raise ArgumentError.new("\"scope\" is required and cannot be null") if scope.nil?
        if _scope = scope
          _scope.validate if _scope.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/apps/secrets"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["expires_at"] = expires_at.to_s if !expires_at.nil?
      form_params["name"] = name.to_s if !name.nil?
      form_params["payload"] = payload.to_s if !payload.nil?
      form_params["scope"] = scope.to_s if !scope.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_apps_secrets",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Deletes a secret from the secret store by name and scope.</p>
    # @param name [String?] A name for the secret that's unique within the scope.
    # @param scope [Stripe::ScopeParam1?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [AppsSecret]
    def post_apps_secrets_delete(*, name : String? = nil, scope : Stripe::ScopeParam1? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_apps_secrets_delete_with_http_info(name: name, scope: scope, expand: expand)
      data
    end

    # &lt;p&gt;Deletes a secret from the secret store by name and scope.&lt;/p&gt;
    # @param name [String?] A name for the secret that's unique within the scope.
    # @param scope [Stripe::ScopeParam1?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(AppsSecret, Integer, Hash)>] AppsSecret data, response status code and response headers
    def post_apps_secrets_delete_with_http_info(*, name : String? = nil, scope : Stripe::ScopeParam1? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_apps_secrets_delete(name: name, scope: scope, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_apps_secrets_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return AppsSecret.from_json(data), status_code, headers
    end

    # &lt;p&gt;Deletes a secret from the secret store by name and scope.&lt;/p&gt;
    # @param name [String?] A name for the secret that's unique within the scope.
    # @param scope [Stripe::ScopeParam1?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_apps_secrets_delete(*, name : String? = nil, scope : Stripe::ScopeParam1? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_apps_secrets_delete(name: name, scope: scope, expand: expand).execute(&block)
    end

    POST_APPS_SECRETS_DELETE_MAX_LENGTH_FOR_NAME = 5000

    # @return Crest::Request
    def build_api_request_for_post_apps_secrets_delete(*, name : String? = nil, scope : Stripe::ScopeParam1? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_apps_secrets_delete ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"name\" is required and cannot be null") if name.nil?
        if _name = name
          OpenApi::PrimitiveValidator.validate_max_length("name", name.to_s.size, POST_APPS_SECRETS_DELETE_MAX_LENGTH_FOR_NAME)
        end
        raise ArgumentError.new("\"scope\" is required and cannot be null") if scope.nil?
        if _scope = scope
          _scope.validate if _scope.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/apps/secrets/delete"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["name"] = name.to_s if !name.nil?
      form_params["scope"] = scope.to_s if !scope.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_apps_secrets_delete",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a configuration that describes the functionality and behavior of a PortalSession</p>
    # @param business_profile [Stripe::BusinessProfileCreateParam?]
    # @param features [Stripe::FeaturesCreationParam?]
    # @optional @param default_return_url [Stripe::PostBillingPortalConfigurationsRequestDefaultReturnUrl?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param login_page [Stripe::LoginPageCreateParam?]
    # @return [BillingPortalConfiguration]
    def post_billing_portal_configurations(*, business_profile : Stripe::BusinessProfileCreateParam? = nil, features : Stripe::FeaturesCreationParam? = nil, default_return_url : Stripe::PostBillingPortalConfigurationsRequestDefaultReturnUrl? = nil, expand : Array(String)? = nil, login_page : Stripe::LoginPageCreateParam? = nil)
      data, _status_code, _headers = post_billing_portal_configurations_with_http_info(business_profile: business_profile, features: features, default_return_url: default_return_url, expand: expand, login_page: login_page)
      data
    end

    # &lt;p&gt;Creates a configuration that describes the functionality and behavior of a PortalSession&lt;/p&gt;
    # @param business_profile [Stripe::BusinessProfileCreateParam?]
    # @param features [Stripe::FeaturesCreationParam?]
    # @optional @param default_return_url [Stripe::PostBillingPortalConfigurationsRequestDefaultReturnUrl?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param login_page [Stripe::LoginPageCreateParam?]
    # @return [Array<(BillingPortalConfiguration, Integer, Hash)>] BillingPortalConfiguration data, response status code and response headers
    def post_billing_portal_configurations_with_http_info(*, business_profile : Stripe::BusinessProfileCreateParam? = nil, features : Stripe::FeaturesCreationParam? = nil, default_return_url : Stripe::PostBillingPortalConfigurationsRequestDefaultReturnUrl? = nil, expand : Array(String)? = nil, login_page : Stripe::LoginPageCreateParam? = nil)
      request = build_api_request_for_post_billing_portal_configurations(business_profile: business_profile, features: features, default_return_url: default_return_url, expand: expand, login_page: login_page)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_billing_portal_configurations\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return BillingPortalConfiguration.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a configuration that describes the functionality and behavior of a PortalSession&lt;/p&gt;
    # @param business_profile [Stripe::BusinessProfileCreateParam?]
    # @param features [Stripe::FeaturesCreationParam?]
    # @optional @param default_return_url [Stripe::PostBillingPortalConfigurationsRequestDefaultReturnUrl?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param login_page [Stripe::LoginPageCreateParam?]
    # @return nil
    def post_billing_portal_configurations(*, business_profile : Stripe::BusinessProfileCreateParam? = nil, features : Stripe::FeaturesCreationParam? = nil, default_return_url : Stripe::PostBillingPortalConfigurationsRequestDefaultReturnUrl? = nil, expand : Array(String)? = nil, login_page : Stripe::LoginPageCreateParam? = nil, &block : Crest::Response ->)
      build_api_request_for_post_billing_portal_configurations(business_profile: business_profile, features: features, default_return_url: default_return_url, expand: expand, login_page: login_page).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_post_billing_portal_configurations(*, business_profile : Stripe::BusinessProfileCreateParam? = nil, features : Stripe::FeaturesCreationParam? = nil, default_return_url : Stripe::PostBillingPortalConfigurationsRequestDefaultReturnUrl? = nil, expand : Array(String)? = nil, login_page : Stripe::LoginPageCreateParam? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_billing_portal_configurations ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"business_profile\" is required and cannot be null") if business_profile.nil?
        if _business_profile = business_profile
          _business_profile.validate if _business_profile.is_a?(OpenApi::Validatable)
        end
        raise ArgumentError.new("\"features\" is required and cannot be null") if features.nil?
        if _features = features
          _features.validate if _features.is_a?(OpenApi::Validatable)
        end
        if _default_return_url = default_return_url
          _default_return_url.validate if _default_return_url.is_a?(OpenApi::Validatable)
        end

        if _login_page = login_page
          _login_page.validate if _login_page.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/billing_portal/configurations"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["business_profile"] = business_profile.to_s if !business_profile.nil?
      form_params["default_return_url"] = default_return_url.to_s if !default_return_url.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["features"] = features.to_s if !features.nil?
      form_params["login_page"] = login_page.to_s if !login_page.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_billing_portal_configurations",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates a configuration that describes the functionality of the customer portal.</p>
    # @param configuration [String?]
    # @optional @param active [Bool?] Whether the configuration is active and can be used to create portal sessions.
    # @optional @param business_profile [Stripe::BusinessProfileUpdateParam?]
    # @optional @param default_return_url [Stripe::PostBillingPortalConfigurationsRequestDefaultReturnUrl?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param features [Stripe::FeaturesUpdatingParam?]
    # @optional @param login_page [Stripe::LoginPageUpdateParam?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [BillingPortalConfiguration]
    def post_billing_portal_configurations_configuration(*, configuration : String? = nil, active : Bool? = nil, business_profile : Stripe::BusinessProfileUpdateParam? = nil, default_return_url : Stripe::PostBillingPortalConfigurationsRequestDefaultReturnUrl? = nil, expand : Array(String)? = nil, features : Stripe::FeaturesUpdatingParam? = nil, login_page : Stripe::LoginPageUpdateParam? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_billing_portal_configurations_configuration_with_http_info(configuration: configuration, active: active, business_profile: business_profile, default_return_url: default_return_url, expand: expand, features: features, login_page: login_page, metadata: metadata)
      data
    end

    # &lt;p&gt;Updates a configuration that describes the functionality of the customer portal.&lt;/p&gt;
    # @param configuration [String?]
    # @optional @param active [Bool?] Whether the configuration is active and can be used to create portal sessions.
    # @optional @param business_profile [Stripe::BusinessProfileUpdateParam?]
    # @optional @param default_return_url [Stripe::PostBillingPortalConfigurationsRequestDefaultReturnUrl?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param features [Stripe::FeaturesUpdatingParam?]
    # @optional @param login_page [Stripe::LoginPageUpdateParam?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(BillingPortalConfiguration, Integer, Hash)>] BillingPortalConfiguration data, response status code and response headers
    def post_billing_portal_configurations_configuration_with_http_info(*, configuration : String? = nil, active : Bool? = nil, business_profile : Stripe::BusinessProfileUpdateParam? = nil, default_return_url : Stripe::PostBillingPortalConfigurationsRequestDefaultReturnUrl? = nil, expand : Array(String)? = nil, features : Stripe::FeaturesUpdatingParam? = nil, login_page : Stripe::LoginPageUpdateParam? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_billing_portal_configurations_configuration(configuration: configuration, active: active, business_profile: business_profile, default_return_url: default_return_url, expand: expand, features: features, login_page: login_page, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_billing_portal_configurations_configuration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return BillingPortalConfiguration.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates a configuration that describes the functionality of the customer portal.&lt;/p&gt;
    # @param configuration [String?]
    # @optional @param active [Bool?] Whether the configuration is active and can be used to create portal sessions.
    # @optional @param business_profile [Stripe::BusinessProfileUpdateParam?]
    # @optional @param default_return_url [Stripe::PostBillingPortalConfigurationsRequestDefaultReturnUrl?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param features [Stripe::FeaturesUpdatingParam?]
    # @optional @param login_page [Stripe::LoginPageUpdateParam?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_billing_portal_configurations_configuration(*, configuration : String? = nil, active : Bool? = nil, business_profile : Stripe::BusinessProfileUpdateParam? = nil, default_return_url : Stripe::PostBillingPortalConfigurationsRequestDefaultReturnUrl? = nil, expand : Array(String)? = nil, features : Stripe::FeaturesUpdatingParam? = nil, login_page : Stripe::LoginPageUpdateParam? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_billing_portal_configurations_configuration(configuration: configuration, active: active, business_profile: business_profile, default_return_url: default_return_url, expand: expand, features: features, login_page: login_page, metadata: metadata).execute(&block)
    end

    POST_BILLING_PORTAL_CONFIGURATIONS_CONFIGURATION_MAX_LENGTH_FOR_CONFIGURATION = 5000

    # @return Crest::Request
    def build_api_request_for_post_billing_portal_configurations_configuration(*, configuration : String? = nil, active : Bool? = nil, business_profile : Stripe::BusinessProfileUpdateParam? = nil, default_return_url : Stripe::PostBillingPortalConfigurationsRequestDefaultReturnUrl? = nil, expand : Array(String)? = nil, features : Stripe::FeaturesUpdatingParam? = nil, login_page : Stripe::LoginPageUpdateParam? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_billing_portal_configurations_configuration ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"configuration\" is required and cannot be null") if configuration.nil?
        if _configuration = configuration
          OpenApi::PrimitiveValidator.validate_max_length("configuration", configuration.to_s.size, POST_BILLING_PORTAL_CONFIGURATIONS_CONFIGURATION_MAX_LENGTH_FOR_CONFIGURATION)
        end

        if _business_profile = business_profile
          _business_profile.validate if _business_profile.is_a?(OpenApi::Validatable)
        end
        if _default_return_url = default_return_url
          _default_return_url.validate if _default_return_url.is_a?(OpenApi::Validatable)
        end

        if _features = features
          _features.validate if _features.is_a?(OpenApi::Validatable)
        end
        if _login_page = login_page
          _login_page.validate if _login_page.is_a?(OpenApi::Validatable)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/billing_portal/configurations/{configuration}".sub("{" + "configuration" + "}", URI.encode_path(configuration.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["active"] = active.to_s if !active.nil?
      form_params["business_profile"] = business_profile.to_s if !business_profile.nil?
      form_params["default_return_url"] = default_return_url.to_s if !default_return_url.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["features"] = features.to_s if !features.nil?
      form_params["login_page"] = login_page.to_s if !login_page.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_billing_portal_configurations_configuration",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a session of the customer portal.</p>
    # @param customer [String?] The ID of an existing customer.
    # @optional @param configuration [String?] The ID of an existing [configuration](https://stripe.com/docs/api/customer_portal/configuration) to use for this session, describing its functionality and features. If not specified, the session uses the default configuration.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param locale [String?] The IETF language tag of the locale Customer Portal is displayed in. If blank or auto, the customer’s `preferred_locales` or browser’s locale is used.
    # @optional @param on_behalf_of [String?] The `on_behalf_of` account to use for this session. When specified, only subscriptions and invoices with this `on_behalf_of` account appear in the portal. For more information, see the [docs](https://stripe.com/docs/connect/charges-transfers#on-behalf-of). Use the [Accounts API](https://stripe.com/docs/api/accounts/object#account_object-settings-branding) to modify the `on_behalf_of` account's branding settings, which the portal displays.
    # @optional @param return_url [String?] The default URL to redirect customers to when they click on the portal's link to return to your website.
    # @return [BillingPortalSession]
    def post_billing_portal_sessions(*, customer : String? = nil, configuration : String? = nil, expand : Array(String)? = nil, locale : String? = nil, on_behalf_of : String? = nil, return_url : String? = nil)
      data, _status_code, _headers = post_billing_portal_sessions_with_http_info(customer: customer, configuration: configuration, expand: expand, locale: locale, on_behalf_of: on_behalf_of, return_url: return_url)
      data
    end

    # &lt;p&gt;Creates a session of the customer portal.&lt;/p&gt;
    # @param customer [String?] The ID of an existing customer.
    # @optional @param configuration [String?] The ID of an existing [configuration](https://stripe.com/docs/api/customer_portal/configuration) to use for this session, describing its functionality and features. If not specified, the session uses the default configuration.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param locale [String?] The IETF language tag of the locale Customer Portal is displayed in. If blank or auto, the customer’s `preferred_locales` or browser’s locale is used.
    # @optional @param on_behalf_of [String?] The `on_behalf_of` account to use for this session. When specified, only subscriptions and invoices with this `on_behalf_of` account appear in the portal. For more information, see the [docs](https://stripe.com/docs/connect/charges-transfers#on-behalf-of). Use the [Accounts API](https://stripe.com/docs/api/accounts/object#account_object-settings-branding) to modify the `on_behalf_of` account's branding settings, which the portal displays.
    # @optional @param return_url [String?] The default URL to redirect customers to when they click on the portal's link to return to your website.
    # @return [Array<(BillingPortalSession, Integer, Hash)>] BillingPortalSession data, response status code and response headers
    def post_billing_portal_sessions_with_http_info(*, customer : String? = nil, configuration : String? = nil, expand : Array(String)? = nil, locale : String? = nil, on_behalf_of : String? = nil, return_url : String? = nil)
      request = build_api_request_for_post_billing_portal_sessions(customer: customer, configuration: configuration, expand: expand, locale: locale, on_behalf_of: on_behalf_of, return_url: return_url)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_billing_portal_sessions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return BillingPortalSession.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a session of the customer portal.&lt;/p&gt;
    # @param customer [String?] The ID of an existing customer.
    # @optional @param configuration [String?] The ID of an existing [configuration](https://stripe.com/docs/api/customer_portal/configuration) to use for this session, describing its functionality and features. If not specified, the session uses the default configuration.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param locale [String?] The IETF language tag of the locale Customer Portal is displayed in. If blank or auto, the customer’s `preferred_locales` or browser’s locale is used.
    # @optional @param on_behalf_of [String?] The `on_behalf_of` account to use for this session. When specified, only subscriptions and invoices with this `on_behalf_of` account appear in the portal. For more information, see the [docs](https://stripe.com/docs/connect/charges-transfers#on-behalf-of). Use the [Accounts API](https://stripe.com/docs/api/accounts/object#account_object-settings-branding) to modify the `on_behalf_of` account's branding settings, which the portal displays.
    # @optional @param return_url [String?] The default URL to redirect customers to when they click on the portal's link to return to your website.
    # @return nil
    def post_billing_portal_sessions(*, customer : String? = nil, configuration : String? = nil, expand : Array(String)? = nil, locale : String? = nil, on_behalf_of : String? = nil, return_url : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_billing_portal_sessions(customer: customer, configuration: configuration, expand: expand, locale: locale, on_behalf_of: on_behalf_of, return_url: return_url).execute(&block)
    end

    POST_BILLING_PORTAL_SESSIONS_MAX_LENGTH_FOR_CUSTOMER      = 5000
    POST_BILLING_PORTAL_SESSIONS_MAX_LENGTH_FOR_CONFIGURATION = 5000
    POST_BILLING_PORTAL_SESSIONS_VALID_VALUES_FOR_LOCALE      = StaticArray["auto", "bg", "cs", "da", "de", "el", "en", "en-AU", "en-CA", "en-GB", "en-IE", "en-IN", "en-NZ", "en-SG", "es", "es-419", "et", "fi", "fil", "fr", "fr-CA", "hr", "hu", "id", "it", "ja", "ko", "lt", "lv", "ms", "mt", "nb", "nl", "pl", "pt", "pt-BR", "ro", "ru", "sk", "sl", "sv", "th", "tr", "vi", "zh", "zh-HK", "zh-TW"]

    # @return Crest::Request
    def build_api_request_for_post_billing_portal_sessions(*, customer : String? = nil, configuration : String? = nil, expand : Array(String)? = nil, locale : String? = nil, on_behalf_of : String? = nil, return_url : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_billing_portal_sessions ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_BILLING_PORTAL_SESSIONS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _configuration = configuration
          OpenApi::PrimitiveValidator.validate_max_length("configuration", configuration.to_s.size, POST_BILLING_PORTAL_SESSIONS_MAX_LENGTH_FOR_CONFIGURATION)
        end

        if _locale = locale
          OpenApi::EnumValidator.validate("locale", _locale, POST_BILLING_PORTAL_SESSIONS_VALID_VALUES_FOR_LOCALE)
        end
      end

      # resource path
      local_var_path = "/v1/billing_portal/sessions"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["configuration"] = configuration.to_s if !configuration.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["locale"] = locale.to_s if !locale.nil?
      form_params["on_behalf_of"] = on_behalf_of.to_s if !on_behalf_of.nil?
      form_params["return_url"] = return_url.to_s if !return_url.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_billing_portal_sessions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>To charge a credit card or other payment source, you create a <code>Charge</code> object. If your API key is in test mode, the supplied payment source (e.g., card) won’t actually be charged, although everything else will occur as if in live mode. (Stripe assumes that the charge would have completed successfully).</p>
    # @optional @param amount [Int64?] Amount intended to be collected by this payment. A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
    # @optional @param application_fee [Int64?]
    # @optional @param application_fee_amount [Int64?] A fee in cents (or local equivalent) that will be applied to the charge and transferred to the application owner's Stripe account. The request must be made with an OAuth key or the `Stripe-Account` header in order to take an application fee. For more information, see the application fees [documentation](https://stripe.com/docs/connect/direct-charges#collecting-fees).
    # @optional @param capture [Bool?] Whether to immediately capture the charge. Defaults to `true`. When `false`, the charge issues an authorization (or pre-authorization), and will need to be [captured](https://stripe.com/docs/api#capture_charge) later. Uncaptured charges expire after a set number of days (7 by default). For more information, see the [authorizing charges and settling later](https://stripe.com/docs/charges/placing-a-hold) documentation.
    # @optional @param card [Stripe::PostChargesRequestCard?]
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param customer [String?] The ID of an existing customer that will be charged in this request.
    # @optional @param description [String?] An arbitrary string which you can attach to a `Charge` object. It is displayed when in the web interface alongside the charge. Note that if you use Stripe to send automatic email receipts to your customers, your receipt emails will include the `description` of the charge(s) that they are describing.
    # @optional @param destination [Stripe::PostChargesRequestDestination?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param on_behalf_of [String?] The Stripe account ID for which these funds are intended. Automatically set if you use the `destination` parameter. For details, see [Creating Separate Charges and Transfers](https://stripe.com/docs/connect/charges-transfers#on-behalf-of).
    # @optional @param radar_options [Stripe::RadarOptions?]
    # @optional @param receipt_email [String?] The email address to which this charge's [receipt](https://stripe.com/docs/dashboard/receipts) will be sent. The receipt will not be sent until the charge is paid, and no receipts will be sent for test mode charges. If this charge is for a [Customer](https://stripe.com/docs/api/customers/object), the email address specified here will override the customer's email address. If `receipt_email` is specified for a charge in live mode, a receipt will be sent regardless of your [email settings](https://dashboard.stripe.com/account/emails).
    # @optional @param shipping [Stripe::OptionalFieldsShipping?]
    # @optional @param source [String?] A payment source to be charged. This can be the ID of a [card](https://stripe.com/docs/api#cards) (i.e., credit or debit card), a [bank account](https://stripe.com/docs/api#bank_accounts), a [source](https://stripe.com/docs/api#sources), a [token](https://stripe.com/docs/api#tokens), or a [connected account](https://stripe.com/docs/connect/account-debits#charging-a-connected-account). For certain sources---namely, [cards](https://stripe.com/docs/api#cards), [bank accounts](https://stripe.com/docs/api#bank_accounts), and attached [sources](https://stripe.com/docs/api#sources)---you must also pass the ID of the associated customer.
    # @optional @param statement_descriptor [String?] For card charges, use `statement_descriptor_suffix` instead. Otherwise, you can use this value as the complete description of a charge on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    # @optional @param statement_descriptor_suffix [String?] Provides information about the charge that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
    # @optional @param transfer_data [Stripe::TransferDataSpecs?]
    # @optional @param transfer_group [String?] A string that identifies this transaction as part of a group. For details, see [Grouping transactions](https://stripe.com/docs/connect/charges-transfers#transfer-options).
    # @return [Charge]
    def post_charges(*, amount : Int64? = nil, application_fee : Int64? = nil, application_fee_amount : Int64? = nil, capture : Bool? = nil, card : Stripe::PostChargesRequestCard? = nil, currency : String? = nil, customer : String? = nil, description : String? = nil, destination : Stripe::PostChargesRequestDestination? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, on_behalf_of : String? = nil, radar_options : Stripe::RadarOptions? = nil, receipt_email : String? = nil, shipping : Stripe::OptionalFieldsShipping? = nil, source : String? = nil, statement_descriptor : String? = nil, statement_descriptor_suffix : String? = nil, transfer_data : Stripe::TransferDataSpecs? = nil, transfer_group : String? = nil)
      data, _status_code, _headers = post_charges_with_http_info(amount: amount, application_fee: application_fee, application_fee_amount: application_fee_amount, capture: capture, card: card, currency: currency, customer: customer, description: description, destination: destination, expand: expand, metadata: metadata, on_behalf_of: on_behalf_of, radar_options: radar_options, receipt_email: receipt_email, shipping: shipping, source: source, statement_descriptor: statement_descriptor, statement_descriptor_suffix: statement_descriptor_suffix, transfer_data: transfer_data, transfer_group: transfer_group)
      data
    end

    # &lt;p&gt;To charge a credit card or other payment source, you create a &lt;code&gt;Charge&lt;/code&gt; object. If your API key is in test mode, the supplied payment source (e.g., card) won’t actually be charged, although everything else will occur as if in live mode. (Stripe assumes that the charge would have completed successfully).&lt;/p&gt;
    # @optional @param amount [Int64?] Amount intended to be collected by this payment. A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
    # @optional @param application_fee [Int64?]
    # @optional @param application_fee_amount [Int64?] A fee in cents (or local equivalent) that will be applied to the charge and transferred to the application owner's Stripe account. The request must be made with an OAuth key or the `Stripe-Account` header in order to take an application fee. For more information, see the application fees [documentation](https://stripe.com/docs/connect/direct-charges#collecting-fees).
    # @optional @param capture [Bool?] Whether to immediately capture the charge. Defaults to `true`. When `false`, the charge issues an authorization (or pre-authorization), and will need to be [captured](https://stripe.com/docs/api#capture_charge) later. Uncaptured charges expire after a set number of days (7 by default). For more information, see the [authorizing charges and settling later](https://stripe.com/docs/charges/placing-a-hold) documentation.
    # @optional @param card [Stripe::PostChargesRequestCard?]
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param customer [String?] The ID of an existing customer that will be charged in this request.
    # @optional @param description [String?] An arbitrary string which you can attach to a `Charge` object. It is displayed when in the web interface alongside the charge. Note that if you use Stripe to send automatic email receipts to your customers, your receipt emails will include the `description` of the charge(s) that they are describing.
    # @optional @param destination [Stripe::PostChargesRequestDestination?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param on_behalf_of [String?] The Stripe account ID for which these funds are intended. Automatically set if you use the `destination` parameter. For details, see [Creating Separate Charges and Transfers](https://stripe.com/docs/connect/charges-transfers#on-behalf-of).
    # @optional @param radar_options [Stripe::RadarOptions?]
    # @optional @param receipt_email [String?] The email address to which this charge's [receipt](https://stripe.com/docs/dashboard/receipts) will be sent. The receipt will not be sent until the charge is paid, and no receipts will be sent for test mode charges. If this charge is for a [Customer](https://stripe.com/docs/api/customers/object), the email address specified here will override the customer's email address. If `receipt_email` is specified for a charge in live mode, a receipt will be sent regardless of your [email settings](https://dashboard.stripe.com/account/emails).
    # @optional @param shipping [Stripe::OptionalFieldsShipping?]
    # @optional @param source [String?] A payment source to be charged. This can be the ID of a [card](https://stripe.com/docs/api#cards) (i.e., credit or debit card), a [bank account](https://stripe.com/docs/api#bank_accounts), a [source](https://stripe.com/docs/api#sources), a [token](https://stripe.com/docs/api#tokens), or a [connected account](https://stripe.com/docs/connect/account-debits#charging-a-connected-account). For certain sources---namely, [cards](https://stripe.com/docs/api#cards), [bank accounts](https://stripe.com/docs/api#bank_accounts), and attached [sources](https://stripe.com/docs/api#sources)---you must also pass the ID of the associated customer.
    # @optional @param statement_descriptor [String?] For card charges, use `statement_descriptor_suffix` instead. Otherwise, you can use this value as the complete description of a charge on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    # @optional @param statement_descriptor_suffix [String?] Provides information about the charge that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
    # @optional @param transfer_data [Stripe::TransferDataSpecs?]
    # @optional @param transfer_group [String?] A string that identifies this transaction as part of a group. For details, see [Grouping transactions](https://stripe.com/docs/connect/charges-transfers#transfer-options).
    # @return [Array<(Charge, Integer, Hash)>] Charge data, response status code and response headers
    def post_charges_with_http_info(*, amount : Int64? = nil, application_fee : Int64? = nil, application_fee_amount : Int64? = nil, capture : Bool? = nil, card : Stripe::PostChargesRequestCard? = nil, currency : String? = nil, customer : String? = nil, description : String? = nil, destination : Stripe::PostChargesRequestDestination? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, on_behalf_of : String? = nil, radar_options : Stripe::RadarOptions? = nil, receipt_email : String? = nil, shipping : Stripe::OptionalFieldsShipping? = nil, source : String? = nil, statement_descriptor : String? = nil, statement_descriptor_suffix : String? = nil, transfer_data : Stripe::TransferDataSpecs? = nil, transfer_group : String? = nil)
      request = build_api_request_for_post_charges(amount: amount, application_fee: application_fee, application_fee_amount: application_fee_amount, capture: capture, card: card, currency: currency, customer: customer, description: description, destination: destination, expand: expand, metadata: metadata, on_behalf_of: on_behalf_of, radar_options: radar_options, receipt_email: receipt_email, shipping: shipping, source: source, statement_descriptor: statement_descriptor, statement_descriptor_suffix: statement_descriptor_suffix, transfer_data: transfer_data, transfer_group: transfer_group)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_charges\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Charge.from_json(data), status_code, headers
    end

    # &lt;p&gt;To charge a credit card or other payment source, you create a &lt;code&gt;Charge&lt;/code&gt; object. If your API key is in test mode, the supplied payment source (e.g., card) won’t actually be charged, although everything else will occur as if in live mode. (Stripe assumes that the charge would have completed successfully).&lt;/p&gt;
    # @optional @param amount [Int64?] Amount intended to be collected by this payment. A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
    # @optional @param application_fee [Int64?]
    # @optional @param application_fee_amount [Int64?] A fee in cents (or local equivalent) that will be applied to the charge and transferred to the application owner's Stripe account. The request must be made with an OAuth key or the `Stripe-Account` header in order to take an application fee. For more information, see the application fees [documentation](https://stripe.com/docs/connect/direct-charges#collecting-fees).
    # @optional @param capture [Bool?] Whether to immediately capture the charge. Defaults to `true`. When `false`, the charge issues an authorization (or pre-authorization), and will need to be [captured](https://stripe.com/docs/api#capture_charge) later. Uncaptured charges expire after a set number of days (7 by default). For more information, see the [authorizing charges and settling later](https://stripe.com/docs/charges/placing-a-hold) documentation.
    # @optional @param card [Stripe::PostChargesRequestCard?]
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param customer [String?] The ID of an existing customer that will be charged in this request.
    # @optional @param description [String?] An arbitrary string which you can attach to a `Charge` object. It is displayed when in the web interface alongside the charge. Note that if you use Stripe to send automatic email receipts to your customers, your receipt emails will include the `description` of the charge(s) that they are describing.
    # @optional @param destination [Stripe::PostChargesRequestDestination?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param on_behalf_of [String?] The Stripe account ID for which these funds are intended. Automatically set if you use the `destination` parameter. For details, see [Creating Separate Charges and Transfers](https://stripe.com/docs/connect/charges-transfers#on-behalf-of).
    # @optional @param radar_options [Stripe::RadarOptions?]
    # @optional @param receipt_email [String?] The email address to which this charge's [receipt](https://stripe.com/docs/dashboard/receipts) will be sent. The receipt will not be sent until the charge is paid, and no receipts will be sent for test mode charges. If this charge is for a [Customer](https://stripe.com/docs/api/customers/object), the email address specified here will override the customer's email address. If `receipt_email` is specified for a charge in live mode, a receipt will be sent regardless of your [email settings](https://dashboard.stripe.com/account/emails).
    # @optional @param shipping [Stripe::OptionalFieldsShipping?]
    # @optional @param source [String?] A payment source to be charged. This can be the ID of a [card](https://stripe.com/docs/api#cards) (i.e., credit or debit card), a [bank account](https://stripe.com/docs/api#bank_accounts), a [source](https://stripe.com/docs/api#sources), a [token](https://stripe.com/docs/api#tokens), or a [connected account](https://stripe.com/docs/connect/account-debits#charging-a-connected-account). For certain sources---namely, [cards](https://stripe.com/docs/api#cards), [bank accounts](https://stripe.com/docs/api#bank_accounts), and attached [sources](https://stripe.com/docs/api#sources)---you must also pass the ID of the associated customer.
    # @optional @param statement_descriptor [String?] For card charges, use `statement_descriptor_suffix` instead. Otherwise, you can use this value as the complete description of a charge on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    # @optional @param statement_descriptor_suffix [String?] Provides information about the charge that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
    # @optional @param transfer_data [Stripe::TransferDataSpecs?]
    # @optional @param transfer_group [String?] A string that identifies this transaction as part of a group. For details, see [Grouping transactions](https://stripe.com/docs/connect/charges-transfers#transfer-options).
    # @return nil
    def post_charges(*, amount : Int64? = nil, application_fee : Int64? = nil, application_fee_amount : Int64? = nil, capture : Bool? = nil, card : Stripe::PostChargesRequestCard? = nil, currency : String? = nil, customer : String? = nil, description : String? = nil, destination : Stripe::PostChargesRequestDestination? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, on_behalf_of : String? = nil, radar_options : Stripe::RadarOptions? = nil, receipt_email : String? = nil, shipping : Stripe::OptionalFieldsShipping? = nil, source : String? = nil, statement_descriptor : String? = nil, statement_descriptor_suffix : String? = nil, transfer_data : Stripe::TransferDataSpecs? = nil, transfer_group : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_charges(amount: amount, application_fee: application_fee, application_fee_amount: application_fee_amount, capture: capture, card: card, currency: currency, customer: customer, description: description, destination: destination, expand: expand, metadata: metadata, on_behalf_of: on_behalf_of, radar_options: radar_options, receipt_email: receipt_email, shipping: shipping, source: source, statement_descriptor: statement_descriptor, statement_descriptor_suffix: statement_descriptor_suffix, transfer_data: transfer_data, transfer_group: transfer_group).execute(&block)
    end

    POST_CHARGES_MAX_LENGTH_FOR_CUSTOMER                    =   500
    POST_CHARGES_MAX_LENGTH_FOR_DESCRIPTION                 = 40000
    POST_CHARGES_MAX_LENGTH_FOR_ON_BEHALF_OF                =  5000
    POST_CHARGES_MAX_LENGTH_FOR_SOURCE                      =  5000
    POST_CHARGES_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR        =    22
    POST_CHARGES_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR_SUFFIX =    22

    # @return Crest::Request
    def build_api_request_for_post_charges(*, amount : Int64? = nil, application_fee : Int64? = nil, application_fee_amount : Int64? = nil, capture : Bool? = nil, card : Stripe::PostChargesRequestCard? = nil, currency : String? = nil, customer : String? = nil, description : String? = nil, destination : Stripe::PostChargesRequestDestination? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, on_behalf_of : String? = nil, radar_options : Stripe::RadarOptions? = nil, receipt_email : String? = nil, shipping : Stripe::OptionalFieldsShipping? = nil, source : String? = nil, statement_descriptor : String? = nil, statement_descriptor_suffix : String? = nil, transfer_data : Stripe::TransferDataSpecs? = nil, transfer_group : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_charges ..." }
      end

      if client_side_validation
        if _card = card
          _card.validate if _card.is_a?(OpenApi::Validatable)
        end

        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_CHARGES_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_CHARGES_MAX_LENGTH_FOR_DESCRIPTION)
        end
        if _destination = destination
          _destination.validate if _destination.is_a?(OpenApi::Validatable)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _on_behalf_of = on_behalf_of
          OpenApi::PrimitiveValidator.validate_max_length("on_behalf_of", on_behalf_of.to_s.size, POST_CHARGES_MAX_LENGTH_FOR_ON_BEHALF_OF)
        end
        if _radar_options = radar_options
          _radar_options.validate if _radar_options.is_a?(OpenApi::Validatable)
        end

        if _shipping = shipping
          _shipping.validate if _shipping.is_a?(OpenApi::Validatable)
        end
        if _source = source
          OpenApi::PrimitiveValidator.validate_max_length("source", source.to_s.size, POST_CHARGES_MAX_LENGTH_FOR_SOURCE)
        end
        if _statement_descriptor = statement_descriptor
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor", statement_descriptor.to_s.size, POST_CHARGES_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR)
        end
        if _statement_descriptor_suffix = statement_descriptor_suffix
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor_suffix", statement_descriptor_suffix.to_s.size, POST_CHARGES_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR_SUFFIX)
        end
        if _transfer_data = transfer_data
          _transfer_data.validate if _transfer_data.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/charges"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["application_fee"] = application_fee.to_s if !application_fee.nil?
      form_params["application_fee_amount"] = application_fee_amount.to_s if !application_fee_amount.nil?
      form_params["capture"] = capture.to_s if !capture.nil?
      form_params["card"] = card.to_s if !card.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["destination"] = destination.to_s if !destination.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["on_behalf_of"] = on_behalf_of.to_s if !on_behalf_of.nil?
      form_params["radar_options"] = radar_options.to_s if !radar_options.nil?
      form_params["receipt_email"] = receipt_email.to_s if !receipt_email.nil?
      form_params["shipping"] = shipping.to_s if !shipping.nil?
      form_params["source"] = source.to_s if !source.nil?
      form_params["statement_descriptor"] = statement_descriptor.to_s if !statement_descriptor.nil?
      form_params["statement_descriptor_suffix"] = statement_descriptor_suffix.to_s if !statement_descriptor_suffix.nil?
      form_params["transfer_data"] = transfer_data.to_s if !transfer_data.nil?
      form_params["transfer_group"] = transfer_group.to_s if !transfer_group.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_charges",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the specified charge by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
    # @param charge [String?]
    # @optional @param customer [String?] The ID of an existing customer that will be associated with this request. This field may only be updated if there is no existing associated customer with this charge.
    # @optional @param description [String?] An arbitrary string which you can attach to a charge object. It is displayed when in the web interface alongside the charge. Note that if you use Stripe to send automatic email receipts to your customers, your receipt emails will include the `description` of the charge(s) that they are describing.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param fraud_details [Stripe::FraudDetails?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param receipt_email [String?] This is the email address that the receipt for this charge will be sent to. If this field is updated, then a new email receipt will be sent to the updated address.
    # @optional @param shipping [Stripe::OptionalFieldsShipping?]
    # @optional @param transfer_group [String?] A string that identifies this transaction as part of a group. `transfer_group` may only be provided if it has not been set. See the [Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-options) for details.
    # @return [Charge]
    def post_charges_charge(*, charge : String? = nil, customer : String? = nil, description : String? = nil, expand : Array(String)? = nil, fraud_details : Stripe::FraudDetails? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, receipt_email : String? = nil, shipping : Stripe::OptionalFieldsShipping? = nil, transfer_group : String? = nil)
      data, _status_code, _headers = post_charges_charge_with_http_info(charge: charge, customer: customer, description: description, expand: expand, fraud_details: fraud_details, metadata: metadata, receipt_email: receipt_email, shipping: shipping, transfer_group: transfer_group)
      data
    end

    # &lt;p&gt;Updates the specified charge by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;
    # @param charge [String?]
    # @optional @param customer [String?] The ID of an existing customer that will be associated with this request. This field may only be updated if there is no existing associated customer with this charge.
    # @optional @param description [String?] An arbitrary string which you can attach to a charge object. It is displayed when in the web interface alongside the charge. Note that if you use Stripe to send automatic email receipts to your customers, your receipt emails will include the `description` of the charge(s) that they are describing.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param fraud_details [Stripe::FraudDetails?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param receipt_email [String?] This is the email address that the receipt for this charge will be sent to. If this field is updated, then a new email receipt will be sent to the updated address.
    # @optional @param shipping [Stripe::OptionalFieldsShipping?]
    # @optional @param transfer_group [String?] A string that identifies this transaction as part of a group. `transfer_group` may only be provided if it has not been set. See the [Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-options) for details.
    # @return [Array<(Charge, Integer, Hash)>] Charge data, response status code and response headers
    def post_charges_charge_with_http_info(*, charge : String? = nil, customer : String? = nil, description : String? = nil, expand : Array(String)? = nil, fraud_details : Stripe::FraudDetails? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, receipt_email : String? = nil, shipping : Stripe::OptionalFieldsShipping? = nil, transfer_group : String? = nil)
      request = build_api_request_for_post_charges_charge(charge: charge, customer: customer, description: description, expand: expand, fraud_details: fraud_details, metadata: metadata, receipt_email: receipt_email, shipping: shipping, transfer_group: transfer_group)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_charges_charge\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Charge.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the specified charge by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;
    # @param charge [String?]
    # @optional @param customer [String?] The ID of an existing customer that will be associated with this request. This field may only be updated if there is no existing associated customer with this charge.
    # @optional @param description [String?] An arbitrary string which you can attach to a charge object. It is displayed when in the web interface alongside the charge. Note that if you use Stripe to send automatic email receipts to your customers, your receipt emails will include the `description` of the charge(s) that they are describing.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param fraud_details [Stripe::FraudDetails?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param receipt_email [String?] This is the email address that the receipt for this charge will be sent to. If this field is updated, then a new email receipt will be sent to the updated address.
    # @optional @param shipping [Stripe::OptionalFieldsShipping?]
    # @optional @param transfer_group [String?] A string that identifies this transaction as part of a group. `transfer_group` may only be provided if it has not been set. See the [Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-options) for details.
    # @return nil
    def post_charges_charge(*, charge : String? = nil, customer : String? = nil, description : String? = nil, expand : Array(String)? = nil, fraud_details : Stripe::FraudDetails? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, receipt_email : String? = nil, shipping : Stripe::OptionalFieldsShipping? = nil, transfer_group : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_charges_charge(charge: charge, customer: customer, description: description, expand: expand, fraud_details: fraud_details, metadata: metadata, receipt_email: receipt_email, shipping: shipping, transfer_group: transfer_group).execute(&block)
    end

    POST_CHARGES_CHARGE_MAX_LENGTH_FOR_CHARGE        =  5000
    POST_CHARGES_CHARGE_MAX_LENGTH_FOR_CUSTOMER      =  5000
    POST_CHARGES_CHARGE_MAX_LENGTH_FOR_DESCRIPTION   = 40000
    POST_CHARGES_CHARGE_MAX_LENGTH_FOR_RECEIPT_EMAIL =  5000

    # @return Crest::Request
    def build_api_request_for_post_charges_charge(*, charge : String? = nil, customer : String? = nil, description : String? = nil, expand : Array(String)? = nil, fraud_details : Stripe::FraudDetails? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, receipt_email : String? = nil, shipping : Stripe::OptionalFieldsShipping? = nil, transfer_group : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_charges_charge ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"charge\" is required and cannot be null") if charge.nil?
        if _charge = charge
          OpenApi::PrimitiveValidator.validate_max_length("charge", charge.to_s.size, POST_CHARGES_CHARGE_MAX_LENGTH_FOR_CHARGE)
        end
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_CHARGES_CHARGE_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_CHARGES_CHARGE_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _fraud_details = fraud_details
          _fraud_details.validate if _fraud_details.is_a?(OpenApi::Validatable)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _receipt_email = receipt_email
          OpenApi::PrimitiveValidator.validate_max_length("receipt_email", receipt_email.to_s.size, POST_CHARGES_CHARGE_MAX_LENGTH_FOR_RECEIPT_EMAIL)
        end
        if _shipping = shipping
          _shipping.validate if _shipping.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/charges/{charge}".sub("{" + "charge" + "}", URI.encode_path(charge.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["fraud_details"] = fraud_details.to_s if !fraud_details.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["receipt_email"] = receipt_email.to_s if !receipt_email.nil?
      form_params["shipping"] = shipping.to_s if !shipping.nil?
      form_params["transfer_group"] = transfer_group.to_s if !transfer_group.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_charges_charge",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you <a href=\"#create_charge\">created a charge</a> with the capture option set to false.</p>  <p>Uncaptured payments expire a set number of days after they are created (<a href=\"/docs/charges/placing-a-hold\">7 by default</a>). If they are not captured by that point in time, they will be marked as refunded and will no longer be capturable.</p>
    # @param charge [String?]
    # @optional @param amount [Int64?] The amount to capture, which must be less than or equal to the original amount. Any additional amount will be automatically refunded.
    # @optional @param application_fee [Int64?] An application fee to add on to this charge.
    # @optional @param application_fee_amount [Int64?] An application fee amount to add on to this charge, which must be less than or equal to the original amount.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param receipt_email [String?] The email address to send this charge's receipt to. This will override the previously-specified email address for this charge, if one was set. Receipts will not be sent in test mode.
    # @optional @param statement_descriptor [String?] For card charges, use `statement_descriptor_suffix` instead. Otherwise, you can use this value as the complete description of a charge on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    # @optional @param statement_descriptor_suffix [String?] Provides information about the charge that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
    # @optional @param transfer_data [Stripe::TransferDataSpecs1?]
    # @optional @param transfer_group [String?] A string that identifies this transaction as part of a group. `transfer_group` may only be provided if it has not been set. See the [Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-options) for details.
    # @return [Charge]
    def post_charges_charge_capture(*, charge : String? = nil, amount : Int64? = nil, application_fee : Int64? = nil, application_fee_amount : Int64? = nil, expand : Array(String)? = nil, receipt_email : String? = nil, statement_descriptor : String? = nil, statement_descriptor_suffix : String? = nil, transfer_data : Stripe::TransferDataSpecs1? = nil, transfer_group : String? = nil)
      data, _status_code, _headers = post_charges_charge_capture_with_http_info(charge: charge, amount: amount, application_fee: application_fee, application_fee_amount: application_fee_amount, expand: expand, receipt_email: receipt_email, statement_descriptor: statement_descriptor, statement_descriptor_suffix: statement_descriptor_suffix, transfer_data: transfer_data, transfer_group: transfer_group)
      data
    end

    # &lt;p&gt;Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you &lt;a href&#x3D;\&quot;#create_charge\&quot;&gt;created a charge&lt;/a&gt; with the capture option set to false.&lt;/p&gt;  &lt;p&gt;Uncaptured payments expire a set number of days after they are created (&lt;a href&#x3D;\&quot;/docs/charges/placing-a-hold\&quot;&gt;7 by default&lt;/a&gt;). If they are not captured by that point in time, they will be marked as refunded and will no longer be capturable.&lt;/p&gt;
    # @param charge [String?]
    # @optional @param amount [Int64?] The amount to capture, which must be less than or equal to the original amount. Any additional amount will be automatically refunded.
    # @optional @param application_fee [Int64?] An application fee to add on to this charge.
    # @optional @param application_fee_amount [Int64?] An application fee amount to add on to this charge, which must be less than or equal to the original amount.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param receipt_email [String?] The email address to send this charge's receipt to. This will override the previously-specified email address for this charge, if one was set. Receipts will not be sent in test mode.
    # @optional @param statement_descriptor [String?] For card charges, use `statement_descriptor_suffix` instead. Otherwise, you can use this value as the complete description of a charge on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    # @optional @param statement_descriptor_suffix [String?] Provides information about the charge that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
    # @optional @param transfer_data [Stripe::TransferDataSpecs1?]
    # @optional @param transfer_group [String?] A string that identifies this transaction as part of a group. `transfer_group` may only be provided if it has not been set. See the [Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-options) for details.
    # @return [Array<(Charge, Integer, Hash)>] Charge data, response status code and response headers
    def post_charges_charge_capture_with_http_info(*, charge : String? = nil, amount : Int64? = nil, application_fee : Int64? = nil, application_fee_amount : Int64? = nil, expand : Array(String)? = nil, receipt_email : String? = nil, statement_descriptor : String? = nil, statement_descriptor_suffix : String? = nil, transfer_data : Stripe::TransferDataSpecs1? = nil, transfer_group : String? = nil)
      request = build_api_request_for_post_charges_charge_capture(charge: charge, amount: amount, application_fee: application_fee, application_fee_amount: application_fee_amount, expand: expand, receipt_email: receipt_email, statement_descriptor: statement_descriptor, statement_descriptor_suffix: statement_descriptor_suffix, transfer_data: transfer_data, transfer_group: transfer_group)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_charges_charge_capture\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Charge.from_json(data), status_code, headers
    end

    # &lt;p&gt;Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you &lt;a href&#x3D;\&quot;#create_charge\&quot;&gt;created a charge&lt;/a&gt; with the capture option set to false.&lt;/p&gt;  &lt;p&gt;Uncaptured payments expire a set number of days after they are created (&lt;a href&#x3D;\&quot;/docs/charges/placing-a-hold\&quot;&gt;7 by default&lt;/a&gt;). If they are not captured by that point in time, they will be marked as refunded and will no longer be capturable.&lt;/p&gt;
    # @param charge [String?]
    # @optional @param amount [Int64?] The amount to capture, which must be less than or equal to the original amount. Any additional amount will be automatically refunded.
    # @optional @param application_fee [Int64?] An application fee to add on to this charge.
    # @optional @param application_fee_amount [Int64?] An application fee amount to add on to this charge, which must be less than or equal to the original amount.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param receipt_email [String?] The email address to send this charge's receipt to. This will override the previously-specified email address for this charge, if one was set. Receipts will not be sent in test mode.
    # @optional @param statement_descriptor [String?] For card charges, use `statement_descriptor_suffix` instead. Otherwise, you can use this value as the complete description of a charge on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    # @optional @param statement_descriptor_suffix [String?] Provides information about the charge that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
    # @optional @param transfer_data [Stripe::TransferDataSpecs1?]
    # @optional @param transfer_group [String?] A string that identifies this transaction as part of a group. `transfer_group` may only be provided if it has not been set. See the [Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-options) for details.
    # @return nil
    def post_charges_charge_capture(*, charge : String? = nil, amount : Int64? = nil, application_fee : Int64? = nil, application_fee_amount : Int64? = nil, expand : Array(String)? = nil, receipt_email : String? = nil, statement_descriptor : String? = nil, statement_descriptor_suffix : String? = nil, transfer_data : Stripe::TransferDataSpecs1? = nil, transfer_group : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_charges_charge_capture(charge: charge, amount: amount, application_fee: application_fee, application_fee_amount: application_fee_amount, expand: expand, receipt_email: receipt_email, statement_descriptor: statement_descriptor, statement_descriptor_suffix: statement_descriptor_suffix, transfer_data: transfer_data, transfer_group: transfer_group).execute(&block)
    end

    POST_CHARGES_CHARGE_CAPTURE_MAX_LENGTH_FOR_CHARGE                      = 5000
    POST_CHARGES_CHARGE_CAPTURE_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR        =   22
    POST_CHARGES_CHARGE_CAPTURE_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR_SUFFIX =   22

    # @return Crest::Request
    def build_api_request_for_post_charges_charge_capture(*, charge : String? = nil, amount : Int64? = nil, application_fee : Int64? = nil, application_fee_amount : Int64? = nil, expand : Array(String)? = nil, receipt_email : String? = nil, statement_descriptor : String? = nil, statement_descriptor_suffix : String? = nil, transfer_data : Stripe::TransferDataSpecs1? = nil, transfer_group : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_charges_charge_capture ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"charge\" is required and cannot be null") if charge.nil?
        if _charge = charge
          OpenApi::PrimitiveValidator.validate_max_length("charge", charge.to_s.size, POST_CHARGES_CHARGE_CAPTURE_MAX_LENGTH_FOR_CHARGE)
        end

        if _statement_descriptor = statement_descriptor
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor", statement_descriptor.to_s.size, POST_CHARGES_CHARGE_CAPTURE_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR)
        end
        if _statement_descriptor_suffix = statement_descriptor_suffix
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor_suffix", statement_descriptor_suffix.to_s.size, POST_CHARGES_CHARGE_CAPTURE_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR_SUFFIX)
        end
        if _transfer_data = transfer_data
          _transfer_data.validate if _transfer_data.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/charges/{charge}/capture".sub("{" + "charge" + "}", URI.encode_path(charge.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["application_fee"] = application_fee.to_s if !application_fee.nil?
      form_params["application_fee_amount"] = application_fee_amount.to_s if !application_fee_amount.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["receipt_email"] = receipt_email.to_s if !receipt_email.nil?
      form_params["statement_descriptor"] = statement_descriptor.to_s if !statement_descriptor.nil?
      form_params["statement_descriptor_suffix"] = statement_descriptor_suffix.to_s if !statement_descriptor_suffix.nil?
      form_params["transfer_data"] = transfer_data.to_s if !transfer_data.nil?
      form_params["transfer_group"] = transfer_group.to_s if !transfer_group.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_charges_charge_capture",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    #
    # @param charge [String?]
    # @optional @param evidence [Stripe::DisputeEvidenceParams?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param submit [Bool?] Whether to immediately submit evidence to the bank. If `false`, evidence is staged on the dispute. Staged evidence is visible in the API and Dashboard, and can be submitted to the bank by making another request with this attribute set to `true` (the default).
    # @return [Dispute]
    def post_charges_charge_dispute(*, charge : String? = nil, evidence : Stripe::DisputeEvidenceParams? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, submit : Bool? = nil)
      data, _status_code, _headers = post_charges_charge_dispute_with_http_info(charge: charge, evidence: evidence, expand: expand, metadata: metadata, submit: submit)
      data
    end

    #
    # @param charge [String?]
    # @optional @param evidence [Stripe::DisputeEvidenceParams?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param submit [Bool?] Whether to immediately submit evidence to the bank. If `false`, evidence is staged on the dispute. Staged evidence is visible in the API and Dashboard, and can be submitted to the bank by making another request with this attribute set to `true` (the default).
    # @return [Array<(Dispute, Integer, Hash)>] Dispute data, response status code and response headers
    def post_charges_charge_dispute_with_http_info(*, charge : String? = nil, evidence : Stripe::DisputeEvidenceParams? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, submit : Bool? = nil)
      request = build_api_request_for_post_charges_charge_dispute(charge: charge, evidence: evidence, expand: expand, metadata: metadata, submit: submit)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_charges_charge_dispute\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Dispute.from_json(data), status_code, headers
    end

    #
    # @param charge [String?]
    # @optional @param evidence [Stripe::DisputeEvidenceParams?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param submit [Bool?] Whether to immediately submit evidence to the bank. If `false`, evidence is staged on the dispute. Staged evidence is visible in the API and Dashboard, and can be submitted to the bank by making another request with this attribute set to `true` (the default).
    # @return nil
    def post_charges_charge_dispute(*, charge : String? = nil, evidence : Stripe::DisputeEvidenceParams? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, submit : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_post_charges_charge_dispute(charge: charge, evidence: evidence, expand: expand, metadata: metadata, submit: submit).execute(&block)
    end

    POST_CHARGES_CHARGE_DISPUTE_MAX_LENGTH_FOR_CHARGE = 5000

    # @return Crest::Request
    def build_api_request_for_post_charges_charge_dispute(*, charge : String? = nil, evidence : Stripe::DisputeEvidenceParams? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, submit : Bool? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_charges_charge_dispute ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"charge\" is required and cannot be null") if charge.nil?
        if _charge = charge
          OpenApi::PrimitiveValidator.validate_max_length("charge", charge.to_s.size, POST_CHARGES_CHARGE_DISPUTE_MAX_LENGTH_FOR_CHARGE)
        end
        if _evidence = evidence
          _evidence.validate if _evidence.is_a?(OpenApi::Validatable)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/charges/{charge}/dispute".sub("{" + "charge" + "}", URI.encode_path(charge.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["evidence"] = evidence.to_s if !evidence.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["submit"] = submit.to_s if !submit.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_charges_charge_dispute",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    #
    # @param charge [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Dispute]
    def post_charges_charge_dispute_close(*, charge : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_charges_charge_dispute_close_with_http_info(charge: charge, expand: expand)
      data
    end

    #
    # @param charge [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(Dispute, Integer, Hash)>] Dispute data, response status code and response headers
    def post_charges_charge_dispute_close_with_http_info(*, charge : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_charges_charge_dispute_close(charge: charge, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_charges_charge_dispute_close\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Dispute.from_json(data), status_code, headers
    end

    #
    # @param charge [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_charges_charge_dispute_close(*, charge : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_charges_charge_dispute_close(charge: charge, expand: expand).execute(&block)
    end

    POST_CHARGES_CHARGE_DISPUTE_CLOSE_MAX_LENGTH_FOR_CHARGE = 5000

    # @return Crest::Request
    def build_api_request_for_post_charges_charge_dispute_close(*, charge : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_charges_charge_dispute_close ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"charge\" is required and cannot be null") if charge.nil?
        if _charge = charge
          OpenApi::PrimitiveValidator.validate_max_length("charge", charge.to_s.size, POST_CHARGES_CHARGE_DISPUTE_CLOSE_MAX_LENGTH_FOR_CHARGE)
        end
      end

      # resource path
      local_var_path = "/v1/charges/{charge}/dispute/close".sub("{" + "charge" + "}", URI.encode_path(charge.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_charges_charge_dispute_close",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>When you create a new refund, you must specify a Charge or a PaymentIntent object on which to create it.</p>  <p>Creating a new refund will refund a charge that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged.</p>  <p>You can optionally refund only part of a charge. You can do so multiple times, until the entire charge has been refunded.</p>  <p>Once entirely refunded, a charge can’t be refunded again. This method will raise an error when called on an already-refunded charge, or when trying to refund more money than is left on a charge.</p>
    # @param charge [String?]
    # @optional @param amount [Int64?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param instructions_email [String?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param payment_intent [String?]
    # @optional @param reason [String?]
    # @optional @param refund_application_fee [Bool?]
    # @optional @param reverse_transfer [Bool?]
    # @return [Charge]
    def post_charges_charge_refund(*, charge : String? = nil, amount : Int64? = nil, expand : Array(String)? = nil, instructions_email : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, payment_intent : String? = nil, reason : String? = nil, refund_application_fee : Bool? = nil, reverse_transfer : Bool? = nil)
      data, _status_code, _headers = post_charges_charge_refund_with_http_info(charge: charge, amount: amount, expand: expand, instructions_email: instructions_email, metadata: metadata, payment_intent: payment_intent, reason: reason, refund_application_fee: refund_application_fee, reverse_transfer: reverse_transfer)
      data
    end

    # &lt;p&gt;When you create a new refund, you must specify a Charge or a PaymentIntent object on which to create it.&lt;/p&gt;  &lt;p&gt;Creating a new refund will refund a charge that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged.&lt;/p&gt;  &lt;p&gt;You can optionally refund only part of a charge. You can do so multiple times, until the entire charge has been refunded.&lt;/p&gt;  &lt;p&gt;Once entirely refunded, a charge can’t be refunded again. This method will raise an error when called on an already-refunded charge, or when trying to refund more money than is left on a charge.&lt;/p&gt;
    # @param charge [String?]
    # @optional @param amount [Int64?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param instructions_email [String?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param payment_intent [String?]
    # @optional @param reason [String?]
    # @optional @param refund_application_fee [Bool?]
    # @optional @param reverse_transfer [Bool?]
    # @return [Array<(Charge, Integer, Hash)>] Charge data, response status code and response headers
    def post_charges_charge_refund_with_http_info(*, charge : String? = nil, amount : Int64? = nil, expand : Array(String)? = nil, instructions_email : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, payment_intent : String? = nil, reason : String? = nil, refund_application_fee : Bool? = nil, reverse_transfer : Bool? = nil)
      request = build_api_request_for_post_charges_charge_refund(charge: charge, amount: amount, expand: expand, instructions_email: instructions_email, metadata: metadata, payment_intent: payment_intent, reason: reason, refund_application_fee: refund_application_fee, reverse_transfer: reverse_transfer)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_charges_charge_refund\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Charge.from_json(data), status_code, headers
    end

    # &lt;p&gt;When you create a new refund, you must specify a Charge or a PaymentIntent object on which to create it.&lt;/p&gt;  &lt;p&gt;Creating a new refund will refund a charge that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged.&lt;/p&gt;  &lt;p&gt;You can optionally refund only part of a charge. You can do so multiple times, until the entire charge has been refunded.&lt;/p&gt;  &lt;p&gt;Once entirely refunded, a charge can’t be refunded again. This method will raise an error when called on an already-refunded charge, or when trying to refund more money than is left on a charge.&lt;/p&gt;
    # @param charge [String?]
    # @optional @param amount [Int64?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param instructions_email [String?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param payment_intent [String?]
    # @optional @param reason [String?]
    # @optional @param refund_application_fee [Bool?]
    # @optional @param reverse_transfer [Bool?]
    # @return nil
    def post_charges_charge_refund(*, charge : String? = nil, amount : Int64? = nil, expand : Array(String)? = nil, instructions_email : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, payment_intent : String? = nil, reason : String? = nil, refund_application_fee : Bool? = nil, reverse_transfer : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_post_charges_charge_refund(charge: charge, amount: amount, expand: expand, instructions_email: instructions_email, metadata: metadata, payment_intent: payment_intent, reason: reason, refund_application_fee: refund_application_fee, reverse_transfer: reverse_transfer).execute(&block)
    end

    POST_CHARGES_CHARGE_REFUND_MAX_LENGTH_FOR_CHARGE         = 5000
    POST_CHARGES_CHARGE_REFUND_MAX_LENGTH_FOR_PAYMENT_INTENT = 5000
    POST_CHARGES_CHARGE_REFUND_MAX_LENGTH_FOR_REASON         = 5000
    POST_CHARGES_CHARGE_REFUND_VALID_VALUES_FOR_REASON       = StaticArray["duplicate", "fraudulent", "requested_by_customer"]

    # @return Crest::Request
    def build_api_request_for_post_charges_charge_refund(*, charge : String? = nil, amount : Int64? = nil, expand : Array(String)? = nil, instructions_email : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, payment_intent : String? = nil, reason : String? = nil, refund_application_fee : Bool? = nil, reverse_transfer : Bool? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_charges_charge_refund ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"charge\" is required and cannot be null") if charge.nil?
        if _charge = charge
          OpenApi::PrimitiveValidator.validate_max_length("charge", charge.to_s.size, POST_CHARGES_CHARGE_REFUND_MAX_LENGTH_FOR_CHARGE)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _payment_intent = payment_intent
          OpenApi::PrimitiveValidator.validate_max_length("payment_intent", payment_intent.to_s.size, POST_CHARGES_CHARGE_REFUND_MAX_LENGTH_FOR_PAYMENT_INTENT)
        end
        if _reason = reason
          OpenApi::EnumValidator.validate("reason", _reason, POST_CHARGES_CHARGE_REFUND_VALID_VALUES_FOR_REASON)
        end
      end

      # resource path
      local_var_path = "/v1/charges/{charge}/refund".sub("{" + "charge" + "}", URI.encode_path(charge.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["instructions_email"] = instructions_email.to_s if !instructions_email.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["payment_intent"] = payment_intent.to_s if !payment_intent.nil?
      form_params["reason"] = reason.to_s if !reason.nil?
      form_params["refund_application_fee"] = refund_application_fee.to_s if !refund_application_fee.nil?
      form_params["reverse_transfer"] = reverse_transfer.to_s if !reverse_transfer.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_charges_charge_refund",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Create a refund.</p>
    # @param charge [String?]
    # @optional @param amount [Int64?] A positive integer representing how much to refund.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param customer [String?] Customer whose customer balance to refund from.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param instructions_email [String?] Address to send refund email, use customer email if not specified
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param origin [String?] Origin of the refund
    # @optional @param payment_intent [String?]
    # @optional @param reason [String?]
    # @optional @param refund_application_fee [Bool?]
    # @optional @param reverse_transfer [Bool?]
    # @return [Refund]
    def post_charges_charge_refunds(*, charge : String? = nil, amount : Int64? = nil, currency : String? = nil, customer : String? = nil, expand : Array(String)? = nil, instructions_email : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, origin : String? = nil, payment_intent : String? = nil, reason : String? = nil, refund_application_fee : Bool? = nil, reverse_transfer : Bool? = nil)
      data, _status_code, _headers = post_charges_charge_refunds_with_http_info(charge: charge, amount: amount, currency: currency, customer: customer, expand: expand, instructions_email: instructions_email, metadata: metadata, origin: origin, payment_intent: payment_intent, reason: reason, refund_application_fee: refund_application_fee, reverse_transfer: reverse_transfer)
      data
    end

    # &lt;p&gt;Create a refund.&lt;/p&gt;
    # @param charge [String?]
    # @optional @param amount [Int64?] A positive integer representing how much to refund.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param customer [String?] Customer whose customer balance to refund from.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param instructions_email [String?] Address to send refund email, use customer email if not specified
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param origin [String?] Origin of the refund
    # @optional @param payment_intent [String?]
    # @optional @param reason [String?]
    # @optional @param refund_application_fee [Bool?]
    # @optional @param reverse_transfer [Bool?]
    # @return [Array<(Refund, Integer, Hash)>] Refund data, response status code and response headers
    def post_charges_charge_refunds_with_http_info(*, charge : String? = nil, amount : Int64? = nil, currency : String? = nil, customer : String? = nil, expand : Array(String)? = nil, instructions_email : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, origin : String? = nil, payment_intent : String? = nil, reason : String? = nil, refund_application_fee : Bool? = nil, reverse_transfer : Bool? = nil)
      request = build_api_request_for_post_charges_charge_refunds(charge: charge, amount: amount, currency: currency, customer: customer, expand: expand, instructions_email: instructions_email, metadata: metadata, origin: origin, payment_intent: payment_intent, reason: reason, refund_application_fee: refund_application_fee, reverse_transfer: reverse_transfer)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_charges_charge_refunds\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Refund.from_json(data), status_code, headers
    end

    # &lt;p&gt;Create a refund.&lt;/p&gt;
    # @param charge [String?]
    # @optional @param amount [Int64?] A positive integer representing how much to refund.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param customer [String?] Customer whose customer balance to refund from.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param instructions_email [String?] Address to send refund email, use customer email if not specified
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param origin [String?] Origin of the refund
    # @optional @param payment_intent [String?]
    # @optional @param reason [String?]
    # @optional @param refund_application_fee [Bool?]
    # @optional @param reverse_transfer [Bool?]
    # @return nil
    def post_charges_charge_refunds(*, charge : String? = nil, amount : Int64? = nil, currency : String? = nil, customer : String? = nil, expand : Array(String)? = nil, instructions_email : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, origin : String? = nil, payment_intent : String? = nil, reason : String? = nil, refund_application_fee : Bool? = nil, reverse_transfer : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_post_charges_charge_refunds(charge: charge, amount: amount, currency: currency, customer: customer, expand: expand, instructions_email: instructions_email, metadata: metadata, origin: origin, payment_intent: payment_intent, reason: reason, refund_application_fee: refund_application_fee, reverse_transfer: reverse_transfer).execute(&block)
    end

    POST_CHARGES_CHARGE_REFUNDS_MAX_LENGTH_FOR_CHARGE         = 5000
    POST_CHARGES_CHARGE_REFUNDS_MAX_LENGTH_FOR_CUSTOMER       = 5000
    POST_CHARGES_CHARGE_REFUNDS_VALID_VALUES_FOR_ORIGIN       = StaticArray["customer_balance"]
    POST_CHARGES_CHARGE_REFUNDS_MAX_LENGTH_FOR_PAYMENT_INTENT = 5000
    POST_CHARGES_CHARGE_REFUNDS_MAX_LENGTH_FOR_REASON         = 5000
    POST_CHARGES_CHARGE_REFUNDS_VALID_VALUES_FOR_REASON       = StaticArray["duplicate", "fraudulent", "requested_by_customer"]

    # @return Crest::Request
    def build_api_request_for_post_charges_charge_refunds(*, charge : String? = nil, amount : Int64? = nil, currency : String? = nil, customer : String? = nil, expand : Array(String)? = nil, instructions_email : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, origin : String? = nil, payment_intent : String? = nil, reason : String? = nil, refund_application_fee : Bool? = nil, reverse_transfer : Bool? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_charges_charge_refunds ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"charge\" is required and cannot be null") if charge.nil?
        if _charge = charge
          OpenApi::PrimitiveValidator.validate_max_length("charge", charge.to_s.size, POST_CHARGES_CHARGE_REFUNDS_MAX_LENGTH_FOR_CHARGE)
        end

        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_CHARGES_CHARGE_REFUNDS_MAX_LENGTH_FOR_CUSTOMER)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _origin = origin
          OpenApi::EnumValidator.validate("origin", _origin, POST_CHARGES_CHARGE_REFUNDS_VALID_VALUES_FOR_ORIGIN)
        end
        if _payment_intent = payment_intent
          OpenApi::PrimitiveValidator.validate_max_length("payment_intent", payment_intent.to_s.size, POST_CHARGES_CHARGE_REFUNDS_MAX_LENGTH_FOR_PAYMENT_INTENT)
        end
        if _reason = reason
          OpenApi::EnumValidator.validate("reason", _reason, POST_CHARGES_CHARGE_REFUNDS_VALID_VALUES_FOR_REASON)
        end
      end

      # resource path
      local_var_path = "/v1/charges/{charge}/refunds".sub("{" + "charge" + "}", URI.encode_path(charge.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["instructions_email"] = instructions_email.to_s if !instructions_email.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["origin"] = origin.to_s if !origin.nil?
      form_params["payment_intent"] = payment_intent.to_s if !payment_intent.nil?
      form_params["reason"] = reason.to_s if !reason.nil?
      form_params["refund_application_fee"] = refund_application_fee.to_s if !refund_application_fee.nil?
      form_params["reverse_transfer"] = reverse_transfer.to_s if !reverse_transfer.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_charges_charge_refunds",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Update a specified refund.</p>
    # @param charge [String?]
    # @param refund [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::IndividualSpecsMetadata?]
    # @return [Refund]
    def post_charges_charge_refunds_refund(*, charge : String? = nil, refund : String? = nil, expand : Array(String)? = nil, metadata : Stripe::IndividualSpecsMetadata? = nil)
      data, _status_code, _headers = post_charges_charge_refunds_refund_with_http_info(charge: charge, refund: refund, expand: expand, metadata: metadata)
      data
    end

    # &lt;p&gt;Update a specified refund.&lt;/p&gt;
    # @param charge [String?]
    # @param refund [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::IndividualSpecsMetadata?]
    # @return [Array<(Refund, Integer, Hash)>] Refund data, response status code and response headers
    def post_charges_charge_refunds_refund_with_http_info(*, charge : String? = nil, refund : String? = nil, expand : Array(String)? = nil, metadata : Stripe::IndividualSpecsMetadata? = nil)
      request = build_api_request_for_post_charges_charge_refunds_refund(charge: charge, refund: refund, expand: expand, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_charges_charge_refunds_refund\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Refund.from_json(data), status_code, headers
    end

    # &lt;p&gt;Update a specified refund.&lt;/p&gt;
    # @param charge [String?]
    # @param refund [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::IndividualSpecsMetadata?]
    # @return nil
    def post_charges_charge_refunds_refund(*, charge : String? = nil, refund : String? = nil, expand : Array(String)? = nil, metadata : Stripe::IndividualSpecsMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_charges_charge_refunds_refund(charge: charge, refund: refund, expand: expand, metadata: metadata).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_post_charges_charge_refunds_refund(*, charge : String? = nil, refund : String? = nil, expand : Array(String)? = nil, metadata : Stripe::IndividualSpecsMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_charges_charge_refunds_refund ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"charge\" is required and cannot be null") if charge.nil?

        raise ArgumentError.new("\"refund\" is required and cannot be null") if refund.nil?

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/charges/{charge}/refunds/{refund}".sub("{" + "charge" + "}", URI.encode_path(charge.to_s)).sub("{" + "refund" + "}", URI.encode_path(refund.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_charges_charge_refunds_refund",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a Session object.</p>
    # @param cancel_url [String?] The URL the customer will be directed to if they decide to cancel payment and return to your website.
    # @param success_url [String?] The URL to which Stripe should send customers when payment or setup is complete. If you’d like to use information from the successful Checkout Session on your page, read the guide on [customizing your success page](https://stripe.com/docs/payments/checkout/custom-success-page).
    # @optional @param after_expiration [Stripe::AfterExpirationParams?]
    # @optional @param allow_promotion_codes [Bool?] Enables user redeemable promotion codes.
    # @optional @param automatic_tax [Stripe::AutomaticTaxParams?]
    # @optional @param billing_address_collection [String?] Specify whether Checkout should collect the customer's billing address.
    # @optional @param client_reference_id [String?] A unique string to reference the Checkout Session. This can be a customer ID, a cart ID, or similar, and can be used to reconcile the session with your internal systems.
    # @optional @param consent_collection [Stripe::ConsentCollectionParams?]
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param customer [String?] ID of an existing Customer, if one exists. In `payment` mode, the customer’s most recent card payment method will be used to prefill the email, name, card details, and billing address on the Checkout page. In `subscription` mode, the customer’s [default payment method](https://stripe.com/docs/api/customers/update#update_customer-invoice_settings-default_payment_method) will be used if it’s a card, and otherwise the most recent card will be used. A valid billing address, billing name and billing email are required on the payment method for Checkout to prefill the customer's card details.  If the Customer already has a valid [email](https://stripe.com/docs/api/customers/object#customer_object-email) set, the email will be prefilled and not editable in Checkout. If the Customer does not have a valid `email`, Checkout will set the email entered during the session on the Customer.  If blank for Checkout Sessions in `payment` or `subscription` mode, Checkout will create a new Customer object based on information provided during the payment flow.  You can set [`payment_intent_data.setup_future_usage`](https://stripe.com/docs/api/checkout/sessions/create#create_checkout_session-payment_intent_data-setup_future_usage) to have Checkout automatically attach the payment method to the Customer you pass in for future reuse.
    # @optional @param customer_creation [String?] Configure whether a Checkout Session creates a [Customer](https://stripe.com/docs/api/customers) during Session confirmation.  When a Customer is not created, you can still retrieve email, address, and other customer data entered in Checkout with [customer_details](https://stripe.com/docs/api/checkout/sessions/object#checkout_session_object-customer_details).  Sessions that don't create Customers instead create [Guest Customers](https://support.stripe.com/questions/guest-customer-faq) in the Dashboard. Promotion codes limited to first time customers will return invalid for these Sessions.  Can only be set in `payment` and `setup` mode.
    # @optional @param customer_email [String?] If provided, this value will be used when the Customer object is created. If not provided, customers will be asked to enter their email address. Use this parameter to prefill customer data if you already have an email on file. To access information about the customer once a session is complete, use the `customer` field.
    # @optional @param customer_update [Stripe::CustomerUpdateParams?]
    # @optional @param discounts [Array(Stripe::DiscountParams)?] The coupon or promotion code to apply to this Session. Currently, only up to one may be specified.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] The Epoch time in seconds at which the Checkout Session will expire. It can be anywhere from 30 minutes to 24 hours after Checkout Session creation. By default, this value is 24 hours from creation.
    # @optional @param line_items [Array(Stripe::LineItemParams)?] A list of items the customer is purchasing. Use this parameter to pass one-time or recurring [Prices](https://stripe.com/docs/api/prices).  For `payment` mode, there is a maximum of 100 line items, however it is recommended to consolidate line items if there are more than a few dozen.  For `subscription` mode, there is a maximum of 20 line items with recurring Prices and 20 line items with one-time Prices. Line items with one-time Prices will be on the initial invoice only.
    # @optional @param locale [String?] The IETF language tag of the locale Checkout is displayed in. If blank or `auto`, the browser's locale is used.
    # @optional @param mode [String?] The mode of the Checkout Session. Required when using prices or `setup` mode. Pass `subscription` if the Checkout Session includes at least one recurring item.
    # @optional @param payment_intent_data [Stripe::PaymentIntentDataParams?]
    # @optional @param payment_method_collection [String?] Specify whether Checkout should collect a payment method. When set to `if_required`, Checkout will not collect a payment method when the total due for the session is 0. This may occur if the Checkout Session includes a free trial or a discount.  Can only be set in `subscription` mode.  If you'd like information on how to collect a payment method outside of Checkout, read the guide on configuring [subscriptions with a free trial](https://stripe.com/docs/payments/checkout/free-trials).
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam?]
    # @optional @param payment_method_types [Array(String)?] A list of the types of payment methods (e.g., `card`) this Checkout Session can accept.  In `payment` and `subscription` mode, you can omit this attribute to manage your payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods). It is required in `setup` mode.  Read more about the supported payment methods and their requirements in our [payment method details guide](/docs/payments/checkout/payment-methods).  If multiple payment methods are passed, Checkout will dynamically reorder them to prioritize the most relevant payment methods based on the customer's location and other characteristics.
    # @optional @param phone_number_collection [Stripe::PhoneNumberCollectionParams?]
    # @optional @param setup_intent_data [Stripe::SetupIntentDataParam?]
    # @optional @param shipping_address_collection [Stripe::ShippingAddressCollectionParams?]
    # @optional @param shipping_options [Array(Stripe::ShippingOptionParams)?] The shipping rate options to apply to this Session.
    # @optional @param submit_type [String?] Describes the type of transaction being performed by Checkout in order to customize relevant text on the page, such as the submit button. `submit_type` can only be specified on Checkout Sessions in `payment` mode, but not Checkout Sessions in `subscription` or `setup` mode.
    # @optional @param subscription_data [Stripe::SubscriptionDataParams?]
    # @optional @param tax_id_collection [Stripe::TaxIdCollectionParams?]
    # @return [CheckoutSession]
    def post_checkout_sessions(*, cancel_url : String? = nil, success_url : String? = nil, after_expiration : Stripe::AfterExpirationParams? = nil, allow_promotion_codes : Bool? = nil, automatic_tax : Stripe::AutomaticTaxParams? = nil, billing_address_collection : String? = nil, client_reference_id : String? = nil, consent_collection : Stripe::ConsentCollectionParams? = nil, currency : String? = nil, customer : String? = nil, customer_creation : String? = nil, customer_email : String? = nil, customer_update : Stripe::CustomerUpdateParams? = nil, discounts : Array(Stripe::DiscountParams)? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, line_items : Array(Stripe::LineItemParams)? = nil, locale : String? = nil, mode : String? = nil, payment_intent_data : Stripe::PaymentIntentDataParams? = nil, payment_method_collection : String? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam? = nil, payment_method_types : Array(String)? = nil, phone_number_collection : Stripe::PhoneNumberCollectionParams? = nil, setup_intent_data : Stripe::SetupIntentDataParam? = nil, shipping_address_collection : Stripe::ShippingAddressCollectionParams? = nil, shipping_options : Array(Stripe::ShippingOptionParams)? = nil, submit_type : String? = nil, subscription_data : Stripe::SubscriptionDataParams? = nil, tax_id_collection : Stripe::TaxIdCollectionParams? = nil)
      data, _status_code, _headers = post_checkout_sessions_with_http_info(cancel_url: cancel_url, success_url: success_url, after_expiration: after_expiration, allow_promotion_codes: allow_promotion_codes, automatic_tax: automatic_tax, billing_address_collection: billing_address_collection, client_reference_id: client_reference_id, consent_collection: consent_collection, currency: currency, customer: customer, customer_creation: customer_creation, customer_email: customer_email, customer_update: customer_update, discounts: discounts, expand: expand, expires_at: expires_at, line_items: line_items, locale: locale, mode: mode, payment_intent_data: payment_intent_data, payment_method_collection: payment_method_collection, payment_method_options: payment_method_options, payment_method_types: payment_method_types, phone_number_collection: phone_number_collection, setup_intent_data: setup_intent_data, shipping_address_collection: shipping_address_collection, shipping_options: shipping_options, submit_type: submit_type, subscription_data: subscription_data, tax_id_collection: tax_id_collection)
      data
    end

    # &lt;p&gt;Creates a Session object.&lt;/p&gt;
    # @param cancel_url [String?] The URL the customer will be directed to if they decide to cancel payment and return to your website.
    # @param success_url [String?] The URL to which Stripe should send customers when payment or setup is complete. If you’d like to use information from the successful Checkout Session on your page, read the guide on [customizing your success page](https://stripe.com/docs/payments/checkout/custom-success-page).
    # @optional @param after_expiration [Stripe::AfterExpirationParams?]
    # @optional @param allow_promotion_codes [Bool?] Enables user redeemable promotion codes.
    # @optional @param automatic_tax [Stripe::AutomaticTaxParams?]
    # @optional @param billing_address_collection [String?] Specify whether Checkout should collect the customer's billing address.
    # @optional @param client_reference_id [String?] A unique string to reference the Checkout Session. This can be a customer ID, a cart ID, or similar, and can be used to reconcile the session with your internal systems.
    # @optional @param consent_collection [Stripe::ConsentCollectionParams?]
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param customer [String?] ID of an existing Customer, if one exists. In `payment` mode, the customer’s most recent card payment method will be used to prefill the email, name, card details, and billing address on the Checkout page. In `subscription` mode, the customer’s [default payment method](https://stripe.com/docs/api/customers/update#update_customer-invoice_settings-default_payment_method) will be used if it’s a card, and otherwise the most recent card will be used. A valid billing address, billing name and billing email are required on the payment method for Checkout to prefill the customer's card details.  If the Customer already has a valid [email](https://stripe.com/docs/api/customers/object#customer_object-email) set, the email will be prefilled and not editable in Checkout. If the Customer does not have a valid `email`, Checkout will set the email entered during the session on the Customer.  If blank for Checkout Sessions in `payment` or `subscription` mode, Checkout will create a new Customer object based on information provided during the payment flow.  You can set [`payment_intent_data.setup_future_usage`](https://stripe.com/docs/api/checkout/sessions/create#create_checkout_session-payment_intent_data-setup_future_usage) to have Checkout automatically attach the payment method to the Customer you pass in for future reuse.
    # @optional @param customer_creation [String?] Configure whether a Checkout Session creates a [Customer](https://stripe.com/docs/api/customers) during Session confirmation.  When a Customer is not created, you can still retrieve email, address, and other customer data entered in Checkout with [customer_details](https://stripe.com/docs/api/checkout/sessions/object#checkout_session_object-customer_details).  Sessions that don't create Customers instead create [Guest Customers](https://support.stripe.com/questions/guest-customer-faq) in the Dashboard. Promotion codes limited to first time customers will return invalid for these Sessions.  Can only be set in `payment` and `setup` mode.
    # @optional @param customer_email [String?] If provided, this value will be used when the Customer object is created. If not provided, customers will be asked to enter their email address. Use this parameter to prefill customer data if you already have an email on file. To access information about the customer once a session is complete, use the `customer` field.
    # @optional @param customer_update [Stripe::CustomerUpdateParams?]
    # @optional @param discounts [Array(Stripe::DiscountParams)?] The coupon or promotion code to apply to this Session. Currently, only up to one may be specified.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] The Epoch time in seconds at which the Checkout Session will expire. It can be anywhere from 30 minutes to 24 hours after Checkout Session creation. By default, this value is 24 hours from creation.
    # @optional @param line_items [Array(Stripe::LineItemParams)?] A list of items the customer is purchasing. Use this parameter to pass one-time or recurring [Prices](https://stripe.com/docs/api/prices).  For `payment` mode, there is a maximum of 100 line items, however it is recommended to consolidate line items if there are more than a few dozen.  For `subscription` mode, there is a maximum of 20 line items with recurring Prices and 20 line items with one-time Prices. Line items with one-time Prices will be on the initial invoice only.
    # @optional @param locale [String?] The IETF language tag of the locale Checkout is displayed in. If blank or `auto`, the browser's locale is used.
    # @optional @param mode [String?] The mode of the Checkout Session. Required when using prices or `setup` mode. Pass `subscription` if the Checkout Session includes at least one recurring item.
    # @optional @param payment_intent_data [Stripe::PaymentIntentDataParams?]
    # @optional @param payment_method_collection [String?] Specify whether Checkout should collect a payment method. When set to `if_required`, Checkout will not collect a payment method when the total due for the session is 0. This may occur if the Checkout Session includes a free trial or a discount.  Can only be set in `subscription` mode.  If you'd like information on how to collect a payment method outside of Checkout, read the guide on configuring [subscriptions with a free trial](https://stripe.com/docs/payments/checkout/free-trials).
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam?]
    # @optional @param payment_method_types [Array(String)?] A list of the types of payment methods (e.g., `card`) this Checkout Session can accept.  In `payment` and `subscription` mode, you can omit this attribute to manage your payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods). It is required in `setup` mode.  Read more about the supported payment methods and their requirements in our [payment method details guide](/docs/payments/checkout/payment-methods).  If multiple payment methods are passed, Checkout will dynamically reorder them to prioritize the most relevant payment methods based on the customer's location and other characteristics.
    # @optional @param phone_number_collection [Stripe::PhoneNumberCollectionParams?]
    # @optional @param setup_intent_data [Stripe::SetupIntentDataParam?]
    # @optional @param shipping_address_collection [Stripe::ShippingAddressCollectionParams?]
    # @optional @param shipping_options [Array(Stripe::ShippingOptionParams)?] The shipping rate options to apply to this Session.
    # @optional @param submit_type [String?] Describes the type of transaction being performed by Checkout in order to customize relevant text on the page, such as the submit button. `submit_type` can only be specified on Checkout Sessions in `payment` mode, but not Checkout Sessions in `subscription` or `setup` mode.
    # @optional @param subscription_data [Stripe::SubscriptionDataParams?]
    # @optional @param tax_id_collection [Stripe::TaxIdCollectionParams?]
    # @return [Array<(CheckoutSession, Integer, Hash)>] CheckoutSession data, response status code and response headers
    def post_checkout_sessions_with_http_info(*, cancel_url : String? = nil, success_url : String? = nil, after_expiration : Stripe::AfterExpirationParams? = nil, allow_promotion_codes : Bool? = nil, automatic_tax : Stripe::AutomaticTaxParams? = nil, billing_address_collection : String? = nil, client_reference_id : String? = nil, consent_collection : Stripe::ConsentCollectionParams? = nil, currency : String? = nil, customer : String? = nil, customer_creation : String? = nil, customer_email : String? = nil, customer_update : Stripe::CustomerUpdateParams? = nil, discounts : Array(Stripe::DiscountParams)? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, line_items : Array(Stripe::LineItemParams)? = nil, locale : String? = nil, mode : String? = nil, payment_intent_data : Stripe::PaymentIntentDataParams? = nil, payment_method_collection : String? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam? = nil, payment_method_types : Array(String)? = nil, phone_number_collection : Stripe::PhoneNumberCollectionParams? = nil, setup_intent_data : Stripe::SetupIntentDataParam? = nil, shipping_address_collection : Stripe::ShippingAddressCollectionParams? = nil, shipping_options : Array(Stripe::ShippingOptionParams)? = nil, submit_type : String? = nil, subscription_data : Stripe::SubscriptionDataParams? = nil, tax_id_collection : Stripe::TaxIdCollectionParams? = nil)
      request = build_api_request_for_post_checkout_sessions(cancel_url: cancel_url, success_url: success_url, after_expiration: after_expiration, allow_promotion_codes: allow_promotion_codes, automatic_tax: automatic_tax, billing_address_collection: billing_address_collection, client_reference_id: client_reference_id, consent_collection: consent_collection, currency: currency, customer: customer, customer_creation: customer_creation, customer_email: customer_email, customer_update: customer_update, discounts: discounts, expand: expand, expires_at: expires_at, line_items: line_items, locale: locale, mode: mode, payment_intent_data: payment_intent_data, payment_method_collection: payment_method_collection, payment_method_options: payment_method_options, payment_method_types: payment_method_types, phone_number_collection: phone_number_collection, setup_intent_data: setup_intent_data, shipping_address_collection: shipping_address_collection, shipping_options: shipping_options, submit_type: submit_type, subscription_data: subscription_data, tax_id_collection: tax_id_collection)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_checkout_sessions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CheckoutSession.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a Session object.&lt;/p&gt;
    # @param cancel_url [String?] The URL the customer will be directed to if they decide to cancel payment and return to your website.
    # @param success_url [String?] The URL to which Stripe should send customers when payment or setup is complete. If you’d like to use information from the successful Checkout Session on your page, read the guide on [customizing your success page](https://stripe.com/docs/payments/checkout/custom-success-page).
    # @optional @param after_expiration [Stripe::AfterExpirationParams?]
    # @optional @param allow_promotion_codes [Bool?] Enables user redeemable promotion codes.
    # @optional @param automatic_tax [Stripe::AutomaticTaxParams?]
    # @optional @param billing_address_collection [String?] Specify whether Checkout should collect the customer's billing address.
    # @optional @param client_reference_id [String?] A unique string to reference the Checkout Session. This can be a customer ID, a cart ID, or similar, and can be used to reconcile the session with your internal systems.
    # @optional @param consent_collection [Stripe::ConsentCollectionParams?]
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param customer [String?] ID of an existing Customer, if one exists. In `payment` mode, the customer’s most recent card payment method will be used to prefill the email, name, card details, and billing address on the Checkout page. In `subscription` mode, the customer’s [default payment method](https://stripe.com/docs/api/customers/update#update_customer-invoice_settings-default_payment_method) will be used if it’s a card, and otherwise the most recent card will be used. A valid billing address, billing name and billing email are required on the payment method for Checkout to prefill the customer's card details.  If the Customer already has a valid [email](https://stripe.com/docs/api/customers/object#customer_object-email) set, the email will be prefilled and not editable in Checkout. If the Customer does not have a valid `email`, Checkout will set the email entered during the session on the Customer.  If blank for Checkout Sessions in `payment` or `subscription` mode, Checkout will create a new Customer object based on information provided during the payment flow.  You can set [`payment_intent_data.setup_future_usage`](https://stripe.com/docs/api/checkout/sessions/create#create_checkout_session-payment_intent_data-setup_future_usage) to have Checkout automatically attach the payment method to the Customer you pass in for future reuse.
    # @optional @param customer_creation [String?] Configure whether a Checkout Session creates a [Customer](https://stripe.com/docs/api/customers) during Session confirmation.  When a Customer is not created, you can still retrieve email, address, and other customer data entered in Checkout with [customer_details](https://stripe.com/docs/api/checkout/sessions/object#checkout_session_object-customer_details).  Sessions that don't create Customers instead create [Guest Customers](https://support.stripe.com/questions/guest-customer-faq) in the Dashboard. Promotion codes limited to first time customers will return invalid for these Sessions.  Can only be set in `payment` and `setup` mode.
    # @optional @param customer_email [String?] If provided, this value will be used when the Customer object is created. If not provided, customers will be asked to enter their email address. Use this parameter to prefill customer data if you already have an email on file. To access information about the customer once a session is complete, use the `customer` field.
    # @optional @param customer_update [Stripe::CustomerUpdateParams?]
    # @optional @param discounts [Array(Stripe::DiscountParams)?] The coupon or promotion code to apply to this Session. Currently, only up to one may be specified.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] The Epoch time in seconds at which the Checkout Session will expire. It can be anywhere from 30 minutes to 24 hours after Checkout Session creation. By default, this value is 24 hours from creation.
    # @optional @param line_items [Array(Stripe::LineItemParams)?] A list of items the customer is purchasing. Use this parameter to pass one-time or recurring [Prices](https://stripe.com/docs/api/prices).  For `payment` mode, there is a maximum of 100 line items, however it is recommended to consolidate line items if there are more than a few dozen.  For `subscription` mode, there is a maximum of 20 line items with recurring Prices and 20 line items with one-time Prices. Line items with one-time Prices will be on the initial invoice only.
    # @optional @param locale [String?] The IETF language tag of the locale Checkout is displayed in. If blank or `auto`, the browser's locale is used.
    # @optional @param mode [String?] The mode of the Checkout Session. Required when using prices or `setup` mode. Pass `subscription` if the Checkout Session includes at least one recurring item.
    # @optional @param payment_intent_data [Stripe::PaymentIntentDataParams?]
    # @optional @param payment_method_collection [String?] Specify whether Checkout should collect a payment method. When set to `if_required`, Checkout will not collect a payment method when the total due for the session is 0. This may occur if the Checkout Session includes a free trial or a discount.  Can only be set in `subscription` mode.  If you'd like information on how to collect a payment method outside of Checkout, read the guide on configuring [subscriptions with a free trial](https://stripe.com/docs/payments/checkout/free-trials).
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam?]
    # @optional @param payment_method_types [Array(String)?] A list of the types of payment methods (e.g., `card`) this Checkout Session can accept.  In `payment` and `subscription` mode, you can omit this attribute to manage your payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods). It is required in `setup` mode.  Read more about the supported payment methods and their requirements in our [payment method details guide](/docs/payments/checkout/payment-methods).  If multiple payment methods are passed, Checkout will dynamically reorder them to prioritize the most relevant payment methods based on the customer's location and other characteristics.
    # @optional @param phone_number_collection [Stripe::PhoneNumberCollectionParams?]
    # @optional @param setup_intent_data [Stripe::SetupIntentDataParam?]
    # @optional @param shipping_address_collection [Stripe::ShippingAddressCollectionParams?]
    # @optional @param shipping_options [Array(Stripe::ShippingOptionParams)?] The shipping rate options to apply to this Session.
    # @optional @param submit_type [String?] Describes the type of transaction being performed by Checkout in order to customize relevant text on the page, such as the submit button. `submit_type` can only be specified on Checkout Sessions in `payment` mode, but not Checkout Sessions in `subscription` or `setup` mode.
    # @optional @param subscription_data [Stripe::SubscriptionDataParams?]
    # @optional @param tax_id_collection [Stripe::TaxIdCollectionParams?]
    # @return nil
    def post_checkout_sessions(*, cancel_url : String? = nil, success_url : String? = nil, after_expiration : Stripe::AfterExpirationParams? = nil, allow_promotion_codes : Bool? = nil, automatic_tax : Stripe::AutomaticTaxParams? = nil, billing_address_collection : String? = nil, client_reference_id : String? = nil, consent_collection : Stripe::ConsentCollectionParams? = nil, currency : String? = nil, customer : String? = nil, customer_creation : String? = nil, customer_email : String? = nil, customer_update : Stripe::CustomerUpdateParams? = nil, discounts : Array(Stripe::DiscountParams)? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, line_items : Array(Stripe::LineItemParams)? = nil, locale : String? = nil, mode : String? = nil, payment_intent_data : Stripe::PaymentIntentDataParams? = nil, payment_method_collection : String? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam? = nil, payment_method_types : Array(String)? = nil, phone_number_collection : Stripe::PhoneNumberCollectionParams? = nil, setup_intent_data : Stripe::SetupIntentDataParam? = nil, shipping_address_collection : Stripe::ShippingAddressCollectionParams? = nil, shipping_options : Array(Stripe::ShippingOptionParams)? = nil, submit_type : String? = nil, subscription_data : Stripe::SubscriptionDataParams? = nil, tax_id_collection : Stripe::TaxIdCollectionParams? = nil, &block : Crest::Response ->)
      build_api_request_for_post_checkout_sessions(cancel_url: cancel_url, success_url: success_url, after_expiration: after_expiration, allow_promotion_codes: allow_promotion_codes, automatic_tax: automatic_tax, billing_address_collection: billing_address_collection, client_reference_id: client_reference_id, consent_collection: consent_collection, currency: currency, customer: customer, customer_creation: customer_creation, customer_email: customer_email, customer_update: customer_update, discounts: discounts, expand: expand, expires_at: expires_at, line_items: line_items, locale: locale, mode: mode, payment_intent_data: payment_intent_data, payment_method_collection: payment_method_collection, payment_method_options: payment_method_options, payment_method_types: payment_method_types, phone_number_collection: phone_number_collection, setup_intent_data: setup_intent_data, shipping_address_collection: shipping_address_collection, shipping_options: shipping_options, submit_type: submit_type, subscription_data: subscription_data, tax_id_collection: tax_id_collection).execute(&block)
    end

    POST_CHECKOUT_SESSIONS_MAX_LENGTH_FOR_CANCEL_URL                   = 5000
    POST_CHECKOUT_SESSIONS_MAX_LENGTH_FOR_SUCCESS_URL                  = 5000
    POST_CHECKOUT_SESSIONS_VALID_VALUES_FOR_BILLING_ADDRESS_COLLECTION = StaticArray["auto", "required"]
    POST_CHECKOUT_SESSIONS_MAX_LENGTH_FOR_CLIENT_REFERENCE_ID          =  200
    POST_CHECKOUT_SESSIONS_MAX_LENGTH_FOR_CUSTOMER                     = 5000
    POST_CHECKOUT_SESSIONS_VALID_VALUES_FOR_CUSTOMER_CREATION          = StaticArray["always", "if_required"]
    POST_CHECKOUT_SESSIONS_VALID_VALUES_FOR_LOCALE                     = StaticArray["auto", "bg", "cs", "da", "de", "el", "en", "en-GB", "es", "es-419", "et", "fi", "fil", "fr", "fr-CA", "hr", "hu", "id", "it", "ja", "ko", "lt", "lv", "ms", "mt", "nb", "nl", "pl", "pt", "pt-BR", "ro", "ru", "sk", "sl", "sv", "th", "tr", "vi", "zh", "zh-HK", "zh-TW"]
    POST_CHECKOUT_SESSIONS_VALID_VALUES_FOR_MODE                       = StaticArray["payment", "setup", "subscription"]
    POST_CHECKOUT_SESSIONS_VALID_VALUES_FOR_PAYMENT_METHOD_COLLECTION  = StaticArray["always", "if_required"]
    POST_CHECKOUT_SESSIONS_VALID_VALUES_FOR_PAYMENT_METHOD_TYPES       = StaticArray["acss_debit", "affirm", "afterpay_clearpay", "alipay", "au_becs_debit", "bacs_debit", "bancontact", "blik", "boleto", "card", "customer_balance", "eps", "fpx", "giropay", "grabpay", "ideal", "klarna", "konbini", "oxxo", "p24", "paynow", "pix", "promptpay", "sepa_debit", "sofort", "us_bank_account", "wechat_pay"]
    POST_CHECKOUT_SESSIONS_VALID_VALUES_FOR_SUBMIT_TYPE                = StaticArray["auto", "book", "donate", "pay"]

    # @return Crest::Request
    def build_api_request_for_post_checkout_sessions(*, cancel_url : String? = nil, success_url : String? = nil, after_expiration : Stripe::AfterExpirationParams? = nil, allow_promotion_codes : Bool? = nil, automatic_tax : Stripe::AutomaticTaxParams? = nil, billing_address_collection : String? = nil, client_reference_id : String? = nil, consent_collection : Stripe::ConsentCollectionParams? = nil, currency : String? = nil, customer : String? = nil, customer_creation : String? = nil, customer_email : String? = nil, customer_update : Stripe::CustomerUpdateParams? = nil, discounts : Array(Stripe::DiscountParams)? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, line_items : Array(Stripe::LineItemParams)? = nil, locale : String? = nil, mode : String? = nil, payment_intent_data : Stripe::PaymentIntentDataParams? = nil, payment_method_collection : String? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam? = nil, payment_method_types : Array(String)? = nil, phone_number_collection : Stripe::PhoneNumberCollectionParams? = nil, setup_intent_data : Stripe::SetupIntentDataParam? = nil, shipping_address_collection : Stripe::ShippingAddressCollectionParams? = nil, shipping_options : Array(Stripe::ShippingOptionParams)? = nil, submit_type : String? = nil, subscription_data : Stripe::SubscriptionDataParams? = nil, tax_id_collection : Stripe::TaxIdCollectionParams? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_checkout_sessions ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"cancel_url\" is required and cannot be null") if cancel_url.nil?
        if _cancel_url = cancel_url
          OpenApi::PrimitiveValidator.validate_max_length("cancel_url", cancel_url.to_s.size, POST_CHECKOUT_SESSIONS_MAX_LENGTH_FOR_CANCEL_URL)
        end
        raise ArgumentError.new("\"success_url\" is required and cannot be null") if success_url.nil?
        if _success_url = success_url
          OpenApi::PrimitiveValidator.validate_max_length("success_url", success_url.to_s.size, POST_CHECKOUT_SESSIONS_MAX_LENGTH_FOR_SUCCESS_URL)
        end
        if _after_expiration = after_expiration
          _after_expiration.validate if _after_expiration.is_a?(OpenApi::Validatable)
        end

        if _automatic_tax = automatic_tax
          _automatic_tax.validate if _automatic_tax.is_a?(OpenApi::Validatable)
        end
        if _billing_address_collection = billing_address_collection
          OpenApi::EnumValidator.validate("billing_address_collection", _billing_address_collection, POST_CHECKOUT_SESSIONS_VALID_VALUES_FOR_BILLING_ADDRESS_COLLECTION)
        end
        if _client_reference_id = client_reference_id
          OpenApi::PrimitiveValidator.validate_max_length("client_reference_id", client_reference_id.to_s.size, POST_CHECKOUT_SESSIONS_MAX_LENGTH_FOR_CLIENT_REFERENCE_ID)
        end
        if _consent_collection = consent_collection
          _consent_collection.validate if _consent_collection.is_a?(OpenApi::Validatable)
        end

        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_CHECKOUT_SESSIONS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _customer_creation = customer_creation
          OpenApi::EnumValidator.validate("customer_creation", _customer_creation, POST_CHECKOUT_SESSIONS_VALID_VALUES_FOR_CUSTOMER_CREATION)
        end

        if _customer_update = customer_update
          _customer_update.validate if _customer_update.is_a?(OpenApi::Validatable)
        end
        if _discounts = discounts
          OpenApi::ContainerValidator.validate(container: _discounts) if _discounts.is_a?(Array)
        end

        if _line_items = line_items
          OpenApi::ContainerValidator.validate(container: _line_items) if _line_items.is_a?(Array)
        end
        if _locale = locale
          OpenApi::EnumValidator.validate("locale", _locale, POST_CHECKOUT_SESSIONS_VALID_VALUES_FOR_LOCALE)
        end
        if _mode = mode
          OpenApi::EnumValidator.validate("mode", _mode, POST_CHECKOUT_SESSIONS_VALID_VALUES_FOR_MODE)
        end
        if _payment_intent_data = payment_intent_data
          _payment_intent_data.validate if _payment_intent_data.is_a?(OpenApi::Validatable)
        end
        if _payment_method_collection = payment_method_collection
          OpenApi::EnumValidator.validate("payment_method_collection", _payment_method_collection, POST_CHECKOUT_SESSIONS_VALID_VALUES_FOR_PAYMENT_METHOD_COLLECTION)
        end
        if _payment_method_options = payment_method_options
          _payment_method_options.validate if _payment_method_options.is_a?(OpenApi::Validatable)
        end
        if _payment_method_types = payment_method_types
          OpenApi::EnumValidator.validate("payment_method_types", _payment_method_types, POST_CHECKOUT_SESSIONS_VALID_VALUES_FOR_PAYMENT_METHOD_TYPES)
        end
        if _phone_number_collection = phone_number_collection
          _phone_number_collection.validate if _phone_number_collection.is_a?(OpenApi::Validatable)
        end
        if _setup_intent_data = setup_intent_data
          _setup_intent_data.validate if _setup_intent_data.is_a?(OpenApi::Validatable)
        end
        if _shipping_address_collection = shipping_address_collection
          _shipping_address_collection.validate if _shipping_address_collection.is_a?(OpenApi::Validatable)
        end
        if _shipping_options = shipping_options
          OpenApi::ContainerValidator.validate(container: _shipping_options) if _shipping_options.is_a?(Array)
        end
        if _submit_type = submit_type
          OpenApi::EnumValidator.validate("submit_type", _submit_type, POST_CHECKOUT_SESSIONS_VALID_VALUES_FOR_SUBMIT_TYPE)
        end
        if _subscription_data = subscription_data
          _subscription_data.validate if _subscription_data.is_a?(OpenApi::Validatable)
        end
        if _tax_id_collection = tax_id_collection
          _tax_id_collection.validate if _tax_id_collection.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/checkout/sessions"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["after_expiration"] = after_expiration.to_s if !after_expiration.nil?
      form_params["allow_promotion_codes"] = allow_promotion_codes.to_s if !allow_promotion_codes.nil?
      form_params["automatic_tax"] = automatic_tax.to_s if !automatic_tax.nil?
      form_params["billing_address_collection"] = billing_address_collection.to_s if !billing_address_collection.nil?
      form_params["cancel_url"] = cancel_url.to_s if !cancel_url.nil?
      form_params["client_reference_id"] = client_reference_id.to_s if !client_reference_id.nil?
      form_params["consent_collection"] = consent_collection.to_s if !consent_collection.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["customer_creation"] = customer_creation.to_s if !customer_creation.nil?
      form_params["customer_email"] = customer_email.to_s if !customer_email.nil?
      form_params["customer_update"] = customer_update.to_s if !customer_update.nil?
      form_params["discounts"] = @api_client.build_collection_param(discounts, "csv") if !discounts.nil? && !discounts.empty?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["expires_at"] = expires_at.to_s if !expires_at.nil?
      form_params["line_items"] = @api_client.build_collection_param(line_items, "csv") if !line_items.nil? && !line_items.empty?
      form_params["locale"] = locale.to_s if !locale.nil?
      form_params["mode"] = mode.to_s if !mode.nil?
      form_params["payment_intent_data"] = payment_intent_data.to_s if !payment_intent_data.nil?
      form_params["payment_method_collection"] = payment_method_collection.to_s if !payment_method_collection.nil?
      form_params["payment_method_options"] = payment_method_options.to_s if !payment_method_options.nil?
      form_params["payment_method_types"] = @api_client.build_collection_param(payment_method_types, "csv") if !payment_method_types.nil? && !payment_method_types.empty?
      form_params["phone_number_collection"] = phone_number_collection.to_s if !phone_number_collection.nil?
      form_params["setup_intent_data"] = setup_intent_data.to_s if !setup_intent_data.nil?
      form_params["shipping_address_collection"] = shipping_address_collection.to_s if !shipping_address_collection.nil?
      form_params["shipping_options"] = @api_client.build_collection_param(shipping_options, "csv") if !shipping_options.nil? && !shipping_options.empty?
      form_params["submit_type"] = submit_type.to_s if !submit_type.nil?
      form_params["subscription_data"] = subscription_data.to_s if !subscription_data.nil?
      form_params["success_url"] = success_url.to_s if !success_url.nil?
      form_params["tax_id_collection"] = tax_id_collection.to_s if !tax_id_collection.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_checkout_sessions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>A Session can be expired when it is in one of these statuses: <code>open</code> </p>  <p>After it expires, a customer can’t complete a Session and customers loading the Session see a message saying the Session is expired.</p>
    # @param session [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [CheckoutSession]
    def post_checkout_sessions_session_expire(*, session : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_checkout_sessions_session_expire_with_http_info(session: session, expand: expand)
      data
    end

    # &lt;p&gt;A Session can be expired when it is in one of these statuses: &lt;code&gt;open&lt;/code&gt; &lt;/p&gt;  &lt;p&gt;After it expires, a customer can’t complete a Session and customers loading the Session see a message saying the Session is expired.&lt;/p&gt;
    # @param session [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(CheckoutSession, Integer, Hash)>] CheckoutSession data, response status code and response headers
    def post_checkout_sessions_session_expire_with_http_info(*, session : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_checkout_sessions_session_expire(session: session, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_checkout_sessions_session_expire\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CheckoutSession.from_json(data), status_code, headers
    end

    # &lt;p&gt;A Session can be expired when it is in one of these statuses: &lt;code&gt;open&lt;/code&gt; &lt;/p&gt;  &lt;p&gt;After it expires, a customer can’t complete a Session and customers loading the Session see a message saying the Session is expired.&lt;/p&gt;
    # @param session [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_checkout_sessions_session_expire(*, session : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_checkout_sessions_session_expire(session: session, expand: expand).execute(&block)
    end

    POST_CHECKOUT_SESSIONS_SESSION_EXPIRE_MAX_LENGTH_FOR_SESSION = 5000

    # @return Crest::Request
    def build_api_request_for_post_checkout_sessions_session_expire(*, session : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_checkout_sessions_session_expire ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"session\" is required and cannot be null") if session.nil?
        if _session = session
          OpenApi::PrimitiveValidator.validate_max_length("session", session.to_s.size, POST_CHECKOUT_SESSIONS_SESSION_EXPIRE_MAX_LENGTH_FOR_SESSION)
        end
      end

      # resource path
      local_var_path = "/v1/checkout/sessions/{session}/expire".sub("{" + "session" + "}", URI.encode_path(session.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_checkout_sessions_session_expire",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>You can create coupons easily via the <a href=\"https://dashboard.stripe.com/coupons\">coupon management</a> page of the Stripe dashboard. Coupon creation is also accessible via the API if you need to create coupons on the fly.</p>  <p>A coupon has either a <code>percent_off</code> or an <code>amount_off</code> and <code>currency</code>. If you set an <code>amount_off</code>, that amount will be subtracted from any invoice’s subtotal. For example, an invoice with a subtotal of <currency>100</currency> will have a final total of <currency>0</currency> if a coupon with an <code>amount_off</code> of <amount>200</amount> is applied to it and an invoice with a subtotal of <currency>300</currency> will have a final total of <currency>100</currency> if a coupon with an <code>amount_off</code> of <amount>200</amount> is applied to it.</p>
    # @optional @param amount_off [Int64?] A positive integer representing the amount to subtract from an invoice total (required if `percent_off` is not passed).
    # @optional @param applies_to [Stripe::AppliesToParams?]
    # @optional @param currency [String?] Three-letter [ISO code for the currency](https://stripe.com/docs/currencies) of the `amount_off` parameter (required if `amount_off` is passed).
    # @optional @param duration [String?] Specifies how long the discount will be in effect if used on a subscription. Can be `forever`, `once`, or `repeating`. Defaults to `once`.
    # @optional @param duration_in_months [Int64?] Required only if `duration` is `repeating`, in which case it must be a positive integer that specifies the number of months the discount will be in effect.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param id [String?] Unique string of your choice that will be used to identify this coupon when applying it to a customer. If you don't want to specify a particular code, you can leave the ID blank and we'll generate a random code for you.
    # @optional @param max_redemptions [Int64?] A positive integer specifying the number of times the coupon can be redeemed before it's no longer valid. For example, you might have a 50% off coupon that the first 20 readers of your blog can use.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Name of the coupon displayed to customers on, for instance invoices, or receipts. By default the `id` is shown if `name` is not set.
    # @optional @param percent_off [Float64?] A positive float larger than 0, and smaller or equal to 100, that represents the discount the coupon will apply (required if `amount_off` is not passed).
    # @optional @param redeem_by [Int64?] Unix timestamp specifying the last time at which the coupon can be redeemed. After the redeem_by date, the coupon can no longer be applied to new customers.
    # @return [Coupon]
    def post_coupons(*, amount_off : Int64? = nil, applies_to : Stripe::AppliesToParams? = nil, currency : String? = nil, duration : String? = nil, duration_in_months : Int64? = nil, expand : Array(String)? = nil, id : String? = nil, max_redemptions : Int64? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, percent_off : Float64? = nil, redeem_by : Int64? = nil)
      data, _status_code, _headers = post_coupons_with_http_info(amount_off: amount_off, applies_to: applies_to, currency: currency, duration: duration, duration_in_months: duration_in_months, expand: expand, id: id, max_redemptions: max_redemptions, metadata: metadata, name: name, percent_off: percent_off, redeem_by: redeem_by)
      data
    end

    # &lt;p&gt;You can create coupons easily via the &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/coupons\&quot;&gt;coupon management&lt;/a&gt; page of the Stripe dashboard. Coupon creation is also accessible via the API if you need to create coupons on the fly.&lt;/p&gt;  &lt;p&gt;A coupon has either a &lt;code&gt;percent_off&lt;/code&gt; or an &lt;code&gt;amount_off&lt;/code&gt; and &lt;code&gt;currency&lt;/code&gt;. If you set an &lt;code&gt;amount_off&lt;/code&gt;, that amount will be subtracted from any invoice’s subtotal. For example, an invoice with a subtotal of &lt;currency&gt;100&lt;/currency&gt; will have a final total of &lt;currency&gt;0&lt;/currency&gt; if a coupon with an &lt;code&gt;amount_off&lt;/code&gt; of &lt;amount&gt;200&lt;/amount&gt; is applied to it and an invoice with a subtotal of &lt;currency&gt;300&lt;/currency&gt; will have a final total of &lt;currency&gt;100&lt;/currency&gt; if a coupon with an &lt;code&gt;amount_off&lt;/code&gt; of &lt;amount&gt;200&lt;/amount&gt; is applied to it.&lt;/p&gt;
    # @optional @param amount_off [Int64?] A positive integer representing the amount to subtract from an invoice total (required if `percent_off` is not passed).
    # @optional @param applies_to [Stripe::AppliesToParams?]
    # @optional @param currency [String?] Three-letter [ISO code for the currency](https://stripe.com/docs/currencies) of the `amount_off` parameter (required if `amount_off` is passed).
    # @optional @param duration [String?] Specifies how long the discount will be in effect if used on a subscription. Can be `forever`, `once`, or `repeating`. Defaults to `once`.
    # @optional @param duration_in_months [Int64?] Required only if `duration` is `repeating`, in which case it must be a positive integer that specifies the number of months the discount will be in effect.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param id [String?] Unique string of your choice that will be used to identify this coupon when applying it to a customer. If you don't want to specify a particular code, you can leave the ID blank and we'll generate a random code for you.
    # @optional @param max_redemptions [Int64?] A positive integer specifying the number of times the coupon can be redeemed before it's no longer valid. For example, you might have a 50% off coupon that the first 20 readers of your blog can use.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Name of the coupon displayed to customers on, for instance invoices, or receipts. By default the `id` is shown if `name` is not set.
    # @optional @param percent_off [Float64?] A positive float larger than 0, and smaller or equal to 100, that represents the discount the coupon will apply (required if `amount_off` is not passed).
    # @optional @param redeem_by [Int64?] Unix timestamp specifying the last time at which the coupon can be redeemed. After the redeem_by date, the coupon can no longer be applied to new customers.
    # @return [Array<(Coupon, Integer, Hash)>] Coupon data, response status code and response headers
    def post_coupons_with_http_info(*, amount_off : Int64? = nil, applies_to : Stripe::AppliesToParams? = nil, currency : String? = nil, duration : String? = nil, duration_in_months : Int64? = nil, expand : Array(String)? = nil, id : String? = nil, max_redemptions : Int64? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, percent_off : Float64? = nil, redeem_by : Int64? = nil)
      request = build_api_request_for_post_coupons(amount_off: amount_off, applies_to: applies_to, currency: currency, duration: duration, duration_in_months: duration_in_months, expand: expand, id: id, max_redemptions: max_redemptions, metadata: metadata, name: name, percent_off: percent_off, redeem_by: redeem_by)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_coupons\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Coupon.from_json(data), status_code, headers
    end

    # &lt;p&gt;You can create coupons easily via the &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/coupons\&quot;&gt;coupon management&lt;/a&gt; page of the Stripe dashboard. Coupon creation is also accessible via the API if you need to create coupons on the fly.&lt;/p&gt;  &lt;p&gt;A coupon has either a &lt;code&gt;percent_off&lt;/code&gt; or an &lt;code&gt;amount_off&lt;/code&gt; and &lt;code&gt;currency&lt;/code&gt;. If you set an &lt;code&gt;amount_off&lt;/code&gt;, that amount will be subtracted from any invoice’s subtotal. For example, an invoice with a subtotal of &lt;currency&gt;100&lt;/currency&gt; will have a final total of &lt;currency&gt;0&lt;/currency&gt; if a coupon with an &lt;code&gt;amount_off&lt;/code&gt; of &lt;amount&gt;200&lt;/amount&gt; is applied to it and an invoice with a subtotal of &lt;currency&gt;300&lt;/currency&gt; will have a final total of &lt;currency&gt;100&lt;/currency&gt; if a coupon with an &lt;code&gt;amount_off&lt;/code&gt; of &lt;amount&gt;200&lt;/amount&gt; is applied to it.&lt;/p&gt;
    # @optional @param amount_off [Int64?] A positive integer representing the amount to subtract from an invoice total (required if `percent_off` is not passed).
    # @optional @param applies_to [Stripe::AppliesToParams?]
    # @optional @param currency [String?] Three-letter [ISO code for the currency](https://stripe.com/docs/currencies) of the `amount_off` parameter (required if `amount_off` is passed).
    # @optional @param duration [String?] Specifies how long the discount will be in effect if used on a subscription. Can be `forever`, `once`, or `repeating`. Defaults to `once`.
    # @optional @param duration_in_months [Int64?] Required only if `duration` is `repeating`, in which case it must be a positive integer that specifies the number of months the discount will be in effect.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param id [String?] Unique string of your choice that will be used to identify this coupon when applying it to a customer. If you don't want to specify a particular code, you can leave the ID blank and we'll generate a random code for you.
    # @optional @param max_redemptions [Int64?] A positive integer specifying the number of times the coupon can be redeemed before it's no longer valid. For example, you might have a 50% off coupon that the first 20 readers of your blog can use.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Name of the coupon displayed to customers on, for instance invoices, or receipts. By default the `id` is shown if `name` is not set.
    # @optional @param percent_off [Float64?] A positive float larger than 0, and smaller or equal to 100, that represents the discount the coupon will apply (required if `amount_off` is not passed).
    # @optional @param redeem_by [Int64?] Unix timestamp specifying the last time at which the coupon can be redeemed. After the redeem_by date, the coupon can no longer be applied to new customers.
    # @return nil
    def post_coupons(*, amount_off : Int64? = nil, applies_to : Stripe::AppliesToParams? = nil, currency : String? = nil, duration : String? = nil, duration_in_months : Int64? = nil, expand : Array(String)? = nil, id : String? = nil, max_redemptions : Int64? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, percent_off : Float64? = nil, redeem_by : Int64? = nil, &block : Crest::Response ->)
      build_api_request_for_post_coupons(amount_off: amount_off, applies_to: applies_to, currency: currency, duration: duration, duration_in_months: duration_in_months, expand: expand, id: id, max_redemptions: max_redemptions, metadata: metadata, name: name, percent_off: percent_off, redeem_by: redeem_by).execute(&block)
    end

    POST_COUPONS_VALID_VALUES_FOR_DURATION = StaticArray["forever", "once", "repeating"]
    POST_COUPONS_MAX_LENGTH_FOR_ID         = 5000
    POST_COUPONS_MAX_LENGTH_FOR_NAME       =   40

    # @return Crest::Request
    def build_api_request_for_post_coupons(*, amount_off : Int64? = nil, applies_to : Stripe::AppliesToParams? = nil, currency : String? = nil, duration : String? = nil, duration_in_months : Int64? = nil, expand : Array(String)? = nil, id : String? = nil, max_redemptions : Int64? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, percent_off : Float64? = nil, redeem_by : Int64? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_coupons ..." }
      end

      if client_side_validation
        if _applies_to = applies_to
          _applies_to.validate if _applies_to.is_a?(OpenApi::Validatable)
        end

        if _duration = duration
          OpenApi::EnumValidator.validate("duration", _duration, POST_COUPONS_VALID_VALUES_FOR_DURATION)
        end

        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_COUPONS_MAX_LENGTH_FOR_ID)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _name = name
          OpenApi::PrimitiveValidator.validate_max_length("name", name.to_s.size, POST_COUPONS_MAX_LENGTH_FOR_NAME)
        end
      end

      # resource path
      local_var_path = "/v1/coupons"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount_off"] = amount_off.to_s if !amount_off.nil?
      form_params["applies_to"] = applies_to.to_s if !applies_to.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["duration"] = duration.to_s if !duration.nil?
      form_params["duration_in_months"] = duration_in_months.to_s if !duration_in_months.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["id"] = id.to_s if !id.nil?
      form_params["max_redemptions"] = max_redemptions.to_s if !max_redemptions.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["name"] = name.to_s if !name.nil?
      form_params["percent_off"] = percent_off.to_s if !percent_off.nil?
      form_params["redeem_by"] = redeem_by.to_s if !redeem_by.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_coupons",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the metadata of a coupon. Other coupon details (currency, duration, amount_off) are, by design, not editable.</p>
    # @param coupon [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Name of the coupon displayed to customers on, for instance invoices, or receipts. By default the `id` is shown if `name` is not set.
    # @return [Coupon]
    def post_coupons_coupon(*, coupon : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil)
      data, _status_code, _headers = post_coupons_coupon_with_http_info(coupon: coupon, expand: expand, metadata: metadata, name: name)
      data
    end

    # &lt;p&gt;Updates the metadata of a coupon. Other coupon details (currency, duration, amount_off) are, by design, not editable.&lt;/p&gt;
    # @param coupon [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Name of the coupon displayed to customers on, for instance invoices, or receipts. By default the `id` is shown if `name` is not set.
    # @return [Array<(Coupon, Integer, Hash)>] Coupon data, response status code and response headers
    def post_coupons_coupon_with_http_info(*, coupon : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil)
      request = build_api_request_for_post_coupons_coupon(coupon: coupon, expand: expand, metadata: metadata, name: name)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_coupons_coupon\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Coupon.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the metadata of a coupon. Other coupon details (currency, duration, amount_off) are, by design, not editable.&lt;/p&gt;
    # @param coupon [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Name of the coupon displayed to customers on, for instance invoices, or receipts. By default the `id` is shown if `name` is not set.
    # @return nil
    def post_coupons_coupon(*, coupon : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_coupons_coupon(coupon: coupon, expand: expand, metadata: metadata, name: name).execute(&block)
    end

    POST_COUPONS_COUPON_MAX_LENGTH_FOR_COUPON = 5000
    POST_COUPONS_COUPON_MAX_LENGTH_FOR_NAME   =   40

    # @return Crest::Request
    def build_api_request_for_post_coupons_coupon(*, coupon : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_coupons_coupon ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"coupon\" is required and cannot be null") if coupon.nil?
        if _coupon = coupon
          OpenApi::PrimitiveValidator.validate_max_length("coupon", coupon.to_s.size, POST_COUPONS_COUPON_MAX_LENGTH_FOR_COUPON)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _name = name
          OpenApi::PrimitiveValidator.validate_max_length("name", name.to_s.size, POST_COUPONS_COUPON_MAX_LENGTH_FOR_NAME)
        end
      end

      # resource path
      local_var_path = "/v1/coupons/{coupon}".sub("{" + "coupon" + "}", URI.encode_path(coupon.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["name"] = name.to_s if !name.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_coupons_coupon",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Issue a credit note to adjust the amount of a finalized invoice. For a <code>status=open</code> invoice, a credit note reduces its <code>amount_due</code>. For a <code>status=paid</code> invoice, a credit note does not affect its <code>amount_due</code>. Instead, it can result in any combination of the following:</p>  <ul> <li>Refund: create a new refund (using <code>refund_amount</code>) or link an existing refund (using <code>refund</code>).</li> <li>Customer balance credit: credit the customer’s balance (using <code>credit_amount</code>) which will be automatically applied to their next invoice when it’s finalized.</li> <li>Outside of Stripe credit: record the amount that is or will be credited outside of Stripe (using <code>out_of_band_amount</code>).</li> </ul>  <p>For post-payment credit notes the sum of the refund, credit and outside of Stripe amounts must equal the credit note total.</p>  <p>You may issue multiple credit notes for an invoice. Each credit note will increment the invoice’s <code>pre_payment_credit_notes_amount</code> or <code>post_payment_credit_notes_amount</code> depending on its <code>status</code> at the time of credit note creation.</p>
    # @param invoice [String?] ID of the invoice.
    # @optional @param amount [Int64?] The integer amount in cents (or local equivalent) representing the total amount of the credit note.
    # @optional @param credit_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount to credit the customer's balance, which will be automatically applied to their next invoice.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param lines [Array(Stripe::CreditNoteLineItemParams)?] Line items that make up the credit note.
    # @optional @param memo [String?] The credit note's memo appears on the credit note PDF.
    # @optional @param out_of_band_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount that is credited outside of Stripe.
    # @optional @param reason [String?] Reason for issuing this credit note, one of `duplicate`, `fraudulent`, `order_change`, or `product_unsatisfactory`
    # @optional @param refund [String?] ID of an existing refund to link this credit note to.
    # @optional @param refund_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount to refund. If set, a refund will be created for the charge associated with the invoice.
    # @return [CreditNote]
    def post_credit_notes(*, invoice : String? = nil, amount : Int64? = nil, credit_amount : Int64? = nil, expand : Array(String)? = nil, lines : Array(Stripe::CreditNoteLineItemParams)? = nil, memo : String? = nil, out_of_band_amount : Int64? = nil, reason : String? = nil, refund : String? = nil, refund_amount : Int64? = nil)
      data, _status_code, _headers = post_credit_notes_with_http_info(invoice: invoice, amount: amount, credit_amount: credit_amount, expand: expand, lines: lines, memo: memo, out_of_band_amount: out_of_band_amount, reason: reason, refund: refund, refund_amount: refund_amount)
      data
    end

    # &lt;p&gt;Issue a credit note to adjust the amount of a finalized invoice. For a &lt;code&gt;status&#x3D;open&lt;/code&gt; invoice, a credit note reduces its &lt;code&gt;amount_due&lt;/code&gt;. For a &lt;code&gt;status&#x3D;paid&lt;/code&gt; invoice, a credit note does not affect its &lt;code&gt;amount_due&lt;/code&gt;. Instead, it can result in any combination of the following:&lt;/p&gt;  &lt;ul&gt; &lt;li&gt;Refund: create a new refund (using &lt;code&gt;refund_amount&lt;/code&gt;) or link an existing refund (using &lt;code&gt;refund&lt;/code&gt;).&lt;/li&gt; &lt;li&gt;Customer balance credit: credit the customer’s balance (using &lt;code&gt;credit_amount&lt;/code&gt;) which will be automatically applied to their next invoice when it’s finalized.&lt;/li&gt; &lt;li&gt;Outside of Stripe credit: record the amount that is or will be credited outside of Stripe (using &lt;code&gt;out_of_band_amount&lt;/code&gt;).&lt;/li&gt; &lt;/ul&gt;  &lt;p&gt;For post-payment credit notes the sum of the refund, credit and outside of Stripe amounts must equal the credit note total.&lt;/p&gt;  &lt;p&gt;You may issue multiple credit notes for an invoice. Each credit note will increment the invoice’s &lt;code&gt;pre_payment_credit_notes_amount&lt;/code&gt; or &lt;code&gt;post_payment_credit_notes_amount&lt;/code&gt; depending on its &lt;code&gt;status&lt;/code&gt; at the time of credit note creation.&lt;/p&gt;
    # @param invoice [String?] ID of the invoice.
    # @optional @param amount [Int64?] The integer amount in cents (or local equivalent) representing the total amount of the credit note.
    # @optional @param credit_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount to credit the customer's balance, which will be automatically applied to their next invoice.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param lines [Array(Stripe::CreditNoteLineItemParams)?] Line items that make up the credit note.
    # @optional @param memo [String?] The credit note's memo appears on the credit note PDF.
    # @optional @param out_of_band_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount that is credited outside of Stripe.
    # @optional @param reason [String?] Reason for issuing this credit note, one of `duplicate`, `fraudulent`, `order_change`, or `product_unsatisfactory`
    # @optional @param refund [String?] ID of an existing refund to link this credit note to.
    # @optional @param refund_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount to refund. If set, a refund will be created for the charge associated with the invoice.
    # @return [Array<(CreditNote, Integer, Hash)>] CreditNote data, response status code and response headers
    def post_credit_notes_with_http_info(*, invoice : String? = nil, amount : Int64? = nil, credit_amount : Int64? = nil, expand : Array(String)? = nil, lines : Array(Stripe::CreditNoteLineItemParams)? = nil, memo : String? = nil, out_of_band_amount : Int64? = nil, reason : String? = nil, refund : String? = nil, refund_amount : Int64? = nil)
      request = build_api_request_for_post_credit_notes(invoice: invoice, amount: amount, credit_amount: credit_amount, expand: expand, lines: lines, memo: memo, out_of_band_amount: out_of_band_amount, reason: reason, refund: refund, refund_amount: refund_amount)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_credit_notes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CreditNote.from_json(data), status_code, headers
    end

    # &lt;p&gt;Issue a credit note to adjust the amount of a finalized invoice. For a &lt;code&gt;status&#x3D;open&lt;/code&gt; invoice, a credit note reduces its &lt;code&gt;amount_due&lt;/code&gt;. For a &lt;code&gt;status&#x3D;paid&lt;/code&gt; invoice, a credit note does not affect its &lt;code&gt;amount_due&lt;/code&gt;. Instead, it can result in any combination of the following:&lt;/p&gt;  &lt;ul&gt; &lt;li&gt;Refund: create a new refund (using &lt;code&gt;refund_amount&lt;/code&gt;) or link an existing refund (using &lt;code&gt;refund&lt;/code&gt;).&lt;/li&gt; &lt;li&gt;Customer balance credit: credit the customer’s balance (using &lt;code&gt;credit_amount&lt;/code&gt;) which will be automatically applied to their next invoice when it’s finalized.&lt;/li&gt; &lt;li&gt;Outside of Stripe credit: record the amount that is or will be credited outside of Stripe (using &lt;code&gt;out_of_band_amount&lt;/code&gt;).&lt;/li&gt; &lt;/ul&gt;  &lt;p&gt;For post-payment credit notes the sum of the refund, credit and outside of Stripe amounts must equal the credit note total.&lt;/p&gt;  &lt;p&gt;You may issue multiple credit notes for an invoice. Each credit note will increment the invoice’s &lt;code&gt;pre_payment_credit_notes_amount&lt;/code&gt; or &lt;code&gt;post_payment_credit_notes_amount&lt;/code&gt; depending on its &lt;code&gt;status&lt;/code&gt; at the time of credit note creation.&lt;/p&gt;
    # @param invoice [String?] ID of the invoice.
    # @optional @param amount [Int64?] The integer amount in cents (or local equivalent) representing the total amount of the credit note.
    # @optional @param credit_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount to credit the customer's balance, which will be automatically applied to their next invoice.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param lines [Array(Stripe::CreditNoteLineItemParams)?] Line items that make up the credit note.
    # @optional @param memo [String?] The credit note's memo appears on the credit note PDF.
    # @optional @param out_of_band_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount that is credited outside of Stripe.
    # @optional @param reason [String?] Reason for issuing this credit note, one of `duplicate`, `fraudulent`, `order_change`, or `product_unsatisfactory`
    # @optional @param refund [String?] ID of an existing refund to link this credit note to.
    # @optional @param refund_amount [Int64?] The integer amount in cents (or local equivalent) representing the amount to refund. If set, a refund will be created for the charge associated with the invoice.
    # @return nil
    def post_credit_notes(*, invoice : String? = nil, amount : Int64? = nil, credit_amount : Int64? = nil, expand : Array(String)? = nil, lines : Array(Stripe::CreditNoteLineItemParams)? = nil, memo : String? = nil, out_of_band_amount : Int64? = nil, reason : String? = nil, refund : String? = nil, refund_amount : Int64? = nil, &block : Crest::Response ->)
      build_api_request_for_post_credit_notes(invoice: invoice, amount: amount, credit_amount: credit_amount, expand: expand, lines: lines, memo: memo, out_of_band_amount: out_of_band_amount, reason: reason, refund: refund, refund_amount: refund_amount).execute(&block)
    end

    POST_CREDIT_NOTES_MAX_LENGTH_FOR_INVOICE  = 5000
    POST_CREDIT_NOTES_MAX_LENGTH_FOR_MEMO     = 5000
    POST_CREDIT_NOTES_VALID_VALUES_FOR_REASON = StaticArray["duplicate", "fraudulent", "order_change", "product_unsatisfactory"]

    # @return Crest::Request
    def build_api_request_for_post_credit_notes(*, invoice : String? = nil, amount : Int64? = nil, credit_amount : Int64? = nil, expand : Array(String)? = nil, lines : Array(Stripe::CreditNoteLineItemParams)? = nil, memo : String? = nil, out_of_band_amount : Int64? = nil, reason : String? = nil, refund : String? = nil, refund_amount : Int64? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_credit_notes ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"invoice\" is required and cannot be null") if invoice.nil?
        if _invoice = invoice
          OpenApi::PrimitiveValidator.validate_max_length("invoice", invoice.to_s.size, POST_CREDIT_NOTES_MAX_LENGTH_FOR_INVOICE)
        end

        if _lines = lines
          OpenApi::ContainerValidator.validate(container: _lines) if _lines.is_a?(Array)
        end
        if _memo = memo
          OpenApi::PrimitiveValidator.validate_max_length("memo", memo.to_s.size, POST_CREDIT_NOTES_MAX_LENGTH_FOR_MEMO)
        end

        if _reason = reason
          OpenApi::EnumValidator.validate("reason", _reason, POST_CREDIT_NOTES_VALID_VALUES_FOR_REASON)
        end
      end

      # resource path
      local_var_path = "/v1/credit_notes"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["credit_amount"] = credit_amount.to_s if !credit_amount.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["invoice"] = invoice.to_s if !invoice.nil?
      form_params["lines"] = @api_client.build_collection_param(lines, "csv") if !lines.nil? && !lines.empty?
      form_params["memo"] = memo.to_s if !memo.nil?
      form_params["out_of_band_amount"] = out_of_band_amount.to_s if !out_of_band_amount.nil?
      form_params["reason"] = reason.to_s if !reason.nil?
      form_params["refund"] = refund.to_s if !refund.nil?
      form_params["refund_amount"] = refund_amount.to_s if !refund_amount.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_credit_notes",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates an existing credit note.</p>
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param memo [String?] Credit note memo.
    # @return [CreditNote]
    def post_credit_notes_id(*, id : String? = nil, expand : Array(String)? = nil, memo : String? = nil)
      data, _status_code, _headers = post_credit_notes_id_with_http_info(id: id, expand: expand, memo: memo)
      data
    end

    # &lt;p&gt;Updates an existing credit note.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param memo [String?] Credit note memo.
    # @return [Array<(CreditNote, Integer, Hash)>] CreditNote data, response status code and response headers
    def post_credit_notes_id_with_http_info(*, id : String? = nil, expand : Array(String)? = nil, memo : String? = nil)
      request = build_api_request_for_post_credit_notes_id(id: id, expand: expand, memo: memo)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_credit_notes_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CreditNote.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates an existing credit note.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param memo [String?] Credit note memo.
    # @return nil
    def post_credit_notes_id(*, id : String? = nil, expand : Array(String)? = nil, memo : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_credit_notes_id(id: id, expand: expand, memo: memo).execute(&block)
    end

    POST_CREDIT_NOTES_ID_MAX_LENGTH_FOR_ID   = 5000
    POST_CREDIT_NOTES_ID_MAX_LENGTH_FOR_MEMO = 5000

    # @return Crest::Request
    def build_api_request_for_post_credit_notes_id(*, id : String? = nil, expand : Array(String)? = nil, memo : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_credit_notes_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_CREDIT_NOTES_ID_MAX_LENGTH_FOR_ID)
        end

        if _memo = memo
          OpenApi::PrimitiveValidator.validate_max_length("memo", memo.to_s.size, POST_CREDIT_NOTES_ID_MAX_LENGTH_FOR_MEMO)
        end
      end

      # resource path
      local_var_path = "/v1/credit_notes/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["memo"] = memo.to_s if !memo.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_credit_notes_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Marks a credit note as void. Learn more about <a href=\"/docs/billing/invoices/credit-notes#voiding\">voiding credit notes</a>.</p>
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [CreditNote]
    def post_credit_notes_id_void(*, id : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_credit_notes_id_void_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Marks a credit note as void. Learn more about &lt;a href&#x3D;\&quot;/docs/billing/invoices/credit-notes#voiding\&quot;&gt;voiding credit notes&lt;/a&gt;.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(CreditNote, Integer, Hash)>] CreditNote data, response status code and response headers
    def post_credit_notes_id_void_with_http_info(*, id : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_credit_notes_id_void(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_credit_notes_id_void\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CreditNote.from_json(data), status_code, headers
    end

    # &lt;p&gt;Marks a credit note as void. Learn more about &lt;a href&#x3D;\&quot;/docs/billing/invoices/credit-notes#voiding\&quot;&gt;voiding credit notes&lt;/a&gt;.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_credit_notes_id_void(*, id : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_credit_notes_id_void(id: id, expand: expand).execute(&block)
    end

    POST_CREDIT_NOTES_ID_VOID_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_post_credit_notes_id_void(*, id : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_credit_notes_id_void ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_CREDIT_NOTES_ID_VOID_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/credit_notes/{id}/void".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_credit_notes_id_void",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new customer object.</p>
    # @optional @param address [Stripe::PostCustomersRequestAddress?]
    # @optional @param balance [Int64?] An integer amount in cents (or local equivalent) that represents the customer's current balance, which affect the customer's future invoices. A negative amount represents a credit that decreases the amount due on an invoice; a positive amount increases the amount due on an invoice.
    # @optional @param cash_balance [Stripe::CashBalanceParam?]
    # @optional @param coupon [String?]
    # @optional @param description [String?] An arbitrary string that you can attach to a customer object. It is displayed alongside the customer in the dashboard.
    # @optional @param email [String?] Customer's email address. It's displayed alongside the customer in your dashboard and can be useful for searching and tracking. This may be up to *512 characters*.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_prefix [String?] The prefix for the customer used to generate unique invoice numbers. Must be 3–12 uppercase letters or numbers.
    # @optional @param invoice_settings [Stripe::CustomerParam?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] The customer's full name or business name.
    # @optional @param next_invoice_sequence [Int64?] The sequence to be used on the customer's next invoice. Defaults to 1.
    # @optional @param payment_method [String?]
    # @optional @param phone [String?] The customer's phone number.
    # @optional @param preferred_locales [Array(String)?] Customer's preferred languages, ordered by preference.
    # @optional @param promotion_code [String?] The API ID of a promotion code to apply to the customer. The customer will have a discount applied on all recurring payments. Charges you create through the API will not have the discount.
    # @optional @param shipping [Stripe::PostCustomersRequestShipping?]
    # @optional @param source [String?]
    # @optional @param tax [Stripe::TaxParam?]
    # @optional @param tax_exempt [String?] The customer's tax exemption. One of `none`, `exempt`, or `reverse`.
    # @optional @param tax_id_data [Array(Stripe::DataParams)?] The customer's tax IDs.
    # @optional @param test_clock [String?] ID of the test clock to attach to the customer.
    # @return [Customer]
    def post_customers(*, address : Stripe::PostCustomersRequestAddress? = nil, balance : Int64? = nil, cash_balance : Stripe::CashBalanceParam? = nil, coupon : String? = nil, description : String? = nil, email : String? = nil, expand : Array(String)? = nil, invoice_prefix : String? = nil, invoice_settings : Stripe::CustomerParam? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, next_invoice_sequence : Int64? = nil, payment_method : String? = nil, phone : String? = nil, preferred_locales : Array(String)? = nil, promotion_code : String? = nil, shipping : Stripe::PostCustomersRequestShipping? = nil, source : String? = nil, tax : Stripe::TaxParam? = nil, tax_exempt : String? = nil, tax_id_data : Array(Stripe::DataParams)? = nil, test_clock : String? = nil)
      data, _status_code, _headers = post_customers_with_http_info(address: address, balance: balance, cash_balance: cash_balance, coupon: coupon, description: description, email: email, expand: expand, invoice_prefix: invoice_prefix, invoice_settings: invoice_settings, metadata: metadata, name: name, next_invoice_sequence: next_invoice_sequence, payment_method: payment_method, phone: phone, preferred_locales: preferred_locales, promotion_code: promotion_code, shipping: shipping, source: source, tax: tax, tax_exempt: tax_exempt, tax_id_data: tax_id_data, test_clock: test_clock)
      data
    end

    # &lt;p&gt;Creates a new customer object.&lt;/p&gt;
    # @optional @param address [Stripe::PostCustomersRequestAddress?]
    # @optional @param balance [Int64?] An integer amount in cents (or local equivalent) that represents the customer's current balance, which affect the customer's future invoices. A negative amount represents a credit that decreases the amount due on an invoice; a positive amount increases the amount due on an invoice.
    # @optional @param cash_balance [Stripe::CashBalanceParam?]
    # @optional @param coupon [String?]
    # @optional @param description [String?] An arbitrary string that you can attach to a customer object. It is displayed alongside the customer in the dashboard.
    # @optional @param email [String?] Customer's email address. It's displayed alongside the customer in your dashboard and can be useful for searching and tracking. This may be up to *512 characters*.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_prefix [String?] The prefix for the customer used to generate unique invoice numbers. Must be 3–12 uppercase letters or numbers.
    # @optional @param invoice_settings [Stripe::CustomerParam?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] The customer's full name or business name.
    # @optional @param next_invoice_sequence [Int64?] The sequence to be used on the customer's next invoice. Defaults to 1.
    # @optional @param payment_method [String?]
    # @optional @param phone [String?] The customer's phone number.
    # @optional @param preferred_locales [Array(String)?] Customer's preferred languages, ordered by preference.
    # @optional @param promotion_code [String?] The API ID of a promotion code to apply to the customer. The customer will have a discount applied on all recurring payments. Charges you create through the API will not have the discount.
    # @optional @param shipping [Stripe::PostCustomersRequestShipping?]
    # @optional @param source [String?]
    # @optional @param tax [Stripe::TaxParam?]
    # @optional @param tax_exempt [String?] The customer's tax exemption. One of `none`, `exempt`, or `reverse`.
    # @optional @param tax_id_data [Array(Stripe::DataParams)?] The customer's tax IDs.
    # @optional @param test_clock [String?] ID of the test clock to attach to the customer.
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def post_customers_with_http_info(*, address : Stripe::PostCustomersRequestAddress? = nil, balance : Int64? = nil, cash_balance : Stripe::CashBalanceParam? = nil, coupon : String? = nil, description : String? = nil, email : String? = nil, expand : Array(String)? = nil, invoice_prefix : String? = nil, invoice_settings : Stripe::CustomerParam? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, next_invoice_sequence : Int64? = nil, payment_method : String? = nil, phone : String? = nil, preferred_locales : Array(String)? = nil, promotion_code : String? = nil, shipping : Stripe::PostCustomersRequestShipping? = nil, source : String? = nil, tax : Stripe::TaxParam? = nil, tax_exempt : String? = nil, tax_id_data : Array(Stripe::DataParams)? = nil, test_clock : String? = nil)
      request = build_api_request_for_post_customers(address: address, balance: balance, cash_balance: cash_balance, coupon: coupon, description: description, email: email, expand: expand, invoice_prefix: invoice_prefix, invoice_settings: invoice_settings, metadata: metadata, name: name, next_invoice_sequence: next_invoice_sequence, payment_method: payment_method, phone: phone, preferred_locales: preferred_locales, promotion_code: promotion_code, shipping: shipping, source: source, tax: tax, tax_exempt: tax_exempt, tax_id_data: tax_id_data, test_clock: test_clock)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_customers\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Customer.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new customer object.&lt;/p&gt;
    # @optional @param address [Stripe::PostCustomersRequestAddress?]
    # @optional @param balance [Int64?] An integer amount in cents (or local equivalent) that represents the customer's current balance, which affect the customer's future invoices. A negative amount represents a credit that decreases the amount due on an invoice; a positive amount increases the amount due on an invoice.
    # @optional @param cash_balance [Stripe::CashBalanceParam?]
    # @optional @param coupon [String?]
    # @optional @param description [String?] An arbitrary string that you can attach to a customer object. It is displayed alongside the customer in the dashboard.
    # @optional @param email [String?] Customer's email address. It's displayed alongside the customer in your dashboard and can be useful for searching and tracking. This may be up to *512 characters*.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_prefix [String?] The prefix for the customer used to generate unique invoice numbers. Must be 3–12 uppercase letters or numbers.
    # @optional @param invoice_settings [Stripe::CustomerParam?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] The customer's full name or business name.
    # @optional @param next_invoice_sequence [Int64?] The sequence to be used on the customer's next invoice. Defaults to 1.
    # @optional @param payment_method [String?]
    # @optional @param phone [String?] The customer's phone number.
    # @optional @param preferred_locales [Array(String)?] Customer's preferred languages, ordered by preference.
    # @optional @param promotion_code [String?] The API ID of a promotion code to apply to the customer. The customer will have a discount applied on all recurring payments. Charges you create through the API will not have the discount.
    # @optional @param shipping [Stripe::PostCustomersRequestShipping?]
    # @optional @param source [String?]
    # @optional @param tax [Stripe::TaxParam?]
    # @optional @param tax_exempt [String?] The customer's tax exemption. One of `none`, `exempt`, or `reverse`.
    # @optional @param tax_id_data [Array(Stripe::DataParams)?] The customer's tax IDs.
    # @optional @param test_clock [String?] ID of the test clock to attach to the customer.
    # @return nil
    def post_customers(*, address : Stripe::PostCustomersRequestAddress? = nil, balance : Int64? = nil, cash_balance : Stripe::CashBalanceParam? = nil, coupon : String? = nil, description : String? = nil, email : String? = nil, expand : Array(String)? = nil, invoice_prefix : String? = nil, invoice_settings : Stripe::CustomerParam? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, next_invoice_sequence : Int64? = nil, payment_method : String? = nil, phone : String? = nil, preferred_locales : Array(String)? = nil, promotion_code : String? = nil, shipping : Stripe::PostCustomersRequestShipping? = nil, source : String? = nil, tax : Stripe::TaxParam? = nil, tax_exempt : String? = nil, tax_id_data : Array(Stripe::DataParams)? = nil, test_clock : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_customers(address: address, balance: balance, cash_balance: cash_balance, coupon: coupon, description: description, email: email, expand: expand, invoice_prefix: invoice_prefix, invoice_settings: invoice_settings, metadata: metadata, name: name, next_invoice_sequence: next_invoice_sequence, payment_method: payment_method, phone: phone, preferred_locales: preferred_locales, promotion_code: promotion_code, shipping: shipping, source: source, tax: tax, tax_exempt: tax_exempt, tax_id_data: tax_id_data, test_clock: test_clock).execute(&block)
    end

    POST_CUSTOMERS_MAX_LENGTH_FOR_COUPON         = 5000
    POST_CUSTOMERS_MAX_LENGTH_FOR_DESCRIPTION    = 5000
    POST_CUSTOMERS_MAX_LENGTH_FOR_EMAIL          =  512
    POST_CUSTOMERS_MAX_LENGTH_FOR_INVOICE_PREFIX = 5000
    POST_CUSTOMERS_MAX_LENGTH_FOR_NAME           =  256
    POST_CUSTOMERS_MAX_LENGTH_FOR_PAYMENT_METHOD = 5000
    POST_CUSTOMERS_MAX_LENGTH_FOR_PHONE          =   20
    POST_CUSTOMERS_MAX_LENGTH_FOR_PROMOTION_CODE = 5000
    POST_CUSTOMERS_MAX_LENGTH_FOR_SOURCE         = 5000
    POST_CUSTOMERS_VALID_VALUES_FOR_TAX_EXEMPT   = StaticArray["", "exempt", "none", "reverse"]
    POST_CUSTOMERS_MAX_LENGTH_FOR_TEST_CLOCK     = 5000

    # @return Crest::Request
    def build_api_request_for_post_customers(*, address : Stripe::PostCustomersRequestAddress? = nil, balance : Int64? = nil, cash_balance : Stripe::CashBalanceParam? = nil, coupon : String? = nil, description : String? = nil, email : String? = nil, expand : Array(String)? = nil, invoice_prefix : String? = nil, invoice_settings : Stripe::CustomerParam? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, next_invoice_sequence : Int64? = nil, payment_method : String? = nil, phone : String? = nil, preferred_locales : Array(String)? = nil, promotion_code : String? = nil, shipping : Stripe::PostCustomersRequestShipping? = nil, source : String? = nil, tax : Stripe::TaxParam? = nil, tax_exempt : String? = nil, tax_id_data : Array(Stripe::DataParams)? = nil, test_clock : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_customers ..." }
      end

      if client_side_validation
        if _address = address
          _address.validate if _address.is_a?(OpenApi::Validatable)
        end

        if _cash_balance = cash_balance
          _cash_balance.validate if _cash_balance.is_a?(OpenApi::Validatable)
        end
        if _coupon = coupon
          OpenApi::PrimitiveValidator.validate_max_length("coupon", coupon.to_s.size, POST_CUSTOMERS_MAX_LENGTH_FOR_COUPON)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_CUSTOMERS_MAX_LENGTH_FOR_DESCRIPTION)
        end
        if _email = email
          OpenApi::PrimitiveValidator.validate_max_length("email", email.to_s.size, POST_CUSTOMERS_MAX_LENGTH_FOR_EMAIL)
        end

        if _invoice_prefix = invoice_prefix
          OpenApi::PrimitiveValidator.validate_max_length("invoice_prefix", invoice_prefix.to_s.size, POST_CUSTOMERS_MAX_LENGTH_FOR_INVOICE_PREFIX)
        end
        if _invoice_settings = invoice_settings
          _invoice_settings.validate if _invoice_settings.is_a?(OpenApi::Validatable)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _name = name
          OpenApi::PrimitiveValidator.validate_max_length("name", name.to_s.size, POST_CUSTOMERS_MAX_LENGTH_FOR_NAME)
        end

        if _payment_method = payment_method
          OpenApi::PrimitiveValidator.validate_max_length("payment_method", payment_method.to_s.size, POST_CUSTOMERS_MAX_LENGTH_FOR_PAYMENT_METHOD)
        end
        if _phone = phone
          OpenApi::PrimitiveValidator.validate_max_length("phone", phone.to_s.size, POST_CUSTOMERS_MAX_LENGTH_FOR_PHONE)
        end

        if _promotion_code = promotion_code
          OpenApi::PrimitiveValidator.validate_max_length("promotion_code", promotion_code.to_s.size, POST_CUSTOMERS_MAX_LENGTH_FOR_PROMOTION_CODE)
        end
        if _shipping = shipping
          _shipping.validate if _shipping.is_a?(OpenApi::Validatable)
        end
        if _source = source
          OpenApi::PrimitiveValidator.validate_max_length("source", source.to_s.size, POST_CUSTOMERS_MAX_LENGTH_FOR_SOURCE)
        end
        if _tax = tax
          _tax.validate if _tax.is_a?(OpenApi::Validatable)
        end
        if _tax_exempt = tax_exempt
          OpenApi::EnumValidator.validate("tax_exempt", _tax_exempt, POST_CUSTOMERS_VALID_VALUES_FOR_TAX_EXEMPT)
        end
        if _tax_id_data = tax_id_data
          OpenApi::ContainerValidator.validate(container: _tax_id_data) if _tax_id_data.is_a?(Array)
        end
        if _test_clock = test_clock
          OpenApi::PrimitiveValidator.validate_max_length("test_clock", test_clock.to_s.size, POST_CUSTOMERS_MAX_LENGTH_FOR_TEST_CLOCK)
        end
      end

      # resource path
      local_var_path = "/v1/customers"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["address"] = address.to_s if !address.nil?
      form_params["balance"] = balance.to_s if !balance.nil?
      form_params["cash_balance"] = cash_balance.to_s if !cash_balance.nil?
      form_params["coupon"] = coupon.to_s if !coupon.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["email"] = email.to_s if !email.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["invoice_prefix"] = invoice_prefix.to_s if !invoice_prefix.nil?
      form_params["invoice_settings"] = invoice_settings.to_s if !invoice_settings.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["name"] = name.to_s if !name.nil?
      form_params["next_invoice_sequence"] = next_invoice_sequence.to_s if !next_invoice_sequence.nil?
      form_params["payment_method"] = payment_method.to_s if !payment_method.nil?
      form_params["phone"] = phone.to_s if !phone.nil?
      form_params["preferred_locales"] = @api_client.build_collection_param(preferred_locales, "csv") if !preferred_locales.nil? && !preferred_locales.empty?
      form_params["promotion_code"] = promotion_code.to_s if !promotion_code.nil?
      form_params["shipping"] = shipping.to_s if !shipping.nil?
      form_params["source"] = source.to_s if !source.nil?
      form_params["tax"] = tax.to_s if !tax.nil?
      form_params["tax_exempt"] = tax_exempt.to_s if !tax_exempt.nil?
      form_params["tax_id_data"] = @api_client.build_collection_param(tax_id_data, "csv") if !tax_id_data.nil? && !tax_id_data.empty?
      form_params["test_clock"] = test_clock.to_s if !test_clock.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_customers",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the specified customer by setting the values of the parameters passed. Any parameters not provided will be left unchanged. For example, if you pass the <strong>source</strong> parameter, that becomes the customer’s active source (e.g., a card) to be used for all charges in the future. When you update a customer to a new valid card source by passing the <strong>source</strong> parameter: for each of the customer’s current subscriptions, if the subscription bills automatically and is in the <code>past_due</code> state, then the latest open invoice for the subscription with automatic collection enabled will be retried. This retry will not count as an automatic retry, and will not affect the next regularly scheduled payment for the invoice. Changing the <strong>default_source</strong> for a customer will not trigger this behavior.</p>  <p>This request accepts mostly the same arguments as the customer creation call.</p>
    # @param customer [String?]
    # @optional @param address [Stripe::PostCustomersRequestAddress?]
    # @optional @param balance [Int64?] An integer amount in cents (or local equivalent) that represents the customer's current balance, which affect the customer's future invoices. A negative amount represents a credit that decreases the amount due on an invoice; a positive amount increases the amount due on an invoice.
    # @optional @param bank_account [Stripe::PostCustomersCustomerRequestBankAccount?]
    # @optional @param card [Stripe::PostChargesRequestCard?]
    # @optional @param cash_balance [Stripe::CashBalanceParam?]
    # @optional @param coupon [String?]
    # @optional @param default_alipay_account [String?] ID of Alipay account to make the customer's new default for invoice payments.
    # @optional @param default_bank_account [String?] ID of bank account to make the customer's new default for invoice payments.
    # @optional @param default_card [String?] ID of card to make the customer's new default for invoice payments.
    # @optional @param default_source [String?] If you are using payment methods created via the PaymentMethods API, see the [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/update#update_customer-invoice_settings-default_payment_method) parameter.  Provide the ID of a payment source already attached to this customer to make it this customer's default payment source.  If you want to add a new payment source and make it the default, see the [source](https://stripe.com/docs/api/customers/update#update_customer-source) property.
    # @optional @param description [String?] An arbitrary string that you can attach to a customer object. It is displayed alongside the customer in the dashboard.
    # @optional @param email [String?] Customer's email address. It's displayed alongside the customer in your dashboard and can be useful for searching and tracking. This may be up to *512 characters*.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_prefix [String?] The prefix for the customer used to generate unique invoice numbers. Must be 3–12 uppercase letters or numbers.
    # @optional @param invoice_settings [Stripe::CustomerParam?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] The customer's full name or business name.
    # @optional @param next_invoice_sequence [Int64?] The sequence to be used on the customer's next invoice. Defaults to 1.
    # @optional @param phone [String?] The customer's phone number.
    # @optional @param preferred_locales [Array(String)?] Customer's preferred languages, ordered by preference.
    # @optional @param promotion_code [String?] The API ID of a promotion code to apply to the customer. The customer will have a discount applied on all recurring payments. Charges you create through the API will not have the discount.
    # @optional @param shipping [Stripe::PostCustomersRequestShipping?]
    # @optional @param source [String?]
    # @optional @param tax [Stripe::TaxParam?]
    # @optional @param tax_exempt [String?] The customer's tax exemption. One of `none`, `exempt`, or `reverse`.
    # @return [Customer]
    def post_customers_customer(*, customer : String? = nil, address : Stripe::PostCustomersRequestAddress? = nil, balance : Int64? = nil, bank_account : Stripe::PostCustomersCustomerRequestBankAccount? = nil, card : Stripe::PostChargesRequestCard? = nil, cash_balance : Stripe::CashBalanceParam? = nil, coupon : String? = nil, default_alipay_account : String? = nil, default_bank_account : String? = nil, default_card : String? = nil, default_source : String? = nil, description : String? = nil, email : String? = nil, expand : Array(String)? = nil, invoice_prefix : String? = nil, invoice_settings : Stripe::CustomerParam? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, next_invoice_sequence : Int64? = nil, phone : String? = nil, preferred_locales : Array(String)? = nil, promotion_code : String? = nil, shipping : Stripe::PostCustomersRequestShipping? = nil, source : String? = nil, tax : Stripe::TaxParam? = nil, tax_exempt : String? = nil)
      data, _status_code, _headers = post_customers_customer_with_http_info(customer: customer, address: address, balance: balance, bank_account: bank_account, card: card, cash_balance: cash_balance, coupon: coupon, default_alipay_account: default_alipay_account, default_bank_account: default_bank_account, default_card: default_card, default_source: default_source, description: description, email: email, expand: expand, invoice_prefix: invoice_prefix, invoice_settings: invoice_settings, metadata: metadata, name: name, next_invoice_sequence: next_invoice_sequence, phone: phone, preferred_locales: preferred_locales, promotion_code: promotion_code, shipping: shipping, source: source, tax: tax, tax_exempt: tax_exempt)
      data
    end

    # &lt;p&gt;Updates the specified customer by setting the values of the parameters passed. Any parameters not provided will be left unchanged. For example, if you pass the &lt;strong&gt;source&lt;/strong&gt; parameter, that becomes the customer’s active source (e.g., a card) to be used for all charges in the future. When you update a customer to a new valid card source by passing the &lt;strong&gt;source&lt;/strong&gt; parameter: for each of the customer’s current subscriptions, if the subscription bills automatically and is in the &lt;code&gt;past_due&lt;/code&gt; state, then the latest open invoice for the subscription with automatic collection enabled will be retried. This retry will not count as an automatic retry, and will not affect the next regularly scheduled payment for the invoice. Changing the &lt;strong&gt;default_source&lt;/strong&gt; for a customer will not trigger this behavior.&lt;/p&gt;  &lt;p&gt;This request accepts mostly the same arguments as the customer creation call.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param address [Stripe::PostCustomersRequestAddress?]
    # @optional @param balance [Int64?] An integer amount in cents (or local equivalent) that represents the customer's current balance, which affect the customer's future invoices. A negative amount represents a credit that decreases the amount due on an invoice; a positive amount increases the amount due on an invoice.
    # @optional @param bank_account [Stripe::PostCustomersCustomerRequestBankAccount?]
    # @optional @param card [Stripe::PostChargesRequestCard?]
    # @optional @param cash_balance [Stripe::CashBalanceParam?]
    # @optional @param coupon [String?]
    # @optional @param default_alipay_account [String?] ID of Alipay account to make the customer's new default for invoice payments.
    # @optional @param default_bank_account [String?] ID of bank account to make the customer's new default for invoice payments.
    # @optional @param default_card [String?] ID of card to make the customer's new default for invoice payments.
    # @optional @param default_source [String?] If you are using payment methods created via the PaymentMethods API, see the [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/update#update_customer-invoice_settings-default_payment_method) parameter.  Provide the ID of a payment source already attached to this customer to make it this customer's default payment source.  If you want to add a new payment source and make it the default, see the [source](https://stripe.com/docs/api/customers/update#update_customer-source) property.
    # @optional @param description [String?] An arbitrary string that you can attach to a customer object. It is displayed alongside the customer in the dashboard.
    # @optional @param email [String?] Customer's email address. It's displayed alongside the customer in your dashboard and can be useful for searching and tracking. This may be up to *512 characters*.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_prefix [String?] The prefix for the customer used to generate unique invoice numbers. Must be 3–12 uppercase letters or numbers.
    # @optional @param invoice_settings [Stripe::CustomerParam?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] The customer's full name or business name.
    # @optional @param next_invoice_sequence [Int64?] The sequence to be used on the customer's next invoice. Defaults to 1.
    # @optional @param phone [String?] The customer's phone number.
    # @optional @param preferred_locales [Array(String)?] Customer's preferred languages, ordered by preference.
    # @optional @param promotion_code [String?] The API ID of a promotion code to apply to the customer. The customer will have a discount applied on all recurring payments. Charges you create through the API will not have the discount.
    # @optional @param shipping [Stripe::PostCustomersRequestShipping?]
    # @optional @param source [String?]
    # @optional @param tax [Stripe::TaxParam?]
    # @optional @param tax_exempt [String?] The customer's tax exemption. One of `none`, `exempt`, or `reverse`.
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def post_customers_customer_with_http_info(*, customer : String? = nil, address : Stripe::PostCustomersRequestAddress? = nil, balance : Int64? = nil, bank_account : Stripe::PostCustomersCustomerRequestBankAccount? = nil, card : Stripe::PostChargesRequestCard? = nil, cash_balance : Stripe::CashBalanceParam? = nil, coupon : String? = nil, default_alipay_account : String? = nil, default_bank_account : String? = nil, default_card : String? = nil, default_source : String? = nil, description : String? = nil, email : String? = nil, expand : Array(String)? = nil, invoice_prefix : String? = nil, invoice_settings : Stripe::CustomerParam? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, next_invoice_sequence : Int64? = nil, phone : String? = nil, preferred_locales : Array(String)? = nil, promotion_code : String? = nil, shipping : Stripe::PostCustomersRequestShipping? = nil, source : String? = nil, tax : Stripe::TaxParam? = nil, tax_exempt : String? = nil)
      request = build_api_request_for_post_customers_customer(customer: customer, address: address, balance: balance, bank_account: bank_account, card: card, cash_balance: cash_balance, coupon: coupon, default_alipay_account: default_alipay_account, default_bank_account: default_bank_account, default_card: default_card, default_source: default_source, description: description, email: email, expand: expand, invoice_prefix: invoice_prefix, invoice_settings: invoice_settings, metadata: metadata, name: name, next_invoice_sequence: next_invoice_sequence, phone: phone, preferred_locales: preferred_locales, promotion_code: promotion_code, shipping: shipping, source: source, tax: tax, tax_exempt: tax_exempt)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_customers_customer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Customer.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the specified customer by setting the values of the parameters passed. Any parameters not provided will be left unchanged. For example, if you pass the &lt;strong&gt;source&lt;/strong&gt; parameter, that becomes the customer’s active source (e.g., a card) to be used for all charges in the future. When you update a customer to a new valid card source by passing the &lt;strong&gt;source&lt;/strong&gt; parameter: for each of the customer’s current subscriptions, if the subscription bills automatically and is in the &lt;code&gt;past_due&lt;/code&gt; state, then the latest open invoice for the subscription with automatic collection enabled will be retried. This retry will not count as an automatic retry, and will not affect the next regularly scheduled payment for the invoice. Changing the &lt;strong&gt;default_source&lt;/strong&gt; for a customer will not trigger this behavior.&lt;/p&gt;  &lt;p&gt;This request accepts mostly the same arguments as the customer creation call.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param address [Stripe::PostCustomersRequestAddress?]
    # @optional @param balance [Int64?] An integer amount in cents (or local equivalent) that represents the customer's current balance, which affect the customer's future invoices. A negative amount represents a credit that decreases the amount due on an invoice; a positive amount increases the amount due on an invoice.
    # @optional @param bank_account [Stripe::PostCustomersCustomerRequestBankAccount?]
    # @optional @param card [Stripe::PostChargesRequestCard?]
    # @optional @param cash_balance [Stripe::CashBalanceParam?]
    # @optional @param coupon [String?]
    # @optional @param default_alipay_account [String?] ID of Alipay account to make the customer's new default for invoice payments.
    # @optional @param default_bank_account [String?] ID of bank account to make the customer's new default for invoice payments.
    # @optional @param default_card [String?] ID of card to make the customer's new default for invoice payments.
    # @optional @param default_source [String?] If you are using payment methods created via the PaymentMethods API, see the [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/update#update_customer-invoice_settings-default_payment_method) parameter.  Provide the ID of a payment source already attached to this customer to make it this customer's default payment source.  If you want to add a new payment source and make it the default, see the [source](https://stripe.com/docs/api/customers/update#update_customer-source) property.
    # @optional @param description [String?] An arbitrary string that you can attach to a customer object. It is displayed alongside the customer in the dashboard.
    # @optional @param email [String?] Customer's email address. It's displayed alongside the customer in your dashboard and can be useful for searching and tracking. This may be up to *512 characters*.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_prefix [String?] The prefix for the customer used to generate unique invoice numbers. Must be 3–12 uppercase letters or numbers.
    # @optional @param invoice_settings [Stripe::CustomerParam?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] The customer's full name or business name.
    # @optional @param next_invoice_sequence [Int64?] The sequence to be used on the customer's next invoice. Defaults to 1.
    # @optional @param phone [String?] The customer's phone number.
    # @optional @param preferred_locales [Array(String)?] Customer's preferred languages, ordered by preference.
    # @optional @param promotion_code [String?] The API ID of a promotion code to apply to the customer. The customer will have a discount applied on all recurring payments. Charges you create through the API will not have the discount.
    # @optional @param shipping [Stripe::PostCustomersRequestShipping?]
    # @optional @param source [String?]
    # @optional @param tax [Stripe::TaxParam?]
    # @optional @param tax_exempt [String?] The customer's tax exemption. One of `none`, `exempt`, or `reverse`.
    # @return nil
    def post_customers_customer(*, customer : String? = nil, address : Stripe::PostCustomersRequestAddress? = nil, balance : Int64? = nil, bank_account : Stripe::PostCustomersCustomerRequestBankAccount? = nil, card : Stripe::PostChargesRequestCard? = nil, cash_balance : Stripe::CashBalanceParam? = nil, coupon : String? = nil, default_alipay_account : String? = nil, default_bank_account : String? = nil, default_card : String? = nil, default_source : String? = nil, description : String? = nil, email : String? = nil, expand : Array(String)? = nil, invoice_prefix : String? = nil, invoice_settings : Stripe::CustomerParam? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, next_invoice_sequence : Int64? = nil, phone : String? = nil, preferred_locales : Array(String)? = nil, promotion_code : String? = nil, shipping : Stripe::PostCustomersRequestShipping? = nil, source : String? = nil, tax : Stripe::TaxParam? = nil, tax_exempt : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_customers_customer(customer: customer, address: address, balance: balance, bank_account: bank_account, card: card, cash_balance: cash_balance, coupon: coupon, default_alipay_account: default_alipay_account, default_bank_account: default_bank_account, default_card: default_card, default_source: default_source, description: description, email: email, expand: expand, invoice_prefix: invoice_prefix, invoice_settings: invoice_settings, metadata: metadata, name: name, next_invoice_sequence: next_invoice_sequence, phone: phone, preferred_locales: preferred_locales, promotion_code: promotion_code, shipping: shipping, source: source, tax: tax, tax_exempt: tax_exempt).execute(&block)
    end

    POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_CUSTOMER               = 5000
    POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_COUPON                 = 5000
    POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_DEFAULT_ALIPAY_ACCOUNT =  500
    POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_DEFAULT_BANK_ACCOUNT   =  500
    POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_DEFAULT_CARD           =  500
    POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_DEFAULT_SOURCE         =  500
    POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_DESCRIPTION            = 5000
    POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_EMAIL                  =  512
    POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_INVOICE_PREFIX         = 5000
    POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_NAME                   =  256
    POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_PHONE                  =   20
    POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_PROMOTION_CODE         = 5000
    POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_SOURCE                 = 5000
    POST_CUSTOMERS_CUSTOMER_VALID_VALUES_FOR_TAX_EXEMPT           = StaticArray["", "exempt", "none", "reverse"]

    # @return Crest::Request
    def build_api_request_for_post_customers_customer(*, customer : String? = nil, address : Stripe::PostCustomersRequestAddress? = nil, balance : Int64? = nil, bank_account : Stripe::PostCustomersCustomerRequestBankAccount? = nil, card : Stripe::PostChargesRequestCard? = nil, cash_balance : Stripe::CashBalanceParam? = nil, coupon : String? = nil, default_alipay_account : String? = nil, default_bank_account : String? = nil, default_card : String? = nil, default_source : String? = nil, description : String? = nil, email : String? = nil, expand : Array(String)? = nil, invoice_prefix : String? = nil, invoice_settings : Stripe::CustomerParam? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, next_invoice_sequence : Int64? = nil, phone : String? = nil, preferred_locales : Array(String)? = nil, promotion_code : String? = nil, shipping : Stripe::PostCustomersRequestShipping? = nil, source : String? = nil, tax : Stripe::TaxParam? = nil, tax_exempt : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_customers_customer ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _address = address
          _address.validate if _address.is_a?(OpenApi::Validatable)
        end

        if _bank_account = bank_account
          _bank_account.validate if _bank_account.is_a?(OpenApi::Validatable)
        end
        if _card = card
          _card.validate if _card.is_a?(OpenApi::Validatable)
        end
        if _cash_balance = cash_balance
          _cash_balance.validate if _cash_balance.is_a?(OpenApi::Validatable)
        end
        if _coupon = coupon
          OpenApi::PrimitiveValidator.validate_max_length("coupon", coupon.to_s.size, POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_COUPON)
        end
        if _default_alipay_account = default_alipay_account
          OpenApi::PrimitiveValidator.validate_max_length("default_alipay_account", default_alipay_account.to_s.size, POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_DEFAULT_ALIPAY_ACCOUNT)
        end
        if _default_bank_account = default_bank_account
          OpenApi::PrimitiveValidator.validate_max_length("default_bank_account", default_bank_account.to_s.size, POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_DEFAULT_BANK_ACCOUNT)
        end
        if _default_card = default_card
          OpenApi::PrimitiveValidator.validate_max_length("default_card", default_card.to_s.size, POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_DEFAULT_CARD)
        end
        if _default_source = default_source
          OpenApi::PrimitiveValidator.validate_max_length("default_source", default_source.to_s.size, POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_DEFAULT_SOURCE)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_DESCRIPTION)
        end
        if _email = email
          OpenApi::PrimitiveValidator.validate_max_length("email", email.to_s.size, POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_EMAIL)
        end

        if _invoice_prefix = invoice_prefix
          OpenApi::PrimitiveValidator.validate_max_length("invoice_prefix", invoice_prefix.to_s.size, POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_INVOICE_PREFIX)
        end
        if _invoice_settings = invoice_settings
          _invoice_settings.validate if _invoice_settings.is_a?(OpenApi::Validatable)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _name = name
          OpenApi::PrimitiveValidator.validate_max_length("name", name.to_s.size, POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_NAME)
        end

        if _phone = phone
          OpenApi::PrimitiveValidator.validate_max_length("phone", phone.to_s.size, POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_PHONE)
        end

        if _promotion_code = promotion_code
          OpenApi::PrimitiveValidator.validate_max_length("promotion_code", promotion_code.to_s.size, POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_PROMOTION_CODE)
        end
        if _shipping = shipping
          _shipping.validate if _shipping.is_a?(OpenApi::Validatable)
        end
        if _source = source
          OpenApi::PrimitiveValidator.validate_max_length("source", source.to_s.size, POST_CUSTOMERS_CUSTOMER_MAX_LENGTH_FOR_SOURCE)
        end
        if _tax = tax
          _tax.validate if _tax.is_a?(OpenApi::Validatable)
        end
        if _tax_exempt = tax_exempt
          OpenApi::EnumValidator.validate("tax_exempt", _tax_exempt, POST_CUSTOMERS_CUSTOMER_VALID_VALUES_FOR_TAX_EXEMPT)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["address"] = address.to_s if !address.nil?
      form_params["balance"] = balance.to_s if !balance.nil?
      form_params["bank_account"] = bank_account.to_s if !bank_account.nil?
      form_params["card"] = card.to_s if !card.nil?
      form_params["cash_balance"] = cash_balance.to_s if !cash_balance.nil?
      form_params["coupon"] = coupon.to_s if !coupon.nil?
      form_params["default_alipay_account"] = default_alipay_account.to_s if !default_alipay_account.nil?
      form_params["default_bank_account"] = default_bank_account.to_s if !default_bank_account.nil?
      form_params["default_card"] = default_card.to_s if !default_card.nil?
      form_params["default_source"] = default_source.to_s if !default_source.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["email"] = email.to_s if !email.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["invoice_prefix"] = invoice_prefix.to_s if !invoice_prefix.nil?
      form_params["invoice_settings"] = invoice_settings.to_s if !invoice_settings.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["name"] = name.to_s if !name.nil?
      form_params["next_invoice_sequence"] = next_invoice_sequence.to_s if !next_invoice_sequence.nil?
      form_params["phone"] = phone.to_s if !phone.nil?
      form_params["preferred_locales"] = @api_client.build_collection_param(preferred_locales, "csv") if !preferred_locales.nil? && !preferred_locales.empty?
      form_params["promotion_code"] = promotion_code.to_s if !promotion_code.nil?
      form_params["shipping"] = shipping.to_s if !shipping.nil?
      form_params["source"] = source.to_s if !source.nil?
      form_params["tax"] = tax.to_s if !tax.nil?
      form_params["tax_exempt"] = tax_exempt.to_s if !tax_exempt.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_customers_customer",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates an immutable transaction that updates the customer’s credit <a href=\"/docs/billing/customer/balance\">balance</a>.</p>
    # @param customer [String?]
    # @param amount [Int64?] The integer amount in **cents (or local equivalent)** to apply to the customer's credit balance.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies). If the customer's [`currency`](https://stripe.com/docs/api/customers/object#customer_object-currency) is set, this value must match it. If the customer's `currency` is not set, it will be updated to this value.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [CustomerBalanceTransaction]
    def post_customers_customer_balance_transactions(*, customer : String? = nil, amount : Int64? = nil, currency : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_customers_customer_balance_transactions_with_http_info(customer: customer, amount: amount, currency: currency, description: description, expand: expand, metadata: metadata)
      data
    end

    # &lt;p&gt;Creates an immutable transaction that updates the customer’s credit &lt;a href&#x3D;\&quot;/docs/billing/customer/balance\&quot;&gt;balance&lt;/a&gt;.&lt;/p&gt;
    # @param customer [String?]
    # @param amount [Int64?] The integer amount in **cents (or local equivalent)** to apply to the customer's credit balance.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies). If the customer's [`currency`](https://stripe.com/docs/api/customers/object#customer_object-currency) is set, this value must match it. If the customer's `currency` is not set, it will be updated to this value.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(CustomerBalanceTransaction, Integer, Hash)>] CustomerBalanceTransaction data, response status code and response headers
    def post_customers_customer_balance_transactions_with_http_info(*, customer : String? = nil, amount : Int64? = nil, currency : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_customers_customer_balance_transactions(customer: customer, amount: amount, currency: currency, description: description, expand: expand, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_customers_customer_balance_transactions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CustomerBalanceTransaction.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates an immutable transaction that updates the customer’s credit &lt;a href&#x3D;\&quot;/docs/billing/customer/balance\&quot;&gt;balance&lt;/a&gt;.&lt;/p&gt;
    # @param customer [String?]
    # @param amount [Int64?] The integer amount in **cents (or local equivalent)** to apply to the customer's credit balance.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies). If the customer's [`currency`](https://stripe.com/docs/api/customers/object#customer_object-currency) is set, this value must match it. If the customer's `currency` is not set, it will be updated to this value.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_customers_customer_balance_transactions(*, customer : String? = nil, amount : Int64? = nil, currency : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_customers_customer_balance_transactions(customer: customer, amount: amount, currency: currency, description: description, expand: expand, metadata: metadata).execute(&block)
    end

    POST_CUSTOMERS_CUSTOMER_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_CUSTOMER    = 5000
    POST_CUSTOMERS_CUSTOMER_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_DESCRIPTION =  350

    # @return Crest::Request
    def build_api_request_for_post_customers_customer_balance_transactions(*, customer : String? = nil, amount : Int64? = nil, currency : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_customers_customer_balance_transactions ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_CUSTOMERS_CUSTOMER_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"amount\" is required and cannot be null") if amount.nil?

        raise ArgumentError.new("\"currency\" is required and cannot be null") if currency.nil?

        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_CUSTOMERS_CUSTOMER_BALANCE_TRANSACTIONS_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/balance_transactions".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_customers_customer_balance_transactions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Most credit balance transaction fields are immutable, but you may update its <code>description</code> and <code>metadata</code>.</p>
    # @param customer [String?]
    # @param transaction [String?]
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [CustomerBalanceTransaction]
    def post_customers_customer_balance_transactions_transaction(*, customer : String? = nil, transaction : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_customers_customer_balance_transactions_transaction_with_http_info(customer: customer, transaction: transaction, description: description, expand: expand, metadata: metadata)
      data
    end

    # &lt;p&gt;Most credit balance transaction fields are immutable, but you may update its &lt;code&gt;description&lt;/code&gt; and &lt;code&gt;metadata&lt;/code&gt;.&lt;/p&gt;
    # @param customer [String?]
    # @param transaction [String?]
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(CustomerBalanceTransaction, Integer, Hash)>] CustomerBalanceTransaction data, response status code and response headers
    def post_customers_customer_balance_transactions_transaction_with_http_info(*, customer : String? = nil, transaction : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_customers_customer_balance_transactions_transaction(customer: customer, transaction: transaction, description: description, expand: expand, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_customers_customer_balance_transactions_transaction\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CustomerBalanceTransaction.from_json(data), status_code, headers
    end

    # &lt;p&gt;Most credit balance transaction fields are immutable, but you may update its &lt;code&gt;description&lt;/code&gt; and &lt;code&gt;metadata&lt;/code&gt;.&lt;/p&gt;
    # @param customer [String?]
    # @param transaction [String?]
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_customers_customer_balance_transactions_transaction(*, customer : String? = nil, transaction : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_customers_customer_balance_transactions_transaction(customer: customer, transaction: transaction, description: description, expand: expand, metadata: metadata).execute(&block)
    end

    POST_CUSTOMERS_CUSTOMER_BALANCE_TRANSACTIONS_TRANSACTION_MAX_LENGTH_FOR_CUSTOMER    = 5000
    POST_CUSTOMERS_CUSTOMER_BALANCE_TRANSACTIONS_TRANSACTION_MAX_LENGTH_FOR_TRANSACTION = 5000
    POST_CUSTOMERS_CUSTOMER_BALANCE_TRANSACTIONS_TRANSACTION_MAX_LENGTH_FOR_DESCRIPTION =  350

    # @return Crest::Request
    def build_api_request_for_post_customers_customer_balance_transactions_transaction(*, customer : String? = nil, transaction : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_customers_customer_balance_transactions_transaction ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_CUSTOMERS_CUSTOMER_BALANCE_TRANSACTIONS_TRANSACTION_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"transaction\" is required and cannot be null") if transaction.nil?
        if _transaction = transaction
          OpenApi::PrimitiveValidator.validate_max_length("transaction", transaction.to_s.size, POST_CUSTOMERS_CUSTOMER_BALANCE_TRANSACTIONS_TRANSACTION_MAX_LENGTH_FOR_TRANSACTION)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_CUSTOMERS_CUSTOMER_BALANCE_TRANSACTIONS_TRANSACTION_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/balance_transactions/{transaction}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "transaction" + "}", URI.encode_path(transaction.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["description"] = description.to_s if !description.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_customers_customer_balance_transactions_transaction",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>When you create a new credit card, you must specify a customer or recipient on which to create it.</p>  <p>If the card’s owner has no default card, then the new card will become the default. However, if the owner already has a default, then it will not change. To change the default, you should <a href=\"/docs/api#update_customer\">update the customer</a> to have a new <code>default_source</code>.</p>
    # @param customer [String?]
    # @optional @param alipay_account [String?] A token returned by [Stripe.js](https://stripe.com/docs/js) representing the user’s Alipay account details.
    # @optional @param bank_account [Stripe::PostCustomersCustomerRequestBankAccount?]
    # @optional @param card [Stripe::PostChargesRequestCard?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param source [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return [PaymentSource]
    def post_customers_customer_bank_accounts(*, customer : String? = nil, alipay_account : String? = nil, bank_account : Stripe::PostCustomersCustomerRequestBankAccount? = nil, card : Stripe::PostChargesRequestCard? = nil, expand : Array(String)? = nil, source : String? = nil)
      data, _status_code, _headers = post_customers_customer_bank_accounts_with_http_info(customer: customer, alipay_account: alipay_account, bank_account: bank_account, card: card, expand: expand, source: source)
      data
    end

    # &lt;p&gt;When you create a new credit card, you must specify a customer or recipient on which to create it.&lt;/p&gt;  &lt;p&gt;If the card’s owner has no default card, then the new card will become the default. However, if the owner already has a default, then it will not change. To change the default, you should &lt;a href&#x3D;\&quot;/docs/api#update_customer\&quot;&gt;update the customer&lt;/a&gt; to have a new &lt;code&gt;default_source&lt;/code&gt;.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param alipay_account [String?] A token returned by [Stripe.js](https://stripe.com/docs/js) representing the user’s Alipay account details.
    # @optional @param bank_account [Stripe::PostCustomersCustomerRequestBankAccount?]
    # @optional @param card [Stripe::PostChargesRequestCard?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param source [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return [Array<(PaymentSource, Integer, Hash)>] PaymentSource data, response status code and response headers
    def post_customers_customer_bank_accounts_with_http_info(*, customer : String? = nil, alipay_account : String? = nil, bank_account : Stripe::PostCustomersCustomerRequestBankAccount? = nil, card : Stripe::PostChargesRequestCard? = nil, expand : Array(String)? = nil, source : String? = nil)
      request = build_api_request_for_post_customers_customer_bank_accounts(customer: customer, alipay_account: alipay_account, bank_account: bank_account, card: card, expand: expand, source: source)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_customers_customer_bank_accounts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentSource.from_json(data), status_code, headers
    end

    # &lt;p&gt;When you create a new credit card, you must specify a customer or recipient on which to create it.&lt;/p&gt;  &lt;p&gt;If the card’s owner has no default card, then the new card will become the default. However, if the owner already has a default, then it will not change. To change the default, you should &lt;a href&#x3D;\&quot;/docs/api#update_customer\&quot;&gt;update the customer&lt;/a&gt; to have a new &lt;code&gt;default_source&lt;/code&gt;.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param alipay_account [String?] A token returned by [Stripe.js](https://stripe.com/docs/js) representing the user’s Alipay account details.
    # @optional @param bank_account [Stripe::PostCustomersCustomerRequestBankAccount?]
    # @optional @param card [Stripe::PostChargesRequestCard?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param source [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return nil
    def post_customers_customer_bank_accounts(*, customer : String? = nil, alipay_account : String? = nil, bank_account : Stripe::PostCustomersCustomerRequestBankAccount? = nil, card : Stripe::PostChargesRequestCard? = nil, expand : Array(String)? = nil, source : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_customers_customer_bank_accounts(customer: customer, alipay_account: alipay_account, bank_account: bank_account, card: card, expand: expand, source: source).execute(&block)
    end

    POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_MAX_LENGTH_FOR_CUSTOMER       = 5000
    POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_MAX_LENGTH_FOR_ALIPAY_ACCOUNT = 5000
    POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_MAX_LENGTH_FOR_SOURCE         = 5000

    # @return Crest::Request
    def build_api_request_for_post_customers_customer_bank_accounts(*, customer : String? = nil, alipay_account : String? = nil, bank_account : Stripe::PostCustomersCustomerRequestBankAccount? = nil, card : Stripe::PostChargesRequestCard? = nil, expand : Array(String)? = nil, source : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_customers_customer_bank_accounts ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _alipay_account = alipay_account
          OpenApi::PrimitiveValidator.validate_max_length("alipay_account", alipay_account.to_s.size, POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_MAX_LENGTH_FOR_ALIPAY_ACCOUNT)
        end
        if _bank_account = bank_account
          _bank_account.validate if _bank_account.is_a?(OpenApi::Validatable)
        end
        if _card = card
          _card.validate if _card.is_a?(OpenApi::Validatable)
        end

        if _source = source
          OpenApi::PrimitiveValidator.validate_max_length("source", source.to_s.size, POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_MAX_LENGTH_FOR_SOURCE)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/bank_accounts".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["alipay_account"] = alipay_account.to_s if !alipay_account.nil?
      form_params["bank_account"] = bank_account.to_s if !bank_account.nil?
      form_params["card"] = card.to_s if !card.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["source"] = source.to_s if !source.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_customers_customer_bank_accounts",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Update a specified source for a given customer.</p>
    # @param customer [String?]
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @optional @param owner [Stripe::Owner?]
    # @return [PostCustomersCustomerBankAccountsId200Response]
    def post_customers_customer_bank_accounts_id(*, customer : String? = nil, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, owner : Stripe::Owner? = nil)
      data, _status_code, _headers = post_customers_customer_bank_accounts_id_with_http_info(customer: customer, id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name, owner: owner)
      data
    end

    # &lt;p&gt;Update a specified source for a given customer.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @optional @param owner [Stripe::Owner?]
    # @return [Array<(PostCustomersCustomerBankAccountsId200Response, Integer, Hash)>] PostCustomersCustomerBankAccountsId200Response data, response status code and response headers
    def post_customers_customer_bank_accounts_id_with_http_info(*, customer : String? = nil, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, owner : Stripe::Owner? = nil)
      request = build_api_request_for_post_customers_customer_bank_accounts_id(customer: customer, id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name, owner: owner)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_customers_customer_bank_accounts_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PostCustomersCustomerBankAccountsId200Response.from_json(data), status_code, headers
    end

    # &lt;p&gt;Update a specified source for a given customer.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @optional @param owner [Stripe::Owner?]
    # @return nil
    def post_customers_customer_bank_accounts_id(*, customer : String? = nil, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, owner : Stripe::Owner? = nil, &block : Crest::Response ->)
      build_api_request_for_post_customers_customer_bank_accounts_id(customer: customer, id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name, owner: owner).execute(&block)
    end

    POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_CUSTOMER              = 5000
    POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ID                    = 5000
    POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_NAME   = 5000
    POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_TYPE   = 5000
    POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_VALID_VALUES_FOR_ACCOUNT_HOLDER_TYPE = StaticArray["company", "individual"]
    POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_CITY          = 5000
    POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_COUNTRY       = 5000
    POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_LINE1         = 5000
    POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_LINE2         = 5000
    POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_STATE         = 5000
    POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_ZIP           = 5000
    POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_EXP_MONTH             = 5000
    POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_EXP_YEAR              = 5000
    POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_NAME                  = 5000

    # @return Crest::Request
    def build_api_request_for_post_customers_customer_bank_accounts_id(*, customer : String? = nil, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, owner : Stripe::Owner? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_customers_customer_bank_accounts_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ID)
        end
        if _account_holder_name = account_holder_name
          OpenApi::PrimitiveValidator.validate_max_length("account_holder_name", account_holder_name.to_s.size, POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_NAME)
        end
        if _account_holder_type = account_holder_type
          OpenApi::EnumValidator.validate("account_holder_type", _account_holder_type, POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_VALID_VALUES_FOR_ACCOUNT_HOLDER_TYPE)
        end
        if _address_city = address_city
          OpenApi::PrimitiveValidator.validate_max_length("address_city", address_city.to_s.size, POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_CITY)
        end
        if _address_country = address_country
          OpenApi::PrimitiveValidator.validate_max_length("address_country", address_country.to_s.size, POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_COUNTRY)
        end
        if _address_line1 = address_line1
          OpenApi::PrimitiveValidator.validate_max_length("address_line1", address_line1.to_s.size, POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_LINE1)
        end
        if _address_line2 = address_line2
          OpenApi::PrimitiveValidator.validate_max_length("address_line2", address_line2.to_s.size, POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_LINE2)
        end
        if _address_state = address_state
          OpenApi::PrimitiveValidator.validate_max_length("address_state", address_state.to_s.size, POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_STATE)
        end
        if _address_zip = address_zip
          OpenApi::PrimitiveValidator.validate_max_length("address_zip", address_zip.to_s.size, POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_ADDRESS_ZIP)
        end
        if _exp_month = exp_month
          OpenApi::PrimitiveValidator.validate_max_length("exp_month", exp_month.to_s.size, POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_EXP_MONTH)
        end
        if _exp_year = exp_year
          OpenApi::PrimitiveValidator.validate_max_length("exp_year", exp_year.to_s.size, POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_EXP_YEAR)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _name = name
          OpenApi::PrimitiveValidator.validate_max_length("name", name.to_s.size, POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_MAX_LENGTH_FOR_NAME)
        end
        if _owner = owner
          _owner.validate if _owner.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/bank_accounts/{id}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account_holder_name"] = account_holder_name.to_s if !account_holder_name.nil?
      form_params["account_holder_type"] = account_holder_type.to_s if !account_holder_type.nil?
      form_params["address_city"] = address_city.to_s if !address_city.nil?
      form_params["address_country"] = address_country.to_s if !address_country.nil?
      form_params["address_line1"] = address_line1.to_s if !address_line1.nil?
      form_params["address_line2"] = address_line2.to_s if !address_line2.nil?
      form_params["address_state"] = address_state.to_s if !address_state.nil?
      form_params["address_zip"] = address_zip.to_s if !address_zip.nil?
      form_params["exp_month"] = exp_month.to_s if !exp_month.nil?
      form_params["exp_year"] = exp_year.to_s if !exp_year.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["name"] = name.to_s if !name.nil?
      form_params["owner"] = owner.to_s if !owner.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_customers_customer_bank_accounts_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Verify a specified bank account for a given customer.</p>
    # @param customer [String?]
    # @param id [String?]
    # @optional @param amounts [Array(Int64)?] Two positive integers, in *cents*, equal to the values of the microdeposits sent to the bank account.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [BankAccount]
    def post_customers_customer_bank_accounts_id_verify(*, customer : String? = nil, id : String? = nil, amounts : Array(Int64)? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_customers_customer_bank_accounts_id_verify_with_http_info(customer: customer, id: id, amounts: amounts, expand: expand)
      data
    end

    # &lt;p&gt;Verify a specified bank account for a given customer.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param amounts [Array(Int64)?] Two positive integers, in *cents*, equal to the values of the microdeposits sent to the bank account.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(BankAccount, Integer, Hash)>] BankAccount data, response status code and response headers
    def post_customers_customer_bank_accounts_id_verify_with_http_info(*, customer : String? = nil, id : String? = nil, amounts : Array(Int64)? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_customers_customer_bank_accounts_id_verify(customer: customer, id: id, amounts: amounts, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_customers_customer_bank_accounts_id_verify\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return BankAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Verify a specified bank account for a given customer.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param amounts [Array(Int64)?] Two positive integers, in *cents*, equal to the values of the microdeposits sent to the bank account.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_customers_customer_bank_accounts_id_verify(*, customer : String? = nil, id : String? = nil, amounts : Array(Int64)? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_customers_customer_bank_accounts_id_verify(customer: customer, id: id, amounts: amounts, expand: expand).execute(&block)
    end

    POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_VERIFY_MAX_LENGTH_FOR_CUSTOMER = 5000
    POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_VERIFY_MAX_LENGTH_FOR_ID       = 5000

    # @return Crest::Request
    def build_api_request_for_post_customers_customer_bank_accounts_id_verify(*, customer : String? = nil, id : String? = nil, amounts : Array(Int64)? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_customers_customer_bank_accounts_id_verify ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_VERIFY_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_CUSTOMERS_CUSTOMER_BANK_ACCOUNTS_ID_VERIFY_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/bank_accounts/{id}/verify".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amounts"] = @api_client.build_collection_param(amounts, "csv") if !amounts.nil? && !amounts.empty?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_customers_customer_bank_accounts_id_verify",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>When you create a new credit card, you must specify a customer or recipient on which to create it.</p>  <p>If the card’s owner has no default card, then the new card will become the default. However, if the owner already has a default, then it will not change. To change the default, you should <a href=\"/docs/api#update_customer\">update the customer</a> to have a new <code>default_source</code>.</p>
    # @param customer [String?]
    # @optional @param alipay_account [String?] A token returned by [Stripe.js](https://stripe.com/docs/js) representing the user’s Alipay account details.
    # @optional @param bank_account [Stripe::PostCustomersCustomerRequestBankAccount?]
    # @optional @param card [Stripe::PostChargesRequestCard?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param source [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return [PaymentSource]
    def post_customers_customer_cards(*, customer : String? = nil, alipay_account : String? = nil, bank_account : Stripe::PostCustomersCustomerRequestBankAccount? = nil, card : Stripe::PostChargesRequestCard? = nil, expand : Array(String)? = nil, source : String? = nil)
      data, _status_code, _headers = post_customers_customer_cards_with_http_info(customer: customer, alipay_account: alipay_account, bank_account: bank_account, card: card, expand: expand, source: source)
      data
    end

    # &lt;p&gt;When you create a new credit card, you must specify a customer or recipient on which to create it.&lt;/p&gt;  &lt;p&gt;If the card’s owner has no default card, then the new card will become the default. However, if the owner already has a default, then it will not change. To change the default, you should &lt;a href&#x3D;\&quot;/docs/api#update_customer\&quot;&gt;update the customer&lt;/a&gt; to have a new &lt;code&gt;default_source&lt;/code&gt;.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param alipay_account [String?] A token returned by [Stripe.js](https://stripe.com/docs/js) representing the user’s Alipay account details.
    # @optional @param bank_account [Stripe::PostCustomersCustomerRequestBankAccount?]
    # @optional @param card [Stripe::PostChargesRequestCard?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param source [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return [Array<(PaymentSource, Integer, Hash)>] PaymentSource data, response status code and response headers
    def post_customers_customer_cards_with_http_info(*, customer : String? = nil, alipay_account : String? = nil, bank_account : Stripe::PostCustomersCustomerRequestBankAccount? = nil, card : Stripe::PostChargesRequestCard? = nil, expand : Array(String)? = nil, source : String? = nil)
      request = build_api_request_for_post_customers_customer_cards(customer: customer, alipay_account: alipay_account, bank_account: bank_account, card: card, expand: expand, source: source)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_customers_customer_cards\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentSource.from_json(data), status_code, headers
    end

    # &lt;p&gt;When you create a new credit card, you must specify a customer or recipient on which to create it.&lt;/p&gt;  &lt;p&gt;If the card’s owner has no default card, then the new card will become the default. However, if the owner already has a default, then it will not change. To change the default, you should &lt;a href&#x3D;\&quot;/docs/api#update_customer\&quot;&gt;update the customer&lt;/a&gt; to have a new &lt;code&gt;default_source&lt;/code&gt;.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param alipay_account [String?] A token returned by [Stripe.js](https://stripe.com/docs/js) representing the user’s Alipay account details.
    # @optional @param bank_account [Stripe::PostCustomersCustomerRequestBankAccount?]
    # @optional @param card [Stripe::PostChargesRequestCard?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param source [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return nil
    def post_customers_customer_cards(*, customer : String? = nil, alipay_account : String? = nil, bank_account : Stripe::PostCustomersCustomerRequestBankAccount? = nil, card : Stripe::PostChargesRequestCard? = nil, expand : Array(String)? = nil, source : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_customers_customer_cards(customer: customer, alipay_account: alipay_account, bank_account: bank_account, card: card, expand: expand, source: source).execute(&block)
    end

    POST_CUSTOMERS_CUSTOMER_CARDS_MAX_LENGTH_FOR_CUSTOMER       = 5000
    POST_CUSTOMERS_CUSTOMER_CARDS_MAX_LENGTH_FOR_ALIPAY_ACCOUNT = 5000
    POST_CUSTOMERS_CUSTOMER_CARDS_MAX_LENGTH_FOR_SOURCE         = 5000

    # @return Crest::Request
    def build_api_request_for_post_customers_customer_cards(*, customer : String? = nil, alipay_account : String? = nil, bank_account : Stripe::PostCustomersCustomerRequestBankAccount? = nil, card : Stripe::PostChargesRequestCard? = nil, expand : Array(String)? = nil, source : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_customers_customer_cards ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_CUSTOMERS_CUSTOMER_CARDS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _alipay_account = alipay_account
          OpenApi::PrimitiveValidator.validate_max_length("alipay_account", alipay_account.to_s.size, POST_CUSTOMERS_CUSTOMER_CARDS_MAX_LENGTH_FOR_ALIPAY_ACCOUNT)
        end
        if _bank_account = bank_account
          _bank_account.validate if _bank_account.is_a?(OpenApi::Validatable)
        end
        if _card = card
          _card.validate if _card.is_a?(OpenApi::Validatable)
        end

        if _source = source
          OpenApi::PrimitiveValidator.validate_max_length("source", source.to_s.size, POST_CUSTOMERS_CUSTOMER_CARDS_MAX_LENGTH_FOR_SOURCE)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/cards".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["alipay_account"] = alipay_account.to_s if !alipay_account.nil?
      form_params["bank_account"] = bank_account.to_s if !bank_account.nil?
      form_params["card"] = card.to_s if !card.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["source"] = source.to_s if !source.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_customers_customer_cards",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Update a specified source for a given customer.</p>
    # @param customer [String?]
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @optional @param owner [Stripe::Owner?]
    # @return [PostCustomersCustomerBankAccountsId200Response]
    def post_customers_customer_cards_id(*, customer : String? = nil, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, owner : Stripe::Owner? = nil)
      data, _status_code, _headers = post_customers_customer_cards_id_with_http_info(customer: customer, id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name, owner: owner)
      data
    end

    # &lt;p&gt;Update a specified source for a given customer.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @optional @param owner [Stripe::Owner?]
    # @return [Array<(PostCustomersCustomerBankAccountsId200Response, Integer, Hash)>] PostCustomersCustomerBankAccountsId200Response data, response status code and response headers
    def post_customers_customer_cards_id_with_http_info(*, customer : String? = nil, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, owner : Stripe::Owner? = nil)
      request = build_api_request_for_post_customers_customer_cards_id(customer: customer, id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name, owner: owner)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_customers_customer_cards_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PostCustomersCustomerBankAccountsId200Response.from_json(data), status_code, headers
    end

    # &lt;p&gt;Update a specified source for a given customer.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @optional @param owner [Stripe::Owner?]
    # @return nil
    def post_customers_customer_cards_id(*, customer : String? = nil, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, owner : Stripe::Owner? = nil, &block : Crest::Response ->)
      build_api_request_for_post_customers_customer_cards_id(customer: customer, id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name, owner: owner).execute(&block)
    end

    POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_CUSTOMER              = 5000
    POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_ID                    = 5000
    POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_NAME   = 5000
    POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_TYPE   = 5000
    POST_CUSTOMERS_CUSTOMER_CARDS_ID_VALID_VALUES_FOR_ACCOUNT_HOLDER_TYPE = StaticArray["company", "individual"]
    POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_ADDRESS_CITY          = 5000
    POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_ADDRESS_COUNTRY       = 5000
    POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_ADDRESS_LINE1         = 5000
    POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_ADDRESS_LINE2         = 5000
    POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_ADDRESS_STATE         = 5000
    POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_ADDRESS_ZIP           = 5000
    POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_EXP_MONTH             = 5000
    POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_EXP_YEAR              = 5000
    POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_NAME                  = 5000

    # @return Crest::Request
    def build_api_request_for_post_customers_customer_cards_id(*, customer : String? = nil, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, owner : Stripe::Owner? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_customers_customer_cards_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_ID)
        end
        if _account_holder_name = account_holder_name
          OpenApi::PrimitiveValidator.validate_max_length("account_holder_name", account_holder_name.to_s.size, POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_NAME)
        end
        if _account_holder_type = account_holder_type
          OpenApi::EnumValidator.validate("account_holder_type", _account_holder_type, POST_CUSTOMERS_CUSTOMER_CARDS_ID_VALID_VALUES_FOR_ACCOUNT_HOLDER_TYPE)
        end
        if _address_city = address_city
          OpenApi::PrimitiveValidator.validate_max_length("address_city", address_city.to_s.size, POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_ADDRESS_CITY)
        end
        if _address_country = address_country
          OpenApi::PrimitiveValidator.validate_max_length("address_country", address_country.to_s.size, POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_ADDRESS_COUNTRY)
        end
        if _address_line1 = address_line1
          OpenApi::PrimitiveValidator.validate_max_length("address_line1", address_line1.to_s.size, POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_ADDRESS_LINE1)
        end
        if _address_line2 = address_line2
          OpenApi::PrimitiveValidator.validate_max_length("address_line2", address_line2.to_s.size, POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_ADDRESS_LINE2)
        end
        if _address_state = address_state
          OpenApi::PrimitiveValidator.validate_max_length("address_state", address_state.to_s.size, POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_ADDRESS_STATE)
        end
        if _address_zip = address_zip
          OpenApi::PrimitiveValidator.validate_max_length("address_zip", address_zip.to_s.size, POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_ADDRESS_ZIP)
        end
        if _exp_month = exp_month
          OpenApi::PrimitiveValidator.validate_max_length("exp_month", exp_month.to_s.size, POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_EXP_MONTH)
        end
        if _exp_year = exp_year
          OpenApi::PrimitiveValidator.validate_max_length("exp_year", exp_year.to_s.size, POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_EXP_YEAR)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _name = name
          OpenApi::PrimitiveValidator.validate_max_length("name", name.to_s.size, POST_CUSTOMERS_CUSTOMER_CARDS_ID_MAX_LENGTH_FOR_NAME)
        end
        if _owner = owner
          _owner.validate if _owner.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/cards/{id}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account_holder_name"] = account_holder_name.to_s if !account_holder_name.nil?
      form_params["account_holder_type"] = account_holder_type.to_s if !account_holder_type.nil?
      form_params["address_city"] = address_city.to_s if !address_city.nil?
      form_params["address_country"] = address_country.to_s if !address_country.nil?
      form_params["address_line1"] = address_line1.to_s if !address_line1.nil?
      form_params["address_line2"] = address_line2.to_s if !address_line2.nil?
      form_params["address_state"] = address_state.to_s if !address_state.nil?
      form_params["address_zip"] = address_zip.to_s if !address_zip.nil?
      form_params["exp_month"] = exp_month.to_s if !exp_month.nil?
      form_params["exp_year"] = exp_year.to_s if !exp_year.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["name"] = name.to_s if !name.nil?
      form_params["owner"] = owner.to_s if !owner.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_customers_customer_cards_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Changes the settings on a customer’s cash balance.</p>
    # @param customer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param settings [Stripe::BalanceSettingsParam1?]
    # @return [CashBalance]
    def post_customers_customer_cash_balance(*, customer : String? = nil, expand : Array(String)? = nil, settings : Stripe::BalanceSettingsParam1? = nil)
      data, _status_code, _headers = post_customers_customer_cash_balance_with_http_info(customer: customer, expand: expand, settings: settings)
      data
    end

    # &lt;p&gt;Changes the settings on a customer’s cash balance.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param settings [Stripe::BalanceSettingsParam1?]
    # @return [Array<(CashBalance, Integer, Hash)>] CashBalance data, response status code and response headers
    def post_customers_customer_cash_balance_with_http_info(*, customer : String? = nil, expand : Array(String)? = nil, settings : Stripe::BalanceSettingsParam1? = nil)
      request = build_api_request_for_post_customers_customer_cash_balance(customer: customer, expand: expand, settings: settings)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_customers_customer_cash_balance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CashBalance.from_json(data), status_code, headers
    end

    # &lt;p&gt;Changes the settings on a customer’s cash balance.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param settings [Stripe::BalanceSettingsParam1?]
    # @return nil
    def post_customers_customer_cash_balance(*, customer : String? = nil, expand : Array(String)? = nil, settings : Stripe::BalanceSettingsParam1? = nil, &block : Crest::Response ->)
      build_api_request_for_post_customers_customer_cash_balance(customer: customer, expand: expand, settings: settings).execute(&block)
    end

    POST_CUSTOMERS_CUSTOMER_CASH_BALANCE_MAX_LENGTH_FOR_CUSTOMER = 5000

    # @return Crest::Request
    def build_api_request_for_post_customers_customer_cash_balance(*, customer : String? = nil, expand : Array(String)? = nil, settings : Stripe::BalanceSettingsParam1? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_customers_customer_cash_balance ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_CUSTOMERS_CUSTOMER_CASH_BALANCE_MAX_LENGTH_FOR_CUSTOMER)
        end

        if _settings = settings
          _settings.validate if _settings.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/cash_balance".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["settings"] = settings.to_s if !settings.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_customers_customer_cash_balance",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieve funding instructions for a customer cash balance. If funding instructions do not yet exist for the customer, new funding instructions will be created. If funding instructions have already been created for a given customer, the same funding instructions will be retrieved. In other words, we will return the same funding instructions each time.</p>
    # @param customer [String?]
    # @param bank_transfer [Stripe::BankTransferParams?]
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param funding_type [String?] The `funding_type` to get the instructions for.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [FundingInstructions]
    def post_customers_customer_funding_instructions(*, customer : String? = nil, bank_transfer : Stripe::BankTransferParams? = nil, currency : String? = nil, funding_type : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_customers_customer_funding_instructions_with_http_info(customer: customer, bank_transfer: bank_transfer, currency: currency, funding_type: funding_type, expand: expand)
      data
    end

    # &lt;p&gt;Retrieve funding instructions for a customer cash balance. If funding instructions do not yet exist for the customer, new funding instructions will be created. If funding instructions have already been created for a given customer, the same funding instructions will be retrieved. In other words, we will return the same funding instructions each time.&lt;/p&gt;
    # @param customer [String?]
    # @param bank_transfer [Stripe::BankTransferParams?]
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param funding_type [String?] The `funding_type` to get the instructions for.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(FundingInstructions, Integer, Hash)>] FundingInstructions data, response status code and response headers
    def post_customers_customer_funding_instructions_with_http_info(*, customer : String? = nil, bank_transfer : Stripe::BankTransferParams? = nil, currency : String? = nil, funding_type : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_customers_customer_funding_instructions(customer: customer, bank_transfer: bank_transfer, currency: currency, funding_type: funding_type, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_customers_customer_funding_instructions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FundingInstructions.from_json(data), status_code, headers
    end

    # &lt;p&gt;Retrieve funding instructions for a customer cash balance. If funding instructions do not yet exist for the customer, new funding instructions will be created. If funding instructions have already been created for a given customer, the same funding instructions will be retrieved. In other words, we will return the same funding instructions each time.&lt;/p&gt;
    # @param customer [String?]
    # @param bank_transfer [Stripe::BankTransferParams?]
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param funding_type [String?] The `funding_type` to get the instructions for.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_customers_customer_funding_instructions(*, customer : String? = nil, bank_transfer : Stripe::BankTransferParams? = nil, currency : String? = nil, funding_type : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_customers_customer_funding_instructions(customer: customer, bank_transfer: bank_transfer, currency: currency, funding_type: funding_type, expand: expand).execute(&block)
    end

    POST_CUSTOMERS_CUSTOMER_FUNDING_INSTRUCTIONS_MAX_LENGTH_FOR_CUSTOMER       = 5000
    POST_CUSTOMERS_CUSTOMER_FUNDING_INSTRUCTIONS_VALID_VALUES_FOR_FUNDING_TYPE = StaticArray["bank_transfer"]

    # @return Crest::Request
    def build_api_request_for_post_customers_customer_funding_instructions(*, customer : String? = nil, bank_transfer : Stripe::BankTransferParams? = nil, currency : String? = nil, funding_type : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_customers_customer_funding_instructions ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_CUSTOMERS_CUSTOMER_FUNDING_INSTRUCTIONS_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"bank_transfer\" is required and cannot be null") if bank_transfer.nil?
        if _bank_transfer = bank_transfer
          _bank_transfer.validate if _bank_transfer.is_a?(OpenApi::Validatable)
        end
        raise ArgumentError.new("\"currency\" is required and cannot be null") if currency.nil?

        raise ArgumentError.new("\"funding_type\" is required and cannot be null") if funding_type.nil?
        if _funding_type = funding_type
          OpenApi::EnumValidator.validate("funding_type", _funding_type, POST_CUSTOMERS_CUSTOMER_FUNDING_INSTRUCTIONS_VALID_VALUES_FOR_FUNDING_TYPE)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/funding_instructions".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["bank_transfer"] = bank_transfer.to_s if !bank_transfer.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["funding_type"] = funding_type.to_s if !funding_type.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_customers_customer_funding_instructions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>When you create a new credit card, you must specify a customer or recipient on which to create it.</p>  <p>If the card’s owner has no default card, then the new card will become the default. However, if the owner already has a default, then it will not change. To change the default, you should <a href=\"/docs/api#update_customer\">update the customer</a> to have a new <code>default_source</code>.</p>
    # @param customer [String?]
    # @optional @param alipay_account [String?] A token returned by [Stripe.js](https://stripe.com/docs/js) representing the user’s Alipay account details.
    # @optional @param bank_account [Stripe::PostCustomersCustomerRequestBankAccount?]
    # @optional @param card [Stripe::PostChargesRequestCard?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param source [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return [PaymentSource]
    def post_customers_customer_sources(*, customer : String? = nil, alipay_account : String? = nil, bank_account : Stripe::PostCustomersCustomerRequestBankAccount? = nil, card : Stripe::PostChargesRequestCard? = nil, expand : Array(String)? = nil, source : String? = nil)
      data, _status_code, _headers = post_customers_customer_sources_with_http_info(customer: customer, alipay_account: alipay_account, bank_account: bank_account, card: card, expand: expand, source: source)
      data
    end

    # &lt;p&gt;When you create a new credit card, you must specify a customer or recipient on which to create it.&lt;/p&gt;  &lt;p&gt;If the card’s owner has no default card, then the new card will become the default. However, if the owner already has a default, then it will not change. To change the default, you should &lt;a href&#x3D;\&quot;/docs/api#update_customer\&quot;&gt;update the customer&lt;/a&gt; to have a new &lt;code&gt;default_source&lt;/code&gt;.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param alipay_account [String?] A token returned by [Stripe.js](https://stripe.com/docs/js) representing the user’s Alipay account details.
    # @optional @param bank_account [Stripe::PostCustomersCustomerRequestBankAccount?]
    # @optional @param card [Stripe::PostChargesRequestCard?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param source [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return [Array<(PaymentSource, Integer, Hash)>] PaymentSource data, response status code and response headers
    def post_customers_customer_sources_with_http_info(*, customer : String? = nil, alipay_account : String? = nil, bank_account : Stripe::PostCustomersCustomerRequestBankAccount? = nil, card : Stripe::PostChargesRequestCard? = nil, expand : Array(String)? = nil, source : String? = nil)
      request = build_api_request_for_post_customers_customer_sources(customer: customer, alipay_account: alipay_account, bank_account: bank_account, card: card, expand: expand, source: source)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_customers_customer_sources\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentSource.from_json(data), status_code, headers
    end

    # &lt;p&gt;When you create a new credit card, you must specify a customer or recipient on which to create it.&lt;/p&gt;  &lt;p&gt;If the card’s owner has no default card, then the new card will become the default. However, if the owner already has a default, then it will not change. To change the default, you should &lt;a href&#x3D;\&quot;/docs/api#update_customer\&quot;&gt;update the customer&lt;/a&gt; to have a new &lt;code&gt;default_source&lt;/code&gt;.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param alipay_account [String?] A token returned by [Stripe.js](https://stripe.com/docs/js) representing the user’s Alipay account details.
    # @optional @param bank_account [Stripe::PostCustomersCustomerRequestBankAccount?]
    # @optional @param card [Stripe::PostChargesRequestCard?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param source [String?] Please refer to full [documentation](https://stripe.com/docs/api) instead.
    # @return nil
    def post_customers_customer_sources(*, customer : String? = nil, alipay_account : String? = nil, bank_account : Stripe::PostCustomersCustomerRequestBankAccount? = nil, card : Stripe::PostChargesRequestCard? = nil, expand : Array(String)? = nil, source : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_customers_customer_sources(customer: customer, alipay_account: alipay_account, bank_account: bank_account, card: card, expand: expand, source: source).execute(&block)
    end

    POST_CUSTOMERS_CUSTOMER_SOURCES_MAX_LENGTH_FOR_CUSTOMER       = 5000
    POST_CUSTOMERS_CUSTOMER_SOURCES_MAX_LENGTH_FOR_ALIPAY_ACCOUNT = 5000
    POST_CUSTOMERS_CUSTOMER_SOURCES_MAX_LENGTH_FOR_SOURCE         = 5000

    # @return Crest::Request
    def build_api_request_for_post_customers_customer_sources(*, customer : String? = nil, alipay_account : String? = nil, bank_account : Stripe::PostCustomersCustomerRequestBankAccount? = nil, card : Stripe::PostChargesRequestCard? = nil, expand : Array(String)? = nil, source : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_customers_customer_sources ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_CUSTOMERS_CUSTOMER_SOURCES_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _alipay_account = alipay_account
          OpenApi::PrimitiveValidator.validate_max_length("alipay_account", alipay_account.to_s.size, POST_CUSTOMERS_CUSTOMER_SOURCES_MAX_LENGTH_FOR_ALIPAY_ACCOUNT)
        end
        if _bank_account = bank_account
          _bank_account.validate if _bank_account.is_a?(OpenApi::Validatable)
        end
        if _card = card
          _card.validate if _card.is_a?(OpenApi::Validatable)
        end

        if _source = source
          OpenApi::PrimitiveValidator.validate_max_length("source", source.to_s.size, POST_CUSTOMERS_CUSTOMER_SOURCES_MAX_LENGTH_FOR_SOURCE)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/sources".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["alipay_account"] = alipay_account.to_s if !alipay_account.nil?
      form_params["bank_account"] = bank_account.to_s if !bank_account.nil?
      form_params["card"] = card.to_s if !card.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["source"] = source.to_s if !source.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_customers_customer_sources",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Update a specified source for a given customer.</p>
    # @param customer [String?]
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @optional @param owner [Stripe::Owner?]
    # @return [PostCustomersCustomerBankAccountsId200Response]
    def post_customers_customer_sources_id(*, customer : String? = nil, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, owner : Stripe::Owner? = nil)
      data, _status_code, _headers = post_customers_customer_sources_id_with_http_info(customer: customer, id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name, owner: owner)
      data
    end

    # &lt;p&gt;Update a specified source for a given customer.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @optional @param owner [Stripe::Owner?]
    # @return [Array<(PostCustomersCustomerBankAccountsId200Response, Integer, Hash)>] PostCustomersCustomerBankAccountsId200Response data, response status code and response headers
    def post_customers_customer_sources_id_with_http_info(*, customer : String? = nil, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, owner : Stripe::Owner? = nil)
      request = build_api_request_for_post_customers_customer_sources_id(customer: customer, id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name, owner: owner)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_customers_customer_sources_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PostCustomersCustomerBankAccountsId200Response.from_json(data), status_code, headers
    end

    # &lt;p&gt;Update a specified source for a given customer.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param account_holder_name [String?] The name of the person or business that owns the bank account.
    # @optional @param account_holder_type [String?] The type of entity that holds the account. This can be either `individual` or `company`.
    # @optional @param address_city [String?] City/District/Suburb/Town/Village.
    # @optional @param address_country [String?] Billing address country, if provided when creating card.
    # @optional @param address_line1 [String?] Address line 1 (Street address/PO Box/Company name).
    # @optional @param address_line2 [String?] Address line 2 (Apartment/Suite/Unit/Building).
    # @optional @param address_state [String?] State/County/Province/Region.
    # @optional @param address_zip [String?] ZIP or postal code.
    # @optional @param exp_month [String?] Two digit number representing the card’s expiration month.
    # @optional @param exp_year [String?] Four digit number representing the card’s expiration year.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] Cardholder name.
    # @optional @param owner [Stripe::Owner?]
    # @return nil
    def post_customers_customer_sources_id(*, customer : String? = nil, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, owner : Stripe::Owner? = nil, &block : Crest::Response ->)
      build_api_request_for_post_customers_customer_sources_id(customer: customer, id: id, account_holder_name: account_holder_name, account_holder_type: account_holder_type, address_city: address_city, address_country: address_country, address_line1: address_line1, address_line2: address_line2, address_state: address_state, address_zip: address_zip, exp_month: exp_month, exp_year: exp_year, expand: expand, metadata: metadata, name: name, owner: owner).execute(&block)
    end

    POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_CUSTOMER              = 5000
    POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_ID                    = 5000
    POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_NAME   = 5000
    POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_TYPE   = 5000
    POST_CUSTOMERS_CUSTOMER_SOURCES_ID_VALID_VALUES_FOR_ACCOUNT_HOLDER_TYPE = StaticArray["company", "individual"]
    POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_ADDRESS_CITY          = 5000
    POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_ADDRESS_COUNTRY       = 5000
    POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_ADDRESS_LINE1         = 5000
    POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_ADDRESS_LINE2         = 5000
    POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_ADDRESS_STATE         = 5000
    POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_ADDRESS_ZIP           = 5000
    POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_EXP_MONTH             = 5000
    POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_EXP_YEAR              = 5000
    POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_NAME                  = 5000

    # @return Crest::Request
    def build_api_request_for_post_customers_customer_sources_id(*, customer : String? = nil, id : String? = nil, account_holder_name : String? = nil, account_holder_type : String? = nil, address_city : String? = nil, address_country : String? = nil, address_line1 : String? = nil, address_line2 : String? = nil, address_state : String? = nil, address_zip : String? = nil, exp_month : String? = nil, exp_year : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, owner : Stripe::Owner? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_customers_customer_sources_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_ID)
        end
        if _account_holder_name = account_holder_name
          OpenApi::PrimitiveValidator.validate_max_length("account_holder_name", account_holder_name.to_s.size, POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_ACCOUNT_HOLDER_NAME)
        end
        if _account_holder_type = account_holder_type
          OpenApi::EnumValidator.validate("account_holder_type", _account_holder_type, POST_CUSTOMERS_CUSTOMER_SOURCES_ID_VALID_VALUES_FOR_ACCOUNT_HOLDER_TYPE)
        end
        if _address_city = address_city
          OpenApi::PrimitiveValidator.validate_max_length("address_city", address_city.to_s.size, POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_ADDRESS_CITY)
        end
        if _address_country = address_country
          OpenApi::PrimitiveValidator.validate_max_length("address_country", address_country.to_s.size, POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_ADDRESS_COUNTRY)
        end
        if _address_line1 = address_line1
          OpenApi::PrimitiveValidator.validate_max_length("address_line1", address_line1.to_s.size, POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_ADDRESS_LINE1)
        end
        if _address_line2 = address_line2
          OpenApi::PrimitiveValidator.validate_max_length("address_line2", address_line2.to_s.size, POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_ADDRESS_LINE2)
        end
        if _address_state = address_state
          OpenApi::PrimitiveValidator.validate_max_length("address_state", address_state.to_s.size, POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_ADDRESS_STATE)
        end
        if _address_zip = address_zip
          OpenApi::PrimitiveValidator.validate_max_length("address_zip", address_zip.to_s.size, POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_ADDRESS_ZIP)
        end
        if _exp_month = exp_month
          OpenApi::PrimitiveValidator.validate_max_length("exp_month", exp_month.to_s.size, POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_EXP_MONTH)
        end
        if _exp_year = exp_year
          OpenApi::PrimitiveValidator.validate_max_length("exp_year", exp_year.to_s.size, POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_EXP_YEAR)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _name = name
          OpenApi::PrimitiveValidator.validate_max_length("name", name.to_s.size, POST_CUSTOMERS_CUSTOMER_SOURCES_ID_MAX_LENGTH_FOR_NAME)
        end
        if _owner = owner
          _owner.validate if _owner.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/sources/{id}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account_holder_name"] = account_holder_name.to_s if !account_holder_name.nil?
      form_params["account_holder_type"] = account_holder_type.to_s if !account_holder_type.nil?
      form_params["address_city"] = address_city.to_s if !address_city.nil?
      form_params["address_country"] = address_country.to_s if !address_country.nil?
      form_params["address_line1"] = address_line1.to_s if !address_line1.nil?
      form_params["address_line2"] = address_line2.to_s if !address_line2.nil?
      form_params["address_state"] = address_state.to_s if !address_state.nil?
      form_params["address_zip"] = address_zip.to_s if !address_zip.nil?
      form_params["exp_month"] = exp_month.to_s if !exp_month.nil?
      form_params["exp_year"] = exp_year.to_s if !exp_year.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["name"] = name.to_s if !name.nil?
      form_params["owner"] = owner.to_s if !owner.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_customers_customer_sources_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Verify a specified bank account for a given customer.</p>
    # @param customer [String?]
    # @param id [String?]
    # @optional @param amounts [Array(Int64)?] Two positive integers, in *cents*, equal to the values of the microdeposits sent to the bank account.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [BankAccount]
    def post_customers_customer_sources_id_verify(*, customer : String? = nil, id : String? = nil, amounts : Array(Int64)? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_customers_customer_sources_id_verify_with_http_info(customer: customer, id: id, amounts: amounts, expand: expand)
      data
    end

    # &lt;p&gt;Verify a specified bank account for a given customer.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param amounts [Array(Int64)?] Two positive integers, in *cents*, equal to the values of the microdeposits sent to the bank account.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(BankAccount, Integer, Hash)>] BankAccount data, response status code and response headers
    def post_customers_customer_sources_id_verify_with_http_info(*, customer : String? = nil, id : String? = nil, amounts : Array(Int64)? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_customers_customer_sources_id_verify(customer: customer, id: id, amounts: amounts, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_customers_customer_sources_id_verify\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return BankAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Verify a specified bank account for a given customer.&lt;/p&gt;
    # @param customer [String?]
    # @param id [String?]
    # @optional @param amounts [Array(Int64)?] Two positive integers, in *cents*, equal to the values of the microdeposits sent to the bank account.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_customers_customer_sources_id_verify(*, customer : String? = nil, id : String? = nil, amounts : Array(Int64)? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_customers_customer_sources_id_verify(customer: customer, id: id, amounts: amounts, expand: expand).execute(&block)
    end

    POST_CUSTOMERS_CUSTOMER_SOURCES_ID_VERIFY_MAX_LENGTH_FOR_CUSTOMER = 5000
    POST_CUSTOMERS_CUSTOMER_SOURCES_ID_VERIFY_MAX_LENGTH_FOR_ID       = 5000

    # @return Crest::Request
    def build_api_request_for_post_customers_customer_sources_id_verify(*, customer : String? = nil, id : String? = nil, amounts : Array(Int64)? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_customers_customer_sources_id_verify ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_CUSTOMERS_CUSTOMER_SOURCES_ID_VERIFY_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_CUSTOMERS_CUSTOMER_SOURCES_ID_VERIFY_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/sources/{id}/verify".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amounts"] = @api_client.build_collection_param(amounts, "csv") if !amounts.nil? && !amounts.empty?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_customers_customer_sources_id_verify",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new subscription on an existing customer.</p>
    # @param customer [String?]
    # @optional @param add_invoice_items [Array(Stripe::AddInvoiceItemEntry)?] A list of prices and quantities that will generate invoice items appended to the next invoice for this subscription. You may pass up to 20 items.
    # @optional @param application_fee_percent [Float64?] A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. The request must be made by a platform account on a connected account in order to set an application fee percentage. For more information, see the application fees [documentation](https://stripe.com/docs/connect/subscriptions#collecting-fees-on-subscriptions).
    # @optional @param automatic_tax [Stripe::AutomaticTaxConfig?]
    # @optional @param backdate_start_date [Int64?] For new subscriptions, a past timestamp to backdate the subscription's start date to. If set, the first invoice will contain a proration for the timespan between the start date and the current time. Can be combined with trials and the billing cycle anchor.
    # @optional @param billing_cycle_anchor [Int64?] A future timestamp to anchor the subscription's [billing cycle](https://stripe.com/docs/subscriptions/billing-cycle). This is used to determine the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices. The timestamp is in UTC format.
    # @optional @param billing_thresholds [Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds?]
    # @optional @param cancel_at [Int64?] A timestamp at which the subscription should cancel. If set to a date before the current period ends, this will cause a proration if prorations have been enabled using `proration_behavior`. If set during a future period, this will always cause a proration for that period.
    # @optional @param cancel_at_period_end [Bool?] Boolean indicating whether this subscription should cancel at the end of the current period.
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
    # @optional @param coupon [String?] The ID of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param days_until_due [Int64?] Number of days a customer has to pay invoices generated by this subscription. Valid only for subscriptions where `collection_method` is set to `send_invoice`.
    # @optional @param default_payment_method [String?] ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over `default_source`. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_source [String?] ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If `default_payment_method` is also set, `default_payment_method` will take precedence. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_tax_rates [Stripe::PostCustomersCustomerSubscriptionsRequestDefaultTaxRates?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param items [Array(Stripe::SubscriptionItemCreateParams)?] A list of up to 20 subscription items, each with an attached price.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param off_session [Bool?] Indicates if a customer is on or off-session while an invoice payment is attempted.
    # @optional @param payment_behavior [String?] Use `allow_incomplete` to create subscriptions with `status=incomplete` if the first invoice cannot be paid. Creating subscriptions with this status allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use `default_incomplete` to create Subscriptions with `status=incomplete` when the first invoice requires payment, otherwise start as active. Subscriptions transition to `status=active` when successfully confirming the payment intent on the first invoice. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method. If the payment intent is not confirmed within 23 hours subscriptions transition to `status=incomplete_expired`, which is a terminal state.  Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's first invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not create a subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.  `pending_if_incomplete` is only used with updates and cannot be passed when creating a subscription.
    # @optional @param payment_settings [Stripe::PaymentSettings?]
    # @optional @param pending_invoice_item_interval [Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval?]
    # @optional @param promotion_code [String?] The API ID of a promotion code to apply to this subscription. A promotion code applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) resulting from the `billing_cycle_anchor`. If no value is passed, the default is `create_prorations`.
    # @optional @param transfer_data [Stripe::TransferDataSpecs3?]
    # @optional @param trial_end [Stripe::PostCustomersCustomerSubscriptionsRequestTrialEnd?]
    # @optional @param trial_from_plan [Bool?] Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @optional @param trial_period_days [Int64?] Integer representing the number of trial period days before the customer is charged for the first time. This will always overwrite any trials that might apply via a subscribed plan. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @return [Subscription]
    def post_customers_customer_subscriptions(*, customer : String? = nil, add_invoice_items : Array(Stripe::AddInvoiceItemEntry)? = nil, application_fee_percent : Float64? = nil, automatic_tax : Stripe::AutomaticTaxConfig? = nil, backdate_start_date : Int64? = nil, billing_cycle_anchor : Int64? = nil, billing_thresholds : Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds? = nil, cancel_at : Int64? = nil, cancel_at_period_end : Bool? = nil, collection_method : String? = nil, coupon : String? = nil, currency : String? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Stripe::PostCustomersCustomerSubscriptionsRequestDefaultTaxRates? = nil, expand : Array(String)? = nil, items : Array(Stripe::SubscriptionItemCreateParams)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, off_session : Bool? = nil, payment_behavior : String? = nil, payment_settings : Stripe::PaymentSettings? = nil, pending_invoice_item_interval : Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval? = nil, promotion_code : String? = nil, proration_behavior : String? = nil, transfer_data : Stripe::TransferDataSpecs3? = nil, trial_end : Stripe::PostCustomersCustomerSubscriptionsRequestTrialEnd? = nil, trial_from_plan : Bool? = nil, trial_period_days : Int64? = nil)
      data, _status_code, _headers = post_customers_customer_subscriptions_with_http_info(customer: customer, add_invoice_items: add_invoice_items, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, backdate_start_date: backdate_start_date, billing_cycle_anchor: billing_cycle_anchor, billing_thresholds: billing_thresholds, cancel_at: cancel_at, cancel_at_period_end: cancel_at_period_end, collection_method: collection_method, coupon: coupon, currency: currency, days_until_due: days_until_due, default_payment_method: default_payment_method, default_source: default_source, default_tax_rates: default_tax_rates, expand: expand, items: items, metadata: metadata, off_session: off_session, payment_behavior: payment_behavior, payment_settings: payment_settings, pending_invoice_item_interval: pending_invoice_item_interval, promotion_code: promotion_code, proration_behavior: proration_behavior, transfer_data: transfer_data, trial_end: trial_end, trial_from_plan: trial_from_plan, trial_period_days: trial_period_days)
      data
    end

    # &lt;p&gt;Creates a new subscription on an existing customer.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param add_invoice_items [Array(Stripe::AddInvoiceItemEntry)?] A list of prices and quantities that will generate invoice items appended to the next invoice for this subscription. You may pass up to 20 items.
    # @optional @param application_fee_percent [Float64?] A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. The request must be made by a platform account on a connected account in order to set an application fee percentage. For more information, see the application fees [documentation](https://stripe.com/docs/connect/subscriptions#collecting-fees-on-subscriptions).
    # @optional @param automatic_tax [Stripe::AutomaticTaxConfig?]
    # @optional @param backdate_start_date [Int64?] For new subscriptions, a past timestamp to backdate the subscription's start date to. If set, the first invoice will contain a proration for the timespan between the start date and the current time. Can be combined with trials and the billing cycle anchor.
    # @optional @param billing_cycle_anchor [Int64?] A future timestamp to anchor the subscription's [billing cycle](https://stripe.com/docs/subscriptions/billing-cycle). This is used to determine the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices. The timestamp is in UTC format.
    # @optional @param billing_thresholds [Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds?]
    # @optional @param cancel_at [Int64?] A timestamp at which the subscription should cancel. If set to a date before the current period ends, this will cause a proration if prorations have been enabled using `proration_behavior`. If set during a future period, this will always cause a proration for that period.
    # @optional @param cancel_at_period_end [Bool?] Boolean indicating whether this subscription should cancel at the end of the current period.
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
    # @optional @param coupon [String?] The ID of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param days_until_due [Int64?] Number of days a customer has to pay invoices generated by this subscription. Valid only for subscriptions where `collection_method` is set to `send_invoice`.
    # @optional @param default_payment_method [String?] ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over `default_source`. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_source [String?] ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If `default_payment_method` is also set, `default_payment_method` will take precedence. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_tax_rates [Stripe::PostCustomersCustomerSubscriptionsRequestDefaultTaxRates?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param items [Array(Stripe::SubscriptionItemCreateParams)?] A list of up to 20 subscription items, each with an attached price.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param off_session [Bool?] Indicates if a customer is on or off-session while an invoice payment is attempted.
    # @optional @param payment_behavior [String?] Use `allow_incomplete` to create subscriptions with `status=incomplete` if the first invoice cannot be paid. Creating subscriptions with this status allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use `default_incomplete` to create Subscriptions with `status=incomplete` when the first invoice requires payment, otherwise start as active. Subscriptions transition to `status=active` when successfully confirming the payment intent on the first invoice. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method. If the payment intent is not confirmed within 23 hours subscriptions transition to `status=incomplete_expired`, which is a terminal state.  Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's first invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not create a subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.  `pending_if_incomplete` is only used with updates and cannot be passed when creating a subscription.
    # @optional @param payment_settings [Stripe::PaymentSettings?]
    # @optional @param pending_invoice_item_interval [Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval?]
    # @optional @param promotion_code [String?] The API ID of a promotion code to apply to this subscription. A promotion code applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) resulting from the `billing_cycle_anchor`. If no value is passed, the default is `create_prorations`.
    # @optional @param transfer_data [Stripe::TransferDataSpecs3?]
    # @optional @param trial_end [Stripe::PostCustomersCustomerSubscriptionsRequestTrialEnd?]
    # @optional @param trial_from_plan [Bool?] Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @optional @param trial_period_days [Int64?] Integer representing the number of trial period days before the customer is charged for the first time. This will always overwrite any trials that might apply via a subscribed plan. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @return [Array<(Subscription, Integer, Hash)>] Subscription data, response status code and response headers
    def post_customers_customer_subscriptions_with_http_info(*, customer : String? = nil, add_invoice_items : Array(Stripe::AddInvoiceItemEntry)? = nil, application_fee_percent : Float64? = nil, automatic_tax : Stripe::AutomaticTaxConfig? = nil, backdate_start_date : Int64? = nil, billing_cycle_anchor : Int64? = nil, billing_thresholds : Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds? = nil, cancel_at : Int64? = nil, cancel_at_period_end : Bool? = nil, collection_method : String? = nil, coupon : String? = nil, currency : String? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Stripe::PostCustomersCustomerSubscriptionsRequestDefaultTaxRates? = nil, expand : Array(String)? = nil, items : Array(Stripe::SubscriptionItemCreateParams)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, off_session : Bool? = nil, payment_behavior : String? = nil, payment_settings : Stripe::PaymentSettings? = nil, pending_invoice_item_interval : Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval? = nil, promotion_code : String? = nil, proration_behavior : String? = nil, transfer_data : Stripe::TransferDataSpecs3? = nil, trial_end : Stripe::PostCustomersCustomerSubscriptionsRequestTrialEnd? = nil, trial_from_plan : Bool? = nil, trial_period_days : Int64? = nil)
      request = build_api_request_for_post_customers_customer_subscriptions(customer: customer, add_invoice_items: add_invoice_items, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, backdate_start_date: backdate_start_date, billing_cycle_anchor: billing_cycle_anchor, billing_thresholds: billing_thresholds, cancel_at: cancel_at, cancel_at_period_end: cancel_at_period_end, collection_method: collection_method, coupon: coupon, currency: currency, days_until_due: days_until_due, default_payment_method: default_payment_method, default_source: default_source, default_tax_rates: default_tax_rates, expand: expand, items: items, metadata: metadata, off_session: off_session, payment_behavior: payment_behavior, payment_settings: payment_settings, pending_invoice_item_interval: pending_invoice_item_interval, promotion_code: promotion_code, proration_behavior: proration_behavior, transfer_data: transfer_data, trial_end: trial_end, trial_from_plan: trial_from_plan, trial_period_days: trial_period_days)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_customers_customer_subscriptions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Subscription.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new subscription on an existing customer.&lt;/p&gt;
    # @param customer [String?]
    # @optional @param add_invoice_items [Array(Stripe::AddInvoiceItemEntry)?] A list of prices and quantities that will generate invoice items appended to the next invoice for this subscription. You may pass up to 20 items.
    # @optional @param application_fee_percent [Float64?] A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. The request must be made by a platform account on a connected account in order to set an application fee percentage. For more information, see the application fees [documentation](https://stripe.com/docs/connect/subscriptions#collecting-fees-on-subscriptions).
    # @optional @param automatic_tax [Stripe::AutomaticTaxConfig?]
    # @optional @param backdate_start_date [Int64?] For new subscriptions, a past timestamp to backdate the subscription's start date to. If set, the first invoice will contain a proration for the timespan between the start date and the current time. Can be combined with trials and the billing cycle anchor.
    # @optional @param billing_cycle_anchor [Int64?] A future timestamp to anchor the subscription's [billing cycle](https://stripe.com/docs/subscriptions/billing-cycle). This is used to determine the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices. The timestamp is in UTC format.
    # @optional @param billing_thresholds [Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds?]
    # @optional @param cancel_at [Int64?] A timestamp at which the subscription should cancel. If set to a date before the current period ends, this will cause a proration if prorations have been enabled using `proration_behavior`. If set during a future period, this will always cause a proration for that period.
    # @optional @param cancel_at_period_end [Bool?] Boolean indicating whether this subscription should cancel at the end of the current period.
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
    # @optional @param coupon [String?] The ID of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param days_until_due [Int64?] Number of days a customer has to pay invoices generated by this subscription. Valid only for subscriptions where `collection_method` is set to `send_invoice`.
    # @optional @param default_payment_method [String?] ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over `default_source`. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_source [String?] ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If `default_payment_method` is also set, `default_payment_method` will take precedence. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_tax_rates [Stripe::PostCustomersCustomerSubscriptionsRequestDefaultTaxRates?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param items [Array(Stripe::SubscriptionItemCreateParams)?] A list of up to 20 subscription items, each with an attached price.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param off_session [Bool?] Indicates if a customer is on or off-session while an invoice payment is attempted.
    # @optional @param payment_behavior [String?] Use `allow_incomplete` to create subscriptions with `status=incomplete` if the first invoice cannot be paid. Creating subscriptions with this status allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use `default_incomplete` to create Subscriptions with `status=incomplete` when the first invoice requires payment, otherwise start as active. Subscriptions transition to `status=active` when successfully confirming the payment intent on the first invoice. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method. If the payment intent is not confirmed within 23 hours subscriptions transition to `status=incomplete_expired`, which is a terminal state.  Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's first invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not create a subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.  `pending_if_incomplete` is only used with updates and cannot be passed when creating a subscription.
    # @optional @param payment_settings [Stripe::PaymentSettings?]
    # @optional @param pending_invoice_item_interval [Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval?]
    # @optional @param promotion_code [String?] The API ID of a promotion code to apply to this subscription. A promotion code applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) resulting from the `billing_cycle_anchor`. If no value is passed, the default is `create_prorations`.
    # @optional @param transfer_data [Stripe::TransferDataSpecs3?]
    # @optional @param trial_end [Stripe::PostCustomersCustomerSubscriptionsRequestTrialEnd?]
    # @optional @param trial_from_plan [Bool?] Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @optional @param trial_period_days [Int64?] Integer representing the number of trial period days before the customer is charged for the first time. This will always overwrite any trials that might apply via a subscribed plan. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @return nil
    def post_customers_customer_subscriptions(*, customer : String? = nil, add_invoice_items : Array(Stripe::AddInvoiceItemEntry)? = nil, application_fee_percent : Float64? = nil, automatic_tax : Stripe::AutomaticTaxConfig? = nil, backdate_start_date : Int64? = nil, billing_cycle_anchor : Int64? = nil, billing_thresholds : Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds? = nil, cancel_at : Int64? = nil, cancel_at_period_end : Bool? = nil, collection_method : String? = nil, coupon : String? = nil, currency : String? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Stripe::PostCustomersCustomerSubscriptionsRequestDefaultTaxRates? = nil, expand : Array(String)? = nil, items : Array(Stripe::SubscriptionItemCreateParams)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, off_session : Bool? = nil, payment_behavior : String? = nil, payment_settings : Stripe::PaymentSettings? = nil, pending_invoice_item_interval : Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval? = nil, promotion_code : String? = nil, proration_behavior : String? = nil, transfer_data : Stripe::TransferDataSpecs3? = nil, trial_end : Stripe::PostCustomersCustomerSubscriptionsRequestTrialEnd? = nil, trial_from_plan : Bool? = nil, trial_period_days : Int64? = nil, &block : Crest::Response ->)
      build_api_request_for_post_customers_customer_subscriptions(customer: customer, add_invoice_items: add_invoice_items, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, backdate_start_date: backdate_start_date, billing_cycle_anchor: billing_cycle_anchor, billing_thresholds: billing_thresholds, cancel_at: cancel_at, cancel_at_period_end: cancel_at_period_end, collection_method: collection_method, coupon: coupon, currency: currency, days_until_due: days_until_due, default_payment_method: default_payment_method, default_source: default_source, default_tax_rates: default_tax_rates, expand: expand, items: items, metadata: metadata, off_session: off_session, payment_behavior: payment_behavior, payment_settings: payment_settings, pending_invoice_item_interval: pending_invoice_item_interval, promotion_code: promotion_code, proration_behavior: proration_behavior, transfer_data: transfer_data, trial_end: trial_end, trial_from_plan: trial_from_plan, trial_period_days: trial_period_days).execute(&block)
    end

    POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_MAX_LENGTH_FOR_CUSTOMER               = 5000
    POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_VALID_VALUES_FOR_COLLECTION_METHOD    = StaticArray["charge_automatically", "send_invoice"]
    POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_MAX_LENGTH_FOR_COUPON                 = 5000
    POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_MAX_LENGTH_FOR_DEFAULT_PAYMENT_METHOD = 5000
    POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_MAX_LENGTH_FOR_DEFAULT_SOURCE         = 5000
    POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_VALID_VALUES_FOR_PAYMENT_BEHAVIOR     = StaticArray["allow_incomplete", "default_incomplete", "error_if_incomplete", "pending_if_incomplete"]
    POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_MAX_LENGTH_FOR_PROMOTION_CODE         = 5000
    POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_VALID_VALUES_FOR_PRORATION_BEHAVIOR   = StaticArray["always_invoice", "create_prorations", "none"]

    # @return Crest::Request
    def build_api_request_for_post_customers_customer_subscriptions(*, customer : String? = nil, add_invoice_items : Array(Stripe::AddInvoiceItemEntry)? = nil, application_fee_percent : Float64? = nil, automatic_tax : Stripe::AutomaticTaxConfig? = nil, backdate_start_date : Int64? = nil, billing_cycle_anchor : Int64? = nil, billing_thresholds : Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds? = nil, cancel_at : Int64? = nil, cancel_at_period_end : Bool? = nil, collection_method : String? = nil, coupon : String? = nil, currency : String? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Stripe::PostCustomersCustomerSubscriptionsRequestDefaultTaxRates? = nil, expand : Array(String)? = nil, items : Array(Stripe::SubscriptionItemCreateParams)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, off_session : Bool? = nil, payment_behavior : String? = nil, payment_settings : Stripe::PaymentSettings? = nil, pending_invoice_item_interval : Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval? = nil, promotion_code : String? = nil, proration_behavior : String? = nil, transfer_data : Stripe::TransferDataSpecs3? = nil, trial_end : Stripe::PostCustomersCustomerSubscriptionsRequestTrialEnd? = nil, trial_from_plan : Bool? = nil, trial_period_days : Int64? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_customers_customer_subscriptions ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _add_invoice_items = add_invoice_items
          OpenApi::ContainerValidator.validate(container: _add_invoice_items) if _add_invoice_items.is_a?(Array)
        end

        if _automatic_tax = automatic_tax
          _automatic_tax.validate if _automatic_tax.is_a?(OpenApi::Validatable)
        end

        if _billing_thresholds = billing_thresholds
          _billing_thresholds.validate if _billing_thresholds.is_a?(OpenApi::Validatable)
        end

        if _collection_method = collection_method
          OpenApi::EnumValidator.validate("collection_method", _collection_method, POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_VALID_VALUES_FOR_COLLECTION_METHOD)
        end
        if _coupon = coupon
          OpenApi::PrimitiveValidator.validate_max_length("coupon", coupon.to_s.size, POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_MAX_LENGTH_FOR_COUPON)
        end

        if _default_payment_method = default_payment_method
          OpenApi::PrimitiveValidator.validate_max_length("default_payment_method", default_payment_method.to_s.size, POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_MAX_LENGTH_FOR_DEFAULT_PAYMENT_METHOD)
        end
        if _default_source = default_source
          OpenApi::PrimitiveValidator.validate_max_length("default_source", default_source.to_s.size, POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_MAX_LENGTH_FOR_DEFAULT_SOURCE)
        end
        if _default_tax_rates = default_tax_rates
          _default_tax_rates.validate if _default_tax_rates.is_a?(OpenApi::Validatable)
        end

        if _items = items
          OpenApi::ContainerValidator.validate(container: _items) if _items.is_a?(Array)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end

        if _payment_behavior = payment_behavior
          OpenApi::EnumValidator.validate("payment_behavior", _payment_behavior, POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_VALID_VALUES_FOR_PAYMENT_BEHAVIOR)
        end
        if _payment_settings = payment_settings
          _payment_settings.validate if _payment_settings.is_a?(OpenApi::Validatable)
        end
        if _pending_invoice_item_interval = pending_invoice_item_interval
          _pending_invoice_item_interval.validate if _pending_invoice_item_interval.is_a?(OpenApi::Validatable)
        end
        if _promotion_code = promotion_code
          OpenApi::PrimitiveValidator.validate_max_length("promotion_code", promotion_code.to_s.size, POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_MAX_LENGTH_FOR_PROMOTION_CODE)
        end
        if _proration_behavior = proration_behavior
          OpenApi::EnumValidator.validate("proration_behavior", _proration_behavior, POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_VALID_VALUES_FOR_PRORATION_BEHAVIOR)
        end
        if _transfer_data = transfer_data
          _transfer_data.validate if _transfer_data.is_a?(OpenApi::Validatable)
        end
        if _trial_end = trial_end
          _trial_end.validate if _trial_end.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/subscriptions".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["add_invoice_items"] = @api_client.build_collection_param(add_invoice_items, "csv") if !add_invoice_items.nil? && !add_invoice_items.empty?
      form_params["application_fee_percent"] = application_fee_percent.to_s if !application_fee_percent.nil?
      form_params["automatic_tax"] = automatic_tax.to_s if !automatic_tax.nil?
      form_params["backdate_start_date"] = backdate_start_date.to_s if !backdate_start_date.nil?
      form_params["billing_cycle_anchor"] = billing_cycle_anchor.to_s if !billing_cycle_anchor.nil?
      form_params["billing_thresholds"] = billing_thresholds.to_s if !billing_thresholds.nil?
      form_params["cancel_at"] = cancel_at.to_s if !cancel_at.nil?
      form_params["cancel_at_period_end"] = cancel_at_period_end.to_s if !cancel_at_period_end.nil?
      form_params["collection_method"] = collection_method.to_s if !collection_method.nil?
      form_params["coupon"] = coupon.to_s if !coupon.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["days_until_due"] = days_until_due.to_s if !days_until_due.nil?
      form_params["default_payment_method"] = default_payment_method.to_s if !default_payment_method.nil?
      form_params["default_source"] = default_source.to_s if !default_source.nil?
      form_params["default_tax_rates"] = default_tax_rates.to_s if !default_tax_rates.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["items"] = @api_client.build_collection_param(items, "csv") if !items.nil? && !items.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["off_session"] = off_session.to_s if !off_session.nil?
      form_params["payment_behavior"] = payment_behavior.to_s if !payment_behavior.nil?
      form_params["payment_settings"] = payment_settings.to_s if !payment_settings.nil?
      form_params["pending_invoice_item_interval"] = pending_invoice_item_interval.to_s if !pending_invoice_item_interval.nil?
      form_params["promotion_code"] = promotion_code.to_s if !promotion_code.nil?
      form_params["proration_behavior"] = proration_behavior.to_s if !proration_behavior.nil?
      form_params["transfer_data"] = transfer_data.to_s if !transfer_data.nil?
      form_params["trial_end"] = trial_end.to_s if !trial_end.nil?
      form_params["trial_from_plan"] = trial_from_plan.to_s if !trial_from_plan.nil?
      form_params["trial_period_days"] = trial_period_days.to_s if !trial_period_days.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_customers_customer_subscriptions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates an existing subscription on a customer to match the specified parameters. When changing plans or quantities, we will optionally prorate the price we charge next month to make up for any price changes. To preview how the proration will be calculated, use the <a href=\"#upcoming_invoice\">upcoming invoice</a> endpoint.</p>
    # @param customer [String?]
    # @param subscription_exposed_id [String?]
    # @optional @param add_invoice_items [Array(Stripe::AddInvoiceItemEntry)?] A list of prices and quantities that will generate invoice items appended to the next invoice for this subscription. You may pass up to 20 items.
    # @optional @param application_fee_percent [Float64?] A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. The request must be made by a platform account on a connected account in order to set an application fee percentage. For more information, see the application fees [documentation](https://stripe.com/docs/connect/subscriptions#collecting-fees-on-subscriptions).
    # @optional @param automatic_tax [Stripe::AutomaticTaxConfig?]
    # @optional @param billing_cycle_anchor [String?] Either `now` or `unchanged`. Setting the value to `now` resets the subscription's billing cycle anchor to the current time. For more information, see the billing cycle [documentation](https://stripe.com/docs/billing/subscriptions/billing-cycle).
    # @optional @param billing_thresholds [Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds?]
    # @optional @param cancel_at [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestCancelAt?]
    # @optional @param cancel_at_period_end [Bool?] Boolean indicating whether this subscription should cancel at the end of the current period.
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
    # @optional @param coupon [String?] The ID of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param days_until_due [Int64?] Number of days a customer has to pay invoices generated by this subscription. Valid only for subscriptions where `collection_method` is set to `send_invoice`.
    # @optional @param default_payment_method [String?] ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over `default_source`. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_source [String?] ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If `default_payment_method` is also set, `default_payment_method` will take precedence. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_tax_rates [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestDefaultTaxRates?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param items [Array(Stripe::SubscriptionItemUpdateParams)?] A list of up to 20 subscription items, each with an attached price.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param off_session [Bool?] Indicates if a customer is on or off-session while an invoice payment is attempted.
    # @optional @param pause_collection [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestPauseCollection?]
    # @optional @param payment_behavior [String?] Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.  Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).  Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
    # @optional @param payment_settings [Stripe::PaymentSettings?]
    # @optional @param pending_invoice_item_interval [Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval?]
    # @optional @param promotion_code [String?] The promotion code to apply to this subscription. A promotion code applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param proration_date [Int64?] If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply exactly the same proration that was previewed with [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint. It can also be used to implement custom proration logic, such as prorating by day instead of by second, by providing the time that you wish to use for proration calculations.
    # @optional @param transfer_data [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTransferData?]
    # @optional @param trial_end [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTrialEnd?]
    # @optional @param trial_from_plan [Bool?] Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @return [Subscription]
    def post_customers_customer_subscriptions_subscription_exposed_id(*, customer : String? = nil, subscription_exposed_id : String? = nil, add_invoice_items : Array(Stripe::AddInvoiceItemEntry)? = nil, application_fee_percent : Float64? = nil, automatic_tax : Stripe::AutomaticTaxConfig? = nil, billing_cycle_anchor : String? = nil, billing_thresholds : Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds? = nil, cancel_at : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestCancelAt? = nil, cancel_at_period_end : Bool? = nil, collection_method : String? = nil, coupon : String? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestDefaultTaxRates? = nil, expand : Array(String)? = nil, items : Array(Stripe::SubscriptionItemUpdateParams)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, off_session : Bool? = nil, pause_collection : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestPauseCollection? = nil, payment_behavior : String? = nil, payment_settings : Stripe::PaymentSettings? = nil, pending_invoice_item_interval : Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval? = nil, promotion_code : String? = nil, proration_behavior : String? = nil, proration_date : Int64? = nil, transfer_data : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTransferData? = nil, trial_end : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTrialEnd? = nil, trial_from_plan : Bool? = nil)
      data, _status_code, _headers = post_customers_customer_subscriptions_subscription_exposed_id_with_http_info(customer: customer, subscription_exposed_id: subscription_exposed_id, add_invoice_items: add_invoice_items, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, billing_cycle_anchor: billing_cycle_anchor, billing_thresholds: billing_thresholds, cancel_at: cancel_at, cancel_at_period_end: cancel_at_period_end, collection_method: collection_method, coupon: coupon, days_until_due: days_until_due, default_payment_method: default_payment_method, default_source: default_source, default_tax_rates: default_tax_rates, expand: expand, items: items, metadata: metadata, off_session: off_session, pause_collection: pause_collection, payment_behavior: payment_behavior, payment_settings: payment_settings, pending_invoice_item_interval: pending_invoice_item_interval, promotion_code: promotion_code, proration_behavior: proration_behavior, proration_date: proration_date, transfer_data: transfer_data, trial_end: trial_end, trial_from_plan: trial_from_plan)
      data
    end

    # &lt;p&gt;Updates an existing subscription on a customer to match the specified parameters. When changing plans or quantities, we will optionally prorate the price we charge next month to make up for any price changes. To preview how the proration will be calculated, use the &lt;a href&#x3D;\&quot;#upcoming_invoice\&quot;&gt;upcoming invoice&lt;/a&gt; endpoint.&lt;/p&gt;
    # @param customer [String?]
    # @param subscription_exposed_id [String?]
    # @optional @param add_invoice_items [Array(Stripe::AddInvoiceItemEntry)?] A list of prices and quantities that will generate invoice items appended to the next invoice for this subscription. You may pass up to 20 items.
    # @optional @param application_fee_percent [Float64?] A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. The request must be made by a platform account on a connected account in order to set an application fee percentage. For more information, see the application fees [documentation](https://stripe.com/docs/connect/subscriptions#collecting-fees-on-subscriptions).
    # @optional @param automatic_tax [Stripe::AutomaticTaxConfig?]
    # @optional @param billing_cycle_anchor [String?] Either `now` or `unchanged`. Setting the value to `now` resets the subscription's billing cycle anchor to the current time. For more information, see the billing cycle [documentation](https://stripe.com/docs/billing/subscriptions/billing-cycle).
    # @optional @param billing_thresholds [Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds?]
    # @optional @param cancel_at [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestCancelAt?]
    # @optional @param cancel_at_period_end [Bool?] Boolean indicating whether this subscription should cancel at the end of the current period.
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
    # @optional @param coupon [String?] The ID of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param days_until_due [Int64?] Number of days a customer has to pay invoices generated by this subscription. Valid only for subscriptions where `collection_method` is set to `send_invoice`.
    # @optional @param default_payment_method [String?] ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over `default_source`. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_source [String?] ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If `default_payment_method` is also set, `default_payment_method` will take precedence. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_tax_rates [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestDefaultTaxRates?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param items [Array(Stripe::SubscriptionItemUpdateParams)?] A list of up to 20 subscription items, each with an attached price.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param off_session [Bool?] Indicates if a customer is on or off-session while an invoice payment is attempted.
    # @optional @param pause_collection [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestPauseCollection?]
    # @optional @param payment_behavior [String?] Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.  Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).  Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
    # @optional @param payment_settings [Stripe::PaymentSettings?]
    # @optional @param pending_invoice_item_interval [Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval?]
    # @optional @param promotion_code [String?] The promotion code to apply to this subscription. A promotion code applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param proration_date [Int64?] If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply exactly the same proration that was previewed with [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint. It can also be used to implement custom proration logic, such as prorating by day instead of by second, by providing the time that you wish to use for proration calculations.
    # @optional @param transfer_data [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTransferData?]
    # @optional @param trial_end [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTrialEnd?]
    # @optional @param trial_from_plan [Bool?] Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @return [Array<(Subscription, Integer, Hash)>] Subscription data, response status code and response headers
    def post_customers_customer_subscriptions_subscription_exposed_id_with_http_info(*, customer : String? = nil, subscription_exposed_id : String? = nil, add_invoice_items : Array(Stripe::AddInvoiceItemEntry)? = nil, application_fee_percent : Float64? = nil, automatic_tax : Stripe::AutomaticTaxConfig? = nil, billing_cycle_anchor : String? = nil, billing_thresholds : Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds? = nil, cancel_at : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestCancelAt? = nil, cancel_at_period_end : Bool? = nil, collection_method : String? = nil, coupon : String? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestDefaultTaxRates? = nil, expand : Array(String)? = nil, items : Array(Stripe::SubscriptionItemUpdateParams)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, off_session : Bool? = nil, pause_collection : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestPauseCollection? = nil, payment_behavior : String? = nil, payment_settings : Stripe::PaymentSettings? = nil, pending_invoice_item_interval : Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval? = nil, promotion_code : String? = nil, proration_behavior : String? = nil, proration_date : Int64? = nil, transfer_data : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTransferData? = nil, trial_end : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTrialEnd? = nil, trial_from_plan : Bool? = nil)
      request = build_api_request_for_post_customers_customer_subscriptions_subscription_exposed_id(customer: customer, subscription_exposed_id: subscription_exposed_id, add_invoice_items: add_invoice_items, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, billing_cycle_anchor: billing_cycle_anchor, billing_thresholds: billing_thresholds, cancel_at: cancel_at, cancel_at_period_end: cancel_at_period_end, collection_method: collection_method, coupon: coupon, days_until_due: days_until_due, default_payment_method: default_payment_method, default_source: default_source, default_tax_rates: default_tax_rates, expand: expand, items: items, metadata: metadata, off_session: off_session, pause_collection: pause_collection, payment_behavior: payment_behavior, payment_settings: payment_settings, pending_invoice_item_interval: pending_invoice_item_interval, promotion_code: promotion_code, proration_behavior: proration_behavior, proration_date: proration_date, transfer_data: transfer_data, trial_end: trial_end, trial_from_plan: trial_from_plan)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_customers_customer_subscriptions_subscription_exposed_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Subscription.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates an existing subscription on a customer to match the specified parameters. When changing plans or quantities, we will optionally prorate the price we charge next month to make up for any price changes. To preview how the proration will be calculated, use the &lt;a href&#x3D;\&quot;#upcoming_invoice\&quot;&gt;upcoming invoice&lt;/a&gt; endpoint.&lt;/p&gt;
    # @param customer [String?]
    # @param subscription_exposed_id [String?]
    # @optional @param add_invoice_items [Array(Stripe::AddInvoiceItemEntry)?] A list of prices and quantities that will generate invoice items appended to the next invoice for this subscription. You may pass up to 20 items.
    # @optional @param application_fee_percent [Float64?] A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. The request must be made by a platform account on a connected account in order to set an application fee percentage. For more information, see the application fees [documentation](https://stripe.com/docs/connect/subscriptions#collecting-fees-on-subscriptions).
    # @optional @param automatic_tax [Stripe::AutomaticTaxConfig?]
    # @optional @param billing_cycle_anchor [String?] Either `now` or `unchanged`. Setting the value to `now` resets the subscription's billing cycle anchor to the current time. For more information, see the billing cycle [documentation](https://stripe.com/docs/billing/subscriptions/billing-cycle).
    # @optional @param billing_thresholds [Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds?]
    # @optional @param cancel_at [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestCancelAt?]
    # @optional @param cancel_at_period_end [Bool?] Boolean indicating whether this subscription should cancel at the end of the current period.
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
    # @optional @param coupon [String?] The ID of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param days_until_due [Int64?] Number of days a customer has to pay invoices generated by this subscription. Valid only for subscriptions where `collection_method` is set to `send_invoice`.
    # @optional @param default_payment_method [String?] ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over `default_source`. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_source [String?] ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If `default_payment_method` is also set, `default_payment_method` will take precedence. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_tax_rates [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestDefaultTaxRates?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param items [Array(Stripe::SubscriptionItemUpdateParams)?] A list of up to 20 subscription items, each with an attached price.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param off_session [Bool?] Indicates if a customer is on or off-session while an invoice payment is attempted.
    # @optional @param pause_collection [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestPauseCollection?]
    # @optional @param payment_behavior [String?] Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.  Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).  Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
    # @optional @param payment_settings [Stripe::PaymentSettings?]
    # @optional @param pending_invoice_item_interval [Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval?]
    # @optional @param promotion_code [String?] The promotion code to apply to this subscription. A promotion code applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param proration_date [Int64?] If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply exactly the same proration that was previewed with [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint. It can also be used to implement custom proration logic, such as prorating by day instead of by second, by providing the time that you wish to use for proration calculations.
    # @optional @param transfer_data [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTransferData?]
    # @optional @param trial_end [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTrialEnd?]
    # @optional @param trial_from_plan [Bool?] Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @return nil
    def post_customers_customer_subscriptions_subscription_exposed_id(*, customer : String? = nil, subscription_exposed_id : String? = nil, add_invoice_items : Array(Stripe::AddInvoiceItemEntry)? = nil, application_fee_percent : Float64? = nil, automatic_tax : Stripe::AutomaticTaxConfig? = nil, billing_cycle_anchor : String? = nil, billing_thresholds : Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds? = nil, cancel_at : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestCancelAt? = nil, cancel_at_period_end : Bool? = nil, collection_method : String? = nil, coupon : String? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestDefaultTaxRates? = nil, expand : Array(String)? = nil, items : Array(Stripe::SubscriptionItemUpdateParams)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, off_session : Bool? = nil, pause_collection : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestPauseCollection? = nil, payment_behavior : String? = nil, payment_settings : Stripe::PaymentSettings? = nil, pending_invoice_item_interval : Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval? = nil, promotion_code : String? = nil, proration_behavior : String? = nil, proration_date : Int64? = nil, transfer_data : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTransferData? = nil, trial_end : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTrialEnd? = nil, trial_from_plan : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_post_customers_customer_subscriptions_subscription_exposed_id(customer: customer, subscription_exposed_id: subscription_exposed_id, add_invoice_items: add_invoice_items, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, billing_cycle_anchor: billing_cycle_anchor, billing_thresholds: billing_thresholds, cancel_at: cancel_at, cancel_at_period_end: cancel_at_period_end, collection_method: collection_method, coupon: coupon, days_until_due: days_until_due, default_payment_method: default_payment_method, default_source: default_source, default_tax_rates: default_tax_rates, expand: expand, items: items, metadata: metadata, off_session: off_session, pause_collection: pause_collection, payment_behavior: payment_behavior, payment_settings: payment_settings, pending_invoice_item_interval: pending_invoice_item_interval, promotion_code: promotion_code, proration_behavior: proration_behavior, proration_date: proration_date, transfer_data: transfer_data, trial_end: trial_end, trial_from_plan: trial_from_plan).execute(&block)
    end

    POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_CUSTOMER                = 5000
    POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID = 5000
    POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_BILLING_CYCLE_ANCHOR    = 5000
    POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_VALID_VALUES_FOR_BILLING_CYCLE_ANCHOR  = StaticArray["now", "unchanged"]
    POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_VALID_VALUES_FOR_COLLECTION_METHOD     = StaticArray["charge_automatically", "send_invoice"]
    POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_COUPON                  = 5000
    POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_DEFAULT_PAYMENT_METHOD  = 5000
    POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_DEFAULT_SOURCE          = 5000
    POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_VALID_VALUES_FOR_PAYMENT_BEHAVIOR      = StaticArray["allow_incomplete", "default_incomplete", "error_if_incomplete", "pending_if_incomplete"]
    POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_PROMOTION_CODE          = 5000
    POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_VALID_VALUES_FOR_PRORATION_BEHAVIOR    = StaticArray["always_invoice", "create_prorations", "none"]

    # @return Crest::Request
    def build_api_request_for_post_customers_customer_subscriptions_subscription_exposed_id(*, customer : String? = nil, subscription_exposed_id : String? = nil, add_invoice_items : Array(Stripe::AddInvoiceItemEntry)? = nil, application_fee_percent : Float64? = nil, automatic_tax : Stripe::AutomaticTaxConfig? = nil, billing_cycle_anchor : String? = nil, billing_thresholds : Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds? = nil, cancel_at : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestCancelAt? = nil, cancel_at_period_end : Bool? = nil, collection_method : String? = nil, coupon : String? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestDefaultTaxRates? = nil, expand : Array(String)? = nil, items : Array(Stripe::SubscriptionItemUpdateParams)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, off_session : Bool? = nil, pause_collection : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestPauseCollection? = nil, payment_behavior : String? = nil, payment_settings : Stripe::PaymentSettings? = nil, pending_invoice_item_interval : Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval? = nil, promotion_code : String? = nil, proration_behavior : String? = nil, proration_date : Int64? = nil, transfer_data : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTransferData? = nil, trial_end : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTrialEnd? = nil, trial_from_plan : Bool? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_customers_customer_subscriptions_subscription_exposed_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"subscription_exposed_id\" is required and cannot be null") if subscription_exposed_id.nil?
        if _subscription_exposed_id = subscription_exposed_id
          OpenApi::PrimitiveValidator.validate_max_length("subscription_exposed_id", subscription_exposed_id.to_s.size, POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID)
        end
        if _add_invoice_items = add_invoice_items
          OpenApi::ContainerValidator.validate(container: _add_invoice_items) if _add_invoice_items.is_a?(Array)
        end

        if _automatic_tax = automatic_tax
          _automatic_tax.validate if _automatic_tax.is_a?(OpenApi::Validatable)
        end
        if _billing_cycle_anchor = billing_cycle_anchor
          OpenApi::EnumValidator.validate("billing_cycle_anchor", _billing_cycle_anchor, POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_VALID_VALUES_FOR_BILLING_CYCLE_ANCHOR)
        end
        if _billing_thresholds = billing_thresholds
          _billing_thresholds.validate if _billing_thresholds.is_a?(OpenApi::Validatable)
        end
        if _cancel_at = cancel_at
          _cancel_at.validate if _cancel_at.is_a?(OpenApi::Validatable)
        end

        if _collection_method = collection_method
          OpenApi::EnumValidator.validate("collection_method", _collection_method, POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_VALID_VALUES_FOR_COLLECTION_METHOD)
        end
        if _coupon = coupon
          OpenApi::PrimitiveValidator.validate_max_length("coupon", coupon.to_s.size, POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_COUPON)
        end

        if _default_payment_method = default_payment_method
          OpenApi::PrimitiveValidator.validate_max_length("default_payment_method", default_payment_method.to_s.size, POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_DEFAULT_PAYMENT_METHOD)
        end
        if _default_source = default_source
          OpenApi::PrimitiveValidator.validate_max_length("default_source", default_source.to_s.size, POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_DEFAULT_SOURCE)
        end
        if _default_tax_rates = default_tax_rates
          _default_tax_rates.validate if _default_tax_rates.is_a?(OpenApi::Validatable)
        end

        if _items = items
          OpenApi::ContainerValidator.validate(container: _items) if _items.is_a?(Array)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end

        if _pause_collection = pause_collection
          _pause_collection.validate if _pause_collection.is_a?(OpenApi::Validatable)
        end
        if _payment_behavior = payment_behavior
          OpenApi::EnumValidator.validate("payment_behavior", _payment_behavior, POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_VALID_VALUES_FOR_PAYMENT_BEHAVIOR)
        end
        if _payment_settings = payment_settings
          _payment_settings.validate if _payment_settings.is_a?(OpenApi::Validatable)
        end
        if _pending_invoice_item_interval = pending_invoice_item_interval
          _pending_invoice_item_interval.validate if _pending_invoice_item_interval.is_a?(OpenApi::Validatable)
        end
        if _promotion_code = promotion_code
          OpenApi::PrimitiveValidator.validate_max_length("promotion_code", promotion_code.to_s.size, POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_PROMOTION_CODE)
        end
        if _proration_behavior = proration_behavior
          OpenApi::EnumValidator.validate("proration_behavior", _proration_behavior, POST_CUSTOMERS_CUSTOMER_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_VALID_VALUES_FOR_PRORATION_BEHAVIOR)
        end

        if _transfer_data = transfer_data
          _transfer_data.validate if _transfer_data.is_a?(OpenApi::Validatable)
        end
        if _trial_end = trial_end
          _trial_end.validate if _trial_end.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/subscriptions/{subscription_exposed_id}".sub("{" + "customer" + "}", URI.encode_path(customer.to_s)).sub("{" + "subscription_exposed_id" + "}", URI.encode_path(subscription_exposed_id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["add_invoice_items"] = @api_client.build_collection_param(add_invoice_items, "csv") if !add_invoice_items.nil? && !add_invoice_items.empty?
      form_params["application_fee_percent"] = application_fee_percent.to_s if !application_fee_percent.nil?
      form_params["automatic_tax"] = automatic_tax.to_s if !automatic_tax.nil?
      form_params["billing_cycle_anchor"] = billing_cycle_anchor.to_s if !billing_cycle_anchor.nil?
      form_params["billing_thresholds"] = billing_thresholds.to_s if !billing_thresholds.nil?
      form_params["cancel_at"] = cancel_at.to_s if !cancel_at.nil?
      form_params["cancel_at_period_end"] = cancel_at_period_end.to_s if !cancel_at_period_end.nil?
      form_params["collection_method"] = collection_method.to_s if !collection_method.nil?
      form_params["coupon"] = coupon.to_s if !coupon.nil?
      form_params["days_until_due"] = days_until_due.to_s if !days_until_due.nil?
      form_params["default_payment_method"] = default_payment_method.to_s if !default_payment_method.nil?
      form_params["default_source"] = default_source.to_s if !default_source.nil?
      form_params["default_tax_rates"] = default_tax_rates.to_s if !default_tax_rates.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["items"] = @api_client.build_collection_param(items, "csv") if !items.nil? && !items.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["off_session"] = off_session.to_s if !off_session.nil?
      form_params["pause_collection"] = pause_collection.to_s if !pause_collection.nil?
      form_params["payment_behavior"] = payment_behavior.to_s if !payment_behavior.nil?
      form_params["payment_settings"] = payment_settings.to_s if !payment_settings.nil?
      form_params["pending_invoice_item_interval"] = pending_invoice_item_interval.to_s if !pending_invoice_item_interval.nil?
      form_params["promotion_code"] = promotion_code.to_s if !promotion_code.nil?
      form_params["proration_behavior"] = proration_behavior.to_s if !proration_behavior.nil?
      form_params["proration_date"] = proration_date.to_s if !proration_date.nil?
      form_params["transfer_data"] = transfer_data.to_s if !transfer_data.nil?
      form_params["trial_end"] = trial_end.to_s if !trial_end.nil?
      form_params["trial_from_plan"] = trial_from_plan.to_s if !trial_from_plan.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_customers_customer_subscriptions_subscription_exposed_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new <code>TaxID</code> object for a customer.</p>
    # @param customer [String?]
    # @param _type [String?] Type of the tax ID, one of `ae_trn`, `au_abn`, `au_arn`, `bg_uic`, `br_cnpj`, `br_cpf`, `ca_bn`, `ca_gst_hst`, `ca_pst_bc`, `ca_pst_mb`, `ca_pst_sk`, `ca_qst`, `ch_vat`, `cl_tin`, `es_cif`, `eu_oss_vat`, `eu_vat`, `gb_vat`, `ge_vat`, `hk_br`, `hu_tin`, `id_npwp`, `il_vat`, `in_gst`, `is_vat`, `jp_cn`, `jp_rn`, `kr_brn`, `li_uid`, `mx_rfc`, `my_frp`, `my_itn`, `my_sst`, `no_vat`, `nz_gst`, `ru_inn`, `ru_kpp`, `sa_vat`, `sg_gst`, `sg_uen`, `si_tin`, `th_vat`, `tw_vat`, `ua_vat`, `us_ein`, or `za_vat`
    # @param value [String?] Value of the tax ID.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [TaxId]
    def post_customers_customer_tax_ids(*, customer : String? = nil, _type : String? = nil, value : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_customers_customer_tax_ids_with_http_info(customer: customer, _type: _type, value: value, expand: expand)
      data
    end

    # &lt;p&gt;Creates a new &lt;code&gt;TaxID&lt;/code&gt; object for a customer.&lt;/p&gt;
    # @param customer [String?]
    # @param _type [String?] Type of the tax ID, one of `ae_trn`, `au_abn`, `au_arn`, `bg_uic`, `br_cnpj`, `br_cpf`, `ca_bn`, `ca_gst_hst`, `ca_pst_bc`, `ca_pst_mb`, `ca_pst_sk`, `ca_qst`, `ch_vat`, `cl_tin`, `es_cif`, `eu_oss_vat`, `eu_vat`, `gb_vat`, `ge_vat`, `hk_br`, `hu_tin`, `id_npwp`, `il_vat`, `in_gst`, `is_vat`, `jp_cn`, `jp_rn`, `kr_brn`, `li_uid`, `mx_rfc`, `my_frp`, `my_itn`, `my_sst`, `no_vat`, `nz_gst`, `ru_inn`, `ru_kpp`, `sa_vat`, `sg_gst`, `sg_uen`, `si_tin`, `th_vat`, `tw_vat`, `ua_vat`, `us_ein`, or `za_vat`
    # @param value [String?] Value of the tax ID.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(TaxId, Integer, Hash)>] TaxId data, response status code and response headers
    def post_customers_customer_tax_ids_with_http_info(*, customer : String? = nil, _type : String? = nil, value : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_customers_customer_tax_ids(customer: customer, _type: _type, value: value, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_customers_customer_tax_ids\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TaxId.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new &lt;code&gt;TaxID&lt;/code&gt; object for a customer.&lt;/p&gt;
    # @param customer [String?]
    # @param _type [String?] Type of the tax ID, one of `ae_trn`, `au_abn`, `au_arn`, `bg_uic`, `br_cnpj`, `br_cpf`, `ca_bn`, `ca_gst_hst`, `ca_pst_bc`, `ca_pst_mb`, `ca_pst_sk`, `ca_qst`, `ch_vat`, `cl_tin`, `es_cif`, `eu_oss_vat`, `eu_vat`, `gb_vat`, `ge_vat`, `hk_br`, `hu_tin`, `id_npwp`, `il_vat`, `in_gst`, `is_vat`, `jp_cn`, `jp_rn`, `kr_brn`, `li_uid`, `mx_rfc`, `my_frp`, `my_itn`, `my_sst`, `no_vat`, `nz_gst`, `ru_inn`, `ru_kpp`, `sa_vat`, `sg_gst`, `sg_uen`, `si_tin`, `th_vat`, `tw_vat`, `ua_vat`, `us_ein`, or `za_vat`
    # @param value [String?] Value of the tax ID.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_customers_customer_tax_ids(*, customer : String? = nil, _type : String? = nil, value : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_customers_customer_tax_ids(customer: customer, _type: _type, value: value, expand: expand).execute(&block)
    end

    POST_CUSTOMERS_CUSTOMER_TAX_IDS_MAX_LENGTH_FOR_CUSTOMER = 5000
    POST_CUSTOMERS_CUSTOMER_TAX_IDS_MAX_LENGTH_FOR__TYPE    = 5000
    POST_CUSTOMERS_CUSTOMER_TAX_IDS_VALID_VALUES_FOR__TYPE  = StaticArray["ae_trn", "au_abn", "au_arn", "bg_uic", "br_cnpj", "br_cpf", "ca_bn", "ca_gst_hst", "ca_pst_bc", "ca_pst_mb", "ca_pst_sk", "ca_qst", "ch_vat", "cl_tin", "es_cif", "eu_oss_vat", "eu_vat", "gb_vat", "ge_vat", "hk_br", "hu_tin", "id_npwp", "il_vat", "in_gst", "is_vat", "jp_cn", "jp_rn", "kr_brn", "li_uid", "mx_rfc", "my_frp", "my_itn", "my_sst", "no_vat", "nz_gst", "ru_inn", "ru_kpp", "sa_vat", "sg_gst", "sg_uen", "si_tin", "th_vat", "tw_vat", "ua_vat", "us_ein", "za_vat"]

    # @return Crest::Request
    def build_api_request_for_post_customers_customer_tax_ids(*, customer : String? = nil, _type : String? = nil, value : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_customers_customer_tax_ids ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_CUSTOMERS_CUSTOMER_TAX_IDS_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"_type\" is required and cannot be null") if _type.nil?
        if __type = _type
          OpenApi::EnumValidator.validate("_type", __type, POST_CUSTOMERS_CUSTOMER_TAX_IDS_VALID_VALUES_FOR__TYPE)
        end
        raise ArgumentError.new("\"value\" is required and cannot be null") if value.nil?
      end

      # resource path
      local_var_path = "/v1/customers/{customer}/tax_ids".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["type"] = _type.to_s if !_type.nil?
      form_params["value"] = value.to_s if !value.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_customers_customer_tax_ids",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>When you get a dispute, contacting your customer is always the best first step. If that doesn’t work, you can submit evidence to help us resolve the dispute in your favor. You can do this in your <a href=\"https://dashboard.stripe.com/disputes\">dashboard</a>, but if you prefer, you can use the API to submit evidence programmatically.</p>  <p>Depending on your dispute type, different evidence fields will give you a better chance of winning your dispute. To figure out which evidence fields to provide, see our <a href=\"/docs/disputes/categories\">guide to dispute types</a>.</p>
    # @param dispute [String?]
    # @optional @param evidence [Stripe::DisputeEvidenceParams?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param submit [Bool?] Whether to immediately submit evidence to the bank. If `false`, evidence is staged on the dispute. Staged evidence is visible in the API and Dashboard, and can be submitted to the bank by making another request with this attribute set to `true` (the default).
    # @return [Dispute]
    def post_disputes_dispute(*, dispute : String? = nil, evidence : Stripe::DisputeEvidenceParams? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, submit : Bool? = nil)
      data, _status_code, _headers = post_disputes_dispute_with_http_info(dispute: dispute, evidence: evidence, expand: expand, metadata: metadata, submit: submit)
      data
    end

    # &lt;p&gt;When you get a dispute, contacting your customer is always the best first step. If that doesn’t work, you can submit evidence to help us resolve the dispute in your favor. You can do this in your &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/disputes\&quot;&gt;dashboard&lt;/a&gt;, but if you prefer, you can use the API to submit evidence programmatically.&lt;/p&gt;  &lt;p&gt;Depending on your dispute type, different evidence fields will give you a better chance of winning your dispute. To figure out which evidence fields to provide, see our &lt;a href&#x3D;\&quot;/docs/disputes/categories\&quot;&gt;guide to dispute types&lt;/a&gt;.&lt;/p&gt;
    # @param dispute [String?]
    # @optional @param evidence [Stripe::DisputeEvidenceParams?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param submit [Bool?] Whether to immediately submit evidence to the bank. If `false`, evidence is staged on the dispute. Staged evidence is visible in the API and Dashboard, and can be submitted to the bank by making another request with this attribute set to `true` (the default).
    # @return [Array<(Dispute, Integer, Hash)>] Dispute data, response status code and response headers
    def post_disputes_dispute_with_http_info(*, dispute : String? = nil, evidence : Stripe::DisputeEvidenceParams? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, submit : Bool? = nil)
      request = build_api_request_for_post_disputes_dispute(dispute: dispute, evidence: evidence, expand: expand, metadata: metadata, submit: submit)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_disputes_dispute\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Dispute.from_json(data), status_code, headers
    end

    # &lt;p&gt;When you get a dispute, contacting your customer is always the best first step. If that doesn’t work, you can submit evidence to help us resolve the dispute in your favor. You can do this in your &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/disputes\&quot;&gt;dashboard&lt;/a&gt;, but if you prefer, you can use the API to submit evidence programmatically.&lt;/p&gt;  &lt;p&gt;Depending on your dispute type, different evidence fields will give you a better chance of winning your dispute. To figure out which evidence fields to provide, see our &lt;a href&#x3D;\&quot;/docs/disputes/categories\&quot;&gt;guide to dispute types&lt;/a&gt;.&lt;/p&gt;
    # @param dispute [String?]
    # @optional @param evidence [Stripe::DisputeEvidenceParams?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param submit [Bool?] Whether to immediately submit evidence to the bank. If `false`, evidence is staged on the dispute. Staged evidence is visible in the API and Dashboard, and can be submitted to the bank by making another request with this attribute set to `true` (the default).
    # @return nil
    def post_disputes_dispute(*, dispute : String? = nil, evidence : Stripe::DisputeEvidenceParams? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, submit : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_post_disputes_dispute(dispute: dispute, evidence: evidence, expand: expand, metadata: metadata, submit: submit).execute(&block)
    end

    POST_DISPUTES_DISPUTE_MAX_LENGTH_FOR_DISPUTE = 5000

    # @return Crest::Request
    def build_api_request_for_post_disputes_dispute(*, dispute : String? = nil, evidence : Stripe::DisputeEvidenceParams? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, submit : Bool? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_disputes_dispute ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"dispute\" is required and cannot be null") if dispute.nil?
        if _dispute = dispute
          OpenApi::PrimitiveValidator.validate_max_length("dispute", dispute.to_s.size, POST_DISPUTES_DISPUTE_MAX_LENGTH_FOR_DISPUTE)
        end
        if _evidence = evidence
          _evidence.validate if _evidence.is_a?(OpenApi::Validatable)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/disputes/{dispute}".sub("{" + "dispute" + "}", URI.encode_path(dispute.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["evidence"] = evidence.to_s if !evidence.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["submit"] = submit.to_s if !submit.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_disputes_dispute",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Closing the dispute for a charge indicates that you do not have any evidence to submit and are essentially dismissing the dispute, acknowledging it as lost.</p>  <p>The status of the dispute will change from <code>needs_response</code> to <code>lost</code>. <em>Closing a dispute is irreversible</em>.</p>
    # @param dispute [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Dispute]
    def post_disputes_dispute_close(*, dispute : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_disputes_dispute_close_with_http_info(dispute: dispute, expand: expand)
      data
    end

    # &lt;p&gt;Closing the dispute for a charge indicates that you do not have any evidence to submit and are essentially dismissing the dispute, acknowledging it as lost.&lt;/p&gt;  &lt;p&gt;The status of the dispute will change from &lt;code&gt;needs_response&lt;/code&gt; to &lt;code&gt;lost&lt;/code&gt;. &lt;em&gt;Closing a dispute is irreversible&lt;/em&gt;.&lt;/p&gt;
    # @param dispute [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(Dispute, Integer, Hash)>] Dispute data, response status code and response headers
    def post_disputes_dispute_close_with_http_info(*, dispute : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_disputes_dispute_close(dispute: dispute, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_disputes_dispute_close\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Dispute.from_json(data), status_code, headers
    end

    # &lt;p&gt;Closing the dispute for a charge indicates that you do not have any evidence to submit and are essentially dismissing the dispute, acknowledging it as lost.&lt;/p&gt;  &lt;p&gt;The status of the dispute will change from &lt;code&gt;needs_response&lt;/code&gt; to &lt;code&gt;lost&lt;/code&gt;. &lt;em&gt;Closing a dispute is irreversible&lt;/em&gt;.&lt;/p&gt;
    # @param dispute [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_disputes_dispute_close(*, dispute : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_disputes_dispute_close(dispute: dispute, expand: expand).execute(&block)
    end

    POST_DISPUTES_DISPUTE_CLOSE_MAX_LENGTH_FOR_DISPUTE = 5000

    # @return Crest::Request
    def build_api_request_for_post_disputes_dispute_close(*, dispute : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_disputes_dispute_close ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"dispute\" is required and cannot be null") if dispute.nil?
        if _dispute = dispute
          OpenApi::PrimitiveValidator.validate_max_length("dispute", dispute.to_s.size, POST_DISPUTES_DISPUTE_CLOSE_MAX_LENGTH_FOR_DISPUTE)
        end
      end

      # resource path
      local_var_path = "/v1/disputes/{dispute}/close".sub("{" + "dispute" + "}", URI.encode_path(dispute.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_disputes_dispute_close",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a short-lived API key for a given resource.</p>
    # @optional @param customer [String?] The ID of the Customer you'd like to modify using the resulting ephemeral key.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param issuing_card [String?] The ID of the Issuing Card you'd like to access using the resulting ephemeral key.
    # @return [EphemeralKey]
    def post_ephemeral_keys(*, customer : String? = nil, expand : Array(String)? = nil, issuing_card : String? = nil)
      data, _status_code, _headers = post_ephemeral_keys_with_http_info(customer: customer, expand: expand, issuing_card: issuing_card)
      data
    end

    # &lt;p&gt;Creates a short-lived API key for a given resource.&lt;/p&gt;
    # @optional @param customer [String?] The ID of the Customer you'd like to modify using the resulting ephemeral key.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param issuing_card [String?] The ID of the Issuing Card you'd like to access using the resulting ephemeral key.
    # @return [Array<(EphemeralKey, Integer, Hash)>] EphemeralKey data, response status code and response headers
    def post_ephemeral_keys_with_http_info(*, customer : String? = nil, expand : Array(String)? = nil, issuing_card : String? = nil)
      request = build_api_request_for_post_ephemeral_keys(customer: customer, expand: expand, issuing_card: issuing_card)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_ephemeral_keys\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return EphemeralKey.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a short-lived API key for a given resource.&lt;/p&gt;
    # @optional @param customer [String?] The ID of the Customer you'd like to modify using the resulting ephemeral key.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param issuing_card [String?] The ID of the Issuing Card you'd like to access using the resulting ephemeral key.
    # @return nil
    def post_ephemeral_keys(*, customer : String? = nil, expand : Array(String)? = nil, issuing_card : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_ephemeral_keys(customer: customer, expand: expand, issuing_card: issuing_card).execute(&block)
    end

    POST_EPHEMERAL_KEYS_MAX_LENGTH_FOR_CUSTOMER     = 5000
    POST_EPHEMERAL_KEYS_MAX_LENGTH_FOR_ISSUING_CARD = 5000

    # @return Crest::Request
    def build_api_request_for_post_ephemeral_keys(*, customer : String? = nil, expand : Array(String)? = nil, issuing_card : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_ephemeral_keys ..." }
      end

      if client_side_validation
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_EPHEMERAL_KEYS_MAX_LENGTH_FOR_CUSTOMER)
        end

        if _issuing_card = issuing_card
          OpenApi::PrimitiveValidator.validate_max_length("issuing_card", issuing_card.to_s.size, POST_EPHEMERAL_KEYS_MAX_LENGTH_FOR_ISSUING_CARD)
        end
      end

      # resource path
      local_var_path = "/v1/ephemeral_keys"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["issuing_card"] = issuing_card.to_s if !issuing_card.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_ephemeral_keys",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new file link object.</p>
    # @param file [String?] The ID of the file. The file's `purpose` must be one of the following: `business_icon`, `business_logo`, `customer_signature`, `dispute_evidence`, `finance_report_run`, `identity_document_downloadable`, `pci_document`, `selfie`, `sigma_scheduled_query`, `tax_document_user_upload`, or `terminal_reader_splashscreen`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] A future timestamp after which the link will no longer be usable.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [FileLink]
    def post_file_links(*, file : String? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_file_links_with_http_info(file: file, expand: expand, expires_at: expires_at, metadata: metadata)
      data
    end

    # &lt;p&gt;Creates a new file link object.&lt;/p&gt;
    # @param file [String?] The ID of the file. The file's `purpose` must be one of the following: `business_icon`, `business_logo`, `customer_signature`, `dispute_evidence`, `finance_report_run`, `identity_document_downloadable`, `pci_document`, `selfie`, `sigma_scheduled_query`, `tax_document_user_upload`, or `terminal_reader_splashscreen`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] A future timestamp after which the link will no longer be usable.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(FileLink, Integer, Hash)>] FileLink data, response status code and response headers
    def post_file_links_with_http_info(*, file : String? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_file_links(file: file, expand: expand, expires_at: expires_at, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_file_links\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FileLink.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new file link object.&lt;/p&gt;
    # @param file [String?] The ID of the file. The file's `purpose` must be one of the following: `business_icon`, `business_logo`, `customer_signature`, `dispute_evidence`, `finance_report_run`, `identity_document_downloadable`, `pci_document`, `selfie`, `sigma_scheduled_query`, `tax_document_user_upload`, or `terminal_reader_splashscreen`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] A future timestamp after which the link will no longer be usable.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_file_links(*, file : String? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_file_links(file: file, expand: expand, expires_at: expires_at, metadata: metadata).execute(&block)
    end

    POST_FILE_LINKS_MAX_LENGTH_FOR_FILE = 5000

    # @return Crest::Request
    def build_api_request_for_post_file_links(*, file : String? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_file_links ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"file\" is required and cannot be null") if file.nil?
        if _file = file
          OpenApi::PrimitiveValidator.validate_max_length("file", file.to_s.size, POST_FILE_LINKS_MAX_LENGTH_FOR_FILE)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/file_links"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["expires_at"] = expires_at.to_s if !expires_at.nil?
      form_params["file"] = file.to_s if !file.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_file_links",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates an existing file link object. Expired links can no longer be updated.</p>
    # @param link [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Stripe::PostFileLinksLinkRequestExpiresAt?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [FileLink]
    def post_file_links_link(*, link : String? = nil, expand : Array(String)? = nil, expires_at : Stripe::PostFileLinksLinkRequestExpiresAt? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_file_links_link_with_http_info(link: link, expand: expand, expires_at: expires_at, metadata: metadata)
      data
    end

    # &lt;p&gt;Updates an existing file link object. Expired links can no longer be updated.&lt;/p&gt;
    # @param link [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Stripe::PostFileLinksLinkRequestExpiresAt?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(FileLink, Integer, Hash)>] FileLink data, response status code and response headers
    def post_file_links_link_with_http_info(*, link : String? = nil, expand : Array(String)? = nil, expires_at : Stripe::PostFileLinksLinkRequestExpiresAt? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_file_links_link(link: link, expand: expand, expires_at: expires_at, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_file_links_link\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FileLink.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates an existing file link object. Expired links can no longer be updated.&lt;/p&gt;
    # @param link [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Stripe::PostFileLinksLinkRequestExpiresAt?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_file_links_link(*, link : String? = nil, expand : Array(String)? = nil, expires_at : Stripe::PostFileLinksLinkRequestExpiresAt? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_file_links_link(link: link, expand: expand, expires_at: expires_at, metadata: metadata).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_post_file_links_link(*, link : String? = nil, expand : Array(String)? = nil, expires_at : Stripe::PostFileLinksLinkRequestExpiresAt? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_file_links_link ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"link\" is required and cannot be null") if link.nil?

        if _expires_at = expires_at
          _expires_at.validate if _expires_at.is_a?(OpenApi::Validatable)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/file_links/{link}".sub("{" + "link" + "}", URI.encode_path(link.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["expires_at"] = expires_at.to_s if !expires_at.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_file_links_link",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>To upload a file to Stripe, you’ll need to send a request of type <code>multipart/form-data</code>. The request should contain the file you would like to upload, as well as the parameters for creating a file.</p>  <p>All of Stripe’s officially supported Client libraries should have support for sending <code>multipart/form-data</code>.</p>
    # @param file [String?] A file to upload. The file should follow the specifications of RFC 2388 (which defines file transfers for the `multipart/form-data` protocol).
    # @param purpose [String?] The [purpose](https://stripe.com/docs/file-upload#uploading-a-file) of the uploaded file.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param file_link_data [Stripe::FileLinkCreationParams?]
    # @return [::File]
    def post_files(*, file : String? = nil, purpose : String? = nil, expand : Array(String)? = nil, file_link_data : Stripe::FileLinkCreationParams? = nil)
      data, _status_code, _headers = post_files_with_http_info(file: file, purpose: purpose, expand: expand, file_link_data: file_link_data)
      data
    end

    # &lt;p&gt;To upload a file to Stripe, you’ll need to send a request of type &lt;code&gt;multipart/form-data&lt;/code&gt;. The request should contain the file you would like to upload, as well as the parameters for creating a file.&lt;/p&gt;  &lt;p&gt;All of Stripe’s officially supported Client libraries should have support for sending &lt;code&gt;multipart/form-data&lt;/code&gt;.&lt;/p&gt;
    # @param file [String?] A file to upload. The file should follow the specifications of RFC 2388 (which defines file transfers for the `multipart/form-data` protocol).
    # @param purpose [String?] The [purpose](https://stripe.com/docs/file-upload#uploading-a-file) of the uploaded file.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param file_link_data [Stripe::FileLinkCreationParams?]
    # @return [Array<(::File, Integer, Hash)>] ::File data, response status code and response headers
    def post_files_with_http_info(*, file : String? = nil, purpose : String? = nil, expand : Array(String)? = nil, file_link_data : Stripe::FileLinkCreationParams? = nil)
      request = build_api_request_for_post_files(file: file, purpose: purpose, expand: expand, file_link_data: file_link_data)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_files\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ::File.from_json(data), status_code, headers
    end

    # &lt;p&gt;To upload a file to Stripe, you’ll need to send a request of type &lt;code&gt;multipart/form-data&lt;/code&gt;. The request should contain the file you would like to upload, as well as the parameters for creating a file.&lt;/p&gt;  &lt;p&gt;All of Stripe’s officially supported Client libraries should have support for sending &lt;code&gt;multipart/form-data&lt;/code&gt;.&lt;/p&gt;
    # @param file [String?] A file to upload. The file should follow the specifications of RFC 2388 (which defines file transfers for the `multipart/form-data` protocol).
    # @param purpose [String?] The [purpose](https://stripe.com/docs/file-upload#uploading-a-file) of the uploaded file.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param file_link_data [Stripe::FileLinkCreationParams?]
    # @return nil
    def post_files(*, file : String? = nil, purpose : String? = nil, expand : Array(String)? = nil, file_link_data : Stripe::FileLinkCreationParams? = nil, &block : Crest::Response ->)
      build_api_request_for_post_files(file: file, purpose: purpose, expand: expand, file_link_data: file_link_data).execute(&block)
    end

    POST_FILES_VALID_VALUES_FOR_PURPOSE = StaticArray["account_requirement", "additional_verification", "business_icon", "business_logo", "customer_signature", "dispute_evidence", "identity_document", "pci_document", "tax_document_user_upload", "terminal_reader_splashscreen"]

    # @return Crest::Request
    def build_api_request_for_post_files(*, file : String? = nil, purpose : String? = nil, expand : Array(String)? = nil, file_link_data : Stripe::FileLinkCreationParams? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_files ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"file\" is required and cannot be null") if file.nil?

        raise ArgumentError.new("\"purpose\" is required and cannot be null") if purpose.nil?
        if _purpose = purpose
          OpenApi::EnumValidator.validate("purpose", _purpose, POST_FILES_VALID_VALUES_FOR_PURPOSE)
        end

        if _file_link_data = file_link_data
          _file_link_data.validate if _file_link_data.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/files"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["multipart/form-data"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["file"] = file.to_s if !file.nil?
      form_params["file_link_data"] = file_link_data.to_s if !file_link_data.nil?
      form_params["purpose"] = purpose.to_s if !purpose.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_files",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Disables your access to a Financial Connections <code>Account</code>. You will no longer be able to access data associated with the account (e.g. balances, transactions).</p>
    # @param account [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [FinancialConnectionsAccount]
    def post_financial_connections_accounts_account_disconnect(*, account : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_financial_connections_accounts_account_disconnect_with_http_info(account: account, expand: expand)
      data
    end

    # &lt;p&gt;Disables your access to a Financial Connections &lt;code&gt;Account&lt;/code&gt;. You will no longer be able to access data associated with the account (e.g. balances, transactions).&lt;/p&gt;
    # @param account [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(FinancialConnectionsAccount, Integer, Hash)>] FinancialConnectionsAccount data, response status code and response headers
    def post_financial_connections_accounts_account_disconnect_with_http_info(*, account : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_financial_connections_accounts_account_disconnect(account: account, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_financial_connections_accounts_account_disconnect\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FinancialConnectionsAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Disables your access to a Financial Connections &lt;code&gt;Account&lt;/code&gt;. You will no longer be able to access data associated with the account (e.g. balances, transactions).&lt;/p&gt;
    # @param account [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_financial_connections_accounts_account_disconnect(*, account : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_financial_connections_accounts_account_disconnect(account: account, expand: expand).execute(&block)
    end

    POST_FINANCIAL_CONNECTIONS_ACCOUNTS_ACCOUNT_DISCONNECT_MAX_LENGTH_FOR_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_post_financial_connections_accounts_account_disconnect(*, account : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_financial_connections_accounts_account_disconnect ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_FINANCIAL_CONNECTIONS_ACCOUNTS_ACCOUNT_DISCONNECT_MAX_LENGTH_FOR_ACCOUNT)
        end
      end

      # resource path
      local_var_path = "/v1/financial_connections/accounts/{account}/disconnect".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_financial_connections_accounts_account_disconnect",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Refreshes the data associated with a Financial Connections <code>Account</code>.</p>
    # @param account [String?]
    # @param features [Array(String)?] The list of account features that you would like to refresh.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [FinancialConnectionsAccount]
    def post_financial_connections_accounts_account_refresh(*, account : String? = nil, features : Array(String)? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_financial_connections_accounts_account_refresh_with_http_info(account: account, features: features, expand: expand)
      data
    end

    # &lt;p&gt;Refreshes the data associated with a Financial Connections &lt;code&gt;Account&lt;/code&gt;.&lt;/p&gt;
    # @param account [String?]
    # @param features [Array(String)?] The list of account features that you would like to refresh.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(FinancialConnectionsAccount, Integer, Hash)>] FinancialConnectionsAccount data, response status code and response headers
    def post_financial_connections_accounts_account_refresh_with_http_info(*, account : String? = nil, features : Array(String)? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_financial_connections_accounts_account_refresh(account: account, features: features, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_financial_connections_accounts_account_refresh\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FinancialConnectionsAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Refreshes the data associated with a Financial Connections &lt;code&gt;Account&lt;/code&gt;.&lt;/p&gt;
    # @param account [String?]
    # @param features [Array(String)?] The list of account features that you would like to refresh.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_financial_connections_accounts_account_refresh(*, account : String? = nil, features : Array(String)? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_financial_connections_accounts_account_refresh(account: account, features: features, expand: expand).execute(&block)
    end

    POST_FINANCIAL_CONNECTIONS_ACCOUNTS_ACCOUNT_REFRESH_MAX_LENGTH_FOR_ACCOUNT    = 5000
    POST_FINANCIAL_CONNECTIONS_ACCOUNTS_ACCOUNT_REFRESH_VALID_VALUES_FOR_FEATURES = StaticArray["balance", "ownership"]

    # @return Crest::Request
    def build_api_request_for_post_financial_connections_accounts_account_refresh(*, account : String? = nil, features : Array(String)? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_financial_connections_accounts_account_refresh ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_FINANCIAL_CONNECTIONS_ACCOUNTS_ACCOUNT_REFRESH_MAX_LENGTH_FOR_ACCOUNT)
        end
        raise ArgumentError.new("\"features\" is required and cannot be null") if features.nil?
        if _features = features
          OpenApi::EnumValidator.validate("features", _features, POST_FINANCIAL_CONNECTIONS_ACCOUNTS_ACCOUNT_REFRESH_VALID_VALUES_FOR_FEATURES)
        end
      end

      # resource path
      local_var_path = "/v1/financial_connections/accounts/{account}/refresh".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["features"] = @api_client.build_collection_param(features, "csv") if !features.nil? && !features.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_financial_connections_accounts_account_refresh",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>To launch the Financial Connections authorization flow, create a <code>Session</code>. The session’s <code>client_secret</code> can be used to launch the flow using Stripe.js.</p>
    # @param account_holder [Stripe::AccountholderParams1?]
    # @param permissions [Array(String)?] List of data features that you would like to request access to.  Possible values are `balances`, `transactions`, `ownership`, and `payment_method`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param filters [Stripe::FiltersParams?]
    # @optional @param return_url [String?] For webview integrations only. Upon completing OAuth login in the native browser, the user will be redirected to this URL to return to your app.
    # @return [FinancialConnectionsSession]
    def post_financial_connections_sessions(*, account_holder : Stripe::AccountholderParams1? = nil, permissions : Array(String)? = nil, expand : Array(String)? = nil, filters : Stripe::FiltersParams? = nil, return_url : String? = nil)
      data, _status_code, _headers = post_financial_connections_sessions_with_http_info(account_holder: account_holder, permissions: permissions, expand: expand, filters: filters, return_url: return_url)
      data
    end

    # &lt;p&gt;To launch the Financial Connections authorization flow, create a &lt;code&gt;Session&lt;/code&gt;. The session’s &lt;code&gt;client_secret&lt;/code&gt; can be used to launch the flow using Stripe.js.&lt;/p&gt;
    # @param account_holder [Stripe::AccountholderParams1?]
    # @param permissions [Array(String)?] List of data features that you would like to request access to.  Possible values are `balances`, `transactions`, `ownership`, and `payment_method`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param filters [Stripe::FiltersParams?]
    # @optional @param return_url [String?] For webview integrations only. Upon completing OAuth login in the native browser, the user will be redirected to this URL to return to your app.
    # @return [Array<(FinancialConnectionsSession, Integer, Hash)>] FinancialConnectionsSession data, response status code and response headers
    def post_financial_connections_sessions_with_http_info(*, account_holder : Stripe::AccountholderParams1? = nil, permissions : Array(String)? = nil, expand : Array(String)? = nil, filters : Stripe::FiltersParams? = nil, return_url : String? = nil)
      request = build_api_request_for_post_financial_connections_sessions(account_holder: account_holder, permissions: permissions, expand: expand, filters: filters, return_url: return_url)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_financial_connections_sessions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FinancialConnectionsSession.from_json(data), status_code, headers
    end

    # &lt;p&gt;To launch the Financial Connections authorization flow, create a &lt;code&gt;Session&lt;/code&gt;. The session’s &lt;code&gt;client_secret&lt;/code&gt; can be used to launch the flow using Stripe.js.&lt;/p&gt;
    # @param account_holder [Stripe::AccountholderParams1?]
    # @param permissions [Array(String)?] List of data features that you would like to request access to.  Possible values are `balances`, `transactions`, `ownership`, and `payment_method`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param filters [Stripe::FiltersParams?]
    # @optional @param return_url [String?] For webview integrations only. Upon completing OAuth login in the native browser, the user will be redirected to this URL to return to your app.
    # @return nil
    def post_financial_connections_sessions(*, account_holder : Stripe::AccountholderParams1? = nil, permissions : Array(String)? = nil, expand : Array(String)? = nil, filters : Stripe::FiltersParams? = nil, return_url : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_financial_connections_sessions(account_holder: account_holder, permissions: permissions, expand: expand, filters: filters, return_url: return_url).execute(&block)
    end

    POST_FINANCIAL_CONNECTIONS_SESSIONS_VALID_VALUES_FOR_PERMISSIONS = StaticArray["balances", "ownership", "payment_method", "transactions"]
    POST_FINANCIAL_CONNECTIONS_SESSIONS_MAX_LENGTH_FOR_RETURN_URL    = 5000

    # @return Crest::Request
    def build_api_request_for_post_financial_connections_sessions(*, account_holder : Stripe::AccountholderParams1? = nil, permissions : Array(String)? = nil, expand : Array(String)? = nil, filters : Stripe::FiltersParams? = nil, return_url : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_financial_connections_sessions ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account_holder\" is required and cannot be null") if account_holder.nil?
        if _account_holder = account_holder
          _account_holder.validate if _account_holder.is_a?(OpenApi::Validatable)
        end
        raise ArgumentError.new("\"permissions\" is required and cannot be null") if permissions.nil?
        if _permissions = permissions
          OpenApi::EnumValidator.validate("permissions", _permissions, POST_FINANCIAL_CONNECTIONS_SESSIONS_VALID_VALUES_FOR_PERMISSIONS)
        end

        if _filters = filters
          _filters.validate if _filters.is_a?(OpenApi::Validatable)
        end
        if _return_url = return_url
          OpenApi::PrimitiveValidator.validate_max_length("return_url", return_url.to_s.size, POST_FINANCIAL_CONNECTIONS_SESSIONS_MAX_LENGTH_FOR_RETURN_URL)
        end
      end

      # resource path
      local_var_path = "/v1/financial_connections/sessions"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account_holder"] = account_holder.to_s if !account_holder.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["filters"] = filters.to_s if !filters.nil?
      form_params["permissions"] = @api_client.build_collection_param(permissions, "csv") if !permissions.nil? && !permissions.empty?
      form_params["return_url"] = return_url.to_s if !return_url.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_financial_connections_sessions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a VerificationSession object.</p>  <p>After the VerificationSession is created, display a verification modal using the session <code>client_secret</code> or send your users to the session’s <code>url</code>.</p>  <p>If your API key is in test mode, verification checks won’t actually process, though everything else will occur as if in live mode.</p>  <p>Related guide: <a href=\"/docs/identity/verify-identity-documents\">Verify your users’ identity documents</a>.</p>
    # @param _type [String?] The type of [verification check](https://stripe.com/docs/identity/verification-checks) to be performed.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param options [Stripe::SessionOptionsParam?]
    # @optional @param return_url [String?] The URL that the user will be redirected to upon completing the verification flow.
    # @return [IdentityVerificationSession]
    def post_identity_verification_sessions(*, _type : String? = nil, expand : Array(String)? = nil, options : Stripe::SessionOptionsParam? = nil, return_url : String? = nil)
      data, _status_code, _headers = post_identity_verification_sessions_with_http_info(_type: _type, expand: expand, options: options, return_url: return_url)
      data
    end

    # &lt;p&gt;Creates a VerificationSession object.&lt;/p&gt;  &lt;p&gt;After the VerificationSession is created, display a verification modal using the session &lt;code&gt;client_secret&lt;/code&gt; or send your users to the session’s &lt;code&gt;url&lt;/code&gt;.&lt;/p&gt;  &lt;p&gt;If your API key is in test mode, verification checks won’t actually process, though everything else will occur as if in live mode.&lt;/p&gt;  &lt;p&gt;Related guide: &lt;a href&#x3D;\&quot;/docs/identity/verify-identity-documents\&quot;&gt;Verify your users’ identity documents&lt;/a&gt;.&lt;/p&gt;
    # @param _type [String?] The type of [verification check](https://stripe.com/docs/identity/verification-checks) to be performed.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param options [Stripe::SessionOptionsParam?]
    # @optional @param return_url [String?] The URL that the user will be redirected to upon completing the verification flow.
    # @return [Array<(IdentityVerificationSession, Integer, Hash)>] IdentityVerificationSession data, response status code and response headers
    def post_identity_verification_sessions_with_http_info(*, _type : String? = nil, expand : Array(String)? = nil, options : Stripe::SessionOptionsParam? = nil, return_url : String? = nil)
      request = build_api_request_for_post_identity_verification_sessions(_type: _type, expand: expand, options: options, return_url: return_url)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_identity_verification_sessions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IdentityVerificationSession.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a VerificationSession object.&lt;/p&gt;  &lt;p&gt;After the VerificationSession is created, display a verification modal using the session &lt;code&gt;client_secret&lt;/code&gt; or send your users to the session’s &lt;code&gt;url&lt;/code&gt;.&lt;/p&gt;  &lt;p&gt;If your API key is in test mode, verification checks won’t actually process, though everything else will occur as if in live mode.&lt;/p&gt;  &lt;p&gt;Related guide: &lt;a href&#x3D;\&quot;/docs/identity/verify-identity-documents\&quot;&gt;Verify your users’ identity documents&lt;/a&gt;.&lt;/p&gt;
    # @param _type [String?] The type of [verification check](https://stripe.com/docs/identity/verification-checks) to be performed.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param options [Stripe::SessionOptionsParam?]
    # @optional @param return_url [String?] The URL that the user will be redirected to upon completing the verification flow.
    # @return nil
    def post_identity_verification_sessions(*, _type : String? = nil, expand : Array(String)? = nil, options : Stripe::SessionOptionsParam? = nil, return_url : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_identity_verification_sessions(_type: _type, expand: expand, options: options, return_url: return_url).execute(&block)
    end

    POST_IDENTITY_VERIFICATION_SESSIONS_VALID_VALUES_FOR__TYPE = StaticArray["document", "id_number"]

    # @return Crest::Request
    def build_api_request_for_post_identity_verification_sessions(*, _type : String? = nil, expand : Array(String)? = nil, options : Stripe::SessionOptionsParam? = nil, return_url : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_identity_verification_sessions ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"_type\" is required and cannot be null") if _type.nil?
        if __type = _type
          OpenApi::EnumValidator.validate("_type", __type, POST_IDENTITY_VERIFICATION_SESSIONS_VALID_VALUES_FOR__TYPE)
        end

        if _options = options
          _options.validate if _options.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/identity/verification_sessions"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["options"] = options.to_s if !options.nil?
      form_params["return_url"] = return_url.to_s if !return_url.nil?
      form_params["type"] = _type.to_s if !_type.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_identity_verification_sessions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates a VerificationSession object.</p>  <p>When the session status is <code>requires_input</code>, you can use this method to update the verification check and options.</p>
    # @param session [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param options [Stripe::SessionOptionsParam?]
    # @optional @param _type [String?] The type of [verification check](https://stripe.com/docs/identity/verification-checks) to be performed.
    # @return [IdentityVerificationSession]
    def post_identity_verification_sessions_session(*, session : String? = nil, expand : Array(String)? = nil, options : Stripe::SessionOptionsParam? = nil, _type : String? = nil)
      data, _status_code, _headers = post_identity_verification_sessions_session_with_http_info(session: session, expand: expand, options: options, _type: _type)
      data
    end

    # &lt;p&gt;Updates a VerificationSession object.&lt;/p&gt;  &lt;p&gt;When the session status is &lt;code&gt;requires_input&lt;/code&gt;, you can use this method to update the verification check and options.&lt;/p&gt;
    # @param session [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param options [Stripe::SessionOptionsParam?]
    # @optional @param _type [String?] The type of [verification check](https://stripe.com/docs/identity/verification-checks) to be performed.
    # @return [Array<(IdentityVerificationSession, Integer, Hash)>] IdentityVerificationSession data, response status code and response headers
    def post_identity_verification_sessions_session_with_http_info(*, session : String? = nil, expand : Array(String)? = nil, options : Stripe::SessionOptionsParam? = nil, _type : String? = nil)
      request = build_api_request_for_post_identity_verification_sessions_session(session: session, expand: expand, options: options, _type: _type)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_identity_verification_sessions_session\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IdentityVerificationSession.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates a VerificationSession object.&lt;/p&gt;  &lt;p&gt;When the session status is &lt;code&gt;requires_input&lt;/code&gt;, you can use this method to update the verification check and options.&lt;/p&gt;
    # @param session [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param options [Stripe::SessionOptionsParam?]
    # @optional @param _type [String?] The type of [verification check](https://stripe.com/docs/identity/verification-checks) to be performed.
    # @return nil
    def post_identity_verification_sessions_session(*, session : String? = nil, expand : Array(String)? = nil, options : Stripe::SessionOptionsParam? = nil, _type : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_identity_verification_sessions_session(session: session, expand: expand, options: options, _type: _type).execute(&block)
    end

    POST_IDENTITY_VERIFICATION_SESSIONS_SESSION_MAX_LENGTH_FOR_SESSION = 5000
    POST_IDENTITY_VERIFICATION_SESSIONS_SESSION_VALID_VALUES_FOR__TYPE = StaticArray["document", "id_number"]

    # @return Crest::Request
    def build_api_request_for_post_identity_verification_sessions_session(*, session : String? = nil, expand : Array(String)? = nil, options : Stripe::SessionOptionsParam? = nil, _type : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_identity_verification_sessions_session ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"session\" is required and cannot be null") if session.nil?
        if _session = session
          OpenApi::PrimitiveValidator.validate_max_length("session", session.to_s.size, POST_IDENTITY_VERIFICATION_SESSIONS_SESSION_MAX_LENGTH_FOR_SESSION)
        end

        if _options = options
          _options.validate if _options.is_a?(OpenApi::Validatable)
        end
        if __type = _type
          OpenApi::EnumValidator.validate("_type", __type, POST_IDENTITY_VERIFICATION_SESSIONS_SESSION_VALID_VALUES_FOR__TYPE)
        end
      end

      # resource path
      local_var_path = "/v1/identity/verification_sessions/{session}".sub("{" + "session" + "}", URI.encode_path(session.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["options"] = options.to_s if !options.nil?
      form_params["type"] = _type.to_s if !_type.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_identity_verification_sessions_session",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>A VerificationSession object can be canceled when it is in <code>requires_input</code> <a href=\"/docs/identity/how-sessions-work\">status</a>.</p>  <p>Once canceled, future submission attempts are disabled. This cannot be undone. <a href=\"/docs/identity/verification-sessions#cancel\">Learn more</a>.</p>
    # @param session [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [IdentityVerificationSession]
    def post_identity_verification_sessions_session_cancel(*, session : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_identity_verification_sessions_session_cancel_with_http_info(session: session, expand: expand)
      data
    end

    # &lt;p&gt;A VerificationSession object can be canceled when it is in &lt;code&gt;requires_input&lt;/code&gt; &lt;a href&#x3D;\&quot;/docs/identity/how-sessions-work\&quot;&gt;status&lt;/a&gt;.&lt;/p&gt;  &lt;p&gt;Once canceled, future submission attempts are disabled. This cannot be undone. &lt;a href&#x3D;\&quot;/docs/identity/verification-sessions#cancel\&quot;&gt;Learn more&lt;/a&gt;.&lt;/p&gt;
    # @param session [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(IdentityVerificationSession, Integer, Hash)>] IdentityVerificationSession data, response status code and response headers
    def post_identity_verification_sessions_session_cancel_with_http_info(*, session : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_identity_verification_sessions_session_cancel(session: session, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_identity_verification_sessions_session_cancel\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IdentityVerificationSession.from_json(data), status_code, headers
    end

    # &lt;p&gt;A VerificationSession object can be canceled when it is in &lt;code&gt;requires_input&lt;/code&gt; &lt;a href&#x3D;\&quot;/docs/identity/how-sessions-work\&quot;&gt;status&lt;/a&gt;.&lt;/p&gt;  &lt;p&gt;Once canceled, future submission attempts are disabled. This cannot be undone. &lt;a href&#x3D;\&quot;/docs/identity/verification-sessions#cancel\&quot;&gt;Learn more&lt;/a&gt;.&lt;/p&gt;
    # @param session [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_identity_verification_sessions_session_cancel(*, session : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_identity_verification_sessions_session_cancel(session: session, expand: expand).execute(&block)
    end

    POST_IDENTITY_VERIFICATION_SESSIONS_SESSION_CANCEL_MAX_LENGTH_FOR_SESSION = 5000

    # @return Crest::Request
    def build_api_request_for_post_identity_verification_sessions_session_cancel(*, session : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_identity_verification_sessions_session_cancel ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"session\" is required and cannot be null") if session.nil?
        if _session = session
          OpenApi::PrimitiveValidator.validate_max_length("session", session.to_s.size, POST_IDENTITY_VERIFICATION_SESSIONS_SESSION_CANCEL_MAX_LENGTH_FOR_SESSION)
        end
      end

      # resource path
      local_var_path = "/v1/identity/verification_sessions/{session}/cancel".sub("{" + "session" + "}", URI.encode_path(session.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_identity_verification_sessions_session_cancel",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Redact a VerificationSession to remove all collected information from Stripe. This will redact the VerificationSession and all objects related to it, including VerificationReports, Events, request logs, etc.</p>  <p>A VerificationSession object can be redacted when it is in <code>requires_input</code> or <code>verified</code> <a href=\"/docs/identity/how-sessions-work\">status</a>. Redacting a VerificationSession in <code>requires_action</code> state will automatically cancel it.</p>  <p>The redaction process may take up to four days. When the redaction process is in progress, the VerificationSession’s <code>redaction.status</code> field will be set to <code>processing</code>; when the process is finished, it will change to <code>redacted</code> and an <code>identity.verification_session.redacted</code> event will be emitted.</p>  <p>Redaction is irreversible. Redacted objects are still accessible in the Stripe API, but all the fields that contain personal data will be replaced by the string <code>[redacted]</code> or a similar placeholder. The <code>metadata</code> field will also be erased. Redacted objects cannot be updated or used for any purpose.</p>  <p><a href=\"/docs/identity/verification-sessions#redact\">Learn more</a>.</p>
    # @param session [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [IdentityVerificationSession]
    def post_identity_verification_sessions_session_redact(*, session : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_identity_verification_sessions_session_redact_with_http_info(session: session, expand: expand)
      data
    end

    # &lt;p&gt;Redact a VerificationSession to remove all collected information from Stripe. This will redact the VerificationSession and all objects related to it, including VerificationReports, Events, request logs, etc.&lt;/p&gt;  &lt;p&gt;A VerificationSession object can be redacted when it is in &lt;code&gt;requires_input&lt;/code&gt; or &lt;code&gt;verified&lt;/code&gt; &lt;a href&#x3D;\&quot;/docs/identity/how-sessions-work\&quot;&gt;status&lt;/a&gt;. Redacting a VerificationSession in &lt;code&gt;requires_action&lt;/code&gt; state will automatically cancel it.&lt;/p&gt;  &lt;p&gt;The redaction process may take up to four days. When the redaction process is in progress, the VerificationSession’s &lt;code&gt;redaction.status&lt;/code&gt; field will be set to &lt;code&gt;processing&lt;/code&gt;; when the process is finished, it will change to &lt;code&gt;redacted&lt;/code&gt; and an &lt;code&gt;identity.verification_session.redacted&lt;/code&gt; event will be emitted.&lt;/p&gt;  &lt;p&gt;Redaction is irreversible. Redacted objects are still accessible in the Stripe API, but all the fields that contain personal data will be replaced by the string &lt;code&gt;[redacted]&lt;/code&gt; or a similar placeholder. The &lt;code&gt;metadata&lt;/code&gt; field will also be erased. Redacted objects cannot be updated or used for any purpose.&lt;/p&gt;  &lt;p&gt;&lt;a href&#x3D;\&quot;/docs/identity/verification-sessions#redact\&quot;&gt;Learn more&lt;/a&gt;.&lt;/p&gt;
    # @param session [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(IdentityVerificationSession, Integer, Hash)>] IdentityVerificationSession data, response status code and response headers
    def post_identity_verification_sessions_session_redact_with_http_info(*, session : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_identity_verification_sessions_session_redact(session: session, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_identity_verification_sessions_session_redact\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IdentityVerificationSession.from_json(data), status_code, headers
    end

    # &lt;p&gt;Redact a VerificationSession to remove all collected information from Stripe. This will redact the VerificationSession and all objects related to it, including VerificationReports, Events, request logs, etc.&lt;/p&gt;  &lt;p&gt;A VerificationSession object can be redacted when it is in &lt;code&gt;requires_input&lt;/code&gt; or &lt;code&gt;verified&lt;/code&gt; &lt;a href&#x3D;\&quot;/docs/identity/how-sessions-work\&quot;&gt;status&lt;/a&gt;. Redacting a VerificationSession in &lt;code&gt;requires_action&lt;/code&gt; state will automatically cancel it.&lt;/p&gt;  &lt;p&gt;The redaction process may take up to four days. When the redaction process is in progress, the VerificationSession’s &lt;code&gt;redaction.status&lt;/code&gt; field will be set to &lt;code&gt;processing&lt;/code&gt;; when the process is finished, it will change to &lt;code&gt;redacted&lt;/code&gt; and an &lt;code&gt;identity.verification_session.redacted&lt;/code&gt; event will be emitted.&lt;/p&gt;  &lt;p&gt;Redaction is irreversible. Redacted objects are still accessible in the Stripe API, but all the fields that contain personal data will be replaced by the string &lt;code&gt;[redacted]&lt;/code&gt; or a similar placeholder. The &lt;code&gt;metadata&lt;/code&gt; field will also be erased. Redacted objects cannot be updated or used for any purpose.&lt;/p&gt;  &lt;p&gt;&lt;a href&#x3D;\&quot;/docs/identity/verification-sessions#redact\&quot;&gt;Learn more&lt;/a&gt;.&lt;/p&gt;
    # @param session [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_identity_verification_sessions_session_redact(*, session : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_identity_verification_sessions_session_redact(session: session, expand: expand).execute(&block)
    end

    POST_IDENTITY_VERIFICATION_SESSIONS_SESSION_REDACT_MAX_LENGTH_FOR_SESSION = 5000

    # @return Crest::Request
    def build_api_request_for_post_identity_verification_sessions_session_redact(*, session : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_identity_verification_sessions_session_redact ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"session\" is required and cannot be null") if session.nil?
        if _session = session
          OpenApi::PrimitiveValidator.validate_max_length("session", session.to_s.size, POST_IDENTITY_VERIFICATION_SESSIONS_SESSION_REDACT_MAX_LENGTH_FOR_SESSION)
        end
      end

      # resource path
      local_var_path = "/v1/identity/verification_sessions/{session}/redact".sub("{" + "session" + "}", URI.encode_path(session.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_identity_verification_sessions_session_redact",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates an item to be added to a draft invoice (up to 250 items per invoice). If no invoice is specified, the item will be on the next invoice created for the customer specified.</p>
    # @param customer [String?] The ID of the customer who will be billed when this invoice item is billed.
    # @optional @param amount [Int64?] The integer amount in cents (or local equivalent) of the charge to be applied to the upcoming invoice. Passing in a negative `amount` will reduce the `amount_due` on the invoice.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param description [String?] An arbitrary string which you can attach to the invoice item. The description is displayed in the invoice for easy tracking.
    # @optional @param discountable [Bool?] Controls whether discounts apply to this invoice item. Defaults to false for prorations or negative invoice items, and true for all other invoice items.
    # @optional @param discounts [Stripe::PostInvoiceitemsRequestDiscounts?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param invoice [String?] The ID of an existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming scheduled invoice. This is useful when adding invoice items in response to an invoice.created webhook. You can only add invoice items to draft invoices and there is a maximum of 250 items per invoice.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param period [Stripe::Period1?]
    # @optional @param price [String?] The ID of the price object.
    # @optional @param price_data [Stripe::OneTimePriceData1?]
    # @optional @param quantity [Int64?] Non-negative integer. The quantity of units for the invoice item.
    # @optional @param subscription [String?] The ID of a subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming scheduled invoice. When set, scheduled invoices for subscriptions other than the specified subscription will ignore the invoice item. Use this when you want to express that an invoice item has been accrued within the context of a particular subscription.
    # @optional @param tax_rates [Array(String)?] The tax rates which apply to the invoice item. When set, the `default_tax_rates` on the invoice do not apply to this invoice item.
    # @optional @param unit_amount [Int64?] The integer unit amount in cents (or local equivalent) of the charge to be applied to the upcoming invoice. This `unit_amount` will be multiplied by the quantity to get the full amount. Passing in a negative `unit_amount` will reduce the `amount_due` on the invoice.
    # @optional @param unit_amount_decimal [String?] Same as `unit_amount`, but accepts a decimal value in cents (or local equivalent) with at most 12 decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
    # @return [Invoiceitem]
    def post_invoiceitems(*, customer : String? = nil, amount : Int64? = nil, currency : String? = nil, description : String? = nil, discountable : Bool? = nil, discounts : Stripe::PostInvoiceitemsRequestDiscounts? = nil, expand : Array(String)? = nil, invoice : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, period : Stripe::Period1? = nil, price : String? = nil, price_data : Stripe::OneTimePriceData1? = nil, quantity : Int64? = nil, subscription : String? = nil, tax_rates : Array(String)? = nil, unit_amount : Int64? = nil, unit_amount_decimal : String? = nil)
      data, _status_code, _headers = post_invoiceitems_with_http_info(customer: customer, amount: amount, currency: currency, description: description, discountable: discountable, discounts: discounts, expand: expand, invoice: invoice, metadata: metadata, period: period, price: price, price_data: price_data, quantity: quantity, subscription: subscription, tax_rates: tax_rates, unit_amount: unit_amount, unit_amount_decimal: unit_amount_decimal)
      data
    end

    # &lt;p&gt;Creates an item to be added to a draft invoice (up to 250 items per invoice). If no invoice is specified, the item will be on the next invoice created for the customer specified.&lt;/p&gt;
    # @param customer [String?] The ID of the customer who will be billed when this invoice item is billed.
    # @optional @param amount [Int64?] The integer amount in cents (or local equivalent) of the charge to be applied to the upcoming invoice. Passing in a negative `amount` will reduce the `amount_due` on the invoice.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param description [String?] An arbitrary string which you can attach to the invoice item. The description is displayed in the invoice for easy tracking.
    # @optional @param discountable [Bool?] Controls whether discounts apply to this invoice item. Defaults to false for prorations or negative invoice items, and true for all other invoice items.
    # @optional @param discounts [Stripe::PostInvoiceitemsRequestDiscounts?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param invoice [String?] The ID of an existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming scheduled invoice. This is useful when adding invoice items in response to an invoice.created webhook. You can only add invoice items to draft invoices and there is a maximum of 250 items per invoice.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param period [Stripe::Period1?]
    # @optional @param price [String?] The ID of the price object.
    # @optional @param price_data [Stripe::OneTimePriceData1?]
    # @optional @param quantity [Int64?] Non-negative integer. The quantity of units for the invoice item.
    # @optional @param subscription [String?] The ID of a subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming scheduled invoice. When set, scheduled invoices for subscriptions other than the specified subscription will ignore the invoice item. Use this when you want to express that an invoice item has been accrued within the context of a particular subscription.
    # @optional @param tax_rates [Array(String)?] The tax rates which apply to the invoice item. When set, the `default_tax_rates` on the invoice do not apply to this invoice item.
    # @optional @param unit_amount [Int64?] The integer unit amount in cents (or local equivalent) of the charge to be applied to the upcoming invoice. This `unit_amount` will be multiplied by the quantity to get the full amount. Passing in a negative `unit_amount` will reduce the `amount_due` on the invoice.
    # @optional @param unit_amount_decimal [String?] Same as `unit_amount`, but accepts a decimal value in cents (or local equivalent) with at most 12 decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
    # @return [Array<(Invoiceitem, Integer, Hash)>] Invoiceitem data, response status code and response headers
    def post_invoiceitems_with_http_info(*, customer : String? = nil, amount : Int64? = nil, currency : String? = nil, description : String? = nil, discountable : Bool? = nil, discounts : Stripe::PostInvoiceitemsRequestDiscounts? = nil, expand : Array(String)? = nil, invoice : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, period : Stripe::Period1? = nil, price : String? = nil, price_data : Stripe::OneTimePriceData1? = nil, quantity : Int64? = nil, subscription : String? = nil, tax_rates : Array(String)? = nil, unit_amount : Int64? = nil, unit_amount_decimal : String? = nil)
      request = build_api_request_for_post_invoiceitems(customer: customer, amount: amount, currency: currency, description: description, discountable: discountable, discounts: discounts, expand: expand, invoice: invoice, metadata: metadata, period: period, price: price, price_data: price_data, quantity: quantity, subscription: subscription, tax_rates: tax_rates, unit_amount: unit_amount, unit_amount_decimal: unit_amount_decimal)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_invoiceitems\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Invoiceitem.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates an item to be added to a draft invoice (up to 250 items per invoice). If no invoice is specified, the item will be on the next invoice created for the customer specified.&lt;/p&gt;
    # @param customer [String?] The ID of the customer who will be billed when this invoice item is billed.
    # @optional @param amount [Int64?] The integer amount in cents (or local equivalent) of the charge to be applied to the upcoming invoice. Passing in a negative `amount` will reduce the `amount_due` on the invoice.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param description [String?] An arbitrary string which you can attach to the invoice item. The description is displayed in the invoice for easy tracking.
    # @optional @param discountable [Bool?] Controls whether discounts apply to this invoice item. Defaults to false for prorations or negative invoice items, and true for all other invoice items.
    # @optional @param discounts [Stripe::PostInvoiceitemsRequestDiscounts?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param invoice [String?] The ID of an existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming scheduled invoice. This is useful when adding invoice items in response to an invoice.created webhook. You can only add invoice items to draft invoices and there is a maximum of 250 items per invoice.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param period [Stripe::Period1?]
    # @optional @param price [String?] The ID of the price object.
    # @optional @param price_data [Stripe::OneTimePriceData1?]
    # @optional @param quantity [Int64?] Non-negative integer. The quantity of units for the invoice item.
    # @optional @param subscription [String?] The ID of a subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming scheduled invoice. When set, scheduled invoices for subscriptions other than the specified subscription will ignore the invoice item. Use this when you want to express that an invoice item has been accrued within the context of a particular subscription.
    # @optional @param tax_rates [Array(String)?] The tax rates which apply to the invoice item. When set, the `default_tax_rates` on the invoice do not apply to this invoice item.
    # @optional @param unit_amount [Int64?] The integer unit amount in cents (or local equivalent) of the charge to be applied to the upcoming invoice. This `unit_amount` will be multiplied by the quantity to get the full amount. Passing in a negative `unit_amount` will reduce the `amount_due` on the invoice.
    # @optional @param unit_amount_decimal [String?] Same as `unit_amount`, but accepts a decimal value in cents (or local equivalent) with at most 12 decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
    # @return nil
    def post_invoiceitems(*, customer : String? = nil, amount : Int64? = nil, currency : String? = nil, description : String? = nil, discountable : Bool? = nil, discounts : Stripe::PostInvoiceitemsRequestDiscounts? = nil, expand : Array(String)? = nil, invoice : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, period : Stripe::Period1? = nil, price : String? = nil, price_data : Stripe::OneTimePriceData1? = nil, quantity : Int64? = nil, subscription : String? = nil, tax_rates : Array(String)? = nil, unit_amount : Int64? = nil, unit_amount_decimal : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_invoiceitems(customer: customer, amount: amount, currency: currency, description: description, discountable: discountable, discounts: discounts, expand: expand, invoice: invoice, metadata: metadata, period: period, price: price, price_data: price_data, quantity: quantity, subscription: subscription, tax_rates: tax_rates, unit_amount: unit_amount, unit_amount_decimal: unit_amount_decimal).execute(&block)
    end

    POST_INVOICEITEMS_MAX_LENGTH_FOR_CUSTOMER     = 5000
    POST_INVOICEITEMS_MAX_LENGTH_FOR_DESCRIPTION  = 5000
    POST_INVOICEITEMS_MAX_LENGTH_FOR_INVOICE      = 5000
    POST_INVOICEITEMS_MAX_LENGTH_FOR_PRICE        = 5000
    POST_INVOICEITEMS_MAX_LENGTH_FOR_SUBSCRIPTION = 5000

    # @return Crest::Request
    def build_api_request_for_post_invoiceitems(*, customer : String? = nil, amount : Int64? = nil, currency : String? = nil, description : String? = nil, discountable : Bool? = nil, discounts : Stripe::PostInvoiceitemsRequestDiscounts? = nil, expand : Array(String)? = nil, invoice : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, period : Stripe::Period1? = nil, price : String? = nil, price_data : Stripe::OneTimePriceData1? = nil, quantity : Int64? = nil, subscription : String? = nil, tax_rates : Array(String)? = nil, unit_amount : Int64? = nil, unit_amount_decimal : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_invoiceitems ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_INVOICEITEMS_MAX_LENGTH_FOR_CUSTOMER)
        end

        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_INVOICEITEMS_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _discounts = discounts
          _discounts.validate if _discounts.is_a?(OpenApi::Validatable)
        end

        if _invoice = invoice
          OpenApi::PrimitiveValidator.validate_max_length("invoice", invoice.to_s.size, POST_INVOICEITEMS_MAX_LENGTH_FOR_INVOICE)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _period = period
          _period.validate if _period.is_a?(OpenApi::Validatable)
        end
        if _price = price
          OpenApi::PrimitiveValidator.validate_max_length("price", price.to_s.size, POST_INVOICEITEMS_MAX_LENGTH_FOR_PRICE)
        end
        if _price_data = price_data
          _price_data.validate if _price_data.is_a?(OpenApi::Validatable)
        end

        if _subscription = subscription
          OpenApi::PrimitiveValidator.validate_max_length("subscription", subscription.to_s.size, POST_INVOICEITEMS_MAX_LENGTH_FOR_SUBSCRIPTION)
        end
      end

      # resource path
      local_var_path = "/v1/invoiceitems"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["discountable"] = discountable.to_s if !discountable.nil?
      form_params["discounts"] = discounts.to_s if !discounts.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["invoice"] = invoice.to_s if !invoice.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["period"] = period.to_s if !period.nil?
      form_params["price"] = price.to_s if !price.nil?
      form_params["price_data"] = price_data.to_s if !price_data.nil?
      form_params["quantity"] = quantity.to_s if !quantity.nil?
      form_params["subscription"] = subscription.to_s if !subscription.nil?
      form_params["tax_rates"] = @api_client.build_collection_param(tax_rates, "csv") if !tax_rates.nil? && !tax_rates.empty?
      form_params["unit_amount"] = unit_amount.to_s if !unit_amount.nil?
      form_params["unit_amount_decimal"] = unit_amount_decimal.to_s if !unit_amount_decimal.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_invoiceitems",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the amount or description of an invoice item on an upcoming invoice. Updating an invoice item is only possible before the invoice it’s attached to is closed.</p>
    # @param invoiceitem [String?]
    # @optional @param amount [Int64?] The integer amount in cents (or local equivalent) of the charge to be applied to the upcoming invoice. If you want to apply a credit to the customer's account, pass a negative amount.
    # @optional @param description [String?] An arbitrary string which you can attach to the invoice item. The description is displayed in the invoice for easy tracking.
    # @optional @param discountable [Bool?] Controls whether discounts apply to this invoice item. Defaults to false for prorations or negative invoice items, and true for all other invoice items. Cannot be set to true for prorations.
    # @optional @param discounts [Stripe::PostInvoiceitemsInvoiceitemRequestDiscounts?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param period [Stripe::Period1?]
    # @optional @param price [String?] The ID of the price object.
    # @optional @param price_data [Stripe::OneTimePriceData1?]
    # @optional @param quantity [Int64?] Non-negative integer. The quantity of units for the invoice item.
    # @optional @param tax_rates [Stripe::PostInvoiceitemsInvoiceitemRequestTaxRates?]
    # @optional @param unit_amount [Int64?] The integer unit amount in cents (or local equivalent) of the charge to be applied to the upcoming invoice. This unit_amount will be multiplied by the quantity to get the full amount. If you want to apply a credit to the customer's account, pass a negative unit_amount.
    # @optional @param unit_amount_decimal [String?] Same as `unit_amount`, but accepts a decimal value in cents (or local equivalent) with at most 12 decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
    # @return [Invoiceitem]
    def post_invoiceitems_invoiceitem(*, invoiceitem : String? = nil, amount : Int64? = nil, description : String? = nil, discountable : Bool? = nil, discounts : Stripe::PostInvoiceitemsInvoiceitemRequestDiscounts? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, period : Stripe::Period1? = nil, price : String? = nil, price_data : Stripe::OneTimePriceData1? = nil, quantity : Int64? = nil, tax_rates : Stripe::PostInvoiceitemsInvoiceitemRequestTaxRates? = nil, unit_amount : Int64? = nil, unit_amount_decimal : String? = nil)
      data, _status_code, _headers = post_invoiceitems_invoiceitem_with_http_info(invoiceitem: invoiceitem, amount: amount, description: description, discountable: discountable, discounts: discounts, expand: expand, metadata: metadata, period: period, price: price, price_data: price_data, quantity: quantity, tax_rates: tax_rates, unit_amount: unit_amount, unit_amount_decimal: unit_amount_decimal)
      data
    end

    # &lt;p&gt;Updates the amount or description of an invoice item on an upcoming invoice. Updating an invoice item is only possible before the invoice it’s attached to is closed.&lt;/p&gt;
    # @param invoiceitem [String?]
    # @optional @param amount [Int64?] The integer amount in cents (or local equivalent) of the charge to be applied to the upcoming invoice. If you want to apply a credit to the customer's account, pass a negative amount.
    # @optional @param description [String?] An arbitrary string which you can attach to the invoice item. The description is displayed in the invoice for easy tracking.
    # @optional @param discountable [Bool?] Controls whether discounts apply to this invoice item. Defaults to false for prorations or negative invoice items, and true for all other invoice items. Cannot be set to true for prorations.
    # @optional @param discounts [Stripe::PostInvoiceitemsInvoiceitemRequestDiscounts?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param period [Stripe::Period1?]
    # @optional @param price [String?] The ID of the price object.
    # @optional @param price_data [Stripe::OneTimePriceData1?]
    # @optional @param quantity [Int64?] Non-negative integer. The quantity of units for the invoice item.
    # @optional @param tax_rates [Stripe::PostInvoiceitemsInvoiceitemRequestTaxRates?]
    # @optional @param unit_amount [Int64?] The integer unit amount in cents (or local equivalent) of the charge to be applied to the upcoming invoice. This unit_amount will be multiplied by the quantity to get the full amount. If you want to apply a credit to the customer's account, pass a negative unit_amount.
    # @optional @param unit_amount_decimal [String?] Same as `unit_amount`, but accepts a decimal value in cents (or local equivalent) with at most 12 decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
    # @return [Array<(Invoiceitem, Integer, Hash)>] Invoiceitem data, response status code and response headers
    def post_invoiceitems_invoiceitem_with_http_info(*, invoiceitem : String? = nil, amount : Int64? = nil, description : String? = nil, discountable : Bool? = nil, discounts : Stripe::PostInvoiceitemsInvoiceitemRequestDiscounts? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, period : Stripe::Period1? = nil, price : String? = nil, price_data : Stripe::OneTimePriceData1? = nil, quantity : Int64? = nil, tax_rates : Stripe::PostInvoiceitemsInvoiceitemRequestTaxRates? = nil, unit_amount : Int64? = nil, unit_amount_decimal : String? = nil)
      request = build_api_request_for_post_invoiceitems_invoiceitem(invoiceitem: invoiceitem, amount: amount, description: description, discountable: discountable, discounts: discounts, expand: expand, metadata: metadata, period: period, price: price, price_data: price_data, quantity: quantity, tax_rates: tax_rates, unit_amount: unit_amount, unit_amount_decimal: unit_amount_decimal)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_invoiceitems_invoiceitem\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Invoiceitem.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the amount or description of an invoice item on an upcoming invoice. Updating an invoice item is only possible before the invoice it’s attached to is closed.&lt;/p&gt;
    # @param invoiceitem [String?]
    # @optional @param amount [Int64?] The integer amount in cents (or local equivalent) of the charge to be applied to the upcoming invoice. If you want to apply a credit to the customer's account, pass a negative amount.
    # @optional @param description [String?] An arbitrary string which you can attach to the invoice item. The description is displayed in the invoice for easy tracking.
    # @optional @param discountable [Bool?] Controls whether discounts apply to this invoice item. Defaults to false for prorations or negative invoice items, and true for all other invoice items. Cannot be set to true for prorations.
    # @optional @param discounts [Stripe::PostInvoiceitemsInvoiceitemRequestDiscounts?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param period [Stripe::Period1?]
    # @optional @param price [String?] The ID of the price object.
    # @optional @param price_data [Stripe::OneTimePriceData1?]
    # @optional @param quantity [Int64?] Non-negative integer. The quantity of units for the invoice item.
    # @optional @param tax_rates [Stripe::PostInvoiceitemsInvoiceitemRequestTaxRates?]
    # @optional @param unit_amount [Int64?] The integer unit amount in cents (or local equivalent) of the charge to be applied to the upcoming invoice. This unit_amount will be multiplied by the quantity to get the full amount. If you want to apply a credit to the customer's account, pass a negative unit_amount.
    # @optional @param unit_amount_decimal [String?] Same as `unit_amount`, but accepts a decimal value in cents (or local equivalent) with at most 12 decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
    # @return nil
    def post_invoiceitems_invoiceitem(*, invoiceitem : String? = nil, amount : Int64? = nil, description : String? = nil, discountable : Bool? = nil, discounts : Stripe::PostInvoiceitemsInvoiceitemRequestDiscounts? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, period : Stripe::Period1? = nil, price : String? = nil, price_data : Stripe::OneTimePriceData1? = nil, quantity : Int64? = nil, tax_rates : Stripe::PostInvoiceitemsInvoiceitemRequestTaxRates? = nil, unit_amount : Int64? = nil, unit_amount_decimal : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_invoiceitems_invoiceitem(invoiceitem: invoiceitem, amount: amount, description: description, discountable: discountable, discounts: discounts, expand: expand, metadata: metadata, period: period, price: price, price_data: price_data, quantity: quantity, tax_rates: tax_rates, unit_amount: unit_amount, unit_amount_decimal: unit_amount_decimal).execute(&block)
    end

    POST_INVOICEITEMS_INVOICEITEM_MAX_LENGTH_FOR_INVOICEITEM = 5000
    POST_INVOICEITEMS_INVOICEITEM_MAX_LENGTH_FOR_DESCRIPTION = 5000
    POST_INVOICEITEMS_INVOICEITEM_MAX_LENGTH_FOR_PRICE       = 5000

    # @return Crest::Request
    def build_api_request_for_post_invoiceitems_invoiceitem(*, invoiceitem : String? = nil, amount : Int64? = nil, description : String? = nil, discountable : Bool? = nil, discounts : Stripe::PostInvoiceitemsInvoiceitemRequestDiscounts? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, period : Stripe::Period1? = nil, price : String? = nil, price_data : Stripe::OneTimePriceData1? = nil, quantity : Int64? = nil, tax_rates : Stripe::PostInvoiceitemsInvoiceitemRequestTaxRates? = nil, unit_amount : Int64? = nil, unit_amount_decimal : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_invoiceitems_invoiceitem ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"invoiceitem\" is required and cannot be null") if invoiceitem.nil?
        if _invoiceitem = invoiceitem
          OpenApi::PrimitiveValidator.validate_max_length("invoiceitem", invoiceitem.to_s.size, POST_INVOICEITEMS_INVOICEITEM_MAX_LENGTH_FOR_INVOICEITEM)
        end

        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_INVOICEITEMS_INVOICEITEM_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _discounts = discounts
          _discounts.validate if _discounts.is_a?(OpenApi::Validatable)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _period = period
          _period.validate if _period.is_a?(OpenApi::Validatable)
        end
        if _price = price
          OpenApi::PrimitiveValidator.validate_max_length("price", price.to_s.size, POST_INVOICEITEMS_INVOICEITEM_MAX_LENGTH_FOR_PRICE)
        end
        if _price_data = price_data
          _price_data.validate if _price_data.is_a?(OpenApi::Validatable)
        end

        if _tax_rates = tax_rates
          _tax_rates.validate if _tax_rates.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/invoiceitems/{invoiceitem}".sub("{" + "invoiceitem" + "}", URI.encode_path(invoiceitem.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["discountable"] = discountable.to_s if !discountable.nil?
      form_params["discounts"] = discounts.to_s if !discounts.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["period"] = period.to_s if !period.nil?
      form_params["price"] = price.to_s if !price.nil?
      form_params["price_data"] = price_data.to_s if !price_data.nil?
      form_params["quantity"] = quantity.to_s if !quantity.nil?
      form_params["tax_rates"] = tax_rates.to_s if !tax_rates.nil?
      form_params["unit_amount"] = unit_amount.to_s if !unit_amount.nil?
      form_params["unit_amount_decimal"] = unit_amount_decimal.to_s if !unit_amount_decimal.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_invoiceitems_invoiceitem",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>This endpoint creates a draft invoice for a given customer. The invoice remains a draft until you <a href=\"#finalize_invoice\">finalize</a> the invoice, which allows you to <a href=\"#pay_invoice\">pay</a> or <a href=\"#send_invoice\">send</a> the invoice to your customers.</p>
    # @optional @param account_tax_ids [Stripe::PostInvoicesRequestAccountTaxIds?]
    # @optional @param application_fee_amount [Int64?] A fee in cents (or local equivalent) that will be applied to the invoice and transferred to the application owner's Stripe account. The request must be made with an OAuth key or the Stripe-Account header in order to take an application fee. For more information, see the application fees [documentation](https://stripe.com/docs/billing/invoices/connect#collecting-fees).
    # @optional @param auto_advance [Bool?] Controls whether Stripe will perform [automatic collection](https://stripe.com/docs/billing/invoices/workflow/#auto_advance) of the invoice. When `false`, the invoice's state will not automatically advance without an explicit action.
    # @optional @param automatic_tax [Stripe::AutomaticTaxParam?]
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this invoice using the default source attached to the customer. When sending an invoice, Stripe will email this invoice to the customer with payment instructions. Defaults to `charge_automatically`.
    # @optional @param currency [String?] The currency to create this invoice in. Defaults to that of `customer` if not specified.
    # @optional @param custom_fields [Stripe::PostInvoicesRequestCustomFields?]
    # @optional @param customer [String?] The ID of the customer who will be billed.
    # @optional @param days_until_due [Int64?] The number of days from when the invoice is created until it is due. Valid only for invoices where `collection_method=send_invoice`.
    # @optional @param default_payment_method [String?] ID of the default payment method for the invoice. It must belong to the customer associated with the invoice. If not set, defaults to the subscription's default payment method, if any, or to the default payment method in the customer's invoice settings.
    # @optional @param default_source [String?] ID of the default payment source for the invoice. It must belong to the customer associated with the invoice and be in a chargeable state. If not set, defaults to the subscription's default source, if any, or to the customer's default source.
    # @optional @param default_tax_rates [Array(String)?] The tax rates that will apply to any line item that does not have `tax_rates` set.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users. Referenced as 'memo' in the Dashboard.
    # @optional @param discounts [Stripe::PostInvoicesRequestDiscounts?]
    # @optional @param due_date [Int64?] The date on which payment for this invoice is due. Valid only for invoices where `collection_method=send_invoice`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param footer [String?] Footer to be displayed on the invoice.
    # @optional @param from_invoice [Stripe::FromInvoice?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param on_behalf_of [String?] The account (if any) for which the funds of the invoice payment are intended. If set, the invoice will be presented with the branding and support information of the specified account. See the [Invoices with Connect](https://stripe.com/docs/billing/invoices/connect) documentation for details.
    # @optional @param payment_settings [Stripe::PaymentSettings1?]
    # @optional @param pending_invoice_items_behavior [String?] How to handle pending invoice items on invoice creation. One of `include` or `exclude`. `include` will include any pending invoice items, and will create an empty draft invoice if no pending invoice items exist. `exclude` will always create an empty invoice draft regardless if there are pending invoice items or not. Defaults to `exclude` if the parameter is omitted.
    # @optional @param rendering_options [Stripe::PostInvoicesRequestRenderingOptions?]
    # @optional @param statement_descriptor [String?] Extra information about a charge for the customer's credit card statement. It must contain at least one letter. If not specified and this invoice is part of a subscription, the default `statement_descriptor` will be set to the first subscription item's product's `statement_descriptor`.
    # @optional @param subscription [String?] The ID of the subscription to invoice, if any. If set, the created invoice will only include pending invoice items for that subscription and pending invoice items not associated with any subscription if `pending_invoice_items_behavior` is `include`. The subscription's billing cycle and regular subscription events won't be affected.
    # @optional @param transfer_data [Stripe::TransferDataSpecs4?]
    # @return [Invoice]
    def post_invoices(*, account_tax_ids : Stripe::PostInvoicesRequestAccountTaxIds? = nil, application_fee_amount : Int64? = nil, auto_advance : Bool? = nil, automatic_tax : Stripe::AutomaticTaxParam? = nil, collection_method : String? = nil, currency : String? = nil, custom_fields : Stripe::PostInvoicesRequestCustomFields? = nil, customer : String? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Array(String)? = nil, description : String? = nil, discounts : Stripe::PostInvoicesRequestDiscounts? = nil, due_date : Int64? = nil, expand : Array(String)? = nil, footer : String? = nil, from_invoice : Stripe::FromInvoice? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, on_behalf_of : String? = nil, payment_settings : Stripe::PaymentSettings1? = nil, pending_invoice_items_behavior : String? = nil, rendering_options : Stripe::PostInvoicesRequestRenderingOptions? = nil, statement_descriptor : String? = nil, subscription : String? = nil, transfer_data : Stripe::TransferDataSpecs4? = nil)
      data, _status_code, _headers = post_invoices_with_http_info(account_tax_ids: account_tax_ids, application_fee_amount: application_fee_amount, auto_advance: auto_advance, automatic_tax: automatic_tax, collection_method: collection_method, currency: currency, custom_fields: custom_fields, customer: customer, days_until_due: days_until_due, default_payment_method: default_payment_method, default_source: default_source, default_tax_rates: default_tax_rates, description: description, discounts: discounts, due_date: due_date, expand: expand, footer: footer, from_invoice: from_invoice, metadata: metadata, on_behalf_of: on_behalf_of, payment_settings: payment_settings, pending_invoice_items_behavior: pending_invoice_items_behavior, rendering_options: rendering_options, statement_descriptor: statement_descriptor, subscription: subscription, transfer_data: transfer_data)
      data
    end

    # &lt;p&gt;This endpoint creates a draft invoice for a given customer. The invoice remains a draft until you &lt;a href&#x3D;\&quot;#finalize_invoice\&quot;&gt;finalize&lt;/a&gt; the invoice, which allows you to &lt;a href&#x3D;\&quot;#pay_invoice\&quot;&gt;pay&lt;/a&gt; or &lt;a href&#x3D;\&quot;#send_invoice\&quot;&gt;send&lt;/a&gt; the invoice to your customers.&lt;/p&gt;
    # @optional @param account_tax_ids [Stripe::PostInvoicesRequestAccountTaxIds?]
    # @optional @param application_fee_amount [Int64?] A fee in cents (or local equivalent) that will be applied to the invoice and transferred to the application owner's Stripe account. The request must be made with an OAuth key or the Stripe-Account header in order to take an application fee. For more information, see the application fees [documentation](https://stripe.com/docs/billing/invoices/connect#collecting-fees).
    # @optional @param auto_advance [Bool?] Controls whether Stripe will perform [automatic collection](https://stripe.com/docs/billing/invoices/workflow/#auto_advance) of the invoice. When `false`, the invoice's state will not automatically advance without an explicit action.
    # @optional @param automatic_tax [Stripe::AutomaticTaxParam?]
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this invoice using the default source attached to the customer. When sending an invoice, Stripe will email this invoice to the customer with payment instructions. Defaults to `charge_automatically`.
    # @optional @param currency [String?] The currency to create this invoice in. Defaults to that of `customer` if not specified.
    # @optional @param custom_fields [Stripe::PostInvoicesRequestCustomFields?]
    # @optional @param customer [String?] The ID of the customer who will be billed.
    # @optional @param days_until_due [Int64?] The number of days from when the invoice is created until it is due. Valid only for invoices where `collection_method=send_invoice`.
    # @optional @param default_payment_method [String?] ID of the default payment method for the invoice. It must belong to the customer associated with the invoice. If not set, defaults to the subscription's default payment method, if any, or to the default payment method in the customer's invoice settings.
    # @optional @param default_source [String?] ID of the default payment source for the invoice. It must belong to the customer associated with the invoice and be in a chargeable state. If not set, defaults to the subscription's default source, if any, or to the customer's default source.
    # @optional @param default_tax_rates [Array(String)?] The tax rates that will apply to any line item that does not have `tax_rates` set.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users. Referenced as 'memo' in the Dashboard.
    # @optional @param discounts [Stripe::PostInvoicesRequestDiscounts?]
    # @optional @param due_date [Int64?] The date on which payment for this invoice is due. Valid only for invoices where `collection_method=send_invoice`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param footer [String?] Footer to be displayed on the invoice.
    # @optional @param from_invoice [Stripe::FromInvoice?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param on_behalf_of [String?] The account (if any) for which the funds of the invoice payment are intended. If set, the invoice will be presented with the branding and support information of the specified account. See the [Invoices with Connect](https://stripe.com/docs/billing/invoices/connect) documentation for details.
    # @optional @param payment_settings [Stripe::PaymentSettings1?]
    # @optional @param pending_invoice_items_behavior [String?] How to handle pending invoice items on invoice creation. One of `include` or `exclude`. `include` will include any pending invoice items, and will create an empty draft invoice if no pending invoice items exist. `exclude` will always create an empty invoice draft regardless if there are pending invoice items or not. Defaults to `exclude` if the parameter is omitted.
    # @optional @param rendering_options [Stripe::PostInvoicesRequestRenderingOptions?]
    # @optional @param statement_descriptor [String?] Extra information about a charge for the customer's credit card statement. It must contain at least one letter. If not specified and this invoice is part of a subscription, the default `statement_descriptor` will be set to the first subscription item's product's `statement_descriptor`.
    # @optional @param subscription [String?] The ID of the subscription to invoice, if any. If set, the created invoice will only include pending invoice items for that subscription and pending invoice items not associated with any subscription if `pending_invoice_items_behavior` is `include`. The subscription's billing cycle and regular subscription events won't be affected.
    # @optional @param transfer_data [Stripe::TransferDataSpecs4?]
    # @return [Array<(Invoice, Integer, Hash)>] Invoice data, response status code and response headers
    def post_invoices_with_http_info(*, account_tax_ids : Stripe::PostInvoicesRequestAccountTaxIds? = nil, application_fee_amount : Int64? = nil, auto_advance : Bool? = nil, automatic_tax : Stripe::AutomaticTaxParam? = nil, collection_method : String? = nil, currency : String? = nil, custom_fields : Stripe::PostInvoicesRequestCustomFields? = nil, customer : String? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Array(String)? = nil, description : String? = nil, discounts : Stripe::PostInvoicesRequestDiscounts? = nil, due_date : Int64? = nil, expand : Array(String)? = nil, footer : String? = nil, from_invoice : Stripe::FromInvoice? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, on_behalf_of : String? = nil, payment_settings : Stripe::PaymentSettings1? = nil, pending_invoice_items_behavior : String? = nil, rendering_options : Stripe::PostInvoicesRequestRenderingOptions? = nil, statement_descriptor : String? = nil, subscription : String? = nil, transfer_data : Stripe::TransferDataSpecs4? = nil)
      request = build_api_request_for_post_invoices(account_tax_ids: account_tax_ids, application_fee_amount: application_fee_amount, auto_advance: auto_advance, automatic_tax: automatic_tax, collection_method: collection_method, currency: currency, custom_fields: custom_fields, customer: customer, days_until_due: days_until_due, default_payment_method: default_payment_method, default_source: default_source, default_tax_rates: default_tax_rates, description: description, discounts: discounts, due_date: due_date, expand: expand, footer: footer, from_invoice: from_invoice, metadata: metadata, on_behalf_of: on_behalf_of, payment_settings: payment_settings, pending_invoice_items_behavior: pending_invoice_items_behavior, rendering_options: rendering_options, statement_descriptor: statement_descriptor, subscription: subscription, transfer_data: transfer_data)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_invoices\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Invoice.from_json(data), status_code, headers
    end

    # &lt;p&gt;This endpoint creates a draft invoice for a given customer. The invoice remains a draft until you &lt;a href&#x3D;\&quot;#finalize_invoice\&quot;&gt;finalize&lt;/a&gt; the invoice, which allows you to &lt;a href&#x3D;\&quot;#pay_invoice\&quot;&gt;pay&lt;/a&gt; or &lt;a href&#x3D;\&quot;#send_invoice\&quot;&gt;send&lt;/a&gt; the invoice to your customers.&lt;/p&gt;
    # @optional @param account_tax_ids [Stripe::PostInvoicesRequestAccountTaxIds?]
    # @optional @param application_fee_amount [Int64?] A fee in cents (or local equivalent) that will be applied to the invoice and transferred to the application owner's Stripe account. The request must be made with an OAuth key or the Stripe-Account header in order to take an application fee. For more information, see the application fees [documentation](https://stripe.com/docs/billing/invoices/connect#collecting-fees).
    # @optional @param auto_advance [Bool?] Controls whether Stripe will perform [automatic collection](https://stripe.com/docs/billing/invoices/workflow/#auto_advance) of the invoice. When `false`, the invoice's state will not automatically advance without an explicit action.
    # @optional @param automatic_tax [Stripe::AutomaticTaxParam?]
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this invoice using the default source attached to the customer. When sending an invoice, Stripe will email this invoice to the customer with payment instructions. Defaults to `charge_automatically`.
    # @optional @param currency [String?] The currency to create this invoice in. Defaults to that of `customer` if not specified.
    # @optional @param custom_fields [Stripe::PostInvoicesRequestCustomFields?]
    # @optional @param customer [String?] The ID of the customer who will be billed.
    # @optional @param days_until_due [Int64?] The number of days from when the invoice is created until it is due. Valid only for invoices where `collection_method=send_invoice`.
    # @optional @param default_payment_method [String?] ID of the default payment method for the invoice. It must belong to the customer associated with the invoice. If not set, defaults to the subscription's default payment method, if any, or to the default payment method in the customer's invoice settings.
    # @optional @param default_source [String?] ID of the default payment source for the invoice. It must belong to the customer associated with the invoice and be in a chargeable state. If not set, defaults to the subscription's default source, if any, or to the customer's default source.
    # @optional @param default_tax_rates [Array(String)?] The tax rates that will apply to any line item that does not have `tax_rates` set.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users. Referenced as 'memo' in the Dashboard.
    # @optional @param discounts [Stripe::PostInvoicesRequestDiscounts?]
    # @optional @param due_date [Int64?] The date on which payment for this invoice is due. Valid only for invoices where `collection_method=send_invoice`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param footer [String?] Footer to be displayed on the invoice.
    # @optional @param from_invoice [Stripe::FromInvoice?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param on_behalf_of [String?] The account (if any) for which the funds of the invoice payment are intended. If set, the invoice will be presented with the branding and support information of the specified account. See the [Invoices with Connect](https://stripe.com/docs/billing/invoices/connect) documentation for details.
    # @optional @param payment_settings [Stripe::PaymentSettings1?]
    # @optional @param pending_invoice_items_behavior [String?] How to handle pending invoice items on invoice creation. One of `include` or `exclude`. `include` will include any pending invoice items, and will create an empty draft invoice if no pending invoice items exist. `exclude` will always create an empty invoice draft regardless if there are pending invoice items or not. Defaults to `exclude` if the parameter is omitted.
    # @optional @param rendering_options [Stripe::PostInvoicesRequestRenderingOptions?]
    # @optional @param statement_descriptor [String?] Extra information about a charge for the customer's credit card statement. It must contain at least one letter. If not specified and this invoice is part of a subscription, the default `statement_descriptor` will be set to the first subscription item's product's `statement_descriptor`.
    # @optional @param subscription [String?] The ID of the subscription to invoice, if any. If set, the created invoice will only include pending invoice items for that subscription and pending invoice items not associated with any subscription if `pending_invoice_items_behavior` is `include`. The subscription's billing cycle and regular subscription events won't be affected.
    # @optional @param transfer_data [Stripe::TransferDataSpecs4?]
    # @return nil
    def post_invoices(*, account_tax_ids : Stripe::PostInvoicesRequestAccountTaxIds? = nil, application_fee_amount : Int64? = nil, auto_advance : Bool? = nil, automatic_tax : Stripe::AutomaticTaxParam? = nil, collection_method : String? = nil, currency : String? = nil, custom_fields : Stripe::PostInvoicesRequestCustomFields? = nil, customer : String? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Array(String)? = nil, description : String? = nil, discounts : Stripe::PostInvoicesRequestDiscounts? = nil, due_date : Int64? = nil, expand : Array(String)? = nil, footer : String? = nil, from_invoice : Stripe::FromInvoice? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, on_behalf_of : String? = nil, payment_settings : Stripe::PaymentSettings1? = nil, pending_invoice_items_behavior : String? = nil, rendering_options : Stripe::PostInvoicesRequestRenderingOptions? = nil, statement_descriptor : String? = nil, subscription : String? = nil, transfer_data : Stripe::TransferDataSpecs4? = nil, &block : Crest::Response ->)
      build_api_request_for_post_invoices(account_tax_ids: account_tax_ids, application_fee_amount: application_fee_amount, auto_advance: auto_advance, automatic_tax: automatic_tax, collection_method: collection_method, currency: currency, custom_fields: custom_fields, customer: customer, days_until_due: days_until_due, default_payment_method: default_payment_method, default_source: default_source, default_tax_rates: default_tax_rates, description: description, discounts: discounts, due_date: due_date, expand: expand, footer: footer, from_invoice: from_invoice, metadata: metadata, on_behalf_of: on_behalf_of, payment_settings: payment_settings, pending_invoice_items_behavior: pending_invoice_items_behavior, rendering_options: rendering_options, statement_descriptor: statement_descriptor, subscription: subscription, transfer_data: transfer_data).execute(&block)
    end

    POST_INVOICES_VALID_VALUES_FOR_COLLECTION_METHOD              = StaticArray["charge_automatically", "send_invoice"]
    POST_INVOICES_MAX_LENGTH_FOR_CUSTOMER                         = 5000
    POST_INVOICES_MAX_LENGTH_FOR_DEFAULT_PAYMENT_METHOD           = 5000
    POST_INVOICES_MAX_LENGTH_FOR_DEFAULT_SOURCE                   = 5000
    POST_INVOICES_MAX_LENGTH_FOR_DESCRIPTION                      = 1500
    POST_INVOICES_MAX_LENGTH_FOR_FOOTER                           = 5000
    POST_INVOICES_VALID_VALUES_FOR_PENDING_INVOICE_ITEMS_BEHAVIOR = StaticArray["exclude", "include", "include_and_require"]
    POST_INVOICES_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR             =   22
    POST_INVOICES_MAX_LENGTH_FOR_SUBSCRIPTION                     = 5000

    # @return Crest::Request
    def build_api_request_for_post_invoices(*, account_tax_ids : Stripe::PostInvoicesRequestAccountTaxIds? = nil, application_fee_amount : Int64? = nil, auto_advance : Bool? = nil, automatic_tax : Stripe::AutomaticTaxParam? = nil, collection_method : String? = nil, currency : String? = nil, custom_fields : Stripe::PostInvoicesRequestCustomFields? = nil, customer : String? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Array(String)? = nil, description : String? = nil, discounts : Stripe::PostInvoicesRequestDiscounts? = nil, due_date : Int64? = nil, expand : Array(String)? = nil, footer : String? = nil, from_invoice : Stripe::FromInvoice? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, on_behalf_of : String? = nil, payment_settings : Stripe::PaymentSettings1? = nil, pending_invoice_items_behavior : String? = nil, rendering_options : Stripe::PostInvoicesRequestRenderingOptions? = nil, statement_descriptor : String? = nil, subscription : String? = nil, transfer_data : Stripe::TransferDataSpecs4? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_invoices ..." }
      end

      if client_side_validation
        if _account_tax_ids = account_tax_ids
          _account_tax_ids.validate if _account_tax_ids.is_a?(OpenApi::Validatable)
        end

        if _automatic_tax = automatic_tax
          _automatic_tax.validate if _automatic_tax.is_a?(OpenApi::Validatable)
        end
        if _collection_method = collection_method
          OpenApi::EnumValidator.validate("collection_method", _collection_method, POST_INVOICES_VALID_VALUES_FOR_COLLECTION_METHOD)
        end

        if _custom_fields = custom_fields
          _custom_fields.validate if _custom_fields.is_a?(OpenApi::Validatable)
        end
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_INVOICES_MAX_LENGTH_FOR_CUSTOMER)
        end

        if _default_payment_method = default_payment_method
          OpenApi::PrimitiveValidator.validate_max_length("default_payment_method", default_payment_method.to_s.size, POST_INVOICES_MAX_LENGTH_FOR_DEFAULT_PAYMENT_METHOD)
        end
        if _default_source = default_source
          OpenApi::PrimitiveValidator.validate_max_length("default_source", default_source.to_s.size, POST_INVOICES_MAX_LENGTH_FOR_DEFAULT_SOURCE)
        end

        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_INVOICES_MAX_LENGTH_FOR_DESCRIPTION)
        end
        if _discounts = discounts
          _discounts.validate if _discounts.is_a?(OpenApi::Validatable)
        end

        if _footer = footer
          OpenApi::PrimitiveValidator.validate_max_length("footer", footer.to_s.size, POST_INVOICES_MAX_LENGTH_FOR_FOOTER)
        end
        if _from_invoice = from_invoice
          _from_invoice.validate if _from_invoice.is_a?(OpenApi::Validatable)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end

        if _payment_settings = payment_settings
          _payment_settings.validate if _payment_settings.is_a?(OpenApi::Validatable)
        end
        if _pending_invoice_items_behavior = pending_invoice_items_behavior
          OpenApi::EnumValidator.validate("pending_invoice_items_behavior", _pending_invoice_items_behavior, POST_INVOICES_VALID_VALUES_FOR_PENDING_INVOICE_ITEMS_BEHAVIOR)
        end
        if _rendering_options = rendering_options
          _rendering_options.validate if _rendering_options.is_a?(OpenApi::Validatable)
        end
        if _statement_descriptor = statement_descriptor
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor", statement_descriptor.to_s.size, POST_INVOICES_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR)
        end
        if _subscription = subscription
          OpenApi::PrimitiveValidator.validate_max_length("subscription", subscription.to_s.size, POST_INVOICES_MAX_LENGTH_FOR_SUBSCRIPTION)
        end
        if _transfer_data = transfer_data
          _transfer_data.validate if _transfer_data.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/invoices"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account_tax_ids"] = account_tax_ids.to_s if !account_tax_ids.nil?
      form_params["application_fee_amount"] = application_fee_amount.to_s if !application_fee_amount.nil?
      form_params["auto_advance"] = auto_advance.to_s if !auto_advance.nil?
      form_params["automatic_tax"] = automatic_tax.to_s if !automatic_tax.nil?
      form_params["collection_method"] = collection_method.to_s if !collection_method.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["custom_fields"] = custom_fields.to_s if !custom_fields.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["days_until_due"] = days_until_due.to_s if !days_until_due.nil?
      form_params["default_payment_method"] = default_payment_method.to_s if !default_payment_method.nil?
      form_params["default_source"] = default_source.to_s if !default_source.nil?
      form_params["default_tax_rates"] = @api_client.build_collection_param(default_tax_rates, "csv") if !default_tax_rates.nil? && !default_tax_rates.empty?
      form_params["description"] = description.to_s if !description.nil?
      form_params["discounts"] = discounts.to_s if !discounts.nil?
      form_params["due_date"] = due_date.to_s if !due_date.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["footer"] = footer.to_s if !footer.nil?
      form_params["from_invoice"] = from_invoice.to_s if !from_invoice.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["on_behalf_of"] = on_behalf_of.to_s if !on_behalf_of.nil?
      form_params["payment_settings"] = payment_settings.to_s if !payment_settings.nil?
      form_params["pending_invoice_items_behavior"] = pending_invoice_items_behavior.to_s if !pending_invoice_items_behavior.nil?
      form_params["rendering_options"] = rendering_options.to_s if !rendering_options.nil?
      form_params["statement_descriptor"] = statement_descriptor.to_s if !statement_descriptor.nil?
      form_params["subscription"] = subscription.to_s if !subscription.nil?
      form_params["transfer_data"] = transfer_data.to_s if !transfer_data.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_invoices",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Draft invoices are fully editable. Once an invoice is <a href=\"/docs/billing/invoices/workflow#finalized\">finalized</a>, monetary values, as well as <code>collection_method</code>, become uneditable.</p>  <p>If you would like to stop the Stripe Billing engine from automatically finalizing, reattempting payments on, sending reminders for, or <a href=\"/docs/billing/invoices/reconciliation\">automatically reconciling</a> invoices, pass <code>auto_advance=false</code>.</p>
    # @param invoice [String?]
    # @optional @param account_tax_ids [Stripe::PostInvoicesRequestAccountTaxIds?]
    # @optional @param application_fee_amount [Int64?] A fee in cents (or local equivalent) that will be applied to the invoice and transferred to the application owner's Stripe account. The request must be made with an OAuth key or the Stripe-Account header in order to take an application fee. For more information, see the application fees [documentation](https://stripe.com/docs/billing/invoices/connect#collecting-fees).
    # @optional @param auto_advance [Bool?] Controls whether Stripe will perform [automatic collection](https://stripe.com/docs/billing/invoices/workflow/#auto_advance) of the invoice.
    # @optional @param automatic_tax [Stripe::AutomaticTaxParam?]
    # @optional @param collection_method [String?] Either `charge_automatically` or `send_invoice`. This field can be updated only on `draft` invoices.
    # @optional @param custom_fields [Stripe::PostInvoicesInvoiceRequestCustomFields?]
    # @optional @param days_until_due [Int64?] The number of days from which the invoice is created until it is due. Only valid for invoices where `collection_method=send_invoice`. This field can only be updated on `draft` invoices.
    # @optional @param default_payment_method [String?] ID of the default payment method for the invoice. It must belong to the customer associated with the invoice. If not set, defaults to the subscription's default payment method, if any, or to the default payment method in the customer's invoice settings.
    # @optional @param default_source [String?] ID of the default payment source for the invoice. It must belong to the customer associated with the invoice and be in a chargeable state. If not set, defaults to the subscription's default source, if any, or to the customer's default source.
    # @optional @param default_tax_rates [Stripe::PostInvoicesInvoiceRequestDefaultTaxRates?]
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users. Referenced as 'memo' in the Dashboard.
    # @optional @param discounts [Stripe::PostInvoicesInvoiceRequestDiscounts?]
    # @optional @param due_date [Int64?] The date on which payment for this invoice is due. Only valid for invoices where `collection_method=send_invoice`. This field can only be updated on `draft` invoices.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param footer [String?] Footer to be displayed on the invoice.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param on_behalf_of [Stripe::PostInvoicesInvoiceRequestOnBehalfOf?]
    # @optional @param payment_settings [Stripe::PaymentSettings1?]
    # @optional @param rendering_options [Stripe::PostInvoicesRequestRenderingOptions?]
    # @optional @param statement_descriptor [String?] Extra information about a charge for the customer's credit card statement. It must contain at least one letter. If not specified and this invoice is part of a subscription, the default `statement_descriptor` will be set to the first subscription item's product's `statement_descriptor`.
    # @optional @param transfer_data [Stripe::PostInvoicesInvoiceRequestTransferData?]
    # @return [Invoice]
    def post_invoices_invoice(*, invoice : String? = nil, account_tax_ids : Stripe::PostInvoicesRequestAccountTaxIds? = nil, application_fee_amount : Int64? = nil, auto_advance : Bool? = nil, automatic_tax : Stripe::AutomaticTaxParam? = nil, collection_method : String? = nil, custom_fields : Stripe::PostInvoicesInvoiceRequestCustomFields? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Stripe::PostInvoicesInvoiceRequestDefaultTaxRates? = nil, description : String? = nil, discounts : Stripe::PostInvoicesInvoiceRequestDiscounts? = nil, due_date : Int64? = nil, expand : Array(String)? = nil, footer : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, on_behalf_of : Stripe::PostInvoicesInvoiceRequestOnBehalfOf? = nil, payment_settings : Stripe::PaymentSettings1? = nil, rendering_options : Stripe::PostInvoicesRequestRenderingOptions? = nil, statement_descriptor : String? = nil, transfer_data : Stripe::PostInvoicesInvoiceRequestTransferData? = nil)
      data, _status_code, _headers = post_invoices_invoice_with_http_info(invoice: invoice, account_tax_ids: account_tax_ids, application_fee_amount: application_fee_amount, auto_advance: auto_advance, automatic_tax: automatic_tax, collection_method: collection_method, custom_fields: custom_fields, days_until_due: days_until_due, default_payment_method: default_payment_method, default_source: default_source, default_tax_rates: default_tax_rates, description: description, discounts: discounts, due_date: due_date, expand: expand, footer: footer, metadata: metadata, on_behalf_of: on_behalf_of, payment_settings: payment_settings, rendering_options: rendering_options, statement_descriptor: statement_descriptor, transfer_data: transfer_data)
      data
    end

    # &lt;p&gt;Draft invoices are fully editable. Once an invoice is &lt;a href&#x3D;\&quot;/docs/billing/invoices/workflow#finalized\&quot;&gt;finalized&lt;/a&gt;, monetary values, as well as &lt;code&gt;collection_method&lt;/code&gt;, become uneditable.&lt;/p&gt;  &lt;p&gt;If you would like to stop the Stripe Billing engine from automatically finalizing, reattempting payments on, sending reminders for, or &lt;a href&#x3D;\&quot;/docs/billing/invoices/reconciliation\&quot;&gt;automatically reconciling&lt;/a&gt; invoices, pass &lt;code&gt;auto_advance&#x3D;false&lt;/code&gt;.&lt;/p&gt;
    # @param invoice [String?]
    # @optional @param account_tax_ids [Stripe::PostInvoicesRequestAccountTaxIds?]
    # @optional @param application_fee_amount [Int64?] A fee in cents (or local equivalent) that will be applied to the invoice and transferred to the application owner's Stripe account. The request must be made with an OAuth key or the Stripe-Account header in order to take an application fee. For more information, see the application fees [documentation](https://stripe.com/docs/billing/invoices/connect#collecting-fees).
    # @optional @param auto_advance [Bool?] Controls whether Stripe will perform [automatic collection](https://stripe.com/docs/billing/invoices/workflow/#auto_advance) of the invoice.
    # @optional @param automatic_tax [Stripe::AutomaticTaxParam?]
    # @optional @param collection_method [String?] Either `charge_automatically` or `send_invoice`. This field can be updated only on `draft` invoices.
    # @optional @param custom_fields [Stripe::PostInvoicesInvoiceRequestCustomFields?]
    # @optional @param days_until_due [Int64?] The number of days from which the invoice is created until it is due. Only valid for invoices where `collection_method=send_invoice`. This field can only be updated on `draft` invoices.
    # @optional @param default_payment_method [String?] ID of the default payment method for the invoice. It must belong to the customer associated with the invoice. If not set, defaults to the subscription's default payment method, if any, or to the default payment method in the customer's invoice settings.
    # @optional @param default_source [String?] ID of the default payment source for the invoice. It must belong to the customer associated with the invoice and be in a chargeable state. If not set, defaults to the subscription's default source, if any, or to the customer's default source.
    # @optional @param default_tax_rates [Stripe::PostInvoicesInvoiceRequestDefaultTaxRates?]
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users. Referenced as 'memo' in the Dashboard.
    # @optional @param discounts [Stripe::PostInvoicesInvoiceRequestDiscounts?]
    # @optional @param due_date [Int64?] The date on which payment for this invoice is due. Only valid for invoices where `collection_method=send_invoice`. This field can only be updated on `draft` invoices.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param footer [String?] Footer to be displayed on the invoice.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param on_behalf_of [Stripe::PostInvoicesInvoiceRequestOnBehalfOf?]
    # @optional @param payment_settings [Stripe::PaymentSettings1?]
    # @optional @param rendering_options [Stripe::PostInvoicesRequestRenderingOptions?]
    # @optional @param statement_descriptor [String?] Extra information about a charge for the customer's credit card statement. It must contain at least one letter. If not specified and this invoice is part of a subscription, the default `statement_descriptor` will be set to the first subscription item's product's `statement_descriptor`.
    # @optional @param transfer_data [Stripe::PostInvoicesInvoiceRequestTransferData?]
    # @return [Array<(Invoice, Integer, Hash)>] Invoice data, response status code and response headers
    def post_invoices_invoice_with_http_info(*, invoice : String? = nil, account_tax_ids : Stripe::PostInvoicesRequestAccountTaxIds? = nil, application_fee_amount : Int64? = nil, auto_advance : Bool? = nil, automatic_tax : Stripe::AutomaticTaxParam? = nil, collection_method : String? = nil, custom_fields : Stripe::PostInvoicesInvoiceRequestCustomFields? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Stripe::PostInvoicesInvoiceRequestDefaultTaxRates? = nil, description : String? = nil, discounts : Stripe::PostInvoicesInvoiceRequestDiscounts? = nil, due_date : Int64? = nil, expand : Array(String)? = nil, footer : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, on_behalf_of : Stripe::PostInvoicesInvoiceRequestOnBehalfOf? = nil, payment_settings : Stripe::PaymentSettings1? = nil, rendering_options : Stripe::PostInvoicesRequestRenderingOptions? = nil, statement_descriptor : String? = nil, transfer_data : Stripe::PostInvoicesInvoiceRequestTransferData? = nil)
      request = build_api_request_for_post_invoices_invoice(invoice: invoice, account_tax_ids: account_tax_ids, application_fee_amount: application_fee_amount, auto_advance: auto_advance, automatic_tax: automatic_tax, collection_method: collection_method, custom_fields: custom_fields, days_until_due: days_until_due, default_payment_method: default_payment_method, default_source: default_source, default_tax_rates: default_tax_rates, description: description, discounts: discounts, due_date: due_date, expand: expand, footer: footer, metadata: metadata, on_behalf_of: on_behalf_of, payment_settings: payment_settings, rendering_options: rendering_options, statement_descriptor: statement_descriptor, transfer_data: transfer_data)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_invoices_invoice\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Invoice.from_json(data), status_code, headers
    end

    # &lt;p&gt;Draft invoices are fully editable. Once an invoice is &lt;a href&#x3D;\&quot;/docs/billing/invoices/workflow#finalized\&quot;&gt;finalized&lt;/a&gt;, monetary values, as well as &lt;code&gt;collection_method&lt;/code&gt;, become uneditable.&lt;/p&gt;  &lt;p&gt;If you would like to stop the Stripe Billing engine from automatically finalizing, reattempting payments on, sending reminders for, or &lt;a href&#x3D;\&quot;/docs/billing/invoices/reconciliation\&quot;&gt;automatically reconciling&lt;/a&gt; invoices, pass &lt;code&gt;auto_advance&#x3D;false&lt;/code&gt;.&lt;/p&gt;
    # @param invoice [String?]
    # @optional @param account_tax_ids [Stripe::PostInvoicesRequestAccountTaxIds?]
    # @optional @param application_fee_amount [Int64?] A fee in cents (or local equivalent) that will be applied to the invoice and transferred to the application owner's Stripe account. The request must be made with an OAuth key or the Stripe-Account header in order to take an application fee. For more information, see the application fees [documentation](https://stripe.com/docs/billing/invoices/connect#collecting-fees).
    # @optional @param auto_advance [Bool?] Controls whether Stripe will perform [automatic collection](https://stripe.com/docs/billing/invoices/workflow/#auto_advance) of the invoice.
    # @optional @param automatic_tax [Stripe::AutomaticTaxParam?]
    # @optional @param collection_method [String?] Either `charge_automatically` or `send_invoice`. This field can be updated only on `draft` invoices.
    # @optional @param custom_fields [Stripe::PostInvoicesInvoiceRequestCustomFields?]
    # @optional @param days_until_due [Int64?] The number of days from which the invoice is created until it is due. Only valid for invoices where `collection_method=send_invoice`. This field can only be updated on `draft` invoices.
    # @optional @param default_payment_method [String?] ID of the default payment method for the invoice. It must belong to the customer associated with the invoice. If not set, defaults to the subscription's default payment method, if any, or to the default payment method in the customer's invoice settings.
    # @optional @param default_source [String?] ID of the default payment source for the invoice. It must belong to the customer associated with the invoice and be in a chargeable state. If not set, defaults to the subscription's default source, if any, or to the customer's default source.
    # @optional @param default_tax_rates [Stripe::PostInvoicesInvoiceRequestDefaultTaxRates?]
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users. Referenced as 'memo' in the Dashboard.
    # @optional @param discounts [Stripe::PostInvoicesInvoiceRequestDiscounts?]
    # @optional @param due_date [Int64?] The date on which payment for this invoice is due. Only valid for invoices where `collection_method=send_invoice`. This field can only be updated on `draft` invoices.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param footer [String?] Footer to be displayed on the invoice.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param on_behalf_of [Stripe::PostInvoicesInvoiceRequestOnBehalfOf?]
    # @optional @param payment_settings [Stripe::PaymentSettings1?]
    # @optional @param rendering_options [Stripe::PostInvoicesRequestRenderingOptions?]
    # @optional @param statement_descriptor [String?] Extra information about a charge for the customer's credit card statement. It must contain at least one letter. If not specified and this invoice is part of a subscription, the default `statement_descriptor` will be set to the first subscription item's product's `statement_descriptor`.
    # @optional @param transfer_data [Stripe::PostInvoicesInvoiceRequestTransferData?]
    # @return nil
    def post_invoices_invoice(*, invoice : String? = nil, account_tax_ids : Stripe::PostInvoicesRequestAccountTaxIds? = nil, application_fee_amount : Int64? = nil, auto_advance : Bool? = nil, automatic_tax : Stripe::AutomaticTaxParam? = nil, collection_method : String? = nil, custom_fields : Stripe::PostInvoicesInvoiceRequestCustomFields? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Stripe::PostInvoicesInvoiceRequestDefaultTaxRates? = nil, description : String? = nil, discounts : Stripe::PostInvoicesInvoiceRequestDiscounts? = nil, due_date : Int64? = nil, expand : Array(String)? = nil, footer : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, on_behalf_of : Stripe::PostInvoicesInvoiceRequestOnBehalfOf? = nil, payment_settings : Stripe::PaymentSettings1? = nil, rendering_options : Stripe::PostInvoicesRequestRenderingOptions? = nil, statement_descriptor : String? = nil, transfer_data : Stripe::PostInvoicesInvoiceRequestTransferData? = nil, &block : Crest::Response ->)
      build_api_request_for_post_invoices_invoice(invoice: invoice, account_tax_ids: account_tax_ids, application_fee_amount: application_fee_amount, auto_advance: auto_advance, automatic_tax: automatic_tax, collection_method: collection_method, custom_fields: custom_fields, days_until_due: days_until_due, default_payment_method: default_payment_method, default_source: default_source, default_tax_rates: default_tax_rates, description: description, discounts: discounts, due_date: due_date, expand: expand, footer: footer, metadata: metadata, on_behalf_of: on_behalf_of, payment_settings: payment_settings, rendering_options: rendering_options, statement_descriptor: statement_descriptor, transfer_data: transfer_data).execute(&block)
    end

    POST_INVOICES_INVOICE_MAX_LENGTH_FOR_INVOICE                = 5000
    POST_INVOICES_INVOICE_VALID_VALUES_FOR_COLLECTION_METHOD    = StaticArray["charge_automatically", "send_invoice"]
    POST_INVOICES_INVOICE_MAX_LENGTH_FOR_DEFAULT_PAYMENT_METHOD = 5000
    POST_INVOICES_INVOICE_MAX_LENGTH_FOR_DEFAULT_SOURCE         = 5000
    POST_INVOICES_INVOICE_MAX_LENGTH_FOR_DESCRIPTION            = 1500
    POST_INVOICES_INVOICE_MAX_LENGTH_FOR_FOOTER                 = 5000
    POST_INVOICES_INVOICE_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR   =   22

    # @return Crest::Request
    def build_api_request_for_post_invoices_invoice(*, invoice : String? = nil, account_tax_ids : Stripe::PostInvoicesRequestAccountTaxIds? = nil, application_fee_amount : Int64? = nil, auto_advance : Bool? = nil, automatic_tax : Stripe::AutomaticTaxParam? = nil, collection_method : String? = nil, custom_fields : Stripe::PostInvoicesInvoiceRequestCustomFields? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Stripe::PostInvoicesInvoiceRequestDefaultTaxRates? = nil, description : String? = nil, discounts : Stripe::PostInvoicesInvoiceRequestDiscounts? = nil, due_date : Int64? = nil, expand : Array(String)? = nil, footer : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, on_behalf_of : Stripe::PostInvoicesInvoiceRequestOnBehalfOf? = nil, payment_settings : Stripe::PaymentSettings1? = nil, rendering_options : Stripe::PostInvoicesRequestRenderingOptions? = nil, statement_descriptor : String? = nil, transfer_data : Stripe::PostInvoicesInvoiceRequestTransferData? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_invoices_invoice ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"invoice\" is required and cannot be null") if invoice.nil?
        if _invoice = invoice
          OpenApi::PrimitiveValidator.validate_max_length("invoice", invoice.to_s.size, POST_INVOICES_INVOICE_MAX_LENGTH_FOR_INVOICE)
        end
        if _account_tax_ids = account_tax_ids
          _account_tax_ids.validate if _account_tax_ids.is_a?(OpenApi::Validatable)
        end

        if _automatic_tax = automatic_tax
          _automatic_tax.validate if _automatic_tax.is_a?(OpenApi::Validatable)
        end
        if _collection_method = collection_method
          OpenApi::EnumValidator.validate("collection_method", _collection_method, POST_INVOICES_INVOICE_VALID_VALUES_FOR_COLLECTION_METHOD)
        end
        if _custom_fields = custom_fields
          _custom_fields.validate if _custom_fields.is_a?(OpenApi::Validatable)
        end

        if _default_payment_method = default_payment_method
          OpenApi::PrimitiveValidator.validate_max_length("default_payment_method", default_payment_method.to_s.size, POST_INVOICES_INVOICE_MAX_LENGTH_FOR_DEFAULT_PAYMENT_METHOD)
        end
        if _default_source = default_source
          OpenApi::PrimitiveValidator.validate_max_length("default_source", default_source.to_s.size, POST_INVOICES_INVOICE_MAX_LENGTH_FOR_DEFAULT_SOURCE)
        end
        if _default_tax_rates = default_tax_rates
          _default_tax_rates.validate if _default_tax_rates.is_a?(OpenApi::Validatable)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_INVOICES_INVOICE_MAX_LENGTH_FOR_DESCRIPTION)
        end
        if _discounts = discounts
          _discounts.validate if _discounts.is_a?(OpenApi::Validatable)
        end

        if _footer = footer
          OpenApi::PrimitiveValidator.validate_max_length("footer", footer.to_s.size, POST_INVOICES_INVOICE_MAX_LENGTH_FOR_FOOTER)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _on_behalf_of = on_behalf_of
          _on_behalf_of.validate if _on_behalf_of.is_a?(OpenApi::Validatable)
        end
        if _payment_settings = payment_settings
          _payment_settings.validate if _payment_settings.is_a?(OpenApi::Validatable)
        end
        if _rendering_options = rendering_options
          _rendering_options.validate if _rendering_options.is_a?(OpenApi::Validatable)
        end
        if _statement_descriptor = statement_descriptor
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor", statement_descriptor.to_s.size, POST_INVOICES_INVOICE_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR)
        end
        if _transfer_data = transfer_data
          _transfer_data.validate if _transfer_data.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/invoices/{invoice}".sub("{" + "invoice" + "}", URI.encode_path(invoice.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account_tax_ids"] = account_tax_ids.to_s if !account_tax_ids.nil?
      form_params["application_fee_amount"] = application_fee_amount.to_s if !application_fee_amount.nil?
      form_params["auto_advance"] = auto_advance.to_s if !auto_advance.nil?
      form_params["automatic_tax"] = automatic_tax.to_s if !automatic_tax.nil?
      form_params["collection_method"] = collection_method.to_s if !collection_method.nil?
      form_params["custom_fields"] = custom_fields.to_s if !custom_fields.nil?
      form_params["days_until_due"] = days_until_due.to_s if !days_until_due.nil?
      form_params["default_payment_method"] = default_payment_method.to_s if !default_payment_method.nil?
      form_params["default_source"] = default_source.to_s if !default_source.nil?
      form_params["default_tax_rates"] = default_tax_rates.to_s if !default_tax_rates.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["discounts"] = discounts.to_s if !discounts.nil?
      form_params["due_date"] = due_date.to_s if !due_date.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["footer"] = footer.to_s if !footer.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["on_behalf_of"] = on_behalf_of.to_s if !on_behalf_of.nil?
      form_params["payment_settings"] = payment_settings.to_s if !payment_settings.nil?
      form_params["rendering_options"] = rendering_options.to_s if !rendering_options.nil?
      form_params["statement_descriptor"] = statement_descriptor.to_s if !statement_descriptor.nil?
      form_params["transfer_data"] = transfer_data.to_s if !transfer_data.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_invoices_invoice",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Stripe automatically finalizes drafts before sending and attempting payment on invoices. However, if you’d like to finalize a draft invoice manually, you can do so using this method.</p>
    # @param invoice [String?]
    # @optional @param auto_advance [Bool?] Controls whether Stripe will perform [automatic collection](https://stripe.com/docs/invoicing/automatic-charging) of the invoice. When `false`, the invoice's state will not automatically advance without an explicit action.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Invoice]
    def post_invoices_invoice_finalize(*, invoice : String? = nil, auto_advance : Bool? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_invoices_invoice_finalize_with_http_info(invoice: invoice, auto_advance: auto_advance, expand: expand)
      data
    end

    # &lt;p&gt;Stripe automatically finalizes drafts before sending and attempting payment on invoices. However, if you’d like to finalize a draft invoice manually, you can do so using this method.&lt;/p&gt;
    # @param invoice [String?]
    # @optional @param auto_advance [Bool?] Controls whether Stripe will perform [automatic collection](https://stripe.com/docs/invoicing/automatic-charging) of the invoice. When `false`, the invoice's state will not automatically advance without an explicit action.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(Invoice, Integer, Hash)>] Invoice data, response status code and response headers
    def post_invoices_invoice_finalize_with_http_info(*, invoice : String? = nil, auto_advance : Bool? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_invoices_invoice_finalize(invoice: invoice, auto_advance: auto_advance, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_invoices_invoice_finalize\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Invoice.from_json(data), status_code, headers
    end

    # &lt;p&gt;Stripe automatically finalizes drafts before sending and attempting payment on invoices. However, if you’d like to finalize a draft invoice manually, you can do so using this method.&lt;/p&gt;
    # @param invoice [String?]
    # @optional @param auto_advance [Bool?] Controls whether Stripe will perform [automatic collection](https://stripe.com/docs/invoicing/automatic-charging) of the invoice. When `false`, the invoice's state will not automatically advance without an explicit action.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_invoices_invoice_finalize(*, invoice : String? = nil, auto_advance : Bool? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_invoices_invoice_finalize(invoice: invoice, auto_advance: auto_advance, expand: expand).execute(&block)
    end

    POST_INVOICES_INVOICE_FINALIZE_MAX_LENGTH_FOR_INVOICE = 5000

    # @return Crest::Request
    def build_api_request_for_post_invoices_invoice_finalize(*, invoice : String? = nil, auto_advance : Bool? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_invoices_invoice_finalize ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"invoice\" is required and cannot be null") if invoice.nil?
        if _invoice = invoice
          OpenApi::PrimitiveValidator.validate_max_length("invoice", invoice.to_s.size, POST_INVOICES_INVOICE_FINALIZE_MAX_LENGTH_FOR_INVOICE)
        end
      end

      # resource path
      local_var_path = "/v1/invoices/{invoice}/finalize".sub("{" + "invoice" + "}", URI.encode_path(invoice.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["auto_advance"] = auto_advance.to_s if !auto_advance.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_invoices_invoice_finalize",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Marking an invoice as uncollectible is useful for keeping track of bad debts that can be written off for accounting purposes.</p>
    # @param invoice [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Invoice]
    def post_invoices_invoice_mark_uncollectible(*, invoice : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_invoices_invoice_mark_uncollectible_with_http_info(invoice: invoice, expand: expand)
      data
    end

    # &lt;p&gt;Marking an invoice as uncollectible is useful for keeping track of bad debts that can be written off for accounting purposes.&lt;/p&gt;
    # @param invoice [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(Invoice, Integer, Hash)>] Invoice data, response status code and response headers
    def post_invoices_invoice_mark_uncollectible_with_http_info(*, invoice : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_invoices_invoice_mark_uncollectible(invoice: invoice, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_invoices_invoice_mark_uncollectible\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Invoice.from_json(data), status_code, headers
    end

    # &lt;p&gt;Marking an invoice as uncollectible is useful for keeping track of bad debts that can be written off for accounting purposes.&lt;/p&gt;
    # @param invoice [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_invoices_invoice_mark_uncollectible(*, invoice : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_invoices_invoice_mark_uncollectible(invoice: invoice, expand: expand).execute(&block)
    end

    POST_INVOICES_INVOICE_MARK_UNCOLLECTIBLE_MAX_LENGTH_FOR_INVOICE = 5000

    # @return Crest::Request
    def build_api_request_for_post_invoices_invoice_mark_uncollectible(*, invoice : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_invoices_invoice_mark_uncollectible ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"invoice\" is required and cannot be null") if invoice.nil?
        if _invoice = invoice
          OpenApi::PrimitiveValidator.validate_max_length("invoice", invoice.to_s.size, POST_INVOICES_INVOICE_MARK_UNCOLLECTIBLE_MAX_LENGTH_FOR_INVOICE)
        end
      end

      # resource path
      local_var_path = "/v1/invoices/{invoice}/mark_uncollectible".sub("{" + "invoice" + "}", URI.encode_path(invoice.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_invoices_invoice_mark_uncollectible",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Stripe automatically creates and then attempts to collect payment on invoices for customers on subscriptions according to your <a href=\"https://dashboard.stripe.com/account/billing/automatic\">subscriptions settings</a>. However, if you’d like to attempt payment on an invoice out of the normal collection schedule or for some other reason, you can do so.</p>
    # @param invoice [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param forgive [Bool?] In cases where the source used to pay the invoice has insufficient funds, passing `forgive=true` controls whether a charge should be attempted for the full amount available on the source, up to the amount to fully pay the invoice. This effectively forgives the difference between the amount available on the source and the amount due.   Passing `forgive=false` will fail the charge if the source hasn't been pre-funded with the right amount. An example for this case is with ACH Credit Transfers and wires: if the amount wired is less than the amount due by a small amount, you might want to forgive the difference. Defaults to `false`.
    # @optional @param mandate [String?] ID of the mandate to be used for this invoice. It must correspond to the payment method used to pay the invoice, including the payment_method param or the invoice's default_payment_method or default_source, if set.
    # @optional @param off_session [Bool?] Indicates if a customer is on or off-session while an invoice payment is attempted. Defaults to `true` (off-session).
    # @optional @param paid_out_of_band [Bool?] Boolean representing whether an invoice is paid outside of Stripe. This will result in no charge being made. Defaults to `false`.
    # @optional @param payment_method [String?] A PaymentMethod to be charged. The PaymentMethod must be the ID of a PaymentMethod belonging to the customer associated with the invoice being paid.
    # @optional @param source [String?] A payment source to be charged. The source must be the ID of a source belonging to the customer associated with the invoice being paid.
    # @return [Invoice]
    def post_invoices_invoice_pay(*, invoice : String? = nil, expand : Array(String)? = nil, forgive : Bool? = nil, mandate : String? = nil, off_session : Bool? = nil, paid_out_of_band : Bool? = nil, payment_method : String? = nil, source : String? = nil)
      data, _status_code, _headers = post_invoices_invoice_pay_with_http_info(invoice: invoice, expand: expand, forgive: forgive, mandate: mandate, off_session: off_session, paid_out_of_band: paid_out_of_band, payment_method: payment_method, source: source)
      data
    end

    # &lt;p&gt;Stripe automatically creates and then attempts to collect payment on invoices for customers on subscriptions according to your &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/account/billing/automatic\&quot;&gt;subscriptions settings&lt;/a&gt;. However, if you’d like to attempt payment on an invoice out of the normal collection schedule or for some other reason, you can do so.&lt;/p&gt;
    # @param invoice [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param forgive [Bool?] In cases where the source used to pay the invoice has insufficient funds, passing `forgive=true` controls whether a charge should be attempted for the full amount available on the source, up to the amount to fully pay the invoice. This effectively forgives the difference between the amount available on the source and the amount due.   Passing `forgive=false` will fail the charge if the source hasn't been pre-funded with the right amount. An example for this case is with ACH Credit Transfers and wires: if the amount wired is less than the amount due by a small amount, you might want to forgive the difference. Defaults to `false`.
    # @optional @param mandate [String?] ID of the mandate to be used for this invoice. It must correspond to the payment method used to pay the invoice, including the payment_method param or the invoice's default_payment_method or default_source, if set.
    # @optional @param off_session [Bool?] Indicates if a customer is on or off-session while an invoice payment is attempted. Defaults to `true` (off-session).
    # @optional @param paid_out_of_band [Bool?] Boolean representing whether an invoice is paid outside of Stripe. This will result in no charge being made. Defaults to `false`.
    # @optional @param payment_method [String?] A PaymentMethod to be charged. The PaymentMethod must be the ID of a PaymentMethod belonging to the customer associated with the invoice being paid.
    # @optional @param source [String?] A payment source to be charged. The source must be the ID of a source belonging to the customer associated with the invoice being paid.
    # @return [Array<(Invoice, Integer, Hash)>] Invoice data, response status code and response headers
    def post_invoices_invoice_pay_with_http_info(*, invoice : String? = nil, expand : Array(String)? = nil, forgive : Bool? = nil, mandate : String? = nil, off_session : Bool? = nil, paid_out_of_band : Bool? = nil, payment_method : String? = nil, source : String? = nil)
      request = build_api_request_for_post_invoices_invoice_pay(invoice: invoice, expand: expand, forgive: forgive, mandate: mandate, off_session: off_session, paid_out_of_band: paid_out_of_band, payment_method: payment_method, source: source)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_invoices_invoice_pay\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Invoice.from_json(data), status_code, headers
    end

    # &lt;p&gt;Stripe automatically creates and then attempts to collect payment on invoices for customers on subscriptions according to your &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/account/billing/automatic\&quot;&gt;subscriptions settings&lt;/a&gt;. However, if you’d like to attempt payment on an invoice out of the normal collection schedule or for some other reason, you can do so.&lt;/p&gt;
    # @param invoice [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param forgive [Bool?] In cases where the source used to pay the invoice has insufficient funds, passing `forgive=true` controls whether a charge should be attempted for the full amount available on the source, up to the amount to fully pay the invoice. This effectively forgives the difference between the amount available on the source and the amount due.   Passing `forgive=false` will fail the charge if the source hasn't been pre-funded with the right amount. An example for this case is with ACH Credit Transfers and wires: if the amount wired is less than the amount due by a small amount, you might want to forgive the difference. Defaults to `false`.
    # @optional @param mandate [String?] ID of the mandate to be used for this invoice. It must correspond to the payment method used to pay the invoice, including the payment_method param or the invoice's default_payment_method or default_source, if set.
    # @optional @param off_session [Bool?] Indicates if a customer is on or off-session while an invoice payment is attempted. Defaults to `true` (off-session).
    # @optional @param paid_out_of_band [Bool?] Boolean representing whether an invoice is paid outside of Stripe. This will result in no charge being made. Defaults to `false`.
    # @optional @param payment_method [String?] A PaymentMethod to be charged. The PaymentMethod must be the ID of a PaymentMethod belonging to the customer associated with the invoice being paid.
    # @optional @param source [String?] A payment source to be charged. The source must be the ID of a source belonging to the customer associated with the invoice being paid.
    # @return nil
    def post_invoices_invoice_pay(*, invoice : String? = nil, expand : Array(String)? = nil, forgive : Bool? = nil, mandate : String? = nil, off_session : Bool? = nil, paid_out_of_band : Bool? = nil, payment_method : String? = nil, source : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_invoices_invoice_pay(invoice: invoice, expand: expand, forgive: forgive, mandate: mandate, off_session: off_session, paid_out_of_band: paid_out_of_band, payment_method: payment_method, source: source).execute(&block)
    end

    POST_INVOICES_INVOICE_PAY_MAX_LENGTH_FOR_INVOICE        = 5000
    POST_INVOICES_INVOICE_PAY_MAX_LENGTH_FOR_MANDATE        = 5000
    POST_INVOICES_INVOICE_PAY_MAX_LENGTH_FOR_PAYMENT_METHOD = 5000
    POST_INVOICES_INVOICE_PAY_MAX_LENGTH_FOR_SOURCE         = 5000

    # @return Crest::Request
    def build_api_request_for_post_invoices_invoice_pay(*, invoice : String? = nil, expand : Array(String)? = nil, forgive : Bool? = nil, mandate : String? = nil, off_session : Bool? = nil, paid_out_of_band : Bool? = nil, payment_method : String? = nil, source : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_invoices_invoice_pay ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"invoice\" is required and cannot be null") if invoice.nil?
        if _invoice = invoice
          OpenApi::PrimitiveValidator.validate_max_length("invoice", invoice.to_s.size, POST_INVOICES_INVOICE_PAY_MAX_LENGTH_FOR_INVOICE)
        end

        if _mandate = mandate
          OpenApi::PrimitiveValidator.validate_max_length("mandate", mandate.to_s.size, POST_INVOICES_INVOICE_PAY_MAX_LENGTH_FOR_MANDATE)
        end

        if _payment_method = payment_method
          OpenApi::PrimitiveValidator.validate_max_length("payment_method", payment_method.to_s.size, POST_INVOICES_INVOICE_PAY_MAX_LENGTH_FOR_PAYMENT_METHOD)
        end
        if _source = source
          OpenApi::PrimitiveValidator.validate_max_length("source", source.to_s.size, POST_INVOICES_INVOICE_PAY_MAX_LENGTH_FOR_SOURCE)
        end
      end

      # resource path
      local_var_path = "/v1/invoices/{invoice}/pay".sub("{" + "invoice" + "}", URI.encode_path(invoice.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["forgive"] = forgive.to_s if !forgive.nil?
      form_params["mandate"] = mandate.to_s if !mandate.nil?
      form_params["off_session"] = off_session.to_s if !off_session.nil?
      form_params["paid_out_of_band"] = paid_out_of_band.to_s if !paid_out_of_band.nil?
      form_params["payment_method"] = payment_method.to_s if !payment_method.nil?
      form_params["source"] = source.to_s if !source.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_invoices_invoice_pay",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Stripe will automatically send invoices to customers according to your <a href=\"https://dashboard.stripe.com/account/billing/automatic\">subscriptions settings</a>. However, if you’d like to manually send an invoice to your customer out of the normal schedule, you can do so. When sending invoices that have already been paid, there will be no reference to the payment in the email.</p>  <p>Requests made in test-mode result in no emails being sent, despite sending an <code>invoice.sent</code> event.</p>
    # @param invoice [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Invoice]
    def post_invoices_invoice_send(*, invoice : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_invoices_invoice_send_with_http_info(invoice: invoice, expand: expand)
      data
    end

    # &lt;p&gt;Stripe will automatically send invoices to customers according to your &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/account/billing/automatic\&quot;&gt;subscriptions settings&lt;/a&gt;. However, if you’d like to manually send an invoice to your customer out of the normal schedule, you can do so. When sending invoices that have already been paid, there will be no reference to the payment in the email.&lt;/p&gt;  &lt;p&gt;Requests made in test-mode result in no emails being sent, despite sending an &lt;code&gt;invoice.sent&lt;/code&gt; event.&lt;/p&gt;
    # @param invoice [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(Invoice, Integer, Hash)>] Invoice data, response status code and response headers
    def post_invoices_invoice_send_with_http_info(*, invoice : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_invoices_invoice_send(invoice: invoice, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_invoices_invoice_send\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Invoice.from_json(data), status_code, headers
    end

    # &lt;p&gt;Stripe will automatically send invoices to customers according to your &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/account/billing/automatic\&quot;&gt;subscriptions settings&lt;/a&gt;. However, if you’d like to manually send an invoice to your customer out of the normal schedule, you can do so. When sending invoices that have already been paid, there will be no reference to the payment in the email.&lt;/p&gt;  &lt;p&gt;Requests made in test-mode result in no emails being sent, despite sending an &lt;code&gt;invoice.sent&lt;/code&gt; event.&lt;/p&gt;
    # @param invoice [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_invoices_invoice_send(*, invoice : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_invoices_invoice_send(invoice: invoice, expand: expand).execute(&block)
    end

    POST_INVOICES_INVOICE_SEND_MAX_LENGTH_FOR_INVOICE = 5000

    # @return Crest::Request
    def build_api_request_for_post_invoices_invoice_send(*, invoice : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_invoices_invoice_send ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"invoice\" is required and cannot be null") if invoice.nil?
        if _invoice = invoice
          OpenApi::PrimitiveValidator.validate_max_length("invoice", invoice.to_s.size, POST_INVOICES_INVOICE_SEND_MAX_LENGTH_FOR_INVOICE)
        end
      end

      # resource path
      local_var_path = "/v1/invoices/{invoice}/send".sub("{" + "invoice" + "}", URI.encode_path(invoice.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_invoices_invoice_send",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Mark a finalized invoice as void. This cannot be undone. Voiding an invoice is similar to <a href=\"#delete_invoice\">deletion</a>, however it only applies to finalized invoices and maintains a papertrail where the invoice can still be found.</p>
    # @param invoice [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Invoice]
    def post_invoices_invoice_void(*, invoice : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_invoices_invoice_void_with_http_info(invoice: invoice, expand: expand)
      data
    end

    # &lt;p&gt;Mark a finalized invoice as void. This cannot be undone. Voiding an invoice is similar to &lt;a href&#x3D;\&quot;#delete_invoice\&quot;&gt;deletion&lt;/a&gt;, however it only applies to finalized invoices and maintains a papertrail where the invoice can still be found.&lt;/p&gt;
    # @param invoice [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(Invoice, Integer, Hash)>] Invoice data, response status code and response headers
    def post_invoices_invoice_void_with_http_info(*, invoice : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_invoices_invoice_void(invoice: invoice, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_invoices_invoice_void\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Invoice.from_json(data), status_code, headers
    end

    # &lt;p&gt;Mark a finalized invoice as void. This cannot be undone. Voiding an invoice is similar to &lt;a href&#x3D;\&quot;#delete_invoice\&quot;&gt;deletion&lt;/a&gt;, however it only applies to finalized invoices and maintains a papertrail where the invoice can still be found.&lt;/p&gt;
    # @param invoice [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_invoices_invoice_void(*, invoice : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_invoices_invoice_void(invoice: invoice, expand: expand).execute(&block)
    end

    POST_INVOICES_INVOICE_VOID_MAX_LENGTH_FOR_INVOICE = 5000

    # @return Crest::Request
    def build_api_request_for_post_invoices_invoice_void(*, invoice : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_invoices_invoice_void ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"invoice\" is required and cannot be null") if invoice.nil?
        if _invoice = invoice
          OpenApi::PrimitiveValidator.validate_max_length("invoice", invoice.to_s.size, POST_INVOICES_INVOICE_VOID_MAX_LENGTH_FOR_INVOICE)
        end
      end

      # resource path
      local_var_path = "/v1/invoices/{invoice}/void".sub("{" + "invoice" + "}", URI.encode_path(invoice.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_invoices_invoice_void",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the specified Issuing <code>Authorization</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
    # @param authorization [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [IssuingAuthorization]
    def post_issuing_authorizations_authorization(*, authorization : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_issuing_authorizations_authorization_with_http_info(authorization: authorization, expand: expand, metadata: metadata)
      data
    end

    # &lt;p&gt;Updates the specified Issuing &lt;code&gt;Authorization&lt;/code&gt; object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;
    # @param authorization [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(IssuingAuthorization, Integer, Hash)>] IssuingAuthorization data, response status code and response headers
    def post_issuing_authorizations_authorization_with_http_info(*, authorization : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_issuing_authorizations_authorization(authorization: authorization, expand: expand, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_issuing_authorizations_authorization\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingAuthorization.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the specified Issuing &lt;code&gt;Authorization&lt;/code&gt; object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;
    # @param authorization [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_issuing_authorizations_authorization(*, authorization : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_issuing_authorizations_authorization(authorization: authorization, expand: expand, metadata: metadata).execute(&block)
    end

    POST_ISSUING_AUTHORIZATIONS_AUTHORIZATION_MAX_LENGTH_FOR_AUTHORIZATION = 5000

    # @return Crest::Request
    def build_api_request_for_post_issuing_authorizations_authorization(*, authorization : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_issuing_authorizations_authorization ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"authorization\" is required and cannot be null") if authorization.nil?
        if _authorization = authorization
          OpenApi::PrimitiveValidator.validate_max_length("authorization", authorization.to_s.size, POST_ISSUING_AUTHORIZATIONS_AUTHORIZATION_MAX_LENGTH_FOR_AUTHORIZATION)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/authorizations/{authorization}".sub("{" + "authorization" + "}", URI.encode_path(authorization.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_issuing_authorizations_authorization",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Approves a pending Issuing <code>Authorization</code> object. This request should be made within the timeout window of the <a href=\"/docs/issuing/controls/real-time-authorizations\">real-time authorization</a> flow.</p>
    # @param authorization [String?]
    # @optional @param amount [Int64?] If the authorization's `pending_request.is_amount_controllable` property is `true`, you may provide this value to control how much to hold for the authorization. Must be positive (use [`decline`](https://stripe.com/docs/api/issuing/authorizations/decline) to decline an authorization request).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [IssuingAuthorization]
    def post_issuing_authorizations_authorization_approve(*, authorization : String? = nil, amount : Int64? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_issuing_authorizations_authorization_approve_with_http_info(authorization: authorization, amount: amount, expand: expand, metadata: metadata)
      data
    end

    # &lt;p&gt;Approves a pending Issuing &lt;code&gt;Authorization&lt;/code&gt; object. This request should be made within the timeout window of the &lt;a href&#x3D;\&quot;/docs/issuing/controls/real-time-authorizations\&quot;&gt;real-time authorization&lt;/a&gt; flow.&lt;/p&gt;
    # @param authorization [String?]
    # @optional @param amount [Int64?] If the authorization's `pending_request.is_amount_controllable` property is `true`, you may provide this value to control how much to hold for the authorization. Must be positive (use [`decline`](https://stripe.com/docs/api/issuing/authorizations/decline) to decline an authorization request).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(IssuingAuthorization, Integer, Hash)>] IssuingAuthorization data, response status code and response headers
    def post_issuing_authorizations_authorization_approve_with_http_info(*, authorization : String? = nil, amount : Int64? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_issuing_authorizations_authorization_approve(authorization: authorization, amount: amount, expand: expand, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_issuing_authorizations_authorization_approve\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingAuthorization.from_json(data), status_code, headers
    end

    # &lt;p&gt;Approves a pending Issuing &lt;code&gt;Authorization&lt;/code&gt; object. This request should be made within the timeout window of the &lt;a href&#x3D;\&quot;/docs/issuing/controls/real-time-authorizations\&quot;&gt;real-time authorization&lt;/a&gt; flow.&lt;/p&gt;
    # @param authorization [String?]
    # @optional @param amount [Int64?] If the authorization's `pending_request.is_amount_controllable` property is `true`, you may provide this value to control how much to hold for the authorization. Must be positive (use [`decline`](https://stripe.com/docs/api/issuing/authorizations/decline) to decline an authorization request).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_issuing_authorizations_authorization_approve(*, authorization : String? = nil, amount : Int64? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_issuing_authorizations_authorization_approve(authorization: authorization, amount: amount, expand: expand, metadata: metadata).execute(&block)
    end

    POST_ISSUING_AUTHORIZATIONS_AUTHORIZATION_APPROVE_MAX_LENGTH_FOR_AUTHORIZATION = 5000

    # @return Crest::Request
    def build_api_request_for_post_issuing_authorizations_authorization_approve(*, authorization : String? = nil, amount : Int64? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_issuing_authorizations_authorization_approve ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"authorization\" is required and cannot be null") if authorization.nil?
        if _authorization = authorization
          OpenApi::PrimitiveValidator.validate_max_length("authorization", authorization.to_s.size, POST_ISSUING_AUTHORIZATIONS_AUTHORIZATION_APPROVE_MAX_LENGTH_FOR_AUTHORIZATION)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/authorizations/{authorization}/approve".sub("{" + "authorization" + "}", URI.encode_path(authorization.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_issuing_authorizations_authorization_approve",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Declines a pending Issuing <code>Authorization</code> object. This request should be made within the timeout window of the <a href=\"/docs/issuing/controls/real-time-authorizations\">real time authorization</a> flow.</p>
    # @param authorization [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [IssuingAuthorization]
    def post_issuing_authorizations_authorization_decline(*, authorization : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_issuing_authorizations_authorization_decline_with_http_info(authorization: authorization, expand: expand, metadata: metadata)
      data
    end

    # &lt;p&gt;Declines a pending Issuing &lt;code&gt;Authorization&lt;/code&gt; object. This request should be made within the timeout window of the &lt;a href&#x3D;\&quot;/docs/issuing/controls/real-time-authorizations\&quot;&gt;real time authorization&lt;/a&gt; flow.&lt;/p&gt;
    # @param authorization [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(IssuingAuthorization, Integer, Hash)>] IssuingAuthorization data, response status code and response headers
    def post_issuing_authorizations_authorization_decline_with_http_info(*, authorization : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_issuing_authorizations_authorization_decline(authorization: authorization, expand: expand, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_issuing_authorizations_authorization_decline\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingAuthorization.from_json(data), status_code, headers
    end

    # &lt;p&gt;Declines a pending Issuing &lt;code&gt;Authorization&lt;/code&gt; object. This request should be made within the timeout window of the &lt;a href&#x3D;\&quot;/docs/issuing/controls/real-time-authorizations\&quot;&gt;real time authorization&lt;/a&gt; flow.&lt;/p&gt;
    # @param authorization [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_issuing_authorizations_authorization_decline(*, authorization : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_issuing_authorizations_authorization_decline(authorization: authorization, expand: expand, metadata: metadata).execute(&block)
    end

    POST_ISSUING_AUTHORIZATIONS_AUTHORIZATION_DECLINE_MAX_LENGTH_FOR_AUTHORIZATION = 5000

    # @return Crest::Request
    def build_api_request_for_post_issuing_authorizations_authorization_decline(*, authorization : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_issuing_authorizations_authorization_decline ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"authorization\" is required and cannot be null") if authorization.nil?
        if _authorization = authorization
          OpenApi::PrimitiveValidator.validate_max_length("authorization", authorization.to_s.size, POST_ISSUING_AUTHORIZATIONS_AUTHORIZATION_DECLINE_MAX_LENGTH_FOR_AUTHORIZATION)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/authorizations/{authorization}/decline".sub("{" + "authorization" + "}", URI.encode_path(authorization.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_issuing_authorizations_authorization_decline",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new Issuing <code>Cardholder</code> object that can be issued cards.</p>
    # @param billing [Stripe::BillingSpecs?]
    # @param name [String?] The cardholder's name. This will be printed on cards issued to them. The maximum length of this field is 24 characters. This field cannot contain any special characters or numbers.
    # @param _type [String?] One of `individual` or `company`.
    # @optional @param company [Stripe::CompanyParam?]
    # @optional @param email [String?] The cardholder's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param individual [Stripe::IndividualParam?]
    # @optional @param phone_number [String?] The cardholder's phone number. This will be transformed to [E.164](https://en.wikipedia.org/wiki/E.164) if it is not provided in that format already. This is required for all cardholders who will be creating EU cards. See the [3D Secure documentation](https://stripe.com/docs/issuing/3d-secure#when-is-3d-secure-applied) for more details.
    # @optional @param spending_controls [Stripe::AuthorizationControlsParamV2?]
    # @optional @param status [String?] Specifies whether to permit authorizations on this cardholder's cards. Defaults to `active`.
    # @return [IssuingCardholder]
    def post_issuing_cardholders(*, billing : Stripe::BillingSpecs? = nil, name : String? = nil, _type : String? = nil, company : Stripe::CompanyParam? = nil, email : String? = nil, expand : Array(String)? = nil, individual : Stripe::IndividualParam? = nil, phone_number : String? = nil, spending_controls : Stripe::AuthorizationControlsParamV2? = nil, status : String? = nil)
      data, _status_code, _headers = post_issuing_cardholders_with_http_info(billing: billing, name: name, _type: _type, company: company, email: email, expand: expand, individual: individual, phone_number: phone_number, spending_controls: spending_controls, status: status)
      data
    end

    # &lt;p&gt;Creates a new Issuing &lt;code&gt;Cardholder&lt;/code&gt; object that can be issued cards.&lt;/p&gt;
    # @param billing [Stripe::BillingSpecs?]
    # @param name [String?] The cardholder's name. This will be printed on cards issued to them. The maximum length of this field is 24 characters. This field cannot contain any special characters or numbers.
    # @param _type [String?] One of `individual` or `company`.
    # @optional @param company [Stripe::CompanyParam?]
    # @optional @param email [String?] The cardholder's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param individual [Stripe::IndividualParam?]
    # @optional @param phone_number [String?] The cardholder's phone number. This will be transformed to [E.164](https://en.wikipedia.org/wiki/E.164) if it is not provided in that format already. This is required for all cardholders who will be creating EU cards. See the [3D Secure documentation](https://stripe.com/docs/issuing/3d-secure#when-is-3d-secure-applied) for more details.
    # @optional @param spending_controls [Stripe::AuthorizationControlsParamV2?]
    # @optional @param status [String?] Specifies whether to permit authorizations on this cardholder's cards. Defaults to `active`.
    # @return [Array<(IssuingCardholder, Integer, Hash)>] IssuingCardholder data, response status code and response headers
    def post_issuing_cardholders_with_http_info(*, billing : Stripe::BillingSpecs? = nil, name : String? = nil, _type : String? = nil, company : Stripe::CompanyParam? = nil, email : String? = nil, expand : Array(String)? = nil, individual : Stripe::IndividualParam? = nil, phone_number : String? = nil, spending_controls : Stripe::AuthorizationControlsParamV2? = nil, status : String? = nil)
      request = build_api_request_for_post_issuing_cardholders(billing: billing, name: name, _type: _type, company: company, email: email, expand: expand, individual: individual, phone_number: phone_number, spending_controls: spending_controls, status: status)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_issuing_cardholders\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingCardholder.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new Issuing &lt;code&gt;Cardholder&lt;/code&gt; object that can be issued cards.&lt;/p&gt;
    # @param billing [Stripe::BillingSpecs?]
    # @param name [String?] The cardholder's name. This will be printed on cards issued to them. The maximum length of this field is 24 characters. This field cannot contain any special characters or numbers.
    # @param _type [String?] One of `individual` or `company`.
    # @optional @param company [Stripe::CompanyParam?]
    # @optional @param email [String?] The cardholder's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param individual [Stripe::IndividualParam?]
    # @optional @param phone_number [String?] The cardholder's phone number. This will be transformed to [E.164](https://en.wikipedia.org/wiki/E.164) if it is not provided in that format already. This is required for all cardholders who will be creating EU cards. See the [3D Secure documentation](https://stripe.com/docs/issuing/3d-secure#when-is-3d-secure-applied) for more details.
    # @optional @param spending_controls [Stripe::AuthorizationControlsParamV2?]
    # @optional @param status [String?] Specifies whether to permit authorizations on this cardholder's cards. Defaults to `active`.
    # @return nil
    def post_issuing_cardholders(*, billing : Stripe::BillingSpecs? = nil, name : String? = nil, _type : String? = nil, company : Stripe::CompanyParam? = nil, email : String? = nil, expand : Array(String)? = nil, individual : Stripe::IndividualParam? = nil, phone_number : String? = nil, spending_controls : Stripe::AuthorizationControlsParamV2? = nil, status : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_issuing_cardholders(billing: billing, name: name, _type: _type, company: company, email: email, expand: expand, individual: individual, phone_number: phone_number, spending_controls: spending_controls, status: status).execute(&block)
    end

    POST_ISSUING_CARDHOLDERS_VALID_VALUES_FOR__TYPE  = StaticArray["company", "individual"]
    POST_ISSUING_CARDHOLDERS_VALID_VALUES_FOR_STATUS = StaticArray["active", "inactive"]

    # @return Crest::Request
    def build_api_request_for_post_issuing_cardholders(*, billing : Stripe::BillingSpecs? = nil, name : String? = nil, _type : String? = nil, company : Stripe::CompanyParam? = nil, email : String? = nil, expand : Array(String)? = nil, individual : Stripe::IndividualParam? = nil, phone_number : String? = nil, spending_controls : Stripe::AuthorizationControlsParamV2? = nil, status : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_issuing_cardholders ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"billing\" is required and cannot be null") if billing.nil?
        if _billing = billing
          _billing.validate if _billing.is_a?(OpenApi::Validatable)
        end
        raise ArgumentError.new("\"name\" is required and cannot be null") if name.nil?

        raise ArgumentError.new("\"_type\" is required and cannot be null") if _type.nil?
        if __type = _type
          OpenApi::EnumValidator.validate("_type", __type, POST_ISSUING_CARDHOLDERS_VALID_VALUES_FOR__TYPE)
        end
        if _company = company
          _company.validate if _company.is_a?(OpenApi::Validatable)
        end

        if _individual = individual
          _individual.validate if _individual.is_a?(OpenApi::Validatable)
        end

        if _spending_controls = spending_controls
          _spending_controls.validate if _spending_controls.is_a?(OpenApi::Validatable)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, POST_ISSUING_CARDHOLDERS_VALID_VALUES_FOR_STATUS)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/cardholders"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["billing"] = billing.to_s if !billing.nil?
      form_params["company"] = company.to_s if !company.nil?
      form_params["email"] = email.to_s if !email.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["individual"] = individual.to_s if !individual.nil?
      form_params["name"] = name.to_s if !name.nil?
      form_params["phone_number"] = phone_number.to_s if !phone_number.nil?
      form_params["spending_controls"] = spending_controls.to_s if !spending_controls.nil?
      form_params["status"] = status.to_s if !status.nil?
      form_params["type"] = _type.to_s if !_type.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_issuing_cardholders",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the specified Issuing <code>Cardholder</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
    # @param cardholder [String?]
    # @optional @param billing [Stripe::BillingSpecs?]
    # @optional @param company [Stripe::CompanyParam?]
    # @optional @param email [String?] The cardholder's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param individual [Stripe::IndividualParam?]
    # @optional @param phone_number [String?] The cardholder's phone number. This is required for all cardholders who will be creating EU cards. See the [3D Secure documentation](https://stripe.com/docs/issuing/3d-secure) for more details.
    # @optional @param spending_controls [Stripe::AuthorizationControlsParamV2?]
    # @optional @param status [String?] Specifies whether to permit authorizations on this cardholder's cards.
    # @return [IssuingCardholder]
    def post_issuing_cardholders_cardholder(*, cardholder : String? = nil, billing : Stripe::BillingSpecs? = nil, company : Stripe::CompanyParam? = nil, email : String? = nil, expand : Array(String)? = nil, individual : Stripe::IndividualParam? = nil, phone_number : String? = nil, spending_controls : Stripe::AuthorizationControlsParamV2? = nil, status : String? = nil)
      data, _status_code, _headers = post_issuing_cardholders_cardholder_with_http_info(cardholder: cardholder, billing: billing, company: company, email: email, expand: expand, individual: individual, phone_number: phone_number, spending_controls: spending_controls, status: status)
      data
    end

    # &lt;p&gt;Updates the specified Issuing &lt;code&gt;Cardholder&lt;/code&gt; object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;
    # @param cardholder [String?]
    # @optional @param billing [Stripe::BillingSpecs?]
    # @optional @param company [Stripe::CompanyParam?]
    # @optional @param email [String?] The cardholder's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param individual [Stripe::IndividualParam?]
    # @optional @param phone_number [String?] The cardholder's phone number. This is required for all cardholders who will be creating EU cards. See the [3D Secure documentation](https://stripe.com/docs/issuing/3d-secure) for more details.
    # @optional @param spending_controls [Stripe::AuthorizationControlsParamV2?]
    # @optional @param status [String?] Specifies whether to permit authorizations on this cardholder's cards.
    # @return [Array<(IssuingCardholder, Integer, Hash)>] IssuingCardholder data, response status code and response headers
    def post_issuing_cardholders_cardholder_with_http_info(*, cardholder : String? = nil, billing : Stripe::BillingSpecs? = nil, company : Stripe::CompanyParam? = nil, email : String? = nil, expand : Array(String)? = nil, individual : Stripe::IndividualParam? = nil, phone_number : String? = nil, spending_controls : Stripe::AuthorizationControlsParamV2? = nil, status : String? = nil)
      request = build_api_request_for_post_issuing_cardholders_cardholder(cardholder: cardholder, billing: billing, company: company, email: email, expand: expand, individual: individual, phone_number: phone_number, spending_controls: spending_controls, status: status)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_issuing_cardholders_cardholder\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingCardholder.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the specified Issuing &lt;code&gt;Cardholder&lt;/code&gt; object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;
    # @param cardholder [String?]
    # @optional @param billing [Stripe::BillingSpecs?]
    # @optional @param company [Stripe::CompanyParam?]
    # @optional @param email [String?] The cardholder's email address.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param individual [Stripe::IndividualParam?]
    # @optional @param phone_number [String?] The cardholder's phone number. This is required for all cardholders who will be creating EU cards. See the [3D Secure documentation](https://stripe.com/docs/issuing/3d-secure) for more details.
    # @optional @param spending_controls [Stripe::AuthorizationControlsParamV2?]
    # @optional @param status [String?] Specifies whether to permit authorizations on this cardholder's cards.
    # @return nil
    def post_issuing_cardholders_cardholder(*, cardholder : String? = nil, billing : Stripe::BillingSpecs? = nil, company : Stripe::CompanyParam? = nil, email : String? = nil, expand : Array(String)? = nil, individual : Stripe::IndividualParam? = nil, phone_number : String? = nil, spending_controls : Stripe::AuthorizationControlsParamV2? = nil, status : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_issuing_cardholders_cardholder(cardholder: cardholder, billing: billing, company: company, email: email, expand: expand, individual: individual, phone_number: phone_number, spending_controls: spending_controls, status: status).execute(&block)
    end

    POST_ISSUING_CARDHOLDERS_CARDHOLDER_MAX_LENGTH_FOR_CARDHOLDER = 5000
    POST_ISSUING_CARDHOLDERS_CARDHOLDER_VALID_VALUES_FOR_STATUS   = StaticArray["active", "inactive"]

    # @return Crest::Request
    def build_api_request_for_post_issuing_cardholders_cardholder(*, cardholder : String? = nil, billing : Stripe::BillingSpecs? = nil, company : Stripe::CompanyParam? = nil, email : String? = nil, expand : Array(String)? = nil, individual : Stripe::IndividualParam? = nil, phone_number : String? = nil, spending_controls : Stripe::AuthorizationControlsParamV2? = nil, status : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_issuing_cardholders_cardholder ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"cardholder\" is required and cannot be null") if cardholder.nil?
        if _cardholder = cardholder
          OpenApi::PrimitiveValidator.validate_max_length("cardholder", cardholder.to_s.size, POST_ISSUING_CARDHOLDERS_CARDHOLDER_MAX_LENGTH_FOR_CARDHOLDER)
        end
        if _billing = billing
          _billing.validate if _billing.is_a?(OpenApi::Validatable)
        end
        if _company = company
          _company.validate if _company.is_a?(OpenApi::Validatable)
        end

        if _individual = individual
          _individual.validate if _individual.is_a?(OpenApi::Validatable)
        end

        if _spending_controls = spending_controls
          _spending_controls.validate if _spending_controls.is_a?(OpenApi::Validatable)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, POST_ISSUING_CARDHOLDERS_CARDHOLDER_VALID_VALUES_FOR_STATUS)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/cardholders/{cardholder}".sub("{" + "cardholder" + "}", URI.encode_path(cardholder.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["billing"] = billing.to_s if !billing.nil?
      form_params["company"] = company.to_s if !company.nil?
      form_params["email"] = email.to_s if !email.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["individual"] = individual.to_s if !individual.nil?
      form_params["phone_number"] = phone_number.to_s if !phone_number.nil?
      form_params["spending_controls"] = spending_controls.to_s if !spending_controls.nil?
      form_params["status"] = status.to_s if !status.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_issuing_cardholders_cardholder",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates an Issuing <code>Card</code> object.</p>
    # @param currency [String?] The currency for the card.
    # @param _type [String?] The type of card to issue. Possible values are `physical` or `virtual`.
    # @optional @param cardholder [String?] The [Cardholder](https://stripe.com/docs/api#issuing_cardholder_object) object with which the card will be associated.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param financial_account [String?]
    # @optional @param replacement_for [String?] The card this is meant to be a replacement for (if any).
    # @optional @param replacement_reason [String?] If `replacement_for` is specified, this should indicate why that card is being replaced.
    # @optional @param shipping [Stripe::ShippingSpecs?]
    # @optional @param spending_controls [Stripe::AuthorizationControlsParam?]
    # @optional @param status [String?] Whether authorizations can be approved on this card. Defaults to `inactive`.
    # @return [IssuingCard]
    def post_issuing_cards(*, currency : String? = nil, _type : String? = nil, cardholder : String? = nil, expand : Array(String)? = nil, financial_account : String? = nil, replacement_for : String? = nil, replacement_reason : String? = nil, shipping : Stripe::ShippingSpecs? = nil, spending_controls : Stripe::AuthorizationControlsParam? = nil, status : String? = nil)
      data, _status_code, _headers = post_issuing_cards_with_http_info(currency: currency, _type: _type, cardholder: cardholder, expand: expand, financial_account: financial_account, replacement_for: replacement_for, replacement_reason: replacement_reason, shipping: shipping, spending_controls: spending_controls, status: status)
      data
    end

    # &lt;p&gt;Creates an Issuing &lt;code&gt;Card&lt;/code&gt; object.&lt;/p&gt;
    # @param currency [String?] The currency for the card.
    # @param _type [String?] The type of card to issue. Possible values are `physical` or `virtual`.
    # @optional @param cardholder [String?] The [Cardholder](https://stripe.com/docs/api#issuing_cardholder_object) object with which the card will be associated.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param financial_account [String?]
    # @optional @param replacement_for [String?] The card this is meant to be a replacement for (if any).
    # @optional @param replacement_reason [String?] If `replacement_for` is specified, this should indicate why that card is being replaced.
    # @optional @param shipping [Stripe::ShippingSpecs?]
    # @optional @param spending_controls [Stripe::AuthorizationControlsParam?]
    # @optional @param status [String?] Whether authorizations can be approved on this card. Defaults to `inactive`.
    # @return [Array<(IssuingCard, Integer, Hash)>] IssuingCard data, response status code and response headers
    def post_issuing_cards_with_http_info(*, currency : String? = nil, _type : String? = nil, cardholder : String? = nil, expand : Array(String)? = nil, financial_account : String? = nil, replacement_for : String? = nil, replacement_reason : String? = nil, shipping : Stripe::ShippingSpecs? = nil, spending_controls : Stripe::AuthorizationControlsParam? = nil, status : String? = nil)
      request = build_api_request_for_post_issuing_cards(currency: currency, _type: _type, cardholder: cardholder, expand: expand, financial_account: financial_account, replacement_for: replacement_for, replacement_reason: replacement_reason, shipping: shipping, spending_controls: spending_controls, status: status)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_issuing_cards\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingCard.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates an Issuing &lt;code&gt;Card&lt;/code&gt; object.&lt;/p&gt;
    # @param currency [String?] The currency for the card.
    # @param _type [String?] The type of card to issue. Possible values are `physical` or `virtual`.
    # @optional @param cardholder [String?] The [Cardholder](https://stripe.com/docs/api#issuing_cardholder_object) object with which the card will be associated.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param financial_account [String?]
    # @optional @param replacement_for [String?] The card this is meant to be a replacement for (if any).
    # @optional @param replacement_reason [String?] If `replacement_for` is specified, this should indicate why that card is being replaced.
    # @optional @param shipping [Stripe::ShippingSpecs?]
    # @optional @param spending_controls [Stripe::AuthorizationControlsParam?]
    # @optional @param status [String?] Whether authorizations can be approved on this card. Defaults to `inactive`.
    # @return nil
    def post_issuing_cards(*, currency : String? = nil, _type : String? = nil, cardholder : String? = nil, expand : Array(String)? = nil, financial_account : String? = nil, replacement_for : String? = nil, replacement_reason : String? = nil, shipping : Stripe::ShippingSpecs? = nil, spending_controls : Stripe::AuthorizationControlsParam? = nil, status : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_issuing_cards(currency: currency, _type: _type, cardholder: cardholder, expand: expand, financial_account: financial_account, replacement_for: replacement_for, replacement_reason: replacement_reason, shipping: shipping, spending_controls: spending_controls, status: status).execute(&block)
    end

    POST_ISSUING_CARDS_VALID_VALUES_FOR__TYPE              = StaticArray["physical", "virtual"]
    POST_ISSUING_CARDS_MAX_LENGTH_FOR_CARDHOLDER           = 5000
    POST_ISSUING_CARDS_MAX_LENGTH_FOR_REPLACEMENT_FOR      = 5000
    POST_ISSUING_CARDS_VALID_VALUES_FOR_REPLACEMENT_REASON = StaticArray["damaged", "expired", "lost", "stolen"]
    POST_ISSUING_CARDS_VALID_VALUES_FOR_STATUS             = StaticArray["active", "inactive"]

    # @return Crest::Request
    def build_api_request_for_post_issuing_cards(*, currency : String? = nil, _type : String? = nil, cardholder : String? = nil, expand : Array(String)? = nil, financial_account : String? = nil, replacement_for : String? = nil, replacement_reason : String? = nil, shipping : Stripe::ShippingSpecs? = nil, spending_controls : Stripe::AuthorizationControlsParam? = nil, status : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_issuing_cards ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"currency\" is required and cannot be null") if currency.nil?

        raise ArgumentError.new("\"_type\" is required and cannot be null") if _type.nil?
        if __type = _type
          OpenApi::EnumValidator.validate("_type", __type, POST_ISSUING_CARDS_VALID_VALUES_FOR__TYPE)
        end
        if _cardholder = cardholder
          OpenApi::PrimitiveValidator.validate_max_length("cardholder", cardholder.to_s.size, POST_ISSUING_CARDS_MAX_LENGTH_FOR_CARDHOLDER)
        end

        if _replacement_for = replacement_for
          OpenApi::PrimitiveValidator.validate_max_length("replacement_for", replacement_for.to_s.size, POST_ISSUING_CARDS_MAX_LENGTH_FOR_REPLACEMENT_FOR)
        end
        if _replacement_reason = replacement_reason
          OpenApi::EnumValidator.validate("replacement_reason", _replacement_reason, POST_ISSUING_CARDS_VALID_VALUES_FOR_REPLACEMENT_REASON)
        end
        if _shipping = shipping
          _shipping.validate if _shipping.is_a?(OpenApi::Validatable)
        end
        if _spending_controls = spending_controls
          _spending_controls.validate if _spending_controls.is_a?(OpenApi::Validatable)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, POST_ISSUING_CARDS_VALID_VALUES_FOR_STATUS)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/cards"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["cardholder"] = cardholder.to_s if !cardholder.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["financial_account"] = financial_account.to_s if !financial_account.nil?
      form_params["replacement_for"] = replacement_for.to_s if !replacement_for.nil?
      form_params["replacement_reason"] = replacement_reason.to_s if !replacement_reason.nil?
      form_params["shipping"] = shipping.to_s if !shipping.nil?
      form_params["spending_controls"] = spending_controls.to_s if !spending_controls.nil?
      form_params["status"] = status.to_s if !status.nil?
      form_params["type"] = _type.to_s if !_type.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_issuing_cards",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the specified Issuing <code>Card</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
    # @param card [String?]
    # @optional @param cancellation_reason [String?] Reason why the `status` of this card is `canceled`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param pin [Stripe::EncryptedPinParam?]
    # @optional @param spending_controls [Stripe::AuthorizationControlsParam?]
    # @optional @param status [String?] Dictates whether authorizations can be approved on this card. If this card is being canceled because it was lost or stolen, this information should be provided as `cancellation_reason`.
    # @return [IssuingCard]
    def post_issuing_cards_card(*, card : String? = nil, cancellation_reason : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, pin : Stripe::EncryptedPinParam? = nil, spending_controls : Stripe::AuthorizationControlsParam? = nil, status : String? = nil)
      data, _status_code, _headers = post_issuing_cards_card_with_http_info(card: card, cancellation_reason: cancellation_reason, expand: expand, metadata: metadata, pin: pin, spending_controls: spending_controls, status: status)
      data
    end

    # &lt;p&gt;Updates the specified Issuing &lt;code&gt;Card&lt;/code&gt; object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;
    # @param card [String?]
    # @optional @param cancellation_reason [String?] Reason why the `status` of this card is `canceled`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param pin [Stripe::EncryptedPinParam?]
    # @optional @param spending_controls [Stripe::AuthorizationControlsParam?]
    # @optional @param status [String?] Dictates whether authorizations can be approved on this card. If this card is being canceled because it was lost or stolen, this information should be provided as `cancellation_reason`.
    # @return [Array<(IssuingCard, Integer, Hash)>] IssuingCard data, response status code and response headers
    def post_issuing_cards_card_with_http_info(*, card : String? = nil, cancellation_reason : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, pin : Stripe::EncryptedPinParam? = nil, spending_controls : Stripe::AuthorizationControlsParam? = nil, status : String? = nil)
      request = build_api_request_for_post_issuing_cards_card(card: card, cancellation_reason: cancellation_reason, expand: expand, metadata: metadata, pin: pin, spending_controls: spending_controls, status: status)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_issuing_cards_card\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingCard.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the specified Issuing &lt;code&gt;Card&lt;/code&gt; object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;
    # @param card [String?]
    # @optional @param cancellation_reason [String?] Reason why the `status` of this card is `canceled`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param pin [Stripe::EncryptedPinParam?]
    # @optional @param spending_controls [Stripe::AuthorizationControlsParam?]
    # @optional @param status [String?] Dictates whether authorizations can be approved on this card. If this card is being canceled because it was lost or stolen, this information should be provided as `cancellation_reason`.
    # @return nil
    def post_issuing_cards_card(*, card : String? = nil, cancellation_reason : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, pin : Stripe::EncryptedPinParam? = nil, spending_controls : Stripe::AuthorizationControlsParam? = nil, status : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_issuing_cards_card(card: card, cancellation_reason: cancellation_reason, expand: expand, metadata: metadata, pin: pin, spending_controls: spending_controls, status: status).execute(&block)
    end

    POST_ISSUING_CARDS_CARD_MAX_LENGTH_FOR_CARD                  = 5000
    POST_ISSUING_CARDS_CARD_VALID_VALUES_FOR_CANCELLATION_REASON = StaticArray["lost", "stolen"]
    POST_ISSUING_CARDS_CARD_VALID_VALUES_FOR_STATUS              = StaticArray["active", "canceled", "inactive"]

    # @return Crest::Request
    def build_api_request_for_post_issuing_cards_card(*, card : String? = nil, cancellation_reason : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, pin : Stripe::EncryptedPinParam? = nil, spending_controls : Stripe::AuthorizationControlsParam? = nil, status : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_issuing_cards_card ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"card\" is required and cannot be null") if card.nil?
        if _card = card
          OpenApi::PrimitiveValidator.validate_max_length("card", card.to_s.size, POST_ISSUING_CARDS_CARD_MAX_LENGTH_FOR_CARD)
        end
        if _cancellation_reason = cancellation_reason
          OpenApi::EnumValidator.validate("cancellation_reason", _cancellation_reason, POST_ISSUING_CARDS_CARD_VALID_VALUES_FOR_CANCELLATION_REASON)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _pin = pin
          _pin.validate if _pin.is_a?(OpenApi::Validatable)
        end
        if _spending_controls = spending_controls
          _spending_controls.validate if _spending_controls.is_a?(OpenApi::Validatable)
        end
        if _status = status
          OpenApi::EnumValidator.validate("status", _status, POST_ISSUING_CARDS_CARD_VALID_VALUES_FOR_STATUS)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/cards/{card}".sub("{" + "card" + "}", URI.encode_path(card.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["cancellation_reason"] = cancellation_reason.to_s if !cancellation_reason.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["pin"] = pin.to_s if !pin.nil?
      form_params["spending_controls"] = spending_controls.to_s if !spending_controls.nil?
      form_params["status"] = status.to_s if !status.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_issuing_cards_card",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates an Issuing <code>Dispute</code> object. Individual pieces of evidence within the <code>evidence</code> object are optional at this point. Stripe only validates that required evidence is present during submission. Refer to <a href=\"/docs/issuing/purchases/disputes#dispute-reasons-and-evidence\">Dispute reasons and evidence</a> for more details about evidence requirements.</p>
    # @optional @param amount [Int64?] The dispute amount in the card's currency and in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal). If not set, defaults to the full transaction amount.
    # @optional @param evidence [Stripe::EvidenceParam?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param transaction [String?] The ID of the issuing transaction to create a dispute for. For transaction on Treasury FinancialAccounts, use `treasury.received_debit`.
    # @optional @param treasury [Stripe::TreasuryParam?]
    # @return [IssuingDispute]
    def post_issuing_disputes(*, amount : Int64? = nil, evidence : Stripe::EvidenceParam? = nil, expand : Array(String)? = nil, transaction : String? = nil, treasury : Stripe::TreasuryParam? = nil)
      data, _status_code, _headers = post_issuing_disputes_with_http_info(amount: amount, evidence: evidence, expand: expand, transaction: transaction, treasury: treasury)
      data
    end

    # &lt;p&gt;Creates an Issuing &lt;code&gt;Dispute&lt;/code&gt; object. Individual pieces of evidence within the &lt;code&gt;evidence&lt;/code&gt; object are optional at this point. Stripe only validates that required evidence is present during submission. Refer to &lt;a href&#x3D;\&quot;/docs/issuing/purchases/disputes#dispute-reasons-and-evidence\&quot;&gt;Dispute reasons and evidence&lt;/a&gt; for more details about evidence requirements.&lt;/p&gt;
    # @optional @param amount [Int64?] The dispute amount in the card's currency and in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal). If not set, defaults to the full transaction amount.
    # @optional @param evidence [Stripe::EvidenceParam?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param transaction [String?] The ID of the issuing transaction to create a dispute for. For transaction on Treasury FinancialAccounts, use `treasury.received_debit`.
    # @optional @param treasury [Stripe::TreasuryParam?]
    # @return [Array<(IssuingDispute, Integer, Hash)>] IssuingDispute data, response status code and response headers
    def post_issuing_disputes_with_http_info(*, amount : Int64? = nil, evidence : Stripe::EvidenceParam? = nil, expand : Array(String)? = nil, transaction : String? = nil, treasury : Stripe::TreasuryParam? = nil)
      request = build_api_request_for_post_issuing_disputes(amount: amount, evidence: evidence, expand: expand, transaction: transaction, treasury: treasury)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_issuing_disputes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingDispute.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates an Issuing &lt;code&gt;Dispute&lt;/code&gt; object. Individual pieces of evidence within the &lt;code&gt;evidence&lt;/code&gt; object are optional at this point. Stripe only validates that required evidence is present during submission. Refer to &lt;a href&#x3D;\&quot;/docs/issuing/purchases/disputes#dispute-reasons-and-evidence\&quot;&gt;Dispute reasons and evidence&lt;/a&gt; for more details about evidence requirements.&lt;/p&gt;
    # @optional @param amount [Int64?] The dispute amount in the card's currency and in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal). If not set, defaults to the full transaction amount.
    # @optional @param evidence [Stripe::EvidenceParam?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param transaction [String?] The ID of the issuing transaction to create a dispute for. For transaction on Treasury FinancialAccounts, use `treasury.received_debit`.
    # @optional @param treasury [Stripe::TreasuryParam?]
    # @return nil
    def post_issuing_disputes(*, amount : Int64? = nil, evidence : Stripe::EvidenceParam? = nil, expand : Array(String)? = nil, transaction : String? = nil, treasury : Stripe::TreasuryParam? = nil, &block : Crest::Response ->)
      build_api_request_for_post_issuing_disputes(amount: amount, evidence: evidence, expand: expand, transaction: transaction, treasury: treasury).execute(&block)
    end

    POST_ISSUING_DISPUTES_MAX_LENGTH_FOR_TRANSACTION = 5000

    # @return Crest::Request
    def build_api_request_for_post_issuing_disputes(*, amount : Int64? = nil, evidence : Stripe::EvidenceParam? = nil, expand : Array(String)? = nil, transaction : String? = nil, treasury : Stripe::TreasuryParam? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_issuing_disputes ..." }
      end

      if client_side_validation
        if _evidence = evidence
          _evidence.validate if _evidence.is_a?(OpenApi::Validatable)
        end

        if _transaction = transaction
          OpenApi::PrimitiveValidator.validate_max_length("transaction", transaction.to_s.size, POST_ISSUING_DISPUTES_MAX_LENGTH_FOR_TRANSACTION)
        end
        if _treasury = treasury
          _treasury.validate if _treasury.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/disputes"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["evidence"] = evidence.to_s if !evidence.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["transaction"] = transaction.to_s if !transaction.nil?
      form_params["treasury"] = treasury.to_s if !treasury.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_issuing_disputes",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the specified Issuing <code>Dispute</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged. Properties on the <code>evidence</code> object can be unset by passing in an empty string.</p>
    # @param dispute [String?]
    # @optional @param amount [Int64?] The dispute amount in the card's currency and in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal).
    # @optional @param evidence [Stripe::EvidenceParam?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [IssuingDispute]
    def post_issuing_disputes_dispute(*, dispute : String? = nil, amount : Int64? = nil, evidence : Stripe::EvidenceParam? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_issuing_disputes_dispute_with_http_info(dispute: dispute, amount: amount, evidence: evidence, expand: expand, metadata: metadata)
      data
    end

    # &lt;p&gt;Updates the specified Issuing &lt;code&gt;Dispute&lt;/code&gt; object by setting the values of the parameters passed. Any parameters not provided will be left unchanged. Properties on the &lt;code&gt;evidence&lt;/code&gt; object can be unset by passing in an empty string.&lt;/p&gt;
    # @param dispute [String?]
    # @optional @param amount [Int64?] The dispute amount in the card's currency and in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal).
    # @optional @param evidence [Stripe::EvidenceParam?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(IssuingDispute, Integer, Hash)>] IssuingDispute data, response status code and response headers
    def post_issuing_disputes_dispute_with_http_info(*, dispute : String? = nil, amount : Int64? = nil, evidence : Stripe::EvidenceParam? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_issuing_disputes_dispute(dispute: dispute, amount: amount, evidence: evidence, expand: expand, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_issuing_disputes_dispute\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingDispute.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the specified Issuing &lt;code&gt;Dispute&lt;/code&gt; object by setting the values of the parameters passed. Any parameters not provided will be left unchanged. Properties on the &lt;code&gt;evidence&lt;/code&gt; object can be unset by passing in an empty string.&lt;/p&gt;
    # @param dispute [String?]
    # @optional @param amount [Int64?] The dispute amount in the card's currency and in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal).
    # @optional @param evidence [Stripe::EvidenceParam?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_issuing_disputes_dispute(*, dispute : String? = nil, amount : Int64? = nil, evidence : Stripe::EvidenceParam? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_issuing_disputes_dispute(dispute: dispute, amount: amount, evidence: evidence, expand: expand, metadata: metadata).execute(&block)
    end

    POST_ISSUING_DISPUTES_DISPUTE_MAX_LENGTH_FOR_DISPUTE = 5000

    # @return Crest::Request
    def build_api_request_for_post_issuing_disputes_dispute(*, dispute : String? = nil, amount : Int64? = nil, evidence : Stripe::EvidenceParam? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_issuing_disputes_dispute ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"dispute\" is required and cannot be null") if dispute.nil?
        if _dispute = dispute
          OpenApi::PrimitiveValidator.validate_max_length("dispute", dispute.to_s.size, POST_ISSUING_DISPUTES_DISPUTE_MAX_LENGTH_FOR_DISPUTE)
        end

        if _evidence = evidence
          _evidence.validate if _evidence.is_a?(OpenApi::Validatable)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/disputes/{dispute}".sub("{" + "dispute" + "}", URI.encode_path(dispute.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["evidence"] = evidence.to_s if !evidence.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_issuing_disputes_dispute",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Submits an Issuing <code>Dispute</code> to the card network. Stripe validates that all evidence fields required for the dispute’s reason are present. For more details, see <a href=\"/docs/issuing/purchases/disputes#dispute-reasons-and-evidence\">Dispute reasons and evidence</a>.</p>
    # @param dispute [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [IssuingDispute]
    def post_issuing_disputes_dispute_submit(*, dispute : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_issuing_disputes_dispute_submit_with_http_info(dispute: dispute, expand: expand, metadata: metadata)
      data
    end

    # &lt;p&gt;Submits an Issuing &lt;code&gt;Dispute&lt;/code&gt; to the card network. Stripe validates that all evidence fields required for the dispute’s reason are present. For more details, see &lt;a href&#x3D;\&quot;/docs/issuing/purchases/disputes#dispute-reasons-and-evidence\&quot;&gt;Dispute reasons and evidence&lt;/a&gt;.&lt;/p&gt;
    # @param dispute [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(IssuingDispute, Integer, Hash)>] IssuingDispute data, response status code and response headers
    def post_issuing_disputes_dispute_submit_with_http_info(*, dispute : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_issuing_disputes_dispute_submit(dispute: dispute, expand: expand, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_issuing_disputes_dispute_submit\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingDispute.from_json(data), status_code, headers
    end

    # &lt;p&gt;Submits an Issuing &lt;code&gt;Dispute&lt;/code&gt; to the card network. Stripe validates that all evidence fields required for the dispute’s reason are present. For more details, see &lt;a href&#x3D;\&quot;/docs/issuing/purchases/disputes#dispute-reasons-and-evidence\&quot;&gt;Dispute reasons and evidence&lt;/a&gt;.&lt;/p&gt;
    # @param dispute [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_issuing_disputes_dispute_submit(*, dispute : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_issuing_disputes_dispute_submit(dispute: dispute, expand: expand, metadata: metadata).execute(&block)
    end

    POST_ISSUING_DISPUTES_DISPUTE_SUBMIT_MAX_LENGTH_FOR_DISPUTE = 5000

    # @return Crest::Request
    def build_api_request_for_post_issuing_disputes_dispute_submit(*, dispute : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_issuing_disputes_dispute_submit ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"dispute\" is required and cannot be null") if dispute.nil?
        if _dispute = dispute
          OpenApi::PrimitiveValidator.validate_max_length("dispute", dispute.to_s.size, POST_ISSUING_DISPUTES_DISPUTE_SUBMIT_MAX_LENGTH_FOR_DISPUTE)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/disputes/{dispute}/submit".sub("{" + "dispute" + "}", URI.encode_path(dispute.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_issuing_disputes_dispute_submit",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the specified Issuing <code>Settlement</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
    # @param settlement [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [IssuingSettlement]
    def post_issuing_settlements_settlement(*, settlement : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_issuing_settlements_settlement_with_http_info(settlement: settlement, expand: expand)
      data
    end

    # &lt;p&gt;Updates the specified Issuing &lt;code&gt;Settlement&lt;/code&gt; object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;
    # @param settlement [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(IssuingSettlement, Integer, Hash)>] IssuingSettlement data, response status code and response headers
    def post_issuing_settlements_settlement_with_http_info(*, settlement : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_issuing_settlements_settlement(settlement: settlement, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_issuing_settlements_settlement\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingSettlement.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the specified Issuing &lt;code&gt;Settlement&lt;/code&gt; object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;
    # @param settlement [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_issuing_settlements_settlement(*, settlement : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_issuing_settlements_settlement(settlement: settlement, expand: expand).execute(&block)
    end

    POST_ISSUING_SETTLEMENTS_SETTLEMENT_MAX_LENGTH_FOR_SETTLEMENT = 5000

    # @return Crest::Request
    def build_api_request_for_post_issuing_settlements_settlement(*, settlement : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_issuing_settlements_settlement ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"settlement\" is required and cannot be null") if settlement.nil?
        if _settlement = settlement
          OpenApi::PrimitiveValidator.validate_max_length("settlement", settlement.to_s.size, POST_ISSUING_SETTLEMENTS_SETTLEMENT_MAX_LENGTH_FOR_SETTLEMENT)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/settlements/{settlement}".sub("{" + "settlement" + "}", URI.encode_path(settlement.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_issuing_settlements_settlement",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the specified Issuing <code>Transaction</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
    # @param transaction [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [IssuingTransaction]
    def post_issuing_transactions_transaction(*, transaction : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_issuing_transactions_transaction_with_http_info(transaction: transaction, expand: expand, metadata: metadata)
      data
    end

    # &lt;p&gt;Updates the specified Issuing &lt;code&gt;Transaction&lt;/code&gt; object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;
    # @param transaction [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(IssuingTransaction, Integer, Hash)>] IssuingTransaction data, response status code and response headers
    def post_issuing_transactions_transaction_with_http_info(*, transaction : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_issuing_transactions_transaction(transaction: transaction, expand: expand, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_issuing_transactions_transaction\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingTransaction.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the specified Issuing &lt;code&gt;Transaction&lt;/code&gt; object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;
    # @param transaction [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_issuing_transactions_transaction(*, transaction : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_issuing_transactions_transaction(transaction: transaction, expand: expand, metadata: metadata).execute(&block)
    end

    POST_ISSUING_TRANSACTIONS_TRANSACTION_MAX_LENGTH_FOR_TRANSACTION = 5000

    # @return Crest::Request
    def build_api_request_for_post_issuing_transactions_transaction(*, transaction : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_issuing_transactions_transaction ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"transaction\" is required and cannot be null") if transaction.nil?
        if _transaction = transaction
          OpenApi::PrimitiveValidator.validate_max_length("transaction", transaction.to_s.size, POST_ISSUING_TRANSACTIONS_TRANSACTION_MAX_LENGTH_FOR_TRANSACTION)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/issuing/transactions/{transaction}".sub("{" + "transaction" + "}", URI.encode_path(transaction.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_issuing_transactions_transaction",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>To launch the Financial Connections authorization flow, create a <code>Session</code>. The session’s <code>client_secret</code> can be used to launch the flow using Stripe.js.</p>
    # @param account_holder [Stripe::AccountholderParams1?]
    # @param permissions [Array(String)?] List of data features that you would like to request access to.  Possible values are `balances`, `transactions`, `ownership`, and `payment_method`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param filters [Stripe::FiltersParams?]
    # @optional @param return_url [String?] For webview integrations only. Upon completing OAuth login in the native browser, the user will be redirected to this URL to return to your app.
    # @return [FinancialConnectionsSession]
    def post_link_account_sessions(*, account_holder : Stripe::AccountholderParams1? = nil, permissions : Array(String)? = nil, expand : Array(String)? = nil, filters : Stripe::FiltersParams? = nil, return_url : String? = nil)
      data, _status_code, _headers = post_link_account_sessions_with_http_info(account_holder: account_holder, permissions: permissions, expand: expand, filters: filters, return_url: return_url)
      data
    end

    # &lt;p&gt;To launch the Financial Connections authorization flow, create a &lt;code&gt;Session&lt;/code&gt;. The session’s &lt;code&gt;client_secret&lt;/code&gt; can be used to launch the flow using Stripe.js.&lt;/p&gt;
    # @param account_holder [Stripe::AccountholderParams1?]
    # @param permissions [Array(String)?] List of data features that you would like to request access to.  Possible values are `balances`, `transactions`, `ownership`, and `payment_method`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param filters [Stripe::FiltersParams?]
    # @optional @param return_url [String?] For webview integrations only. Upon completing OAuth login in the native browser, the user will be redirected to this URL to return to your app.
    # @return [Array<(FinancialConnectionsSession, Integer, Hash)>] FinancialConnectionsSession data, response status code and response headers
    def post_link_account_sessions_with_http_info(*, account_holder : Stripe::AccountholderParams1? = nil, permissions : Array(String)? = nil, expand : Array(String)? = nil, filters : Stripe::FiltersParams? = nil, return_url : String? = nil)
      request = build_api_request_for_post_link_account_sessions(account_holder: account_holder, permissions: permissions, expand: expand, filters: filters, return_url: return_url)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_link_account_sessions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FinancialConnectionsSession.from_json(data), status_code, headers
    end

    # &lt;p&gt;To launch the Financial Connections authorization flow, create a &lt;code&gt;Session&lt;/code&gt;. The session’s &lt;code&gt;client_secret&lt;/code&gt; can be used to launch the flow using Stripe.js.&lt;/p&gt;
    # @param account_holder [Stripe::AccountholderParams1?]
    # @param permissions [Array(String)?] List of data features that you would like to request access to.  Possible values are `balances`, `transactions`, `ownership`, and `payment_method`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param filters [Stripe::FiltersParams?]
    # @optional @param return_url [String?] For webview integrations only. Upon completing OAuth login in the native browser, the user will be redirected to this URL to return to your app.
    # @return nil
    def post_link_account_sessions(*, account_holder : Stripe::AccountholderParams1? = nil, permissions : Array(String)? = nil, expand : Array(String)? = nil, filters : Stripe::FiltersParams? = nil, return_url : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_link_account_sessions(account_holder: account_holder, permissions: permissions, expand: expand, filters: filters, return_url: return_url).execute(&block)
    end

    POST_LINK_ACCOUNT_SESSIONS_VALID_VALUES_FOR_PERMISSIONS = StaticArray["balances", "ownership", "payment_method", "transactions"]
    POST_LINK_ACCOUNT_SESSIONS_MAX_LENGTH_FOR_RETURN_URL    = 5000

    # @return Crest::Request
    def build_api_request_for_post_link_account_sessions(*, account_holder : Stripe::AccountholderParams1? = nil, permissions : Array(String)? = nil, expand : Array(String)? = nil, filters : Stripe::FiltersParams? = nil, return_url : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_link_account_sessions ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account_holder\" is required and cannot be null") if account_holder.nil?
        if _account_holder = account_holder
          _account_holder.validate if _account_holder.is_a?(OpenApi::Validatable)
        end
        raise ArgumentError.new("\"permissions\" is required and cannot be null") if permissions.nil?
        if _permissions = permissions
          OpenApi::EnumValidator.validate("permissions", _permissions, POST_LINK_ACCOUNT_SESSIONS_VALID_VALUES_FOR_PERMISSIONS)
        end

        if _filters = filters
          _filters.validate if _filters.is_a?(OpenApi::Validatable)
        end
        if _return_url = return_url
          OpenApi::PrimitiveValidator.validate_max_length("return_url", return_url.to_s.size, POST_LINK_ACCOUNT_SESSIONS_MAX_LENGTH_FOR_RETURN_URL)
        end
      end

      # resource path
      local_var_path = "/v1/link_account_sessions"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account_holder"] = account_holder.to_s if !account_holder.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["filters"] = filters.to_s if !filters.nil?
      form_params["permissions"] = @api_client.build_collection_param(permissions, "csv") if !permissions.nil? && !permissions.empty?
      form_params["return_url"] = return_url.to_s if !return_url.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_link_account_sessions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Disables your access to a Financial Connections <code>Account</code>. You will no longer be able to access data associated with the account (e.g. balances, transactions).</p>
    # @param account [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [FinancialConnectionsAccount]
    def post_linked_accounts_account_disconnect(*, account : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_linked_accounts_account_disconnect_with_http_info(account: account, expand: expand)
      data
    end

    # &lt;p&gt;Disables your access to a Financial Connections &lt;code&gt;Account&lt;/code&gt;. You will no longer be able to access data associated with the account (e.g. balances, transactions).&lt;/p&gt;
    # @param account [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(FinancialConnectionsAccount, Integer, Hash)>] FinancialConnectionsAccount data, response status code and response headers
    def post_linked_accounts_account_disconnect_with_http_info(*, account : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_linked_accounts_account_disconnect(account: account, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_linked_accounts_account_disconnect\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FinancialConnectionsAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Disables your access to a Financial Connections &lt;code&gt;Account&lt;/code&gt;. You will no longer be able to access data associated with the account (e.g. balances, transactions).&lt;/p&gt;
    # @param account [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_linked_accounts_account_disconnect(*, account : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_linked_accounts_account_disconnect(account: account, expand: expand).execute(&block)
    end

    POST_LINKED_ACCOUNTS_ACCOUNT_DISCONNECT_MAX_LENGTH_FOR_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_post_linked_accounts_account_disconnect(*, account : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_linked_accounts_account_disconnect ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_LINKED_ACCOUNTS_ACCOUNT_DISCONNECT_MAX_LENGTH_FOR_ACCOUNT)
        end
      end

      # resource path
      local_var_path = "/v1/linked_accounts/{account}/disconnect".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_linked_accounts_account_disconnect",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Refreshes the data associated with a Financial Connections <code>Account</code>.</p>
    # @param account [String?]
    # @param features [Array(String)?] The list of account features that you would like to refresh.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [FinancialConnectionsAccount]
    def post_linked_accounts_account_refresh(*, account : String? = nil, features : Array(String)? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_linked_accounts_account_refresh_with_http_info(account: account, features: features, expand: expand)
      data
    end

    # &lt;p&gt;Refreshes the data associated with a Financial Connections &lt;code&gt;Account&lt;/code&gt;.&lt;/p&gt;
    # @param account [String?]
    # @param features [Array(String)?] The list of account features that you would like to refresh.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(FinancialConnectionsAccount, Integer, Hash)>] FinancialConnectionsAccount data, response status code and response headers
    def post_linked_accounts_account_refresh_with_http_info(*, account : String? = nil, features : Array(String)? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_linked_accounts_account_refresh(account: account, features: features, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_linked_accounts_account_refresh\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FinancialConnectionsAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Refreshes the data associated with a Financial Connections &lt;code&gt;Account&lt;/code&gt;.&lt;/p&gt;
    # @param account [String?]
    # @param features [Array(String)?] The list of account features that you would like to refresh.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_linked_accounts_account_refresh(*, account : String? = nil, features : Array(String)? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_linked_accounts_account_refresh(account: account, features: features, expand: expand).execute(&block)
    end

    POST_LINKED_ACCOUNTS_ACCOUNT_REFRESH_MAX_LENGTH_FOR_ACCOUNT    = 5000
    POST_LINKED_ACCOUNTS_ACCOUNT_REFRESH_VALID_VALUES_FOR_FEATURES = StaticArray["balance", "ownership"]

    # @return Crest::Request
    def build_api_request_for_post_linked_accounts_account_refresh(*, account : String? = nil, features : Array(String)? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_linked_accounts_account_refresh ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"account\" is required and cannot be null") if account.nil?
        if _account = account
          OpenApi::PrimitiveValidator.validate_max_length("account", account.to_s.size, POST_LINKED_ACCOUNTS_ACCOUNT_REFRESH_MAX_LENGTH_FOR_ACCOUNT)
        end
        raise ArgumentError.new("\"features\" is required and cannot be null") if features.nil?
        if _features = features
          OpenApi::EnumValidator.validate("features", _features, POST_LINKED_ACCOUNTS_ACCOUNT_REFRESH_VALID_VALUES_FOR_FEATURES)
        end
      end

      # resource path
      local_var_path = "/v1/linked_accounts/{account}/refresh".sub("{" + "account" + "}", URI.encode_path(account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["features"] = @api_client.build_collection_param(features, "csv") if !features.nil? && !features.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_linked_accounts_account_refresh",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new <code>open</code> order object.</p>
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param line_items [Array(Stripe::CreateParams)?] A list of line items the customer is ordering. Each line item includes information about the product, the quantity, and the resulting cost.
    # @optional @param automatic_tax [Stripe::AutomaticTax1?]
    # @optional @param billing_details [Stripe::PostOrdersRequestBillingDetails?]
    # @optional @param client_permissions [Stripe::ClientPermissions?]
    # @optional @param customer [String?] The customer associated with this order.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param discounts [Stripe::PostOrdersRequestDiscounts?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param ip_address [String?] The IP address of the purchaser for this order.
    # @optional @param payment [Stripe::CreateParams1?]
    # @optional @param shipping_cost [Stripe::PostOrdersRequestShippingCost?]
    # @optional @param shipping_details [Stripe::PostOrdersRequestShippingDetails?]
    # @optional @param tax_details [Stripe::TaxDetails?]
    # @return [Order]
    def post_orders(*, currency : String? = nil, line_items : Array(Stripe::CreateParams)? = nil, automatic_tax : Stripe::AutomaticTax1? = nil, billing_details : Stripe::PostOrdersRequestBillingDetails? = nil, client_permissions : Stripe::ClientPermissions? = nil, customer : String? = nil, description : String? = nil, discounts : Stripe::PostOrdersRequestDiscounts? = nil, expand : Array(String)? = nil, ip_address : String? = nil, payment : Stripe::CreateParams1? = nil, shipping_cost : Stripe::PostOrdersRequestShippingCost? = nil, shipping_details : Stripe::PostOrdersRequestShippingDetails? = nil, tax_details : Stripe::TaxDetails? = nil)
      data, _status_code, _headers = post_orders_with_http_info(currency: currency, line_items: line_items, automatic_tax: automatic_tax, billing_details: billing_details, client_permissions: client_permissions, customer: customer, description: description, discounts: discounts, expand: expand, ip_address: ip_address, payment: payment, shipping_cost: shipping_cost, shipping_details: shipping_details, tax_details: tax_details)
      data
    end

    # &lt;p&gt;Creates a new &lt;code&gt;open&lt;/code&gt; order object.&lt;/p&gt;
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param line_items [Array(Stripe::CreateParams)?] A list of line items the customer is ordering. Each line item includes information about the product, the quantity, and the resulting cost.
    # @optional @param automatic_tax [Stripe::AutomaticTax1?]
    # @optional @param billing_details [Stripe::PostOrdersRequestBillingDetails?]
    # @optional @param client_permissions [Stripe::ClientPermissions?]
    # @optional @param customer [String?] The customer associated with this order.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param discounts [Stripe::PostOrdersRequestDiscounts?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param ip_address [String?] The IP address of the purchaser for this order.
    # @optional @param payment [Stripe::CreateParams1?]
    # @optional @param shipping_cost [Stripe::PostOrdersRequestShippingCost?]
    # @optional @param shipping_details [Stripe::PostOrdersRequestShippingDetails?]
    # @optional @param tax_details [Stripe::TaxDetails?]
    # @return [Array<(Order, Integer, Hash)>] Order data, response status code and response headers
    def post_orders_with_http_info(*, currency : String? = nil, line_items : Array(Stripe::CreateParams)? = nil, automatic_tax : Stripe::AutomaticTax1? = nil, billing_details : Stripe::PostOrdersRequestBillingDetails? = nil, client_permissions : Stripe::ClientPermissions? = nil, customer : String? = nil, description : String? = nil, discounts : Stripe::PostOrdersRequestDiscounts? = nil, expand : Array(String)? = nil, ip_address : String? = nil, payment : Stripe::CreateParams1? = nil, shipping_cost : Stripe::PostOrdersRequestShippingCost? = nil, shipping_details : Stripe::PostOrdersRequestShippingDetails? = nil, tax_details : Stripe::TaxDetails? = nil)
      request = build_api_request_for_post_orders(currency: currency, line_items: line_items, automatic_tax: automatic_tax, billing_details: billing_details, client_permissions: client_permissions, customer: customer, description: description, discounts: discounts, expand: expand, ip_address: ip_address, payment: payment, shipping_cost: shipping_cost, shipping_details: shipping_details, tax_details: tax_details)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_orders\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Order.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new &lt;code&gt;open&lt;/code&gt; order object.&lt;/p&gt;
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param line_items [Array(Stripe::CreateParams)?] A list of line items the customer is ordering. Each line item includes information about the product, the quantity, and the resulting cost.
    # @optional @param automatic_tax [Stripe::AutomaticTax1?]
    # @optional @param billing_details [Stripe::PostOrdersRequestBillingDetails?]
    # @optional @param client_permissions [Stripe::ClientPermissions?]
    # @optional @param customer [String?] The customer associated with this order.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param discounts [Stripe::PostOrdersRequestDiscounts?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param ip_address [String?] The IP address of the purchaser for this order.
    # @optional @param payment [Stripe::CreateParams1?]
    # @optional @param shipping_cost [Stripe::PostOrdersRequestShippingCost?]
    # @optional @param shipping_details [Stripe::PostOrdersRequestShippingDetails?]
    # @optional @param tax_details [Stripe::TaxDetails?]
    # @return nil
    def post_orders(*, currency : String? = nil, line_items : Array(Stripe::CreateParams)? = nil, automatic_tax : Stripe::AutomaticTax1? = nil, billing_details : Stripe::PostOrdersRequestBillingDetails? = nil, client_permissions : Stripe::ClientPermissions? = nil, customer : String? = nil, description : String? = nil, discounts : Stripe::PostOrdersRequestDiscounts? = nil, expand : Array(String)? = nil, ip_address : String? = nil, payment : Stripe::CreateParams1? = nil, shipping_cost : Stripe::PostOrdersRequestShippingCost? = nil, shipping_details : Stripe::PostOrdersRequestShippingDetails? = nil, tax_details : Stripe::TaxDetails? = nil, &block : Crest::Response ->)
      build_api_request_for_post_orders(currency: currency, line_items: line_items, automatic_tax: automatic_tax, billing_details: billing_details, client_permissions: client_permissions, customer: customer, description: description, discounts: discounts, expand: expand, ip_address: ip_address, payment: payment, shipping_cost: shipping_cost, shipping_details: shipping_details, tax_details: tax_details).execute(&block)
    end

    POST_ORDERS_MAX_LENGTH_FOR_CUSTOMER    = 5000
    POST_ORDERS_MAX_LENGTH_FOR_DESCRIPTION = 5000

    # @return Crest::Request
    def build_api_request_for_post_orders(*, currency : String? = nil, line_items : Array(Stripe::CreateParams)? = nil, automatic_tax : Stripe::AutomaticTax1? = nil, billing_details : Stripe::PostOrdersRequestBillingDetails? = nil, client_permissions : Stripe::ClientPermissions? = nil, customer : String? = nil, description : String? = nil, discounts : Stripe::PostOrdersRequestDiscounts? = nil, expand : Array(String)? = nil, ip_address : String? = nil, payment : Stripe::CreateParams1? = nil, shipping_cost : Stripe::PostOrdersRequestShippingCost? = nil, shipping_details : Stripe::PostOrdersRequestShippingDetails? = nil, tax_details : Stripe::TaxDetails? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_orders ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"currency\" is required and cannot be null") if currency.nil?

        raise ArgumentError.new("\"line_items\" is required and cannot be null") if line_items.nil?
        if _line_items = line_items
          OpenApi::ContainerValidator.validate(container: _line_items) if _line_items.is_a?(Array)
        end
        if _automatic_tax = automatic_tax
          _automatic_tax.validate if _automatic_tax.is_a?(OpenApi::Validatable)
        end
        if _billing_details = billing_details
          _billing_details.validate if _billing_details.is_a?(OpenApi::Validatable)
        end
        if _client_permissions = client_permissions
          _client_permissions.validate if _client_permissions.is_a?(OpenApi::Validatable)
        end
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_ORDERS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_ORDERS_MAX_LENGTH_FOR_DESCRIPTION)
        end
        if _discounts = discounts
          _discounts.validate if _discounts.is_a?(OpenApi::Validatable)
        end

        if _payment = payment
          _payment.validate if _payment.is_a?(OpenApi::Validatable)
        end
        if _shipping_cost = shipping_cost
          _shipping_cost.validate if _shipping_cost.is_a?(OpenApi::Validatable)
        end
        if _shipping_details = shipping_details
          _shipping_details.validate if _shipping_details.is_a?(OpenApi::Validatable)
        end
        if _tax_details = tax_details
          _tax_details.validate if _tax_details.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/orders"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["automatic_tax"] = automatic_tax.to_s if !automatic_tax.nil?
      form_params["billing_details"] = billing_details.to_s if !billing_details.nil?
      form_params["client_permissions"] = client_permissions.to_s if !client_permissions.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["discounts"] = discounts.to_s if !discounts.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["ip_address"] = ip_address.to_s if !ip_address.nil?
      form_params["line_items"] = @api_client.build_collection_param(line_items, "csv") if !line_items.nil? && !line_items.empty?
      form_params["payment"] = payment.to_s if !payment.nil?
      form_params["shipping_cost"] = shipping_cost.to_s if !shipping_cost.nil?
      form_params["shipping_details"] = shipping_details.to_s if !shipping_details.nil?
      form_params["tax_details"] = tax_details.to_s if !tax_details.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_orders",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the specific order by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
    # @param id [String?]
    # @optional @param automatic_tax [Stripe::AutomaticTax1?]
    # @optional @param billing_details [Stripe::PostOrdersRequestBillingDetails?]
    # @optional @param client_permissions [Stripe::ClientPermissions?]
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param customer [String?] The customer associated with this order.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param discounts [Stripe::PostOrdersIdRequestDiscounts?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param ip_address [String?] The IP address of the purchaser for this order.
    # @optional @param line_items [Array(Stripe::UpdateParams)?] A list of line items the customer is ordering. Each line item includes information about the product, the quantity, and the resulting cost.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param payment [Stripe::UpdateParams1?]
    # @optional @param shipping_cost [Stripe::PostOrdersRequestShippingCost?]
    # @optional @param shipping_details [Stripe::PostOrdersRequestShippingDetails?]
    # @optional @param tax_details [Stripe::TaxDetails?]
    # @return [Order]
    def post_orders_id(*, id : String? = nil, automatic_tax : Stripe::AutomaticTax1? = nil, billing_details : Stripe::PostOrdersRequestBillingDetails? = nil, client_permissions : Stripe::ClientPermissions? = nil, currency : String? = nil, customer : String? = nil, description : String? = nil, discounts : Stripe::PostOrdersIdRequestDiscounts? = nil, expand : Array(String)? = nil, ip_address : String? = nil, line_items : Array(Stripe::UpdateParams)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, payment : Stripe::UpdateParams1? = nil, shipping_cost : Stripe::PostOrdersRequestShippingCost? = nil, shipping_details : Stripe::PostOrdersRequestShippingDetails? = nil, tax_details : Stripe::TaxDetails? = nil)
      data, _status_code, _headers = post_orders_id_with_http_info(id: id, automatic_tax: automatic_tax, billing_details: billing_details, client_permissions: client_permissions, currency: currency, customer: customer, description: description, discounts: discounts, expand: expand, ip_address: ip_address, line_items: line_items, metadata: metadata, payment: payment, shipping_cost: shipping_cost, shipping_details: shipping_details, tax_details: tax_details)
      data
    end

    # &lt;p&gt;Updates the specific order by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;
    # @param id [String?]
    # @optional @param automatic_tax [Stripe::AutomaticTax1?]
    # @optional @param billing_details [Stripe::PostOrdersRequestBillingDetails?]
    # @optional @param client_permissions [Stripe::ClientPermissions?]
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param customer [String?] The customer associated with this order.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param discounts [Stripe::PostOrdersIdRequestDiscounts?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param ip_address [String?] The IP address of the purchaser for this order.
    # @optional @param line_items [Array(Stripe::UpdateParams)?] A list of line items the customer is ordering. Each line item includes information about the product, the quantity, and the resulting cost.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param payment [Stripe::UpdateParams1?]
    # @optional @param shipping_cost [Stripe::PostOrdersRequestShippingCost?]
    # @optional @param shipping_details [Stripe::PostOrdersRequestShippingDetails?]
    # @optional @param tax_details [Stripe::TaxDetails?]
    # @return [Array<(Order, Integer, Hash)>] Order data, response status code and response headers
    def post_orders_id_with_http_info(*, id : String? = nil, automatic_tax : Stripe::AutomaticTax1? = nil, billing_details : Stripe::PostOrdersRequestBillingDetails? = nil, client_permissions : Stripe::ClientPermissions? = nil, currency : String? = nil, customer : String? = nil, description : String? = nil, discounts : Stripe::PostOrdersIdRequestDiscounts? = nil, expand : Array(String)? = nil, ip_address : String? = nil, line_items : Array(Stripe::UpdateParams)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, payment : Stripe::UpdateParams1? = nil, shipping_cost : Stripe::PostOrdersRequestShippingCost? = nil, shipping_details : Stripe::PostOrdersRequestShippingDetails? = nil, tax_details : Stripe::TaxDetails? = nil)
      request = build_api_request_for_post_orders_id(id: id, automatic_tax: automatic_tax, billing_details: billing_details, client_permissions: client_permissions, currency: currency, customer: customer, description: description, discounts: discounts, expand: expand, ip_address: ip_address, line_items: line_items, metadata: metadata, payment: payment, shipping_cost: shipping_cost, shipping_details: shipping_details, tax_details: tax_details)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_orders_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Order.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the specific order by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;
    # @param id [String?]
    # @optional @param automatic_tax [Stripe::AutomaticTax1?]
    # @optional @param billing_details [Stripe::PostOrdersRequestBillingDetails?]
    # @optional @param client_permissions [Stripe::ClientPermissions?]
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param customer [String?] The customer associated with this order.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param discounts [Stripe::PostOrdersIdRequestDiscounts?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param ip_address [String?] The IP address of the purchaser for this order.
    # @optional @param line_items [Array(Stripe::UpdateParams)?] A list of line items the customer is ordering. Each line item includes information about the product, the quantity, and the resulting cost.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param payment [Stripe::UpdateParams1?]
    # @optional @param shipping_cost [Stripe::PostOrdersRequestShippingCost?]
    # @optional @param shipping_details [Stripe::PostOrdersRequestShippingDetails?]
    # @optional @param tax_details [Stripe::TaxDetails?]
    # @return nil
    def post_orders_id(*, id : String? = nil, automatic_tax : Stripe::AutomaticTax1? = nil, billing_details : Stripe::PostOrdersRequestBillingDetails? = nil, client_permissions : Stripe::ClientPermissions? = nil, currency : String? = nil, customer : String? = nil, description : String? = nil, discounts : Stripe::PostOrdersIdRequestDiscounts? = nil, expand : Array(String)? = nil, ip_address : String? = nil, line_items : Array(Stripe::UpdateParams)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, payment : Stripe::UpdateParams1? = nil, shipping_cost : Stripe::PostOrdersRequestShippingCost? = nil, shipping_details : Stripe::PostOrdersRequestShippingDetails? = nil, tax_details : Stripe::TaxDetails? = nil, &block : Crest::Response ->)
      build_api_request_for_post_orders_id(id: id, automatic_tax: automatic_tax, billing_details: billing_details, client_permissions: client_permissions, currency: currency, customer: customer, description: description, discounts: discounts, expand: expand, ip_address: ip_address, line_items: line_items, metadata: metadata, payment: payment, shipping_cost: shipping_cost, shipping_details: shipping_details, tax_details: tax_details).execute(&block)
    end

    POST_ORDERS_ID_MAX_LENGTH_FOR_ID          = 5000
    POST_ORDERS_ID_MAX_LENGTH_FOR_CUSTOMER    = 5000
    POST_ORDERS_ID_MAX_LENGTH_FOR_DESCRIPTION = 5000

    # @return Crest::Request
    def build_api_request_for_post_orders_id(*, id : String? = nil, automatic_tax : Stripe::AutomaticTax1? = nil, billing_details : Stripe::PostOrdersRequestBillingDetails? = nil, client_permissions : Stripe::ClientPermissions? = nil, currency : String? = nil, customer : String? = nil, description : String? = nil, discounts : Stripe::PostOrdersIdRequestDiscounts? = nil, expand : Array(String)? = nil, ip_address : String? = nil, line_items : Array(Stripe::UpdateParams)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, payment : Stripe::UpdateParams1? = nil, shipping_cost : Stripe::PostOrdersRequestShippingCost? = nil, shipping_details : Stripe::PostOrdersRequestShippingDetails? = nil, tax_details : Stripe::TaxDetails? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_orders_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_ORDERS_ID_MAX_LENGTH_FOR_ID)
        end
        if _automatic_tax = automatic_tax
          _automatic_tax.validate if _automatic_tax.is_a?(OpenApi::Validatable)
        end
        if _billing_details = billing_details
          _billing_details.validate if _billing_details.is_a?(OpenApi::Validatable)
        end
        if _client_permissions = client_permissions
          _client_permissions.validate if _client_permissions.is_a?(OpenApi::Validatable)
        end

        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_ORDERS_ID_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_ORDERS_ID_MAX_LENGTH_FOR_DESCRIPTION)
        end
        if _discounts = discounts
          _discounts.validate if _discounts.is_a?(OpenApi::Validatable)
        end

        if _line_items = line_items
          OpenApi::ContainerValidator.validate(container: _line_items) if _line_items.is_a?(Array)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _payment = payment
          _payment.validate if _payment.is_a?(OpenApi::Validatable)
        end
        if _shipping_cost = shipping_cost
          _shipping_cost.validate if _shipping_cost.is_a?(OpenApi::Validatable)
        end
        if _shipping_details = shipping_details
          _shipping_details.validate if _shipping_details.is_a?(OpenApi::Validatable)
        end
        if _tax_details = tax_details
          _tax_details.validate if _tax_details.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/orders/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["automatic_tax"] = automatic_tax.to_s if !automatic_tax.nil?
      form_params["billing_details"] = billing_details.to_s if !billing_details.nil?
      form_params["client_permissions"] = client_permissions.to_s if !client_permissions.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["discounts"] = discounts.to_s if !discounts.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["ip_address"] = ip_address.to_s if !ip_address.nil?
      form_params["line_items"] = @api_client.build_collection_param(line_items, "csv") if !line_items.nil? && !line_items.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["payment"] = payment.to_s if !payment.nil?
      form_params["shipping_cost"] = shipping_cost.to_s if !shipping_cost.nil?
      form_params["shipping_details"] = shipping_details.to_s if !shipping_details.nil?
      form_params["tax_details"] = tax_details.to_s if !tax_details.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_orders_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Cancels the order as well as the payment intent if one is attached.</p>
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Order]
    def post_orders_id_cancel(*, id : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_orders_id_cancel_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Cancels the order as well as the payment intent if one is attached.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(Order, Integer, Hash)>] Order data, response status code and response headers
    def post_orders_id_cancel_with_http_info(*, id : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_orders_id_cancel(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_orders_id_cancel\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Order.from_json(data), status_code, headers
    end

    # &lt;p&gt;Cancels the order as well as the payment intent if one is attached.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_orders_id_cancel(*, id : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_orders_id_cancel(id: id, expand: expand).execute(&block)
    end

    POST_ORDERS_ID_CANCEL_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_post_orders_id_cancel(*, id : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_orders_id_cancel ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_ORDERS_ID_CANCEL_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/orders/{id}/cancel".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_orders_id_cancel",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Reopens a <code>submitted</code> order.</p>
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Order]
    def post_orders_id_reopen(*, id : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_orders_id_reopen_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Reopens a &lt;code&gt;submitted&lt;/code&gt; order.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(Order, Integer, Hash)>] Order data, response status code and response headers
    def post_orders_id_reopen_with_http_info(*, id : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_orders_id_reopen(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_orders_id_reopen\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Order.from_json(data), status_code, headers
    end

    # &lt;p&gt;Reopens a &lt;code&gt;submitted&lt;/code&gt; order.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_orders_id_reopen(*, id : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_orders_id_reopen(id: id, expand: expand).execute(&block)
    end

    POST_ORDERS_ID_REOPEN_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_post_orders_id_reopen(*, id : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_orders_id_reopen ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_ORDERS_ID_REOPEN_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/orders/{id}/reopen".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_orders_id_reopen",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Submitting an Order transitions the status to <code>processing</code> and creates a PaymentIntent object so the order can be paid. If the Order has an <code>amount_total</code> of 0, no PaymentIntent object will be created. Once the order is submitted, its contents cannot be changed, unless the <a href=\"#reopen_order\">reopen</a> method is called.</p>
    # @param id [String?]
    # @param expected_total [Int64?] `expected_total` should always be set to the order's `amount_total` field. If they don't match, submitting the order will fail. This helps detect race conditions where something else concurrently modifies the order.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Order]
    def post_orders_id_submit(*, id : String? = nil, expected_total : Int64? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_orders_id_submit_with_http_info(id: id, expected_total: expected_total, expand: expand)
      data
    end

    # &lt;p&gt;Submitting an Order transitions the status to &lt;code&gt;processing&lt;/code&gt; and creates a PaymentIntent object so the order can be paid. If the Order has an &lt;code&gt;amount_total&lt;/code&gt; of 0, no PaymentIntent object will be created. Once the order is submitted, its contents cannot be changed, unless the &lt;a href&#x3D;\&quot;#reopen_order\&quot;&gt;reopen&lt;/a&gt; method is called.&lt;/p&gt;
    # @param id [String?]
    # @param expected_total [Int64?] `expected_total` should always be set to the order's `amount_total` field. If they don't match, submitting the order will fail. This helps detect race conditions where something else concurrently modifies the order.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(Order, Integer, Hash)>] Order data, response status code and response headers
    def post_orders_id_submit_with_http_info(*, id : String? = nil, expected_total : Int64? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_orders_id_submit(id: id, expected_total: expected_total, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_orders_id_submit\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Order.from_json(data), status_code, headers
    end

    # &lt;p&gt;Submitting an Order transitions the status to &lt;code&gt;processing&lt;/code&gt; and creates a PaymentIntent object so the order can be paid. If the Order has an &lt;code&gt;amount_total&lt;/code&gt; of 0, no PaymentIntent object will be created. Once the order is submitted, its contents cannot be changed, unless the &lt;a href&#x3D;\&quot;#reopen_order\&quot;&gt;reopen&lt;/a&gt; method is called.&lt;/p&gt;
    # @param id [String?]
    # @param expected_total [Int64?] `expected_total` should always be set to the order's `amount_total` field. If they don't match, submitting the order will fail. This helps detect race conditions where something else concurrently modifies the order.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_orders_id_submit(*, id : String? = nil, expected_total : Int64? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_orders_id_submit(id: id, expected_total: expected_total, expand: expand).execute(&block)
    end

    POST_ORDERS_ID_SUBMIT_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_post_orders_id_submit(*, id : String? = nil, expected_total : Int64? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_orders_id_submit ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_ORDERS_ID_SUBMIT_MAX_LENGTH_FOR_ID)
        end
        raise ArgumentError.new("\"expected_total\" is required and cannot be null") if expected_total.nil?
      end

      # resource path
      local_var_path = "/v1/orders/{id}/submit".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["expected_total"] = expected_total.to_s if !expected_total.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_orders_id_submit",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a PaymentIntent object.</p>  <p>After the PaymentIntent is created, attach a payment method and <a href=\"/docs/api/payment_intents/confirm\">confirm</a> to continue the payment. You can read more about the different payment flows available via the Payment Intents API <a href=\"/docs/payments/payment-intents\">here</a>.</p>  <p>When <code>confirm=true</code> is used during creation, it is equivalent to creating and confirming the PaymentIntent in the same call. You may use any parameters available in the <a href=\"/docs/api/payment_intents/confirm\">confirm API</a> when <code>confirm=true</code> is supplied.</p>
    # @param amount [Int64?] Amount intended to be collected by this PaymentIntent. A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param application_fee_amount [Int64?] The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
    # @optional @param automatic_payment_methods [Stripe::AutomaticPaymentMethodsParam?]
    # @optional @param capture_method [String?] Controls when the funds will be captured from the customer's account.
    # @optional @param confirm [Bool?] Set to `true` to attempt to [confirm](https://stripe.com/docs/api/payment_intents/confirm) this PaymentIntent immediately. This parameter defaults to `false`. When creating and confirming a PaymentIntent at the same time, parameters available in the [confirm](https://stripe.com/docs/api/payment_intents/confirm) API may also be provided.
    # @optional @param confirmation_method [String?]
    # @optional @param customer [String?] ID of the Customer this PaymentIntent belongs to, if one exists.  Payment methods attached to other Customers cannot be used with this PaymentIntent.  If present in combination with [setup_future_usage](https://stripe.com/docs/api#payment_intent_object-setup_future_usage), this PaymentIntent's payment method will be attached to the Customer after the PaymentIntent has been confirmed and any required actions from the user are complete.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param error_on_requires_action [Bool?] Set to `true` to fail the payment attempt if the PaymentIntent transitions into `requires_action`. This parameter is intended for simpler integrations that do not handle customer actions, like [saving cards without authentication](https://stripe.com/docs/payments/save-card-without-authentication). This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/payment_intents/create#create_payment_intent-confirm).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param mandate [String?] ID of the mandate to be used for this payment. This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/payment_intents/create#create_payment_intent-confirm).
    # @optional @param mandate_data [Stripe::SecretKeyParam?]
    # @optional @param off_session [Stripe::PostPaymentIntentsRequestOffSession?]
    # @optional @param on_behalf_of [String?] The Stripe account ID for which these funds are intended. For details, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
    # @optional @param payment_method [String?] ID of the payment method (a PaymentMethod, Card, or [compatible Source](https://stripe.com/docs/payments/payment-methods/transitioning#compatibility) object) to attach to this PaymentIntent.  If this parameter is omitted with `confirm=true`, `customer.default_source` will be attached as this PaymentIntent's payment instrument to improve the migration experience for users of the Charges API. We recommend that you explicitly provide the `payment_method` going forward.
    # @optional @param payment_method_data [Stripe::PaymentMethodDataParams?]
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam15?]
    # @optional @param payment_method_types [Array(String)?] The list of payment method types (e.g. card) that this PaymentIntent is allowed to use. If this is not provided, defaults to [\\\"card\\\"]. Use automatic_payment_methods to manage payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods).
    # @optional @param radar_options [Stripe::RadarOptions?]
    # @optional @param receipt_email [String?] Email address that the receipt for the resulting payment will be sent to. If `receipt_email` is specified for a payment in live mode, a receipt will be sent regardless of your [email settings](https://dashboard.stripe.com/account/emails).
    # @optional @param return_url [String?] The URL to redirect your customer back to after they authenticate or cancel their payment on the payment method's app or site. If you'd prefer to redirect to a mobile application, you can alternatively supply an application URI scheme. This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/payment_intents/create#create_payment_intent-confirm).
    # @optional @param setup_future_usage [String?] Indicates that you intend to make future payments with this PaymentIntent's payment method.  Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.  When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).
    # @optional @param shipping [Stripe::OptionalFieldsShipping1?]
    # @optional @param statement_descriptor [String?] For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    # @optional @param statement_descriptor_suffix [String?] Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
    # @optional @param transfer_data [Stripe::TransferDataCreationParams?]
    # @optional @param transfer_group [String?] A string that identifies the resulting payment as part of a group. See the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts) for details.
    # @optional @param use_stripe_sdk [Bool?] Set to `true` only when using manual confirmation and the iOS or Android SDKs to handle additional authentication steps.
    # @return [PaymentIntent]
    def post_payment_intents(*, amount : Int64? = nil, currency : String? = nil, application_fee_amount : Int64? = nil, automatic_payment_methods : Stripe::AutomaticPaymentMethodsParam? = nil, capture_method : String? = nil, confirm : Bool? = nil, confirmation_method : String? = nil, customer : String? = nil, description : String? = nil, error_on_requires_action : Bool? = nil, expand : Array(String)? = nil, mandate : String? = nil, mandate_data : Stripe::SecretKeyParam? = nil, off_session : Stripe::PostPaymentIntentsRequestOffSession? = nil, on_behalf_of : String? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam15? = nil, payment_method_types : Array(String)? = nil, radar_options : Stripe::RadarOptions? = nil, receipt_email : String? = nil, return_url : String? = nil, setup_future_usage : String? = nil, shipping : Stripe::OptionalFieldsShipping1? = nil, statement_descriptor : String? = nil, statement_descriptor_suffix : String? = nil, transfer_data : Stripe::TransferDataCreationParams? = nil, transfer_group : String? = nil, use_stripe_sdk : Bool? = nil)
      data, _status_code, _headers = post_payment_intents_with_http_info(amount: amount, currency: currency, application_fee_amount: application_fee_amount, automatic_payment_methods: automatic_payment_methods, capture_method: capture_method, confirm: confirm, confirmation_method: confirmation_method, customer: customer, description: description, error_on_requires_action: error_on_requires_action, expand: expand, mandate: mandate, mandate_data: mandate_data, off_session: off_session, on_behalf_of: on_behalf_of, payment_method: payment_method, payment_method_data: payment_method_data, payment_method_options: payment_method_options, payment_method_types: payment_method_types, radar_options: radar_options, receipt_email: receipt_email, return_url: return_url, setup_future_usage: setup_future_usage, shipping: shipping, statement_descriptor: statement_descriptor, statement_descriptor_suffix: statement_descriptor_suffix, transfer_data: transfer_data, transfer_group: transfer_group, use_stripe_sdk: use_stripe_sdk)
      data
    end

    # &lt;p&gt;Creates a PaymentIntent object.&lt;/p&gt;  &lt;p&gt;After the PaymentIntent is created, attach a payment method and &lt;a href&#x3D;\&quot;/docs/api/payment_intents/confirm\&quot;&gt;confirm&lt;/a&gt; to continue the payment. You can read more about the different payment flows available via the Payment Intents API &lt;a href&#x3D;\&quot;/docs/payments/payment-intents\&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;  &lt;p&gt;When &lt;code&gt;confirm&#x3D;true&lt;/code&gt; is used during creation, it is equivalent to creating and confirming the PaymentIntent in the same call. You may use any parameters available in the &lt;a href&#x3D;\&quot;/docs/api/payment_intents/confirm\&quot;&gt;confirm API&lt;/a&gt; when &lt;code&gt;confirm&#x3D;true&lt;/code&gt; is supplied.&lt;/p&gt;
    # @param amount [Int64?] Amount intended to be collected by this PaymentIntent. A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param application_fee_amount [Int64?] The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
    # @optional @param automatic_payment_methods [Stripe::AutomaticPaymentMethodsParam?]
    # @optional @param capture_method [String?] Controls when the funds will be captured from the customer's account.
    # @optional @param confirm [Bool?] Set to `true` to attempt to [confirm](https://stripe.com/docs/api/payment_intents/confirm) this PaymentIntent immediately. This parameter defaults to `false`. When creating and confirming a PaymentIntent at the same time, parameters available in the [confirm](https://stripe.com/docs/api/payment_intents/confirm) API may also be provided.
    # @optional @param confirmation_method [String?]
    # @optional @param customer [String?] ID of the Customer this PaymentIntent belongs to, if one exists.  Payment methods attached to other Customers cannot be used with this PaymentIntent.  If present in combination with [setup_future_usage](https://stripe.com/docs/api#payment_intent_object-setup_future_usage), this PaymentIntent's payment method will be attached to the Customer after the PaymentIntent has been confirmed and any required actions from the user are complete.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param error_on_requires_action [Bool?] Set to `true` to fail the payment attempt if the PaymentIntent transitions into `requires_action`. This parameter is intended for simpler integrations that do not handle customer actions, like [saving cards without authentication](https://stripe.com/docs/payments/save-card-without-authentication). This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/payment_intents/create#create_payment_intent-confirm).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param mandate [String?] ID of the mandate to be used for this payment. This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/payment_intents/create#create_payment_intent-confirm).
    # @optional @param mandate_data [Stripe::SecretKeyParam?]
    # @optional @param off_session [Stripe::PostPaymentIntentsRequestOffSession?]
    # @optional @param on_behalf_of [String?] The Stripe account ID for which these funds are intended. For details, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
    # @optional @param payment_method [String?] ID of the payment method (a PaymentMethod, Card, or [compatible Source](https://stripe.com/docs/payments/payment-methods/transitioning#compatibility) object) to attach to this PaymentIntent.  If this parameter is omitted with `confirm=true`, `customer.default_source` will be attached as this PaymentIntent's payment instrument to improve the migration experience for users of the Charges API. We recommend that you explicitly provide the `payment_method` going forward.
    # @optional @param payment_method_data [Stripe::PaymentMethodDataParams?]
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam15?]
    # @optional @param payment_method_types [Array(String)?] The list of payment method types (e.g. card) that this PaymentIntent is allowed to use. If this is not provided, defaults to [\\\"card\\\"]. Use automatic_payment_methods to manage payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods).
    # @optional @param radar_options [Stripe::RadarOptions?]
    # @optional @param receipt_email [String?] Email address that the receipt for the resulting payment will be sent to. If `receipt_email` is specified for a payment in live mode, a receipt will be sent regardless of your [email settings](https://dashboard.stripe.com/account/emails).
    # @optional @param return_url [String?] The URL to redirect your customer back to after they authenticate or cancel their payment on the payment method's app or site. If you'd prefer to redirect to a mobile application, you can alternatively supply an application URI scheme. This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/payment_intents/create#create_payment_intent-confirm).
    # @optional @param setup_future_usage [String?] Indicates that you intend to make future payments with this PaymentIntent's payment method.  Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.  When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).
    # @optional @param shipping [Stripe::OptionalFieldsShipping1?]
    # @optional @param statement_descriptor [String?] For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    # @optional @param statement_descriptor_suffix [String?] Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
    # @optional @param transfer_data [Stripe::TransferDataCreationParams?]
    # @optional @param transfer_group [String?] A string that identifies the resulting payment as part of a group. See the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts) for details.
    # @optional @param use_stripe_sdk [Bool?] Set to `true` only when using manual confirmation and the iOS or Android SDKs to handle additional authentication steps.
    # @return [Array<(PaymentIntent, Integer, Hash)>] PaymentIntent data, response status code and response headers
    def post_payment_intents_with_http_info(*, amount : Int64? = nil, currency : String? = nil, application_fee_amount : Int64? = nil, automatic_payment_methods : Stripe::AutomaticPaymentMethodsParam? = nil, capture_method : String? = nil, confirm : Bool? = nil, confirmation_method : String? = nil, customer : String? = nil, description : String? = nil, error_on_requires_action : Bool? = nil, expand : Array(String)? = nil, mandate : String? = nil, mandate_data : Stripe::SecretKeyParam? = nil, off_session : Stripe::PostPaymentIntentsRequestOffSession? = nil, on_behalf_of : String? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam15? = nil, payment_method_types : Array(String)? = nil, radar_options : Stripe::RadarOptions? = nil, receipt_email : String? = nil, return_url : String? = nil, setup_future_usage : String? = nil, shipping : Stripe::OptionalFieldsShipping1? = nil, statement_descriptor : String? = nil, statement_descriptor_suffix : String? = nil, transfer_data : Stripe::TransferDataCreationParams? = nil, transfer_group : String? = nil, use_stripe_sdk : Bool? = nil)
      request = build_api_request_for_post_payment_intents(amount: amount, currency: currency, application_fee_amount: application_fee_amount, automatic_payment_methods: automatic_payment_methods, capture_method: capture_method, confirm: confirm, confirmation_method: confirmation_method, customer: customer, description: description, error_on_requires_action: error_on_requires_action, expand: expand, mandate: mandate, mandate_data: mandate_data, off_session: off_session, on_behalf_of: on_behalf_of, payment_method: payment_method, payment_method_data: payment_method_data, payment_method_options: payment_method_options, payment_method_types: payment_method_types, radar_options: radar_options, receipt_email: receipt_email, return_url: return_url, setup_future_usage: setup_future_usage, shipping: shipping, statement_descriptor: statement_descriptor, statement_descriptor_suffix: statement_descriptor_suffix, transfer_data: transfer_data, transfer_group: transfer_group, use_stripe_sdk: use_stripe_sdk)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_payment_intents\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentIntent.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a PaymentIntent object.&lt;/p&gt;  &lt;p&gt;After the PaymentIntent is created, attach a payment method and &lt;a href&#x3D;\&quot;/docs/api/payment_intents/confirm\&quot;&gt;confirm&lt;/a&gt; to continue the payment. You can read more about the different payment flows available via the Payment Intents API &lt;a href&#x3D;\&quot;/docs/payments/payment-intents\&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;  &lt;p&gt;When &lt;code&gt;confirm&#x3D;true&lt;/code&gt; is used during creation, it is equivalent to creating and confirming the PaymentIntent in the same call. You may use any parameters available in the &lt;a href&#x3D;\&quot;/docs/api/payment_intents/confirm\&quot;&gt;confirm API&lt;/a&gt; when &lt;code&gt;confirm&#x3D;true&lt;/code&gt; is supplied.&lt;/p&gt;
    # @param amount [Int64?] Amount intended to be collected by this PaymentIntent. A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param application_fee_amount [Int64?] The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
    # @optional @param automatic_payment_methods [Stripe::AutomaticPaymentMethodsParam?]
    # @optional @param capture_method [String?] Controls when the funds will be captured from the customer's account.
    # @optional @param confirm [Bool?] Set to `true` to attempt to [confirm](https://stripe.com/docs/api/payment_intents/confirm) this PaymentIntent immediately. This parameter defaults to `false`. When creating and confirming a PaymentIntent at the same time, parameters available in the [confirm](https://stripe.com/docs/api/payment_intents/confirm) API may also be provided.
    # @optional @param confirmation_method [String?]
    # @optional @param customer [String?] ID of the Customer this PaymentIntent belongs to, if one exists.  Payment methods attached to other Customers cannot be used with this PaymentIntent.  If present in combination with [setup_future_usage](https://stripe.com/docs/api#payment_intent_object-setup_future_usage), this PaymentIntent's payment method will be attached to the Customer after the PaymentIntent has been confirmed and any required actions from the user are complete.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param error_on_requires_action [Bool?] Set to `true` to fail the payment attempt if the PaymentIntent transitions into `requires_action`. This parameter is intended for simpler integrations that do not handle customer actions, like [saving cards without authentication](https://stripe.com/docs/payments/save-card-without-authentication). This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/payment_intents/create#create_payment_intent-confirm).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param mandate [String?] ID of the mandate to be used for this payment. This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/payment_intents/create#create_payment_intent-confirm).
    # @optional @param mandate_data [Stripe::SecretKeyParam?]
    # @optional @param off_session [Stripe::PostPaymentIntentsRequestOffSession?]
    # @optional @param on_behalf_of [String?] The Stripe account ID for which these funds are intended. For details, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
    # @optional @param payment_method [String?] ID of the payment method (a PaymentMethod, Card, or [compatible Source](https://stripe.com/docs/payments/payment-methods/transitioning#compatibility) object) to attach to this PaymentIntent.  If this parameter is omitted with `confirm=true`, `customer.default_source` will be attached as this PaymentIntent's payment instrument to improve the migration experience for users of the Charges API. We recommend that you explicitly provide the `payment_method` going forward.
    # @optional @param payment_method_data [Stripe::PaymentMethodDataParams?]
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam15?]
    # @optional @param payment_method_types [Array(String)?] The list of payment method types (e.g. card) that this PaymentIntent is allowed to use. If this is not provided, defaults to [\\\"card\\\"]. Use automatic_payment_methods to manage payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods).
    # @optional @param radar_options [Stripe::RadarOptions?]
    # @optional @param receipt_email [String?] Email address that the receipt for the resulting payment will be sent to. If `receipt_email` is specified for a payment in live mode, a receipt will be sent regardless of your [email settings](https://dashboard.stripe.com/account/emails).
    # @optional @param return_url [String?] The URL to redirect your customer back to after they authenticate or cancel their payment on the payment method's app or site. If you'd prefer to redirect to a mobile application, you can alternatively supply an application URI scheme. This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/payment_intents/create#create_payment_intent-confirm).
    # @optional @param setup_future_usage [String?] Indicates that you intend to make future payments with this PaymentIntent's payment method.  Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.  When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).
    # @optional @param shipping [Stripe::OptionalFieldsShipping1?]
    # @optional @param statement_descriptor [String?] For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    # @optional @param statement_descriptor_suffix [String?] Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
    # @optional @param transfer_data [Stripe::TransferDataCreationParams?]
    # @optional @param transfer_group [String?] A string that identifies the resulting payment as part of a group. See the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts) for details.
    # @optional @param use_stripe_sdk [Bool?] Set to `true` only when using manual confirmation and the iOS or Android SDKs to handle additional authentication steps.
    # @return nil
    def post_payment_intents(*, amount : Int64? = nil, currency : String? = nil, application_fee_amount : Int64? = nil, automatic_payment_methods : Stripe::AutomaticPaymentMethodsParam? = nil, capture_method : String? = nil, confirm : Bool? = nil, confirmation_method : String? = nil, customer : String? = nil, description : String? = nil, error_on_requires_action : Bool? = nil, expand : Array(String)? = nil, mandate : String? = nil, mandate_data : Stripe::SecretKeyParam? = nil, off_session : Stripe::PostPaymentIntentsRequestOffSession? = nil, on_behalf_of : String? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam15? = nil, payment_method_types : Array(String)? = nil, radar_options : Stripe::RadarOptions? = nil, receipt_email : String? = nil, return_url : String? = nil, setup_future_usage : String? = nil, shipping : Stripe::OptionalFieldsShipping1? = nil, statement_descriptor : String? = nil, statement_descriptor_suffix : String? = nil, transfer_data : Stripe::TransferDataCreationParams? = nil, transfer_group : String? = nil, use_stripe_sdk : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_post_payment_intents(amount: amount, currency: currency, application_fee_amount: application_fee_amount, automatic_payment_methods: automatic_payment_methods, capture_method: capture_method, confirm: confirm, confirmation_method: confirmation_method, customer: customer, description: description, error_on_requires_action: error_on_requires_action, expand: expand, mandate: mandate, mandate_data: mandate_data, off_session: off_session, on_behalf_of: on_behalf_of, payment_method: payment_method, payment_method_data: payment_method_data, payment_method_options: payment_method_options, payment_method_types: payment_method_types, radar_options: radar_options, receipt_email: receipt_email, return_url: return_url, setup_future_usage: setup_future_usage, shipping: shipping, statement_descriptor: statement_descriptor, statement_descriptor_suffix: statement_descriptor_suffix, transfer_data: transfer_data, transfer_group: transfer_group, use_stripe_sdk: use_stripe_sdk).execute(&block)
    end

    POST_PAYMENT_INTENTS_VALID_VALUES_FOR_CAPTURE_METHOD            = StaticArray["automatic", "manual"]
    POST_PAYMENT_INTENTS_VALID_VALUES_FOR_CONFIRMATION_METHOD       = StaticArray["automatic", "manual"]
    POST_PAYMENT_INTENTS_MAX_LENGTH_FOR_CUSTOMER                    = 5000
    POST_PAYMENT_INTENTS_MAX_LENGTH_FOR_DESCRIPTION                 = 1000
    POST_PAYMENT_INTENTS_MAX_LENGTH_FOR_MANDATE                     = 5000
    POST_PAYMENT_INTENTS_MAX_LENGTH_FOR_PAYMENT_METHOD              = 5000
    POST_PAYMENT_INTENTS_VALID_VALUES_FOR_SETUP_FUTURE_USAGE        = StaticArray["off_session", "on_session"]
    POST_PAYMENT_INTENTS_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR        = 22
    POST_PAYMENT_INTENTS_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR_SUFFIX = 22

    # @return Crest::Request
    def build_api_request_for_post_payment_intents(*, amount : Int64? = nil, currency : String? = nil, application_fee_amount : Int64? = nil, automatic_payment_methods : Stripe::AutomaticPaymentMethodsParam? = nil, capture_method : String? = nil, confirm : Bool? = nil, confirmation_method : String? = nil, customer : String? = nil, description : String? = nil, error_on_requires_action : Bool? = nil, expand : Array(String)? = nil, mandate : String? = nil, mandate_data : Stripe::SecretKeyParam? = nil, off_session : Stripe::PostPaymentIntentsRequestOffSession? = nil, on_behalf_of : String? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam15? = nil, payment_method_types : Array(String)? = nil, radar_options : Stripe::RadarOptions? = nil, receipt_email : String? = nil, return_url : String? = nil, setup_future_usage : String? = nil, shipping : Stripe::OptionalFieldsShipping1? = nil, statement_descriptor : String? = nil, statement_descriptor_suffix : String? = nil, transfer_data : Stripe::TransferDataCreationParams? = nil, transfer_group : String? = nil, use_stripe_sdk : Bool? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_payment_intents ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"amount\" is required and cannot be null") if amount.nil?

        raise ArgumentError.new("\"currency\" is required and cannot be null") if currency.nil?

        if _automatic_payment_methods = automatic_payment_methods
          _automatic_payment_methods.validate if _automatic_payment_methods.is_a?(OpenApi::Validatable)
        end
        if _capture_method = capture_method
          OpenApi::EnumValidator.validate("capture_method", _capture_method, POST_PAYMENT_INTENTS_VALID_VALUES_FOR_CAPTURE_METHOD)
        end

        if _confirmation_method = confirmation_method
          OpenApi::EnumValidator.validate("confirmation_method", _confirmation_method, POST_PAYMENT_INTENTS_VALID_VALUES_FOR_CONFIRMATION_METHOD)
        end
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_PAYMENT_INTENTS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_PAYMENT_INTENTS_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _mandate = mandate
          OpenApi::PrimitiveValidator.validate_max_length("mandate", mandate.to_s.size, POST_PAYMENT_INTENTS_MAX_LENGTH_FOR_MANDATE)
        end
        if _mandate_data = mandate_data
          _mandate_data.validate if _mandate_data.is_a?(OpenApi::Validatable)
        end
        if _off_session = off_session
          _off_session.validate if _off_session.is_a?(OpenApi::Validatable)
        end

        if _payment_method = payment_method
          OpenApi::PrimitiveValidator.validate_max_length("payment_method", payment_method.to_s.size, POST_PAYMENT_INTENTS_MAX_LENGTH_FOR_PAYMENT_METHOD)
        end
        if _payment_method_data = payment_method_data
          _payment_method_data.validate if _payment_method_data.is_a?(OpenApi::Validatable)
        end
        if _payment_method_options = payment_method_options
          _payment_method_options.validate if _payment_method_options.is_a?(OpenApi::Validatable)
        end

        if _radar_options = radar_options
          _radar_options.validate if _radar_options.is_a?(OpenApi::Validatable)
        end

        if _setup_future_usage = setup_future_usage
          OpenApi::EnumValidator.validate("setup_future_usage", _setup_future_usage, POST_PAYMENT_INTENTS_VALID_VALUES_FOR_SETUP_FUTURE_USAGE)
        end
        if _shipping = shipping
          _shipping.validate if _shipping.is_a?(OpenApi::Validatable)
        end
        if _statement_descriptor = statement_descriptor
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor", statement_descriptor.to_s.size, POST_PAYMENT_INTENTS_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR)
        end
        if _statement_descriptor_suffix = statement_descriptor_suffix
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor_suffix", statement_descriptor_suffix.to_s.size, POST_PAYMENT_INTENTS_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR_SUFFIX)
        end
        if _transfer_data = transfer_data
          _transfer_data.validate if _transfer_data.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/payment_intents"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["application_fee_amount"] = application_fee_amount.to_s if !application_fee_amount.nil?
      form_params["automatic_payment_methods"] = automatic_payment_methods.to_s if !automatic_payment_methods.nil?
      form_params["capture_method"] = capture_method.to_s if !capture_method.nil?
      form_params["confirm"] = confirm.to_s if !confirm.nil?
      form_params["confirmation_method"] = confirmation_method.to_s if !confirmation_method.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["error_on_requires_action"] = error_on_requires_action.to_s if !error_on_requires_action.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["mandate"] = mandate.to_s if !mandate.nil?
      form_params["mandate_data"] = mandate_data.to_s if !mandate_data.nil?
      form_params["off_session"] = off_session.to_s if !off_session.nil?
      form_params["on_behalf_of"] = on_behalf_of.to_s if !on_behalf_of.nil?
      form_params["payment_method"] = payment_method.to_s if !payment_method.nil?
      form_params["payment_method_data"] = payment_method_data.to_s if !payment_method_data.nil?
      form_params["payment_method_options"] = payment_method_options.to_s if !payment_method_options.nil?
      form_params["payment_method_types"] = @api_client.build_collection_param(payment_method_types, "csv") if !payment_method_types.nil? && !payment_method_types.empty?
      form_params["radar_options"] = radar_options.to_s if !radar_options.nil?
      form_params["receipt_email"] = receipt_email.to_s if !receipt_email.nil?
      form_params["return_url"] = return_url.to_s if !return_url.nil?
      form_params["setup_future_usage"] = setup_future_usage.to_s if !setup_future_usage.nil?
      form_params["shipping"] = shipping.to_s if !shipping.nil?
      form_params["statement_descriptor"] = statement_descriptor.to_s if !statement_descriptor.nil?
      form_params["statement_descriptor_suffix"] = statement_descriptor_suffix.to_s if !statement_descriptor_suffix.nil?
      form_params["transfer_data"] = transfer_data.to_s if !transfer_data.nil?
      form_params["transfer_group"] = transfer_group.to_s if !transfer_group.nil?
      form_params["use_stripe_sdk"] = use_stripe_sdk.to_s if !use_stripe_sdk.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_payment_intents",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates properties on a PaymentIntent object without confirming.</p>  <p>Depending on which properties you update, you may need to confirm the PaymentIntent again. For example, updating the <code>payment_method</code> will always require you to confirm the PaymentIntent again. If you prefer to update and confirm at the same time, we recommend updating properties via the <a href=\"/docs/api/payment_intents/confirm\">confirm API</a> instead.</p>
    # @param intent [String?]
    # @optional @param amount [Int64?] Amount intended to be collected by this PaymentIntent. A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
    # @optional @param application_fee_amount [Stripe::PostPaymentIntentsIntentRequestApplicationFeeAmount?]
    # @optional @param capture_method [String?] Controls when the funds will be captured from the customer's account.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param customer [String?] ID of the Customer this PaymentIntent belongs to, if one exists.  Payment methods attached to other Customers cannot be used with this PaymentIntent.  If present in combination with [setup_future_usage](https://stripe.com/docs/api#payment_intent_object-setup_future_usage), this PaymentIntent's payment method will be attached to the Customer after the PaymentIntent has been confirmed and any required actions from the user are complete.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param payment_method [String?] ID of the payment method (a PaymentMethod, Card, or [compatible Source](https://stripe.com/docs/payments/payment-methods/transitioning#compatibility) object) to attach to this PaymentIntent.
    # @optional @param payment_method_data [Stripe::PaymentMethodDataParams?]
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam15?]
    # @optional @param payment_method_types [Array(String)?] The list of payment method types (e.g. card) that this PaymentIntent is allowed to use. Use automatic_payment_methods to manage payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods).
    # @optional @param receipt_email [Stripe::PostPaymentIntentsIntentRequestReceiptEmail?]
    # @optional @param setup_future_usage [String?] Indicates that you intend to make future payments with this PaymentIntent's payment method.  Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.  When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).  If `setup_future_usage` is already set and you are performing a request using a publishable key, you may only update the value from `on_session` to `off_session`.
    # @optional @param shipping [Stripe::PostPaymentIntentsIntentRequestShipping?]
    # @optional @param statement_descriptor [String?] For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    # @optional @param statement_descriptor_suffix [String?] Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
    # @optional @param transfer_data [Stripe::TransferDataUpdateParams?]
    # @optional @param transfer_group [String?] A string that identifies the resulting payment as part of a group. `transfer_group` may only be provided if it has not been set. See the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts) for details.
    # @return [PaymentIntent]
    def post_payment_intents_intent(*, intent : String? = nil, amount : Int64? = nil, application_fee_amount : Stripe::PostPaymentIntentsIntentRequestApplicationFeeAmount? = nil, capture_method : String? = nil, currency : String? = nil, customer : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam15? = nil, payment_method_types : Array(String)? = nil, receipt_email : Stripe::PostPaymentIntentsIntentRequestReceiptEmail? = nil, setup_future_usage : String? = nil, shipping : Stripe::PostPaymentIntentsIntentRequestShipping? = nil, statement_descriptor : String? = nil, statement_descriptor_suffix : String? = nil, transfer_data : Stripe::TransferDataUpdateParams? = nil, transfer_group : String? = nil)
      data, _status_code, _headers = post_payment_intents_intent_with_http_info(intent: intent, amount: amount, application_fee_amount: application_fee_amount, capture_method: capture_method, currency: currency, customer: customer, description: description, expand: expand, metadata: metadata, payment_method: payment_method, payment_method_data: payment_method_data, payment_method_options: payment_method_options, payment_method_types: payment_method_types, receipt_email: receipt_email, setup_future_usage: setup_future_usage, shipping: shipping, statement_descriptor: statement_descriptor, statement_descriptor_suffix: statement_descriptor_suffix, transfer_data: transfer_data, transfer_group: transfer_group)
      data
    end

    # &lt;p&gt;Updates properties on a PaymentIntent object without confirming.&lt;/p&gt;  &lt;p&gt;Depending on which properties you update, you may need to confirm the PaymentIntent again. For example, updating the &lt;code&gt;payment_method&lt;/code&gt; will always require you to confirm the PaymentIntent again. If you prefer to update and confirm at the same time, we recommend updating properties via the &lt;a href&#x3D;\&quot;/docs/api/payment_intents/confirm\&quot;&gt;confirm API&lt;/a&gt; instead.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param amount [Int64?] Amount intended to be collected by this PaymentIntent. A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
    # @optional @param application_fee_amount [Stripe::PostPaymentIntentsIntentRequestApplicationFeeAmount?]
    # @optional @param capture_method [String?] Controls when the funds will be captured from the customer's account.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param customer [String?] ID of the Customer this PaymentIntent belongs to, if one exists.  Payment methods attached to other Customers cannot be used with this PaymentIntent.  If present in combination with [setup_future_usage](https://stripe.com/docs/api#payment_intent_object-setup_future_usage), this PaymentIntent's payment method will be attached to the Customer after the PaymentIntent has been confirmed and any required actions from the user are complete.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param payment_method [String?] ID of the payment method (a PaymentMethod, Card, or [compatible Source](https://stripe.com/docs/payments/payment-methods/transitioning#compatibility) object) to attach to this PaymentIntent.
    # @optional @param payment_method_data [Stripe::PaymentMethodDataParams?]
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam15?]
    # @optional @param payment_method_types [Array(String)?] The list of payment method types (e.g. card) that this PaymentIntent is allowed to use. Use automatic_payment_methods to manage payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods).
    # @optional @param receipt_email [Stripe::PostPaymentIntentsIntentRequestReceiptEmail?]
    # @optional @param setup_future_usage [String?] Indicates that you intend to make future payments with this PaymentIntent's payment method.  Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.  When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).  If `setup_future_usage` is already set and you are performing a request using a publishable key, you may only update the value from `on_session` to `off_session`.
    # @optional @param shipping [Stripe::PostPaymentIntentsIntentRequestShipping?]
    # @optional @param statement_descriptor [String?] For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    # @optional @param statement_descriptor_suffix [String?] Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
    # @optional @param transfer_data [Stripe::TransferDataUpdateParams?]
    # @optional @param transfer_group [String?] A string that identifies the resulting payment as part of a group. `transfer_group` may only be provided if it has not been set. See the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts) for details.
    # @return [Array<(PaymentIntent, Integer, Hash)>] PaymentIntent data, response status code and response headers
    def post_payment_intents_intent_with_http_info(*, intent : String? = nil, amount : Int64? = nil, application_fee_amount : Stripe::PostPaymentIntentsIntentRequestApplicationFeeAmount? = nil, capture_method : String? = nil, currency : String? = nil, customer : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam15? = nil, payment_method_types : Array(String)? = nil, receipt_email : Stripe::PostPaymentIntentsIntentRequestReceiptEmail? = nil, setup_future_usage : String? = nil, shipping : Stripe::PostPaymentIntentsIntentRequestShipping? = nil, statement_descriptor : String? = nil, statement_descriptor_suffix : String? = nil, transfer_data : Stripe::TransferDataUpdateParams? = nil, transfer_group : String? = nil)
      request = build_api_request_for_post_payment_intents_intent(intent: intent, amount: amount, application_fee_amount: application_fee_amount, capture_method: capture_method, currency: currency, customer: customer, description: description, expand: expand, metadata: metadata, payment_method: payment_method, payment_method_data: payment_method_data, payment_method_options: payment_method_options, payment_method_types: payment_method_types, receipt_email: receipt_email, setup_future_usage: setup_future_usage, shipping: shipping, statement_descriptor: statement_descriptor, statement_descriptor_suffix: statement_descriptor_suffix, transfer_data: transfer_data, transfer_group: transfer_group)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_payment_intents_intent\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentIntent.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates properties on a PaymentIntent object without confirming.&lt;/p&gt;  &lt;p&gt;Depending on which properties you update, you may need to confirm the PaymentIntent again. For example, updating the &lt;code&gt;payment_method&lt;/code&gt; will always require you to confirm the PaymentIntent again. If you prefer to update and confirm at the same time, we recommend updating properties via the &lt;a href&#x3D;\&quot;/docs/api/payment_intents/confirm\&quot;&gt;confirm API&lt;/a&gt; instead.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param amount [Int64?] Amount intended to be collected by this PaymentIntent. A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
    # @optional @param application_fee_amount [Stripe::PostPaymentIntentsIntentRequestApplicationFeeAmount?]
    # @optional @param capture_method [String?] Controls when the funds will be captured from the customer's account.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param customer [String?] ID of the Customer this PaymentIntent belongs to, if one exists.  Payment methods attached to other Customers cannot be used with this PaymentIntent.  If present in combination with [setup_future_usage](https://stripe.com/docs/api#payment_intent_object-setup_future_usage), this PaymentIntent's payment method will be attached to the Customer after the PaymentIntent has been confirmed and any required actions from the user are complete.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param payment_method [String?] ID of the payment method (a PaymentMethod, Card, or [compatible Source](https://stripe.com/docs/payments/payment-methods/transitioning#compatibility) object) to attach to this PaymentIntent.
    # @optional @param payment_method_data [Stripe::PaymentMethodDataParams?]
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam15?]
    # @optional @param payment_method_types [Array(String)?] The list of payment method types (e.g. card) that this PaymentIntent is allowed to use. Use automatic_payment_methods to manage payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods).
    # @optional @param receipt_email [Stripe::PostPaymentIntentsIntentRequestReceiptEmail?]
    # @optional @param setup_future_usage [String?] Indicates that you intend to make future payments with this PaymentIntent's payment method.  Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.  When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).  If `setup_future_usage` is already set and you are performing a request using a publishable key, you may only update the value from `on_session` to `off_session`.
    # @optional @param shipping [Stripe::PostPaymentIntentsIntentRequestShipping?]
    # @optional @param statement_descriptor [String?] For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    # @optional @param statement_descriptor_suffix [String?] Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
    # @optional @param transfer_data [Stripe::TransferDataUpdateParams?]
    # @optional @param transfer_group [String?] A string that identifies the resulting payment as part of a group. `transfer_group` may only be provided if it has not been set. See the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts) for details.
    # @return nil
    def post_payment_intents_intent(*, intent : String? = nil, amount : Int64? = nil, application_fee_amount : Stripe::PostPaymentIntentsIntentRequestApplicationFeeAmount? = nil, capture_method : String? = nil, currency : String? = nil, customer : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam15? = nil, payment_method_types : Array(String)? = nil, receipt_email : Stripe::PostPaymentIntentsIntentRequestReceiptEmail? = nil, setup_future_usage : String? = nil, shipping : Stripe::PostPaymentIntentsIntentRequestShipping? = nil, statement_descriptor : String? = nil, statement_descriptor_suffix : String? = nil, transfer_data : Stripe::TransferDataUpdateParams? = nil, transfer_group : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_payment_intents_intent(intent: intent, amount: amount, application_fee_amount: application_fee_amount, capture_method: capture_method, currency: currency, customer: customer, description: description, expand: expand, metadata: metadata, payment_method: payment_method, payment_method_data: payment_method_data, payment_method_options: payment_method_options, payment_method_types: payment_method_types, receipt_email: receipt_email, setup_future_usage: setup_future_usage, shipping: shipping, statement_descriptor: statement_descriptor, statement_descriptor_suffix: statement_descriptor_suffix, transfer_data: transfer_data, transfer_group: transfer_group).execute(&block)
    end

    POST_PAYMENT_INTENTS_INTENT_MAX_LENGTH_FOR_INTENT                      = 5000
    POST_PAYMENT_INTENTS_INTENT_VALID_VALUES_FOR_CAPTURE_METHOD            = StaticArray["automatic", "manual"]
    POST_PAYMENT_INTENTS_INTENT_MAX_LENGTH_FOR_CUSTOMER                    = 5000
    POST_PAYMENT_INTENTS_INTENT_MAX_LENGTH_FOR_DESCRIPTION                 = 1000
    POST_PAYMENT_INTENTS_INTENT_MAX_LENGTH_FOR_PAYMENT_METHOD              = 5000
    POST_PAYMENT_INTENTS_INTENT_VALID_VALUES_FOR_SETUP_FUTURE_USAGE        = StaticArray["", "off_session", "on_session"]
    POST_PAYMENT_INTENTS_INTENT_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR        = 22
    POST_PAYMENT_INTENTS_INTENT_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR_SUFFIX = 22

    # @return Crest::Request
    def build_api_request_for_post_payment_intents_intent(*, intent : String? = nil, amount : Int64? = nil, application_fee_amount : Stripe::PostPaymentIntentsIntentRequestApplicationFeeAmount? = nil, capture_method : String? = nil, currency : String? = nil, customer : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam15? = nil, payment_method_types : Array(String)? = nil, receipt_email : Stripe::PostPaymentIntentsIntentRequestReceiptEmail? = nil, setup_future_usage : String? = nil, shipping : Stripe::PostPaymentIntentsIntentRequestShipping? = nil, statement_descriptor : String? = nil, statement_descriptor_suffix : String? = nil, transfer_data : Stripe::TransferDataUpdateParams? = nil, transfer_group : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_payment_intents_intent ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"intent\" is required and cannot be null") if intent.nil?
        if _intent = intent
          OpenApi::PrimitiveValidator.validate_max_length("intent", intent.to_s.size, POST_PAYMENT_INTENTS_INTENT_MAX_LENGTH_FOR_INTENT)
        end

        if _application_fee_amount = application_fee_amount
          _application_fee_amount.validate if _application_fee_amount.is_a?(OpenApi::Validatable)
        end
        if _capture_method = capture_method
          OpenApi::EnumValidator.validate("capture_method", _capture_method, POST_PAYMENT_INTENTS_INTENT_VALID_VALUES_FOR_CAPTURE_METHOD)
        end

        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_PAYMENT_INTENTS_INTENT_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_PAYMENT_INTENTS_INTENT_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _payment_method = payment_method
          OpenApi::PrimitiveValidator.validate_max_length("payment_method", payment_method.to_s.size, POST_PAYMENT_INTENTS_INTENT_MAX_LENGTH_FOR_PAYMENT_METHOD)
        end
        if _payment_method_data = payment_method_data
          _payment_method_data.validate if _payment_method_data.is_a?(OpenApi::Validatable)
        end
        if _payment_method_options = payment_method_options
          _payment_method_options.validate if _payment_method_options.is_a?(OpenApi::Validatable)
        end

        if _receipt_email = receipt_email
          _receipt_email.validate if _receipt_email.is_a?(OpenApi::Validatable)
        end
        if _setup_future_usage = setup_future_usage
          OpenApi::EnumValidator.validate("setup_future_usage", _setup_future_usage, POST_PAYMENT_INTENTS_INTENT_VALID_VALUES_FOR_SETUP_FUTURE_USAGE)
        end
        if _shipping = shipping
          _shipping.validate if _shipping.is_a?(OpenApi::Validatable)
        end
        if _statement_descriptor = statement_descriptor
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor", statement_descriptor.to_s.size, POST_PAYMENT_INTENTS_INTENT_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR)
        end
        if _statement_descriptor_suffix = statement_descriptor_suffix
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor_suffix", statement_descriptor_suffix.to_s.size, POST_PAYMENT_INTENTS_INTENT_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR_SUFFIX)
        end
        if _transfer_data = transfer_data
          _transfer_data.validate if _transfer_data.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/payment_intents/{intent}".sub("{" + "intent" + "}", URI.encode_path(intent.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["application_fee_amount"] = application_fee_amount.to_s if !application_fee_amount.nil?
      form_params["capture_method"] = capture_method.to_s if !capture_method.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["payment_method"] = payment_method.to_s if !payment_method.nil?
      form_params["payment_method_data"] = payment_method_data.to_s if !payment_method_data.nil?
      form_params["payment_method_options"] = payment_method_options.to_s if !payment_method_options.nil?
      form_params["payment_method_types"] = @api_client.build_collection_param(payment_method_types, "csv") if !payment_method_types.nil? && !payment_method_types.empty?
      form_params["receipt_email"] = receipt_email.to_s if !receipt_email.nil?
      form_params["setup_future_usage"] = setup_future_usage.to_s if !setup_future_usage.nil?
      form_params["shipping"] = shipping.to_s if !shipping.nil?
      form_params["statement_descriptor"] = statement_descriptor.to_s if !statement_descriptor.nil?
      form_params["statement_descriptor_suffix"] = statement_descriptor_suffix.to_s if !statement_descriptor_suffix.nil?
      form_params["transfer_data"] = transfer_data.to_s if !transfer_data.nil?
      form_params["transfer_group"] = transfer_group.to_s if !transfer_group.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_payment_intents_intent",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Manually reconcile the remaining amount for a customer_balance PaymentIntent.</p>
    # @param intent [String?]
    # @optional @param amount [Int64?] Amount intended to be applied to this PaymentIntent from the customer’s cash balance.  A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency).  The maximum amount is the amount of the PaymentIntent.  When omitted, the amount defaults to the remaining amount requested on the PaymentIntent.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [PaymentIntent]
    def post_payment_intents_intent_apply_customer_balance(*, intent : String? = nil, amount : Int64? = nil, currency : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_payment_intents_intent_apply_customer_balance_with_http_info(intent: intent, amount: amount, currency: currency, expand: expand)
      data
    end

    # &lt;p&gt;Manually reconcile the remaining amount for a customer_balance PaymentIntent.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param amount [Int64?] Amount intended to be applied to this PaymentIntent from the customer’s cash balance.  A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency).  The maximum amount is the amount of the PaymentIntent.  When omitted, the amount defaults to the remaining amount requested on the PaymentIntent.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(PaymentIntent, Integer, Hash)>] PaymentIntent data, response status code and response headers
    def post_payment_intents_intent_apply_customer_balance_with_http_info(*, intent : String? = nil, amount : Int64? = nil, currency : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_payment_intents_intent_apply_customer_balance(intent: intent, amount: amount, currency: currency, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_payment_intents_intent_apply_customer_balance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentIntent.from_json(data), status_code, headers
    end

    # &lt;p&gt;Manually reconcile the remaining amount for a customer_balance PaymentIntent.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param amount [Int64?] Amount intended to be applied to this PaymentIntent from the customer’s cash balance.  A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency).  The maximum amount is the amount of the PaymentIntent.  When omitted, the amount defaults to the remaining amount requested on the PaymentIntent.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_payment_intents_intent_apply_customer_balance(*, intent : String? = nil, amount : Int64? = nil, currency : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_payment_intents_intent_apply_customer_balance(intent: intent, amount: amount, currency: currency, expand: expand).execute(&block)
    end

    POST_PAYMENT_INTENTS_INTENT_APPLY_CUSTOMER_BALANCE_MAX_LENGTH_FOR_INTENT = 5000

    # @return Crest::Request
    def build_api_request_for_post_payment_intents_intent_apply_customer_balance(*, intent : String? = nil, amount : Int64? = nil, currency : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_payment_intents_intent_apply_customer_balance ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"intent\" is required and cannot be null") if intent.nil?
        if _intent = intent
          OpenApi::PrimitiveValidator.validate_max_length("intent", intent.to_s.size, POST_PAYMENT_INTENTS_INTENT_APPLY_CUSTOMER_BALANCE_MAX_LENGTH_FOR_INTENT)
        end
      end

      # resource path
      local_var_path = "/v1/payment_intents/{intent}/apply_customer_balance".sub("{" + "intent" + "}", URI.encode_path(intent.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_payment_intents_intent_apply_customer_balance",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>A PaymentIntent object can be canceled when it is in one of these statuses: <code>requires_payment_method</code>, <code>requires_capture</code>, <code>requires_confirmation</code>, <code>requires_action</code>, or <code>processing</code>. </p>  <p>Once canceled, no additional charges will be made by the PaymentIntent and any operations on the PaymentIntent will fail with an error. For PaymentIntents with <code>status=’requires_capture’</code>, the remaining <code>amount_capturable</code> will automatically be refunded. </p>  <p>You cannot cancel the PaymentIntent for a Checkout Session. <a href=\"/docs/api/checkout/sessions/expire\">Expire the Checkout Session</a> instead</p>
    # @param intent [String?]
    # @optional @param cancellation_reason [String?] Reason for canceling this PaymentIntent. Possible values are `duplicate`, `fraudulent`, `requested_by_customer`, or `abandoned`
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [PaymentIntent]
    def post_payment_intents_intent_cancel(*, intent : String? = nil, cancellation_reason : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_payment_intents_intent_cancel_with_http_info(intent: intent, cancellation_reason: cancellation_reason, expand: expand)
      data
    end

    # &lt;p&gt;A PaymentIntent object can be canceled when it is in one of these statuses: &lt;code&gt;requires_payment_method&lt;/code&gt;, &lt;code&gt;requires_capture&lt;/code&gt;, &lt;code&gt;requires_confirmation&lt;/code&gt;, &lt;code&gt;requires_action&lt;/code&gt;, or &lt;code&gt;processing&lt;/code&gt;. &lt;/p&gt;  &lt;p&gt;Once canceled, no additional charges will be made by the PaymentIntent and any operations on the PaymentIntent will fail with an error. For PaymentIntents with &lt;code&gt;status&#x3D;’requires_capture’&lt;/code&gt;, the remaining &lt;code&gt;amount_capturable&lt;/code&gt; will automatically be refunded. &lt;/p&gt;  &lt;p&gt;You cannot cancel the PaymentIntent for a Checkout Session. &lt;a href&#x3D;\&quot;/docs/api/checkout/sessions/expire\&quot;&gt;Expire the Checkout Session&lt;/a&gt; instead&lt;/p&gt;
    # @param intent [String?]
    # @optional @param cancellation_reason [String?] Reason for canceling this PaymentIntent. Possible values are `duplicate`, `fraudulent`, `requested_by_customer`, or `abandoned`
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(PaymentIntent, Integer, Hash)>] PaymentIntent data, response status code and response headers
    def post_payment_intents_intent_cancel_with_http_info(*, intent : String? = nil, cancellation_reason : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_payment_intents_intent_cancel(intent: intent, cancellation_reason: cancellation_reason, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_payment_intents_intent_cancel\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentIntent.from_json(data), status_code, headers
    end

    # &lt;p&gt;A PaymentIntent object can be canceled when it is in one of these statuses: &lt;code&gt;requires_payment_method&lt;/code&gt;, &lt;code&gt;requires_capture&lt;/code&gt;, &lt;code&gt;requires_confirmation&lt;/code&gt;, &lt;code&gt;requires_action&lt;/code&gt;, or &lt;code&gt;processing&lt;/code&gt;. &lt;/p&gt;  &lt;p&gt;Once canceled, no additional charges will be made by the PaymentIntent and any operations on the PaymentIntent will fail with an error. For PaymentIntents with &lt;code&gt;status&#x3D;’requires_capture’&lt;/code&gt;, the remaining &lt;code&gt;amount_capturable&lt;/code&gt; will automatically be refunded. &lt;/p&gt;  &lt;p&gt;You cannot cancel the PaymentIntent for a Checkout Session. &lt;a href&#x3D;\&quot;/docs/api/checkout/sessions/expire\&quot;&gt;Expire the Checkout Session&lt;/a&gt; instead&lt;/p&gt;
    # @param intent [String?]
    # @optional @param cancellation_reason [String?] Reason for canceling this PaymentIntent. Possible values are `duplicate`, `fraudulent`, `requested_by_customer`, or `abandoned`
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_payment_intents_intent_cancel(*, intent : String? = nil, cancellation_reason : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_payment_intents_intent_cancel(intent: intent, cancellation_reason: cancellation_reason, expand: expand).execute(&block)
    end

    POST_PAYMENT_INTENTS_INTENT_CANCEL_MAX_LENGTH_FOR_INTENT                = 5000
    POST_PAYMENT_INTENTS_INTENT_CANCEL_MAX_LENGTH_FOR_CANCELLATION_REASON   = 5000
    POST_PAYMENT_INTENTS_INTENT_CANCEL_VALID_VALUES_FOR_CANCELLATION_REASON = StaticArray["abandoned", "duplicate", "fraudulent", "requested_by_customer"]

    # @return Crest::Request
    def build_api_request_for_post_payment_intents_intent_cancel(*, intent : String? = nil, cancellation_reason : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_payment_intents_intent_cancel ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"intent\" is required and cannot be null") if intent.nil?
        if _intent = intent
          OpenApi::PrimitiveValidator.validate_max_length("intent", intent.to_s.size, POST_PAYMENT_INTENTS_INTENT_CANCEL_MAX_LENGTH_FOR_INTENT)
        end
        if _cancellation_reason = cancellation_reason
          OpenApi::EnumValidator.validate("cancellation_reason", _cancellation_reason, POST_PAYMENT_INTENTS_INTENT_CANCEL_VALID_VALUES_FOR_CANCELLATION_REASON)
        end
      end

      # resource path
      local_var_path = "/v1/payment_intents/{intent}/cancel".sub("{" + "intent" + "}", URI.encode_path(intent.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["cancellation_reason"] = cancellation_reason.to_s if !cancellation_reason.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_payment_intents_intent_cancel",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Capture the funds of an existing uncaptured PaymentIntent when its status is <code>requires_capture</code>.</p>  <p>Uncaptured PaymentIntents will be canceled a set number of days after they are created (7 by default).</p>  <p>Learn more about <a href=\"/docs/payments/capture-later\">separate authorization and capture</a>.</p>
    # @param intent [String?]
    # @optional @param amount_to_capture [Int64?] The amount to capture from the PaymentIntent, which must be less than or equal to the original amount. Any additional amount will be automatically refunded. Defaults to the full `amount_capturable` if not provided.
    # @optional @param application_fee_amount [Int64?] The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param statement_descriptor [String?] For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    # @optional @param statement_descriptor_suffix [String?] Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
    # @optional @param transfer_data [Stripe::TransferDataUpdateParams1?]
    # @return [PaymentIntent]
    def post_payment_intents_intent_capture(*, intent : String? = nil, amount_to_capture : Int64? = nil, application_fee_amount : Int64? = nil, expand : Array(String)? = nil, statement_descriptor : String? = nil, statement_descriptor_suffix : String? = nil, transfer_data : Stripe::TransferDataUpdateParams1? = nil)
      data, _status_code, _headers = post_payment_intents_intent_capture_with_http_info(intent: intent, amount_to_capture: amount_to_capture, application_fee_amount: application_fee_amount, expand: expand, statement_descriptor: statement_descriptor, statement_descriptor_suffix: statement_descriptor_suffix, transfer_data: transfer_data)
      data
    end

    # &lt;p&gt;Capture the funds of an existing uncaptured PaymentIntent when its status is &lt;code&gt;requires_capture&lt;/code&gt;.&lt;/p&gt;  &lt;p&gt;Uncaptured PaymentIntents will be canceled a set number of days after they are created (7 by default).&lt;/p&gt;  &lt;p&gt;Learn more about &lt;a href&#x3D;\&quot;/docs/payments/capture-later\&quot;&gt;separate authorization and capture&lt;/a&gt;.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param amount_to_capture [Int64?] The amount to capture from the PaymentIntent, which must be less than or equal to the original amount. Any additional amount will be automatically refunded. Defaults to the full `amount_capturable` if not provided.
    # @optional @param application_fee_amount [Int64?] The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param statement_descriptor [String?] For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    # @optional @param statement_descriptor_suffix [String?] Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
    # @optional @param transfer_data [Stripe::TransferDataUpdateParams1?]
    # @return [Array<(PaymentIntent, Integer, Hash)>] PaymentIntent data, response status code and response headers
    def post_payment_intents_intent_capture_with_http_info(*, intent : String? = nil, amount_to_capture : Int64? = nil, application_fee_amount : Int64? = nil, expand : Array(String)? = nil, statement_descriptor : String? = nil, statement_descriptor_suffix : String? = nil, transfer_data : Stripe::TransferDataUpdateParams1? = nil)
      request = build_api_request_for_post_payment_intents_intent_capture(intent: intent, amount_to_capture: amount_to_capture, application_fee_amount: application_fee_amount, expand: expand, statement_descriptor: statement_descriptor, statement_descriptor_suffix: statement_descriptor_suffix, transfer_data: transfer_data)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_payment_intents_intent_capture\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentIntent.from_json(data), status_code, headers
    end

    # &lt;p&gt;Capture the funds of an existing uncaptured PaymentIntent when its status is &lt;code&gt;requires_capture&lt;/code&gt;.&lt;/p&gt;  &lt;p&gt;Uncaptured PaymentIntents will be canceled a set number of days after they are created (7 by default).&lt;/p&gt;  &lt;p&gt;Learn more about &lt;a href&#x3D;\&quot;/docs/payments/capture-later\&quot;&gt;separate authorization and capture&lt;/a&gt;.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param amount_to_capture [Int64?] The amount to capture from the PaymentIntent, which must be less than or equal to the original amount. Any additional amount will be automatically refunded. Defaults to the full `amount_capturable` if not provided.
    # @optional @param application_fee_amount [Int64?] The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param statement_descriptor [String?] For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    # @optional @param statement_descriptor_suffix [String?] Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
    # @optional @param transfer_data [Stripe::TransferDataUpdateParams1?]
    # @return nil
    def post_payment_intents_intent_capture(*, intent : String? = nil, amount_to_capture : Int64? = nil, application_fee_amount : Int64? = nil, expand : Array(String)? = nil, statement_descriptor : String? = nil, statement_descriptor_suffix : String? = nil, transfer_data : Stripe::TransferDataUpdateParams1? = nil, &block : Crest::Response ->)
      build_api_request_for_post_payment_intents_intent_capture(intent: intent, amount_to_capture: amount_to_capture, application_fee_amount: application_fee_amount, expand: expand, statement_descriptor: statement_descriptor, statement_descriptor_suffix: statement_descriptor_suffix, transfer_data: transfer_data).execute(&block)
    end

    POST_PAYMENT_INTENTS_INTENT_CAPTURE_MAX_LENGTH_FOR_INTENT                      = 5000
    POST_PAYMENT_INTENTS_INTENT_CAPTURE_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR        =   22
    POST_PAYMENT_INTENTS_INTENT_CAPTURE_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR_SUFFIX =   22

    # @return Crest::Request
    def build_api_request_for_post_payment_intents_intent_capture(*, intent : String? = nil, amount_to_capture : Int64? = nil, application_fee_amount : Int64? = nil, expand : Array(String)? = nil, statement_descriptor : String? = nil, statement_descriptor_suffix : String? = nil, transfer_data : Stripe::TransferDataUpdateParams1? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_payment_intents_intent_capture ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"intent\" is required and cannot be null") if intent.nil?
        if _intent = intent
          OpenApi::PrimitiveValidator.validate_max_length("intent", intent.to_s.size, POST_PAYMENT_INTENTS_INTENT_CAPTURE_MAX_LENGTH_FOR_INTENT)
        end

        if _statement_descriptor = statement_descriptor
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor", statement_descriptor.to_s.size, POST_PAYMENT_INTENTS_INTENT_CAPTURE_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR)
        end
        if _statement_descriptor_suffix = statement_descriptor_suffix
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor_suffix", statement_descriptor_suffix.to_s.size, POST_PAYMENT_INTENTS_INTENT_CAPTURE_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR_SUFFIX)
        end
        if _transfer_data = transfer_data
          _transfer_data.validate if _transfer_data.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/payment_intents/{intent}/capture".sub("{" + "intent" + "}", URI.encode_path(intent.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount_to_capture"] = amount_to_capture.to_s if !amount_to_capture.nil?
      form_params["application_fee_amount"] = application_fee_amount.to_s if !application_fee_amount.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["statement_descriptor"] = statement_descriptor.to_s if !statement_descriptor.nil?
      form_params["statement_descriptor_suffix"] = statement_descriptor_suffix.to_s if !statement_descriptor_suffix.nil?
      form_params["transfer_data"] = transfer_data.to_s if !transfer_data.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_payment_intents_intent_capture",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Confirm that your customer intends to pay with current or provided payment method. Upon confirmation, the PaymentIntent will attempt to initiate a payment.</p>  <p>If the selected payment method requires additional authentication steps, the PaymentIntent will transition to the <code>requires_action</code> status and suggest additional actions via <code>next_action</code>. If payment fails, the PaymentIntent will transition to the <code>requires_payment_method</code> status. If payment succeeds, the PaymentIntent will transition to the <code>succeeded</code> status (or <code>requires_capture</code>, if <code>capture_method</code> is set to <code>manual</code>).</p>  <p>If the <code>confirmation_method</code> is <code>automatic</code>, payment may be attempted using our <a href=\"/docs/stripe-js/reference#stripe-handle-card-payment\">client SDKs</a> and the PaymentIntent’s <a href=\"#payment_intent_object-client_secret\">client_secret</a>. After <code>next_action</code>s are handled by the client, no additional confirmation is required to complete the payment.</p>  <p>If the <code>confirmation_method</code> is <code>manual</code>, all payment attempts must be initiated using a secret key. If any actions are required for the payment, the PaymentIntent will return to the <code>requires_confirmation</code> state after those actions are completed. Your server needs to then explicitly re-confirm the PaymentIntent to initiate the next payment attempt. Read the <a href=\"/docs/payments/payment-intents/web-manual\">expanded documentation</a> to learn more about manual confirmation.</p>
    # @param intent [String?]
    # @optional @param capture_method [String?] Controls when the funds will be captured from the customer's account.
    # @optional @param client_secret [String?] The client secret of the PaymentIntent.
    # @optional @param error_on_requires_action [Bool?] Set to `true` to fail the payment attempt if the PaymentIntent transitions into `requires_action`. This parameter is intended for simpler integrations that do not handle customer actions, like [saving cards without authentication](https://stripe.com/docs/payments/save-card-without-authentication).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param mandate [String?] ID of the mandate to be used for this payment.
    # @optional @param mandate_data [Stripe::PostPaymentIntentsIntentConfirmRequestMandateData?]
    # @optional @param off_session [Stripe::PostPaymentIntentsIntentConfirmRequestOffSession?]
    # @optional @param payment_method [String?] ID of the payment method (a PaymentMethod, Card, or [compatible Source](https://stripe.com/docs/payments/payment-methods/transitioning#compatibility) object) to attach to this PaymentIntent.
    # @optional @param payment_method_data [Stripe::PaymentMethodDataParams?]
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam15?]
    # @optional @param payment_method_types [Array(String)?] The list of payment method types (e.g. card) that this PaymentIntent is allowed to use. Use automatic_payment_methods to manage payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods).
    # @optional @param radar_options [Stripe::RadarOptions?]
    # @optional @param receipt_email [Stripe::PostPaymentIntentsIntentRequestReceiptEmail?]
    # @optional @param return_url [String?] The URL to redirect your customer back to after they authenticate or cancel their payment on the payment method's app or site. If you'd prefer to redirect to a mobile application, you can alternatively supply an application URI scheme. This parameter is only used for cards and other redirect-based payment methods.
    # @optional @param setup_future_usage [String?] Indicates that you intend to make future payments with this PaymentIntent's payment method.  Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.  When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).  If `setup_future_usage` is already set and you are performing a request using a publishable key, you may only update the value from `on_session` to `off_session`.
    # @optional @param shipping [Stripe::PostPaymentIntentsIntentRequestShipping?]
    # @optional @param use_stripe_sdk [Bool?] Set to `true` only when using manual confirmation and the iOS or Android SDKs to handle additional authentication steps.
    # @return [PaymentIntent]
    def post_payment_intents_intent_confirm(*, intent : String? = nil, capture_method : String? = nil, client_secret : String? = nil, error_on_requires_action : Bool? = nil, expand : Array(String)? = nil, mandate : String? = nil, mandate_data : Stripe::PostPaymentIntentsIntentConfirmRequestMandateData? = nil, off_session : Stripe::PostPaymentIntentsIntentConfirmRequestOffSession? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam15? = nil, payment_method_types : Array(String)? = nil, radar_options : Stripe::RadarOptions? = nil, receipt_email : Stripe::PostPaymentIntentsIntentRequestReceiptEmail? = nil, return_url : String? = nil, setup_future_usage : String? = nil, shipping : Stripe::PostPaymentIntentsIntentRequestShipping? = nil, use_stripe_sdk : Bool? = nil)
      data, _status_code, _headers = post_payment_intents_intent_confirm_with_http_info(intent: intent, capture_method: capture_method, client_secret: client_secret, error_on_requires_action: error_on_requires_action, expand: expand, mandate: mandate, mandate_data: mandate_data, off_session: off_session, payment_method: payment_method, payment_method_data: payment_method_data, payment_method_options: payment_method_options, payment_method_types: payment_method_types, radar_options: radar_options, receipt_email: receipt_email, return_url: return_url, setup_future_usage: setup_future_usage, shipping: shipping, use_stripe_sdk: use_stripe_sdk)
      data
    end

    # &lt;p&gt;Confirm that your customer intends to pay with current or provided payment method. Upon confirmation, the PaymentIntent will attempt to initiate a payment.&lt;/p&gt;  &lt;p&gt;If the selected payment method requires additional authentication steps, the PaymentIntent will transition to the &lt;code&gt;requires_action&lt;/code&gt; status and suggest additional actions via &lt;code&gt;next_action&lt;/code&gt;. If payment fails, the PaymentIntent will transition to the &lt;code&gt;requires_payment_method&lt;/code&gt; status. If payment succeeds, the PaymentIntent will transition to the &lt;code&gt;succeeded&lt;/code&gt; status (or &lt;code&gt;requires_capture&lt;/code&gt;, if &lt;code&gt;capture_method&lt;/code&gt; is set to &lt;code&gt;manual&lt;/code&gt;).&lt;/p&gt;  &lt;p&gt;If the &lt;code&gt;confirmation_method&lt;/code&gt; is &lt;code&gt;automatic&lt;/code&gt;, payment may be attempted using our &lt;a href&#x3D;\&quot;/docs/stripe-js/reference#stripe-handle-card-payment\&quot;&gt;client SDKs&lt;/a&gt; and the PaymentIntent’s &lt;a href&#x3D;\&quot;#payment_intent_object-client_secret\&quot;&gt;client_secret&lt;/a&gt;. After &lt;code&gt;next_action&lt;/code&gt;s are handled by the client, no additional confirmation is required to complete the payment.&lt;/p&gt;  &lt;p&gt;If the &lt;code&gt;confirmation_method&lt;/code&gt; is &lt;code&gt;manual&lt;/code&gt;, all payment attempts must be initiated using a secret key. If any actions are required for the payment, the PaymentIntent will return to the &lt;code&gt;requires_confirmation&lt;/code&gt; state after those actions are completed. Your server needs to then explicitly re-confirm the PaymentIntent to initiate the next payment attempt. Read the &lt;a href&#x3D;\&quot;/docs/payments/payment-intents/web-manual\&quot;&gt;expanded documentation&lt;/a&gt; to learn more about manual confirmation.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param capture_method [String?] Controls when the funds will be captured from the customer's account.
    # @optional @param client_secret [String?] The client secret of the PaymentIntent.
    # @optional @param error_on_requires_action [Bool?] Set to `true` to fail the payment attempt if the PaymentIntent transitions into `requires_action`. This parameter is intended for simpler integrations that do not handle customer actions, like [saving cards without authentication](https://stripe.com/docs/payments/save-card-without-authentication).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param mandate [String?] ID of the mandate to be used for this payment.
    # @optional @param mandate_data [Stripe::PostPaymentIntentsIntentConfirmRequestMandateData?]
    # @optional @param off_session [Stripe::PostPaymentIntentsIntentConfirmRequestOffSession?]
    # @optional @param payment_method [String?] ID of the payment method (a PaymentMethod, Card, or [compatible Source](https://stripe.com/docs/payments/payment-methods/transitioning#compatibility) object) to attach to this PaymentIntent.
    # @optional @param payment_method_data [Stripe::PaymentMethodDataParams?]
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam15?]
    # @optional @param payment_method_types [Array(String)?] The list of payment method types (e.g. card) that this PaymentIntent is allowed to use. Use automatic_payment_methods to manage payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods).
    # @optional @param radar_options [Stripe::RadarOptions?]
    # @optional @param receipt_email [Stripe::PostPaymentIntentsIntentRequestReceiptEmail?]
    # @optional @param return_url [String?] The URL to redirect your customer back to after they authenticate or cancel their payment on the payment method's app or site. If you'd prefer to redirect to a mobile application, you can alternatively supply an application URI scheme. This parameter is only used for cards and other redirect-based payment methods.
    # @optional @param setup_future_usage [String?] Indicates that you intend to make future payments with this PaymentIntent's payment method.  Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.  When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).  If `setup_future_usage` is already set and you are performing a request using a publishable key, you may only update the value from `on_session` to `off_session`.
    # @optional @param shipping [Stripe::PostPaymentIntentsIntentRequestShipping?]
    # @optional @param use_stripe_sdk [Bool?] Set to `true` only when using manual confirmation and the iOS or Android SDKs to handle additional authentication steps.
    # @return [Array<(PaymentIntent, Integer, Hash)>] PaymentIntent data, response status code and response headers
    def post_payment_intents_intent_confirm_with_http_info(*, intent : String? = nil, capture_method : String? = nil, client_secret : String? = nil, error_on_requires_action : Bool? = nil, expand : Array(String)? = nil, mandate : String? = nil, mandate_data : Stripe::PostPaymentIntentsIntentConfirmRequestMandateData? = nil, off_session : Stripe::PostPaymentIntentsIntentConfirmRequestOffSession? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam15? = nil, payment_method_types : Array(String)? = nil, radar_options : Stripe::RadarOptions? = nil, receipt_email : Stripe::PostPaymentIntentsIntentRequestReceiptEmail? = nil, return_url : String? = nil, setup_future_usage : String? = nil, shipping : Stripe::PostPaymentIntentsIntentRequestShipping? = nil, use_stripe_sdk : Bool? = nil)
      request = build_api_request_for_post_payment_intents_intent_confirm(intent: intent, capture_method: capture_method, client_secret: client_secret, error_on_requires_action: error_on_requires_action, expand: expand, mandate: mandate, mandate_data: mandate_data, off_session: off_session, payment_method: payment_method, payment_method_data: payment_method_data, payment_method_options: payment_method_options, payment_method_types: payment_method_types, radar_options: radar_options, receipt_email: receipt_email, return_url: return_url, setup_future_usage: setup_future_usage, shipping: shipping, use_stripe_sdk: use_stripe_sdk)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_payment_intents_intent_confirm\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentIntent.from_json(data), status_code, headers
    end

    # &lt;p&gt;Confirm that your customer intends to pay with current or provided payment method. Upon confirmation, the PaymentIntent will attempt to initiate a payment.&lt;/p&gt;  &lt;p&gt;If the selected payment method requires additional authentication steps, the PaymentIntent will transition to the &lt;code&gt;requires_action&lt;/code&gt; status and suggest additional actions via &lt;code&gt;next_action&lt;/code&gt;. If payment fails, the PaymentIntent will transition to the &lt;code&gt;requires_payment_method&lt;/code&gt; status. If payment succeeds, the PaymentIntent will transition to the &lt;code&gt;succeeded&lt;/code&gt; status (or &lt;code&gt;requires_capture&lt;/code&gt;, if &lt;code&gt;capture_method&lt;/code&gt; is set to &lt;code&gt;manual&lt;/code&gt;).&lt;/p&gt;  &lt;p&gt;If the &lt;code&gt;confirmation_method&lt;/code&gt; is &lt;code&gt;automatic&lt;/code&gt;, payment may be attempted using our &lt;a href&#x3D;\&quot;/docs/stripe-js/reference#stripe-handle-card-payment\&quot;&gt;client SDKs&lt;/a&gt; and the PaymentIntent’s &lt;a href&#x3D;\&quot;#payment_intent_object-client_secret\&quot;&gt;client_secret&lt;/a&gt;. After &lt;code&gt;next_action&lt;/code&gt;s are handled by the client, no additional confirmation is required to complete the payment.&lt;/p&gt;  &lt;p&gt;If the &lt;code&gt;confirmation_method&lt;/code&gt; is &lt;code&gt;manual&lt;/code&gt;, all payment attempts must be initiated using a secret key. If any actions are required for the payment, the PaymentIntent will return to the &lt;code&gt;requires_confirmation&lt;/code&gt; state after those actions are completed. Your server needs to then explicitly re-confirm the PaymentIntent to initiate the next payment attempt. Read the &lt;a href&#x3D;\&quot;/docs/payments/payment-intents/web-manual\&quot;&gt;expanded documentation&lt;/a&gt; to learn more about manual confirmation.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param capture_method [String?] Controls when the funds will be captured from the customer's account.
    # @optional @param client_secret [String?] The client secret of the PaymentIntent.
    # @optional @param error_on_requires_action [Bool?] Set to `true` to fail the payment attempt if the PaymentIntent transitions into `requires_action`. This parameter is intended for simpler integrations that do not handle customer actions, like [saving cards without authentication](https://stripe.com/docs/payments/save-card-without-authentication).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param mandate [String?] ID of the mandate to be used for this payment.
    # @optional @param mandate_data [Stripe::PostPaymentIntentsIntentConfirmRequestMandateData?]
    # @optional @param off_session [Stripe::PostPaymentIntentsIntentConfirmRequestOffSession?]
    # @optional @param payment_method [String?] ID of the payment method (a PaymentMethod, Card, or [compatible Source](https://stripe.com/docs/payments/payment-methods/transitioning#compatibility) object) to attach to this PaymentIntent.
    # @optional @param payment_method_data [Stripe::PaymentMethodDataParams?]
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam15?]
    # @optional @param payment_method_types [Array(String)?] The list of payment method types (e.g. card) that this PaymentIntent is allowed to use. Use automatic_payment_methods to manage payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods).
    # @optional @param radar_options [Stripe::RadarOptions?]
    # @optional @param receipt_email [Stripe::PostPaymentIntentsIntentRequestReceiptEmail?]
    # @optional @param return_url [String?] The URL to redirect your customer back to after they authenticate or cancel their payment on the payment method's app or site. If you'd prefer to redirect to a mobile application, you can alternatively supply an application URI scheme. This parameter is only used for cards and other redirect-based payment methods.
    # @optional @param setup_future_usage [String?] Indicates that you intend to make future payments with this PaymentIntent's payment method.  Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.  When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).  If `setup_future_usage` is already set and you are performing a request using a publishable key, you may only update the value from `on_session` to `off_session`.
    # @optional @param shipping [Stripe::PostPaymentIntentsIntentRequestShipping?]
    # @optional @param use_stripe_sdk [Bool?] Set to `true` only when using manual confirmation and the iOS or Android SDKs to handle additional authentication steps.
    # @return nil
    def post_payment_intents_intent_confirm(*, intent : String? = nil, capture_method : String? = nil, client_secret : String? = nil, error_on_requires_action : Bool? = nil, expand : Array(String)? = nil, mandate : String? = nil, mandate_data : Stripe::PostPaymentIntentsIntentConfirmRequestMandateData? = nil, off_session : Stripe::PostPaymentIntentsIntentConfirmRequestOffSession? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam15? = nil, payment_method_types : Array(String)? = nil, radar_options : Stripe::RadarOptions? = nil, receipt_email : Stripe::PostPaymentIntentsIntentRequestReceiptEmail? = nil, return_url : String? = nil, setup_future_usage : String? = nil, shipping : Stripe::PostPaymentIntentsIntentRequestShipping? = nil, use_stripe_sdk : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_post_payment_intents_intent_confirm(intent: intent, capture_method: capture_method, client_secret: client_secret, error_on_requires_action: error_on_requires_action, expand: expand, mandate: mandate, mandate_data: mandate_data, off_session: off_session, payment_method: payment_method, payment_method_data: payment_method_data, payment_method_options: payment_method_options, payment_method_types: payment_method_types, radar_options: radar_options, receipt_email: receipt_email, return_url: return_url, setup_future_usage: setup_future_usage, shipping: shipping, use_stripe_sdk: use_stripe_sdk).execute(&block)
    end

    POST_PAYMENT_INTENTS_INTENT_CONFIRM_MAX_LENGTH_FOR_INTENT               = 5000
    POST_PAYMENT_INTENTS_INTENT_CONFIRM_VALID_VALUES_FOR_CAPTURE_METHOD     = StaticArray["automatic", "manual"]
    POST_PAYMENT_INTENTS_INTENT_CONFIRM_MAX_LENGTH_FOR_CLIENT_SECRET        = 5000
    POST_PAYMENT_INTENTS_INTENT_CONFIRM_MAX_LENGTH_FOR_MANDATE              = 5000
    POST_PAYMENT_INTENTS_INTENT_CONFIRM_MAX_LENGTH_FOR_PAYMENT_METHOD       = 5000
    POST_PAYMENT_INTENTS_INTENT_CONFIRM_VALID_VALUES_FOR_SETUP_FUTURE_USAGE = StaticArray["", "off_session", "on_session"]

    # @return Crest::Request
    def build_api_request_for_post_payment_intents_intent_confirm(*, intent : String? = nil, capture_method : String? = nil, client_secret : String? = nil, error_on_requires_action : Bool? = nil, expand : Array(String)? = nil, mandate : String? = nil, mandate_data : Stripe::PostPaymentIntentsIntentConfirmRequestMandateData? = nil, off_session : Stripe::PostPaymentIntentsIntentConfirmRequestOffSession? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam15? = nil, payment_method_types : Array(String)? = nil, radar_options : Stripe::RadarOptions? = nil, receipt_email : Stripe::PostPaymentIntentsIntentRequestReceiptEmail? = nil, return_url : String? = nil, setup_future_usage : String? = nil, shipping : Stripe::PostPaymentIntentsIntentRequestShipping? = nil, use_stripe_sdk : Bool? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_payment_intents_intent_confirm ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"intent\" is required and cannot be null") if intent.nil?
        if _intent = intent
          OpenApi::PrimitiveValidator.validate_max_length("intent", intent.to_s.size, POST_PAYMENT_INTENTS_INTENT_CONFIRM_MAX_LENGTH_FOR_INTENT)
        end
        if _capture_method = capture_method
          OpenApi::EnumValidator.validate("capture_method", _capture_method, POST_PAYMENT_INTENTS_INTENT_CONFIRM_VALID_VALUES_FOR_CAPTURE_METHOD)
        end
        if _client_secret = client_secret
          OpenApi::PrimitiveValidator.validate_max_length("client_secret", client_secret.to_s.size, POST_PAYMENT_INTENTS_INTENT_CONFIRM_MAX_LENGTH_FOR_CLIENT_SECRET)
        end

        if _mandate = mandate
          OpenApi::PrimitiveValidator.validate_max_length("mandate", mandate.to_s.size, POST_PAYMENT_INTENTS_INTENT_CONFIRM_MAX_LENGTH_FOR_MANDATE)
        end
        if _mandate_data = mandate_data
          _mandate_data.validate if _mandate_data.is_a?(OpenApi::Validatable)
        end
        if _off_session = off_session
          _off_session.validate if _off_session.is_a?(OpenApi::Validatable)
        end
        if _payment_method = payment_method
          OpenApi::PrimitiveValidator.validate_max_length("payment_method", payment_method.to_s.size, POST_PAYMENT_INTENTS_INTENT_CONFIRM_MAX_LENGTH_FOR_PAYMENT_METHOD)
        end
        if _payment_method_data = payment_method_data
          _payment_method_data.validate if _payment_method_data.is_a?(OpenApi::Validatable)
        end
        if _payment_method_options = payment_method_options
          _payment_method_options.validate if _payment_method_options.is_a?(OpenApi::Validatable)
        end

        if _radar_options = radar_options
          _radar_options.validate if _radar_options.is_a?(OpenApi::Validatable)
        end
        if _receipt_email = receipt_email
          _receipt_email.validate if _receipt_email.is_a?(OpenApi::Validatable)
        end

        if _setup_future_usage = setup_future_usage
          OpenApi::EnumValidator.validate("setup_future_usage", _setup_future_usage, POST_PAYMENT_INTENTS_INTENT_CONFIRM_VALID_VALUES_FOR_SETUP_FUTURE_USAGE)
        end
        if _shipping = shipping
          _shipping.validate if _shipping.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/payment_intents/{intent}/confirm".sub("{" + "intent" + "}", URI.encode_path(intent.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["capture_method"] = capture_method.to_s if !capture_method.nil?
      form_params["client_secret"] = client_secret.to_s if !client_secret.nil?
      form_params["error_on_requires_action"] = error_on_requires_action.to_s if !error_on_requires_action.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["mandate"] = mandate.to_s if !mandate.nil?
      form_params["mandate_data"] = mandate_data.to_s if !mandate_data.nil?
      form_params["off_session"] = off_session.to_s if !off_session.nil?
      form_params["payment_method"] = payment_method.to_s if !payment_method.nil?
      form_params["payment_method_data"] = payment_method_data.to_s if !payment_method_data.nil?
      form_params["payment_method_options"] = payment_method_options.to_s if !payment_method_options.nil?
      form_params["payment_method_types"] = @api_client.build_collection_param(payment_method_types, "csv") if !payment_method_types.nil? && !payment_method_types.empty?
      form_params["radar_options"] = radar_options.to_s if !radar_options.nil?
      form_params["receipt_email"] = receipt_email.to_s if !receipt_email.nil?
      form_params["return_url"] = return_url.to_s if !return_url.nil?
      form_params["setup_future_usage"] = setup_future_usage.to_s if !setup_future_usage.nil?
      form_params["shipping"] = shipping.to_s if !shipping.nil?
      form_params["use_stripe_sdk"] = use_stripe_sdk.to_s if !use_stripe_sdk.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_payment_intents_intent_confirm",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Perform an incremental authorization on an eligible <a href=\"/docs/api/payment_intents/object\">PaymentIntent</a>. To be eligible, the PaymentIntent’s status must be <code>requires_capture</code> and <a href=\"/docs/api/charges/object#charge_object-payment_method_details-card_present-incremental_authorization_supported\">incremental_authorization_supported</a> must be <code>true</code>.</p>  <p>Incremental authorizations attempt to increase the authorized amount on your customer’s card to the new, higher <code>amount</code> provided. As with the initial authorization, incremental authorizations may be declined. A single PaymentIntent can call this endpoint multiple times to further increase the authorized amount.</p>  <p>If the incremental authorization succeeds, the PaymentIntent object is returned with the updated <a href=\"/docs/api/payment_intents/object#payment_intent_object-amount\">amount</a>. If the incremental authorization fails, a <a href=\"/docs/error-codes#card-declined\">card_declined</a> error is returned, and no fields on the PaymentIntent or Charge are updated. The PaymentIntent object remains capturable for the previously authorized amount.</p>  <p>Each PaymentIntent can have a maximum of 10 incremental authorization attempts, including declines. Once captured, a PaymentIntent can no longer be incremented.</p>  <p>Learn more about <a href=\"/docs/terminal/features/incremental-authorizations\">incremental authorizations</a>.</p>
    # @param intent [String?]
    # @param amount [Int64?] The updated total amount you intend to collect from the cardholder. This amount must be greater than the currently authorized amount.
    # @optional @param application_fee_amount [Int64?] The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param statement_descriptor [String?] For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    # @optional @param transfer_data [Stripe::TransferDataUpdateParams2?]
    # @return [PaymentIntent]
    def post_payment_intents_intent_increment_authorization(*, intent : String? = nil, amount : Int64? = nil, application_fee_amount : Int64? = nil, description : String? = nil, expand : Array(String)? = nil, statement_descriptor : String? = nil, transfer_data : Stripe::TransferDataUpdateParams2? = nil)
      data, _status_code, _headers = post_payment_intents_intent_increment_authorization_with_http_info(intent: intent, amount: amount, application_fee_amount: application_fee_amount, description: description, expand: expand, statement_descriptor: statement_descriptor, transfer_data: transfer_data)
      data
    end

    # &lt;p&gt;Perform an incremental authorization on an eligible &lt;a href&#x3D;\&quot;/docs/api/payment_intents/object\&quot;&gt;PaymentIntent&lt;/a&gt;. To be eligible, the PaymentIntent’s status must be &lt;code&gt;requires_capture&lt;/code&gt; and &lt;a href&#x3D;\&quot;/docs/api/charges/object#charge_object-payment_method_details-card_present-incremental_authorization_supported\&quot;&gt;incremental_authorization_supported&lt;/a&gt; must be &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;  &lt;p&gt;Incremental authorizations attempt to increase the authorized amount on your customer’s card to the new, higher &lt;code&gt;amount&lt;/code&gt; provided. As with the initial authorization, incremental authorizations may be declined. A single PaymentIntent can call this endpoint multiple times to further increase the authorized amount.&lt;/p&gt;  &lt;p&gt;If the incremental authorization succeeds, the PaymentIntent object is returned with the updated &lt;a href&#x3D;\&quot;/docs/api/payment_intents/object#payment_intent_object-amount\&quot;&gt;amount&lt;/a&gt;. If the incremental authorization fails, a &lt;a href&#x3D;\&quot;/docs/error-codes#card-declined\&quot;&gt;card_declined&lt;/a&gt; error is returned, and no fields on the PaymentIntent or Charge are updated. The PaymentIntent object remains capturable for the previously authorized amount.&lt;/p&gt;  &lt;p&gt;Each PaymentIntent can have a maximum of 10 incremental authorization attempts, including declines. Once captured, a PaymentIntent can no longer be incremented.&lt;/p&gt;  &lt;p&gt;Learn more about &lt;a href&#x3D;\&quot;/docs/terminal/features/incremental-authorizations\&quot;&gt;incremental authorizations&lt;/a&gt;.&lt;/p&gt;
    # @param intent [String?]
    # @param amount [Int64?] The updated total amount you intend to collect from the cardholder. This amount must be greater than the currently authorized amount.
    # @optional @param application_fee_amount [Int64?] The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param statement_descriptor [String?] For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    # @optional @param transfer_data [Stripe::TransferDataUpdateParams2?]
    # @return [Array<(PaymentIntent, Integer, Hash)>] PaymentIntent data, response status code and response headers
    def post_payment_intents_intent_increment_authorization_with_http_info(*, intent : String? = nil, amount : Int64? = nil, application_fee_amount : Int64? = nil, description : String? = nil, expand : Array(String)? = nil, statement_descriptor : String? = nil, transfer_data : Stripe::TransferDataUpdateParams2? = nil)
      request = build_api_request_for_post_payment_intents_intent_increment_authorization(intent: intent, amount: amount, application_fee_amount: application_fee_amount, description: description, expand: expand, statement_descriptor: statement_descriptor, transfer_data: transfer_data)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_payment_intents_intent_increment_authorization\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentIntent.from_json(data), status_code, headers
    end

    # &lt;p&gt;Perform an incremental authorization on an eligible &lt;a href&#x3D;\&quot;/docs/api/payment_intents/object\&quot;&gt;PaymentIntent&lt;/a&gt;. To be eligible, the PaymentIntent’s status must be &lt;code&gt;requires_capture&lt;/code&gt; and &lt;a href&#x3D;\&quot;/docs/api/charges/object#charge_object-payment_method_details-card_present-incremental_authorization_supported\&quot;&gt;incremental_authorization_supported&lt;/a&gt; must be &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;  &lt;p&gt;Incremental authorizations attempt to increase the authorized amount on your customer’s card to the new, higher &lt;code&gt;amount&lt;/code&gt; provided. As with the initial authorization, incremental authorizations may be declined. A single PaymentIntent can call this endpoint multiple times to further increase the authorized amount.&lt;/p&gt;  &lt;p&gt;If the incremental authorization succeeds, the PaymentIntent object is returned with the updated &lt;a href&#x3D;\&quot;/docs/api/payment_intents/object#payment_intent_object-amount\&quot;&gt;amount&lt;/a&gt;. If the incremental authorization fails, a &lt;a href&#x3D;\&quot;/docs/error-codes#card-declined\&quot;&gt;card_declined&lt;/a&gt; error is returned, and no fields on the PaymentIntent or Charge are updated. The PaymentIntent object remains capturable for the previously authorized amount.&lt;/p&gt;  &lt;p&gt;Each PaymentIntent can have a maximum of 10 incremental authorization attempts, including declines. Once captured, a PaymentIntent can no longer be incremented.&lt;/p&gt;  &lt;p&gt;Learn more about &lt;a href&#x3D;\&quot;/docs/terminal/features/incremental-authorizations\&quot;&gt;incremental authorizations&lt;/a&gt;.&lt;/p&gt;
    # @param intent [String?]
    # @param amount [Int64?] The updated total amount you intend to collect from the cardholder. This amount must be greater than the currently authorized amount.
    # @optional @param application_fee_amount [Int64?] The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param statement_descriptor [String?] For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    # @optional @param transfer_data [Stripe::TransferDataUpdateParams2?]
    # @return nil
    def post_payment_intents_intent_increment_authorization(*, intent : String? = nil, amount : Int64? = nil, application_fee_amount : Int64? = nil, description : String? = nil, expand : Array(String)? = nil, statement_descriptor : String? = nil, transfer_data : Stripe::TransferDataUpdateParams2? = nil, &block : Crest::Response ->)
      build_api_request_for_post_payment_intents_intent_increment_authorization(intent: intent, amount: amount, application_fee_amount: application_fee_amount, description: description, expand: expand, statement_descriptor: statement_descriptor, transfer_data: transfer_data).execute(&block)
    end

    POST_PAYMENT_INTENTS_INTENT_INCREMENT_AUTHORIZATION_MAX_LENGTH_FOR_INTENT               = 5000
    POST_PAYMENT_INTENTS_INTENT_INCREMENT_AUTHORIZATION_MAX_LENGTH_FOR_DESCRIPTION          = 1000
    POST_PAYMENT_INTENTS_INTENT_INCREMENT_AUTHORIZATION_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR =   22

    # @return Crest::Request
    def build_api_request_for_post_payment_intents_intent_increment_authorization(*, intent : String? = nil, amount : Int64? = nil, application_fee_amount : Int64? = nil, description : String? = nil, expand : Array(String)? = nil, statement_descriptor : String? = nil, transfer_data : Stripe::TransferDataUpdateParams2? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_payment_intents_intent_increment_authorization ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"intent\" is required and cannot be null") if intent.nil?
        if _intent = intent
          OpenApi::PrimitiveValidator.validate_max_length("intent", intent.to_s.size, POST_PAYMENT_INTENTS_INTENT_INCREMENT_AUTHORIZATION_MAX_LENGTH_FOR_INTENT)
        end
        raise ArgumentError.new("\"amount\" is required and cannot be null") if amount.nil?

        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_PAYMENT_INTENTS_INTENT_INCREMENT_AUTHORIZATION_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _statement_descriptor = statement_descriptor
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor", statement_descriptor.to_s.size, POST_PAYMENT_INTENTS_INTENT_INCREMENT_AUTHORIZATION_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR)
        end
        if _transfer_data = transfer_data
          _transfer_data.validate if _transfer_data.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/payment_intents/{intent}/increment_authorization".sub("{" + "intent" + "}", URI.encode_path(intent.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["application_fee_amount"] = application_fee_amount.to_s if !application_fee_amount.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["statement_descriptor"] = statement_descriptor.to_s if !statement_descriptor.nil?
      form_params["transfer_data"] = transfer_data.to_s if !transfer_data.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_payment_intents_intent_increment_authorization",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Verifies microdeposits on a PaymentIntent object.</p>
    # @param intent [String?]
    # @optional @param amounts [Array(Int64)?] Two positive integers, in *cents*, equal to the values of the microdeposits sent to the bank account.
    # @optional @param client_secret [String?] The client secret of the PaymentIntent.
    # @optional @param descriptor_code [String?] A six-character code starting with SM present in the microdeposit sent to the bank account.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [PaymentIntent]
    def post_payment_intents_intent_verify_microdeposits(*, intent : String? = nil, amounts : Array(Int64)? = nil, client_secret : String? = nil, descriptor_code : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_payment_intents_intent_verify_microdeposits_with_http_info(intent: intent, amounts: amounts, client_secret: client_secret, descriptor_code: descriptor_code, expand: expand)
      data
    end

    # &lt;p&gt;Verifies microdeposits on a PaymentIntent object.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param amounts [Array(Int64)?] Two positive integers, in *cents*, equal to the values of the microdeposits sent to the bank account.
    # @optional @param client_secret [String?] The client secret of the PaymentIntent.
    # @optional @param descriptor_code [String?] A six-character code starting with SM present in the microdeposit sent to the bank account.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(PaymentIntent, Integer, Hash)>] PaymentIntent data, response status code and response headers
    def post_payment_intents_intent_verify_microdeposits_with_http_info(*, intent : String? = nil, amounts : Array(Int64)? = nil, client_secret : String? = nil, descriptor_code : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_payment_intents_intent_verify_microdeposits(intent: intent, amounts: amounts, client_secret: client_secret, descriptor_code: descriptor_code, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_payment_intents_intent_verify_microdeposits\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentIntent.from_json(data), status_code, headers
    end

    # &lt;p&gt;Verifies microdeposits on a PaymentIntent object.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param amounts [Array(Int64)?] Two positive integers, in *cents*, equal to the values of the microdeposits sent to the bank account.
    # @optional @param client_secret [String?] The client secret of the PaymentIntent.
    # @optional @param descriptor_code [String?] A six-character code starting with SM present in the microdeposit sent to the bank account.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_payment_intents_intent_verify_microdeposits(*, intent : String? = nil, amounts : Array(Int64)? = nil, client_secret : String? = nil, descriptor_code : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_payment_intents_intent_verify_microdeposits(intent: intent, amounts: amounts, client_secret: client_secret, descriptor_code: descriptor_code, expand: expand).execute(&block)
    end

    POST_PAYMENT_INTENTS_INTENT_VERIFY_MICRODEPOSITS_MAX_LENGTH_FOR_INTENT          = 5000
    POST_PAYMENT_INTENTS_INTENT_VERIFY_MICRODEPOSITS_MAX_LENGTH_FOR_CLIENT_SECRET   = 5000
    POST_PAYMENT_INTENTS_INTENT_VERIFY_MICRODEPOSITS_MAX_LENGTH_FOR_DESCRIPTOR_CODE = 5000

    # @return Crest::Request
    def build_api_request_for_post_payment_intents_intent_verify_microdeposits(*, intent : String? = nil, amounts : Array(Int64)? = nil, client_secret : String? = nil, descriptor_code : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_payment_intents_intent_verify_microdeposits ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"intent\" is required and cannot be null") if intent.nil?
        if _intent = intent
          OpenApi::PrimitiveValidator.validate_max_length("intent", intent.to_s.size, POST_PAYMENT_INTENTS_INTENT_VERIFY_MICRODEPOSITS_MAX_LENGTH_FOR_INTENT)
        end

        if _client_secret = client_secret
          OpenApi::PrimitiveValidator.validate_max_length("client_secret", client_secret.to_s.size, POST_PAYMENT_INTENTS_INTENT_VERIFY_MICRODEPOSITS_MAX_LENGTH_FOR_CLIENT_SECRET)
        end
        if _descriptor_code = descriptor_code
          OpenApi::PrimitiveValidator.validate_max_length("descriptor_code", descriptor_code.to_s.size, POST_PAYMENT_INTENTS_INTENT_VERIFY_MICRODEPOSITS_MAX_LENGTH_FOR_DESCRIPTOR_CODE)
        end
      end

      # resource path
      local_var_path = "/v1/payment_intents/{intent}/verify_microdeposits".sub("{" + "intent" + "}", URI.encode_path(intent.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amounts"] = @api_client.build_collection_param(amounts, "csv") if !amounts.nil? && !amounts.empty?
      form_params["client_secret"] = client_secret.to_s if !client_secret.nil?
      form_params["descriptor_code"] = descriptor_code.to_s if !descriptor_code.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_payment_intents_intent_verify_microdeposits",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a payment link.</p>
    # @param line_items [Array(Stripe::LineItemsCreateParams)?] The line items representing what is being sold. Each line item represents an item being sold. Up to 20 line items are supported.
    # @optional @param after_completion [Stripe::AfterCompletionParams?]
    # @optional @param allow_promotion_codes [Bool?] Enables user redeemable promotion codes.
    # @optional @param application_fee_amount [Int64?] The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. Can only be applied when there are no line items with recurring prices.
    # @optional @param application_fee_percent [Float64?] A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. There must be at least 1 line item with a recurring price to use this field.
    # @optional @param automatic_tax [Stripe::AutomaticTaxParams1?]
    # @optional @param billing_address_collection [String?] Configuration for collecting the customer's billing address.
    # @optional @param consent_collection [Stripe::ConsentCollectionParams1?]
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies) and supported by each line item's price.
    # @optional @param customer_creation [String?] Configures whether [checkout sessions](https://stripe.com/docs/api/checkout/sessions) created by this payment link create a [Customer](https://stripe.com/docs/api/customers).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param on_behalf_of [String?] The account on behalf of which to charge.
    # @optional @param payment_intent_data [Stripe::PaymentIntentDataParams1?]
    # @optional @param payment_method_collection [String?] Specify whether Checkout should collect a payment method. When set to `if_required`, Checkout will not collect a payment method when the total due for the session is 0.This may occur if the Checkout Session includes a free trial or a discount.  Can only be set in `subscription` mode.  If you'd like information on how to collect a payment method outside of Checkout, read the guide on [configuring subscriptions with a free trial](https://stripe.com/docs/payments/checkout/free-trials).
    # @optional @param payment_method_types [Array(String)?] The list of payment method types that customers can use. If no value is passed, Stripe will dynamically show relevant payment methods from your [payment method settings](https://dashboard.stripe.com/settings/payment_methods) (20+ payment methods [supported](https://stripe.com/docs/payments/payment-methods/integration-options#payment-method-product-support)).
    # @optional @param phone_number_collection [Stripe::PhoneNumberCollectionParams1?]
    # @optional @param shipping_address_collection [Stripe::ShippingAddressCollectionParams1?]
    # @optional @param shipping_options [Array(Stripe::ShippingOptionParams1)?] The shipping rate options to apply to [checkout sessions](https://stripe.com/docs/api/checkout/sessions) created by this payment link.
    # @optional @param submit_type [String?] Describes the type of transaction being performed in order to customize relevant text on the page, such as the submit button. Changing this value will also affect the hostname in the [url](https://stripe.com/docs/api/payment_links/payment_links/object#url) property (example: `donate.stripe.com`).
    # @optional @param subscription_data [Stripe::SubscriptionDataParams1?]
    # @optional @param tax_id_collection [Stripe::TaxIdCollectionParams1?]
    # @optional @param transfer_data [Stripe::TransferDataParams1?]
    # @return [PaymentLink]
    def post_payment_links(*, line_items : Array(Stripe::LineItemsCreateParams)? = nil, after_completion : Stripe::AfterCompletionParams? = nil, allow_promotion_codes : Bool? = nil, application_fee_amount : Int64? = nil, application_fee_percent : Float64? = nil, automatic_tax : Stripe::AutomaticTaxParams1? = nil, billing_address_collection : String? = nil, consent_collection : Stripe::ConsentCollectionParams1? = nil, currency : String? = nil, customer_creation : String? = nil, expand : Array(String)? = nil, on_behalf_of : String? = nil, payment_intent_data : Stripe::PaymentIntentDataParams1? = nil, payment_method_collection : String? = nil, payment_method_types : Array(String)? = nil, phone_number_collection : Stripe::PhoneNumberCollectionParams1? = nil, shipping_address_collection : Stripe::ShippingAddressCollectionParams1? = nil, shipping_options : Array(Stripe::ShippingOptionParams1)? = nil, submit_type : String? = nil, subscription_data : Stripe::SubscriptionDataParams1? = nil, tax_id_collection : Stripe::TaxIdCollectionParams1? = nil, transfer_data : Stripe::TransferDataParams1? = nil)
      data, _status_code, _headers = post_payment_links_with_http_info(line_items: line_items, after_completion: after_completion, allow_promotion_codes: allow_promotion_codes, application_fee_amount: application_fee_amount, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, billing_address_collection: billing_address_collection, consent_collection: consent_collection, currency: currency, customer_creation: customer_creation, expand: expand, on_behalf_of: on_behalf_of, payment_intent_data: payment_intent_data, payment_method_collection: payment_method_collection, payment_method_types: payment_method_types, phone_number_collection: phone_number_collection, shipping_address_collection: shipping_address_collection, shipping_options: shipping_options, submit_type: submit_type, subscription_data: subscription_data, tax_id_collection: tax_id_collection, transfer_data: transfer_data)
      data
    end

    # &lt;p&gt;Creates a payment link.&lt;/p&gt;
    # @param line_items [Array(Stripe::LineItemsCreateParams)?] The line items representing what is being sold. Each line item represents an item being sold. Up to 20 line items are supported.
    # @optional @param after_completion [Stripe::AfterCompletionParams?]
    # @optional @param allow_promotion_codes [Bool?] Enables user redeemable promotion codes.
    # @optional @param application_fee_amount [Int64?] The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. Can only be applied when there are no line items with recurring prices.
    # @optional @param application_fee_percent [Float64?] A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. There must be at least 1 line item with a recurring price to use this field.
    # @optional @param automatic_tax [Stripe::AutomaticTaxParams1?]
    # @optional @param billing_address_collection [String?] Configuration for collecting the customer's billing address.
    # @optional @param consent_collection [Stripe::ConsentCollectionParams1?]
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies) and supported by each line item's price.
    # @optional @param customer_creation [String?] Configures whether [checkout sessions](https://stripe.com/docs/api/checkout/sessions) created by this payment link create a [Customer](https://stripe.com/docs/api/customers).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param on_behalf_of [String?] The account on behalf of which to charge.
    # @optional @param payment_intent_data [Stripe::PaymentIntentDataParams1?]
    # @optional @param payment_method_collection [String?] Specify whether Checkout should collect a payment method. When set to `if_required`, Checkout will not collect a payment method when the total due for the session is 0.This may occur if the Checkout Session includes a free trial or a discount.  Can only be set in `subscription` mode.  If you'd like information on how to collect a payment method outside of Checkout, read the guide on [configuring subscriptions with a free trial](https://stripe.com/docs/payments/checkout/free-trials).
    # @optional @param payment_method_types [Array(String)?] The list of payment method types that customers can use. If no value is passed, Stripe will dynamically show relevant payment methods from your [payment method settings](https://dashboard.stripe.com/settings/payment_methods) (20+ payment methods [supported](https://stripe.com/docs/payments/payment-methods/integration-options#payment-method-product-support)).
    # @optional @param phone_number_collection [Stripe::PhoneNumberCollectionParams1?]
    # @optional @param shipping_address_collection [Stripe::ShippingAddressCollectionParams1?]
    # @optional @param shipping_options [Array(Stripe::ShippingOptionParams1)?] The shipping rate options to apply to [checkout sessions](https://stripe.com/docs/api/checkout/sessions) created by this payment link.
    # @optional @param submit_type [String?] Describes the type of transaction being performed in order to customize relevant text on the page, such as the submit button. Changing this value will also affect the hostname in the [url](https://stripe.com/docs/api/payment_links/payment_links/object#url) property (example: `donate.stripe.com`).
    # @optional @param subscription_data [Stripe::SubscriptionDataParams1?]
    # @optional @param tax_id_collection [Stripe::TaxIdCollectionParams1?]
    # @optional @param transfer_data [Stripe::TransferDataParams1?]
    # @return [Array<(PaymentLink, Integer, Hash)>] PaymentLink data, response status code and response headers
    def post_payment_links_with_http_info(*, line_items : Array(Stripe::LineItemsCreateParams)? = nil, after_completion : Stripe::AfterCompletionParams? = nil, allow_promotion_codes : Bool? = nil, application_fee_amount : Int64? = nil, application_fee_percent : Float64? = nil, automatic_tax : Stripe::AutomaticTaxParams1? = nil, billing_address_collection : String? = nil, consent_collection : Stripe::ConsentCollectionParams1? = nil, currency : String? = nil, customer_creation : String? = nil, expand : Array(String)? = nil, on_behalf_of : String? = nil, payment_intent_data : Stripe::PaymentIntentDataParams1? = nil, payment_method_collection : String? = nil, payment_method_types : Array(String)? = nil, phone_number_collection : Stripe::PhoneNumberCollectionParams1? = nil, shipping_address_collection : Stripe::ShippingAddressCollectionParams1? = nil, shipping_options : Array(Stripe::ShippingOptionParams1)? = nil, submit_type : String? = nil, subscription_data : Stripe::SubscriptionDataParams1? = nil, tax_id_collection : Stripe::TaxIdCollectionParams1? = nil, transfer_data : Stripe::TransferDataParams1? = nil)
      request = build_api_request_for_post_payment_links(line_items: line_items, after_completion: after_completion, allow_promotion_codes: allow_promotion_codes, application_fee_amount: application_fee_amount, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, billing_address_collection: billing_address_collection, consent_collection: consent_collection, currency: currency, customer_creation: customer_creation, expand: expand, on_behalf_of: on_behalf_of, payment_intent_data: payment_intent_data, payment_method_collection: payment_method_collection, payment_method_types: payment_method_types, phone_number_collection: phone_number_collection, shipping_address_collection: shipping_address_collection, shipping_options: shipping_options, submit_type: submit_type, subscription_data: subscription_data, tax_id_collection: tax_id_collection, transfer_data: transfer_data)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_payment_links\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentLink.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a payment link.&lt;/p&gt;
    # @param line_items [Array(Stripe::LineItemsCreateParams)?] The line items representing what is being sold. Each line item represents an item being sold. Up to 20 line items are supported.
    # @optional @param after_completion [Stripe::AfterCompletionParams?]
    # @optional @param allow_promotion_codes [Bool?] Enables user redeemable promotion codes.
    # @optional @param application_fee_amount [Int64?] The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. Can only be applied when there are no line items with recurring prices.
    # @optional @param application_fee_percent [Float64?] A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. There must be at least 1 line item with a recurring price to use this field.
    # @optional @param automatic_tax [Stripe::AutomaticTaxParams1?]
    # @optional @param billing_address_collection [String?] Configuration for collecting the customer's billing address.
    # @optional @param consent_collection [Stripe::ConsentCollectionParams1?]
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies) and supported by each line item's price.
    # @optional @param customer_creation [String?] Configures whether [checkout sessions](https://stripe.com/docs/api/checkout/sessions) created by this payment link create a [Customer](https://stripe.com/docs/api/customers).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param on_behalf_of [String?] The account on behalf of which to charge.
    # @optional @param payment_intent_data [Stripe::PaymentIntentDataParams1?]
    # @optional @param payment_method_collection [String?] Specify whether Checkout should collect a payment method. When set to `if_required`, Checkout will not collect a payment method when the total due for the session is 0.This may occur if the Checkout Session includes a free trial or a discount.  Can only be set in `subscription` mode.  If you'd like information on how to collect a payment method outside of Checkout, read the guide on [configuring subscriptions with a free trial](https://stripe.com/docs/payments/checkout/free-trials).
    # @optional @param payment_method_types [Array(String)?] The list of payment method types that customers can use. If no value is passed, Stripe will dynamically show relevant payment methods from your [payment method settings](https://dashboard.stripe.com/settings/payment_methods) (20+ payment methods [supported](https://stripe.com/docs/payments/payment-methods/integration-options#payment-method-product-support)).
    # @optional @param phone_number_collection [Stripe::PhoneNumberCollectionParams1?]
    # @optional @param shipping_address_collection [Stripe::ShippingAddressCollectionParams1?]
    # @optional @param shipping_options [Array(Stripe::ShippingOptionParams1)?] The shipping rate options to apply to [checkout sessions](https://stripe.com/docs/api/checkout/sessions) created by this payment link.
    # @optional @param submit_type [String?] Describes the type of transaction being performed in order to customize relevant text on the page, such as the submit button. Changing this value will also affect the hostname in the [url](https://stripe.com/docs/api/payment_links/payment_links/object#url) property (example: `donate.stripe.com`).
    # @optional @param subscription_data [Stripe::SubscriptionDataParams1?]
    # @optional @param tax_id_collection [Stripe::TaxIdCollectionParams1?]
    # @optional @param transfer_data [Stripe::TransferDataParams1?]
    # @return nil
    def post_payment_links(*, line_items : Array(Stripe::LineItemsCreateParams)? = nil, after_completion : Stripe::AfterCompletionParams? = nil, allow_promotion_codes : Bool? = nil, application_fee_amount : Int64? = nil, application_fee_percent : Float64? = nil, automatic_tax : Stripe::AutomaticTaxParams1? = nil, billing_address_collection : String? = nil, consent_collection : Stripe::ConsentCollectionParams1? = nil, currency : String? = nil, customer_creation : String? = nil, expand : Array(String)? = nil, on_behalf_of : String? = nil, payment_intent_data : Stripe::PaymentIntentDataParams1? = nil, payment_method_collection : String? = nil, payment_method_types : Array(String)? = nil, phone_number_collection : Stripe::PhoneNumberCollectionParams1? = nil, shipping_address_collection : Stripe::ShippingAddressCollectionParams1? = nil, shipping_options : Array(Stripe::ShippingOptionParams1)? = nil, submit_type : String? = nil, subscription_data : Stripe::SubscriptionDataParams1? = nil, tax_id_collection : Stripe::TaxIdCollectionParams1? = nil, transfer_data : Stripe::TransferDataParams1? = nil, &block : Crest::Response ->)
      build_api_request_for_post_payment_links(line_items: line_items, after_completion: after_completion, allow_promotion_codes: allow_promotion_codes, application_fee_amount: application_fee_amount, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, billing_address_collection: billing_address_collection, consent_collection: consent_collection, currency: currency, customer_creation: customer_creation, expand: expand, on_behalf_of: on_behalf_of, payment_intent_data: payment_intent_data, payment_method_collection: payment_method_collection, payment_method_types: payment_method_types, phone_number_collection: phone_number_collection, shipping_address_collection: shipping_address_collection, shipping_options: shipping_options, submit_type: submit_type, subscription_data: subscription_data, tax_id_collection: tax_id_collection, transfer_data: transfer_data).execute(&block)
    end

    POST_PAYMENT_LINKS_VALID_VALUES_FOR_BILLING_ADDRESS_COLLECTION = StaticArray["auto", "required"]
    POST_PAYMENT_LINKS_VALID_VALUES_FOR_CUSTOMER_CREATION          = StaticArray["always", "if_required"]
    POST_PAYMENT_LINKS_VALID_VALUES_FOR_PAYMENT_METHOD_COLLECTION  = StaticArray["always", "if_required"]
    POST_PAYMENT_LINKS_VALID_VALUES_FOR_PAYMENT_METHOD_TYPES       = StaticArray["affirm", "afterpay_clearpay", "alipay", "au_becs_debit", "bacs_debit", "bancontact", "blik", "boleto", "card", "eps", "fpx", "giropay", "grabpay", "ideal", "klarna", "konbini", "oxxo", "p24", "paynow", "pix", "promptpay", "sepa_debit", "sofort", "us_bank_account", "wechat_pay"]
    POST_PAYMENT_LINKS_VALID_VALUES_FOR_SUBMIT_TYPE                = StaticArray["auto", "book", "donate", "pay"]

    # @return Crest::Request
    def build_api_request_for_post_payment_links(*, line_items : Array(Stripe::LineItemsCreateParams)? = nil, after_completion : Stripe::AfterCompletionParams? = nil, allow_promotion_codes : Bool? = nil, application_fee_amount : Int64? = nil, application_fee_percent : Float64? = nil, automatic_tax : Stripe::AutomaticTaxParams1? = nil, billing_address_collection : String? = nil, consent_collection : Stripe::ConsentCollectionParams1? = nil, currency : String? = nil, customer_creation : String? = nil, expand : Array(String)? = nil, on_behalf_of : String? = nil, payment_intent_data : Stripe::PaymentIntentDataParams1? = nil, payment_method_collection : String? = nil, payment_method_types : Array(String)? = nil, phone_number_collection : Stripe::PhoneNumberCollectionParams1? = nil, shipping_address_collection : Stripe::ShippingAddressCollectionParams1? = nil, shipping_options : Array(Stripe::ShippingOptionParams1)? = nil, submit_type : String? = nil, subscription_data : Stripe::SubscriptionDataParams1? = nil, tax_id_collection : Stripe::TaxIdCollectionParams1? = nil, transfer_data : Stripe::TransferDataParams1? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_payment_links ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"line_items\" is required and cannot be null") if line_items.nil?
        if _line_items = line_items
          OpenApi::ContainerValidator.validate(container: _line_items) if _line_items.is_a?(Array)
        end
        if _after_completion = after_completion
          _after_completion.validate if _after_completion.is_a?(OpenApi::Validatable)
        end

        if _automatic_tax = automatic_tax
          _automatic_tax.validate if _automatic_tax.is_a?(OpenApi::Validatable)
        end
        if _billing_address_collection = billing_address_collection
          OpenApi::EnumValidator.validate("billing_address_collection", _billing_address_collection, POST_PAYMENT_LINKS_VALID_VALUES_FOR_BILLING_ADDRESS_COLLECTION)
        end
        if _consent_collection = consent_collection
          _consent_collection.validate if _consent_collection.is_a?(OpenApi::Validatable)
        end

        if _customer_creation = customer_creation
          OpenApi::EnumValidator.validate("customer_creation", _customer_creation, POST_PAYMENT_LINKS_VALID_VALUES_FOR_CUSTOMER_CREATION)
        end

        if _payment_intent_data = payment_intent_data
          _payment_intent_data.validate if _payment_intent_data.is_a?(OpenApi::Validatable)
        end
        if _payment_method_collection = payment_method_collection
          OpenApi::EnumValidator.validate("payment_method_collection", _payment_method_collection, POST_PAYMENT_LINKS_VALID_VALUES_FOR_PAYMENT_METHOD_COLLECTION)
        end
        if _payment_method_types = payment_method_types
          OpenApi::EnumValidator.validate("payment_method_types", _payment_method_types, POST_PAYMENT_LINKS_VALID_VALUES_FOR_PAYMENT_METHOD_TYPES)
        end
        if _phone_number_collection = phone_number_collection
          _phone_number_collection.validate if _phone_number_collection.is_a?(OpenApi::Validatable)
        end
        if _shipping_address_collection = shipping_address_collection
          _shipping_address_collection.validate if _shipping_address_collection.is_a?(OpenApi::Validatable)
        end
        if _shipping_options = shipping_options
          OpenApi::ContainerValidator.validate(container: _shipping_options) if _shipping_options.is_a?(Array)
        end
        if _submit_type = submit_type
          OpenApi::EnumValidator.validate("submit_type", _submit_type, POST_PAYMENT_LINKS_VALID_VALUES_FOR_SUBMIT_TYPE)
        end
        if _subscription_data = subscription_data
          _subscription_data.validate if _subscription_data.is_a?(OpenApi::Validatable)
        end
        if _tax_id_collection = tax_id_collection
          _tax_id_collection.validate if _tax_id_collection.is_a?(OpenApi::Validatable)
        end
        if _transfer_data = transfer_data
          _transfer_data.validate if _transfer_data.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/payment_links"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["after_completion"] = after_completion.to_s if !after_completion.nil?
      form_params["allow_promotion_codes"] = allow_promotion_codes.to_s if !allow_promotion_codes.nil?
      form_params["application_fee_amount"] = application_fee_amount.to_s if !application_fee_amount.nil?
      form_params["application_fee_percent"] = application_fee_percent.to_s if !application_fee_percent.nil?
      form_params["automatic_tax"] = automatic_tax.to_s if !automatic_tax.nil?
      form_params["billing_address_collection"] = billing_address_collection.to_s if !billing_address_collection.nil?
      form_params["consent_collection"] = consent_collection.to_s if !consent_collection.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["customer_creation"] = customer_creation.to_s if !customer_creation.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["line_items"] = @api_client.build_collection_param(line_items, "csv") if !line_items.nil? && !line_items.empty?
      form_params["on_behalf_of"] = on_behalf_of.to_s if !on_behalf_of.nil?
      form_params["payment_intent_data"] = payment_intent_data.to_s if !payment_intent_data.nil?
      form_params["payment_method_collection"] = payment_method_collection.to_s if !payment_method_collection.nil?
      form_params["payment_method_types"] = @api_client.build_collection_param(payment_method_types, "csv") if !payment_method_types.nil? && !payment_method_types.empty?
      form_params["phone_number_collection"] = phone_number_collection.to_s if !phone_number_collection.nil?
      form_params["shipping_address_collection"] = shipping_address_collection.to_s if !shipping_address_collection.nil?
      form_params["shipping_options"] = @api_client.build_collection_param(shipping_options, "csv") if !shipping_options.nil? && !shipping_options.empty?
      form_params["submit_type"] = submit_type.to_s if !submit_type.nil?
      form_params["subscription_data"] = subscription_data.to_s if !subscription_data.nil?
      form_params["tax_id_collection"] = tax_id_collection.to_s if !tax_id_collection.nil?
      form_params["transfer_data"] = transfer_data.to_s if !transfer_data.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_payment_links",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates a payment link.</p>
    # @param payment_link [String?]
    # @optional @param active [Bool?] Whether the payment link's `url` is active. If `false`, customers visiting the URL will be shown a page saying that the link has been deactivated.
    # @optional @param after_completion [Stripe::AfterCompletionParams?]
    # @optional @param allow_promotion_codes [Bool?] Enables user redeemable promotion codes.
    # @optional @param automatic_tax [Stripe::AutomaticTaxParams1?]
    # @optional @param billing_address_collection [String?] Configuration for collecting the customer's billing address.
    # @optional @param customer_creation [String?] Configures whether [checkout sessions](https://stripe.com/docs/api/checkout/sessions) created by this payment link create a [Customer](https://stripe.com/docs/api/customers).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param line_items [Array(Stripe::LineItemsUpdateParams)?] The line items representing what is being sold. Each line item represents an item being sold. Up to 20 line items are supported.
    # @optional @param payment_method_collection [String?] Specify whether Checkout should collect a payment method. When set to `if_required`, Checkout will not collect a payment method when the total due for the session is 0.This may occur if the Checkout Session includes a free trial or a discount.  Can only be set in `subscription` mode.  If you'd like information on how to collect a payment method outside of Checkout, read the guide on [configuring subscriptions with a free trial](https://stripe.com/docs/payments/checkout/free-trials).
    # @optional @param payment_method_types [Stripe::PostPaymentLinksPaymentLinkRequestPaymentMethodTypes?]
    # @optional @param shipping_address_collection [Stripe::PostPaymentLinksPaymentLinkRequestShippingAddressCollection?]
    # @return [PaymentLink]
    def post_payment_links_payment_link(*, payment_link : String? = nil, active : Bool? = nil, after_completion : Stripe::AfterCompletionParams? = nil, allow_promotion_codes : Bool? = nil, automatic_tax : Stripe::AutomaticTaxParams1? = nil, billing_address_collection : String? = nil, customer_creation : String? = nil, expand : Array(String)? = nil, line_items : Array(Stripe::LineItemsUpdateParams)? = nil, payment_method_collection : String? = nil, payment_method_types : Stripe::PostPaymentLinksPaymentLinkRequestPaymentMethodTypes? = nil, shipping_address_collection : Stripe::PostPaymentLinksPaymentLinkRequestShippingAddressCollection? = nil)
      data, _status_code, _headers = post_payment_links_payment_link_with_http_info(payment_link: payment_link, active: active, after_completion: after_completion, allow_promotion_codes: allow_promotion_codes, automatic_tax: automatic_tax, billing_address_collection: billing_address_collection, customer_creation: customer_creation, expand: expand, line_items: line_items, payment_method_collection: payment_method_collection, payment_method_types: payment_method_types, shipping_address_collection: shipping_address_collection)
      data
    end

    # &lt;p&gt;Updates a payment link.&lt;/p&gt;
    # @param payment_link [String?]
    # @optional @param active [Bool?] Whether the payment link's `url` is active. If `false`, customers visiting the URL will be shown a page saying that the link has been deactivated.
    # @optional @param after_completion [Stripe::AfterCompletionParams?]
    # @optional @param allow_promotion_codes [Bool?] Enables user redeemable promotion codes.
    # @optional @param automatic_tax [Stripe::AutomaticTaxParams1?]
    # @optional @param billing_address_collection [String?] Configuration for collecting the customer's billing address.
    # @optional @param customer_creation [String?] Configures whether [checkout sessions](https://stripe.com/docs/api/checkout/sessions) created by this payment link create a [Customer](https://stripe.com/docs/api/customers).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param line_items [Array(Stripe::LineItemsUpdateParams)?] The line items representing what is being sold. Each line item represents an item being sold. Up to 20 line items are supported.
    # @optional @param payment_method_collection [String?] Specify whether Checkout should collect a payment method. When set to `if_required`, Checkout will not collect a payment method when the total due for the session is 0.This may occur if the Checkout Session includes a free trial or a discount.  Can only be set in `subscription` mode.  If you'd like information on how to collect a payment method outside of Checkout, read the guide on [configuring subscriptions with a free trial](https://stripe.com/docs/payments/checkout/free-trials).
    # @optional @param payment_method_types [Stripe::PostPaymentLinksPaymentLinkRequestPaymentMethodTypes?]
    # @optional @param shipping_address_collection [Stripe::PostPaymentLinksPaymentLinkRequestShippingAddressCollection?]
    # @return [Array<(PaymentLink, Integer, Hash)>] PaymentLink data, response status code and response headers
    def post_payment_links_payment_link_with_http_info(*, payment_link : String? = nil, active : Bool? = nil, after_completion : Stripe::AfterCompletionParams? = nil, allow_promotion_codes : Bool? = nil, automatic_tax : Stripe::AutomaticTaxParams1? = nil, billing_address_collection : String? = nil, customer_creation : String? = nil, expand : Array(String)? = nil, line_items : Array(Stripe::LineItemsUpdateParams)? = nil, payment_method_collection : String? = nil, payment_method_types : Stripe::PostPaymentLinksPaymentLinkRequestPaymentMethodTypes? = nil, shipping_address_collection : Stripe::PostPaymentLinksPaymentLinkRequestShippingAddressCollection? = nil)
      request = build_api_request_for_post_payment_links_payment_link(payment_link: payment_link, active: active, after_completion: after_completion, allow_promotion_codes: allow_promotion_codes, automatic_tax: automatic_tax, billing_address_collection: billing_address_collection, customer_creation: customer_creation, expand: expand, line_items: line_items, payment_method_collection: payment_method_collection, payment_method_types: payment_method_types, shipping_address_collection: shipping_address_collection)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_payment_links_payment_link\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentLink.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates a payment link.&lt;/p&gt;
    # @param payment_link [String?]
    # @optional @param active [Bool?] Whether the payment link's `url` is active. If `false`, customers visiting the URL will be shown a page saying that the link has been deactivated.
    # @optional @param after_completion [Stripe::AfterCompletionParams?]
    # @optional @param allow_promotion_codes [Bool?] Enables user redeemable promotion codes.
    # @optional @param automatic_tax [Stripe::AutomaticTaxParams1?]
    # @optional @param billing_address_collection [String?] Configuration for collecting the customer's billing address.
    # @optional @param customer_creation [String?] Configures whether [checkout sessions](https://stripe.com/docs/api/checkout/sessions) created by this payment link create a [Customer](https://stripe.com/docs/api/customers).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param line_items [Array(Stripe::LineItemsUpdateParams)?] The line items representing what is being sold. Each line item represents an item being sold. Up to 20 line items are supported.
    # @optional @param payment_method_collection [String?] Specify whether Checkout should collect a payment method. When set to `if_required`, Checkout will not collect a payment method when the total due for the session is 0.This may occur if the Checkout Session includes a free trial or a discount.  Can only be set in `subscription` mode.  If you'd like information on how to collect a payment method outside of Checkout, read the guide on [configuring subscriptions with a free trial](https://stripe.com/docs/payments/checkout/free-trials).
    # @optional @param payment_method_types [Stripe::PostPaymentLinksPaymentLinkRequestPaymentMethodTypes?]
    # @optional @param shipping_address_collection [Stripe::PostPaymentLinksPaymentLinkRequestShippingAddressCollection?]
    # @return nil
    def post_payment_links_payment_link(*, payment_link : String? = nil, active : Bool? = nil, after_completion : Stripe::AfterCompletionParams? = nil, allow_promotion_codes : Bool? = nil, automatic_tax : Stripe::AutomaticTaxParams1? = nil, billing_address_collection : String? = nil, customer_creation : String? = nil, expand : Array(String)? = nil, line_items : Array(Stripe::LineItemsUpdateParams)? = nil, payment_method_collection : String? = nil, payment_method_types : Stripe::PostPaymentLinksPaymentLinkRequestPaymentMethodTypes? = nil, shipping_address_collection : Stripe::PostPaymentLinksPaymentLinkRequestShippingAddressCollection? = nil, &block : Crest::Response ->)
      build_api_request_for_post_payment_links_payment_link(payment_link: payment_link, active: active, after_completion: after_completion, allow_promotion_codes: allow_promotion_codes, automatic_tax: automatic_tax, billing_address_collection: billing_address_collection, customer_creation: customer_creation, expand: expand, line_items: line_items, payment_method_collection: payment_method_collection, payment_method_types: payment_method_types, shipping_address_collection: shipping_address_collection).execute(&block)
    end

    POST_PAYMENT_LINKS_PAYMENT_LINK_MAX_LENGTH_FOR_PAYMENT_LINK                 = 5000
    POST_PAYMENT_LINKS_PAYMENT_LINK_VALID_VALUES_FOR_BILLING_ADDRESS_COLLECTION = StaticArray["auto", "required"]
    POST_PAYMENT_LINKS_PAYMENT_LINK_VALID_VALUES_FOR_CUSTOMER_CREATION          = StaticArray["always", "if_required"]
    POST_PAYMENT_LINKS_PAYMENT_LINK_VALID_VALUES_FOR_PAYMENT_METHOD_COLLECTION  = StaticArray["always", "if_required"]

    # @return Crest::Request
    def build_api_request_for_post_payment_links_payment_link(*, payment_link : String? = nil, active : Bool? = nil, after_completion : Stripe::AfterCompletionParams? = nil, allow_promotion_codes : Bool? = nil, automatic_tax : Stripe::AutomaticTaxParams1? = nil, billing_address_collection : String? = nil, customer_creation : String? = nil, expand : Array(String)? = nil, line_items : Array(Stripe::LineItemsUpdateParams)? = nil, payment_method_collection : String? = nil, payment_method_types : Stripe::PostPaymentLinksPaymentLinkRequestPaymentMethodTypes? = nil, shipping_address_collection : Stripe::PostPaymentLinksPaymentLinkRequestShippingAddressCollection? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_payment_links_payment_link ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"payment_link\" is required and cannot be null") if payment_link.nil?
        if _payment_link = payment_link
          OpenApi::PrimitiveValidator.validate_max_length("payment_link", payment_link.to_s.size, POST_PAYMENT_LINKS_PAYMENT_LINK_MAX_LENGTH_FOR_PAYMENT_LINK)
        end

        if _after_completion = after_completion
          _after_completion.validate if _after_completion.is_a?(OpenApi::Validatable)
        end

        if _automatic_tax = automatic_tax
          _automatic_tax.validate if _automatic_tax.is_a?(OpenApi::Validatable)
        end
        if _billing_address_collection = billing_address_collection
          OpenApi::EnumValidator.validate("billing_address_collection", _billing_address_collection, POST_PAYMENT_LINKS_PAYMENT_LINK_VALID_VALUES_FOR_BILLING_ADDRESS_COLLECTION)
        end
        if _customer_creation = customer_creation
          OpenApi::EnumValidator.validate("customer_creation", _customer_creation, POST_PAYMENT_LINKS_PAYMENT_LINK_VALID_VALUES_FOR_CUSTOMER_CREATION)
        end

        if _line_items = line_items
          OpenApi::ContainerValidator.validate(container: _line_items) if _line_items.is_a?(Array)
        end
        if _payment_method_collection = payment_method_collection
          OpenApi::EnumValidator.validate("payment_method_collection", _payment_method_collection, POST_PAYMENT_LINKS_PAYMENT_LINK_VALID_VALUES_FOR_PAYMENT_METHOD_COLLECTION)
        end
        if _payment_method_types = payment_method_types
          _payment_method_types.validate if _payment_method_types.is_a?(OpenApi::Validatable)
        end
        if _shipping_address_collection = shipping_address_collection
          _shipping_address_collection.validate if _shipping_address_collection.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/payment_links/{payment_link}".sub("{" + "payment_link" + "}", URI.encode_path(payment_link.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["active"] = active.to_s if !active.nil?
      form_params["after_completion"] = after_completion.to_s if !after_completion.nil?
      form_params["allow_promotion_codes"] = allow_promotion_codes.to_s if !allow_promotion_codes.nil?
      form_params["automatic_tax"] = automatic_tax.to_s if !automatic_tax.nil?
      form_params["billing_address_collection"] = billing_address_collection.to_s if !billing_address_collection.nil?
      form_params["customer_creation"] = customer_creation.to_s if !customer_creation.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["line_items"] = @api_client.build_collection_param(line_items, "csv") if !line_items.nil? && !line_items.empty?
      form_params["payment_method_collection"] = payment_method_collection.to_s if !payment_method_collection.nil?
      form_params["payment_method_types"] = payment_method_types.to_s if !payment_method_types.nil?
      form_params["shipping_address_collection"] = shipping_address_collection.to_s if !shipping_address_collection.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_payment_links_payment_link",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a PaymentMethod object. Read the <a href=\"/docs/stripe-js/reference#stripe-create-payment-method\">Stripe.js reference</a> to learn how to create PaymentMethods via Stripe.js.</p>  <p>Instead of creating a PaymentMethod directly, we recommend using the <a href=\"/docs/payments/accept-a-payment\">PaymentIntents</a> API to accept a payment immediately or the <a href=\"/docs/payments/save-and-reuse\">SetupIntent</a> API to collect payment method details ahead of a future payment.</p>
    # @optional @param acss_debit [Stripe::PaymentMethodParam2?]
    # @optional @param affirm [JSON::Any?] If this is an `affirm` PaymentMethod, this hash contains details about the Affirm payment method.
    # @optional @param afterpay_clearpay [JSON::Any?] If this is an `AfterpayClearpay` PaymentMethod, this hash contains details about the AfterpayClearpay payment method.
    # @optional @param alipay [JSON::Any?] If this is an `Alipay` PaymentMethod, this hash contains details about the Alipay payment method.
    # @optional @param au_becs_debit [Stripe::Param10?]
    # @optional @param bacs_debit [Stripe::Param11?]
    # @optional @param bancontact [JSON::Any?] If this is a `bancontact` PaymentMethod, this hash contains details about the Bancontact payment method.
    # @optional @param billing_details [Stripe::BillingDetailsInnerParams1?]
    # @optional @param blik [JSON::Any?] If this is a `blik` PaymentMethod, this hash contains details about the BLIK payment method.
    # @optional @param boleto [Stripe::Param12?]
    # @optional @param card [Stripe::PostPaymentMethodsRequestCard?]
    # @optional @param customer [String?] The `Customer` to whom the original PaymentMethod is attached.
    # @optional @param customer_balance [JSON::Any?] If this is a `customer_balance` PaymentMethod, this hash contains details about the CustomerBalance payment method.
    # @optional @param eps [Stripe::Param13?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param fpx [Stripe::Param14?]
    # @optional @param giropay [JSON::Any?] If this is a `giropay` PaymentMethod, this hash contains details about the Giropay payment method.
    # @optional @param grabpay [JSON::Any?] If this is a `grabpay` PaymentMethod, this hash contains details about the GrabPay payment method.
    # @optional @param ideal [Stripe::Param15?]
    # @optional @param interac_present [JSON::Any?] If this is an `interac_present` PaymentMethod, this hash contains details about the Interac Present payment method.
    # @optional @param klarna [Stripe::Param16?]
    # @optional @param konbini [JSON::Any?] If this is a `konbini` PaymentMethod, this hash contains details about the Konbini payment method.
    # @optional @param link [JSON::Any?] If this is an `Link` PaymentMethod, this hash contains details about the Link payment method.
    # @optional @param oxxo [JSON::Any?] If this is an `oxxo` PaymentMethod, this hash contains details about the OXXO payment method.
    # @optional @param p24 [Stripe::Param17?]
    # @optional @param payment_method [String?] The PaymentMethod to share.
    # @optional @param paynow [JSON::Any?] If this is a `paynow` PaymentMethod, this hash contains details about the PayNow payment method.
    # @optional @param pix [JSON::Any?] If this is a `pix` PaymentMethod, this hash contains details about the Pix payment method.
    # @optional @param promptpay [JSON::Any?] If this is a `promptpay` PaymentMethod, this hash contains details about the PromptPay payment method.
    # @optional @param radar_options [Stripe::RadarOptions?]
    # @optional @param sepa_debit [Stripe::Param18?]
    # @optional @param sofort [Stripe::Param19?]
    # @optional @param _type [String?] The type of the PaymentMethod. An additional hash is included on the PaymentMethod with a name matching this value. It contains additional information specific to the PaymentMethod type.
    # @optional @param us_bank_account [Stripe::PaymentMethodParam3?]
    # @optional @param wechat_pay [JSON::Any?] If this is an `wechat_pay` PaymentMethod, this hash contains details about the wechat_pay payment method.
    # @return [PaymentMethod]
    def post_payment_methods(*, acss_debit : Stripe::PaymentMethodParam2? = nil, affirm : JSON::Any? = nil, afterpay_clearpay : JSON::Any? = nil, alipay : JSON::Any? = nil, au_becs_debit : Stripe::Param10? = nil, bacs_debit : Stripe::Param11? = nil, bancontact : JSON::Any? = nil, billing_details : Stripe::BillingDetailsInnerParams1? = nil, blik : JSON::Any? = nil, boleto : Stripe::Param12? = nil, card : Stripe::PostPaymentMethodsRequestCard? = nil, customer : String? = nil, customer_balance : JSON::Any? = nil, eps : Stripe::Param13? = nil, expand : Array(String)? = nil, fpx : Stripe::Param14? = nil, giropay : JSON::Any? = nil, grabpay : JSON::Any? = nil, ideal : Stripe::Param15? = nil, interac_present : JSON::Any? = nil, klarna : Stripe::Param16? = nil, konbini : JSON::Any? = nil, link : JSON::Any? = nil, oxxo : JSON::Any? = nil, p24 : Stripe::Param17? = nil, payment_method : String? = nil, paynow : JSON::Any? = nil, pix : JSON::Any? = nil, promptpay : JSON::Any? = nil, radar_options : Stripe::RadarOptions? = nil, sepa_debit : Stripe::Param18? = nil, sofort : Stripe::Param19? = nil, _type : String? = nil, us_bank_account : Stripe::PaymentMethodParam3? = nil, wechat_pay : JSON::Any? = nil)
      data, _status_code, _headers = post_payment_methods_with_http_info(acss_debit: acss_debit, affirm: affirm, afterpay_clearpay: afterpay_clearpay, alipay: alipay, au_becs_debit: au_becs_debit, bacs_debit: bacs_debit, bancontact: bancontact, billing_details: billing_details, blik: blik, boleto: boleto, card: card, customer: customer, customer_balance: customer_balance, eps: eps, expand: expand, fpx: fpx, giropay: giropay, grabpay: grabpay, ideal: ideal, interac_present: interac_present, klarna: klarna, konbini: konbini, link: link, oxxo: oxxo, p24: p24, payment_method: payment_method, paynow: paynow, pix: pix, promptpay: promptpay, radar_options: radar_options, sepa_debit: sepa_debit, sofort: sofort, _type: _type, us_bank_account: us_bank_account, wechat_pay: wechat_pay)
      data
    end

    # &lt;p&gt;Creates a PaymentMethod object. Read the &lt;a href&#x3D;\&quot;/docs/stripe-js/reference#stripe-create-payment-method\&quot;&gt;Stripe.js reference&lt;/a&gt; to learn how to create PaymentMethods via Stripe.js.&lt;/p&gt;  &lt;p&gt;Instead of creating a PaymentMethod directly, we recommend using the &lt;a href&#x3D;\&quot;/docs/payments/accept-a-payment\&quot;&gt;PaymentIntents&lt;/a&gt; API to accept a payment immediately or the &lt;a href&#x3D;\&quot;/docs/payments/save-and-reuse\&quot;&gt;SetupIntent&lt;/a&gt; API to collect payment method details ahead of a future payment.&lt;/p&gt;
    # @optional @param acss_debit [Stripe::PaymentMethodParam2?]
    # @optional @param affirm [JSON::Any?] If this is an `affirm` PaymentMethod, this hash contains details about the Affirm payment method.
    # @optional @param afterpay_clearpay [JSON::Any?] If this is an `AfterpayClearpay` PaymentMethod, this hash contains details about the AfterpayClearpay payment method.
    # @optional @param alipay [JSON::Any?] If this is an `Alipay` PaymentMethod, this hash contains details about the Alipay payment method.
    # @optional @param au_becs_debit [Stripe::Param10?]
    # @optional @param bacs_debit [Stripe::Param11?]
    # @optional @param bancontact [JSON::Any?] If this is a `bancontact` PaymentMethod, this hash contains details about the Bancontact payment method.
    # @optional @param billing_details [Stripe::BillingDetailsInnerParams1?]
    # @optional @param blik [JSON::Any?] If this is a `blik` PaymentMethod, this hash contains details about the BLIK payment method.
    # @optional @param boleto [Stripe::Param12?]
    # @optional @param card [Stripe::PostPaymentMethodsRequestCard?]
    # @optional @param customer [String?] The `Customer` to whom the original PaymentMethod is attached.
    # @optional @param customer_balance [JSON::Any?] If this is a `customer_balance` PaymentMethod, this hash contains details about the CustomerBalance payment method.
    # @optional @param eps [Stripe::Param13?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param fpx [Stripe::Param14?]
    # @optional @param giropay [JSON::Any?] If this is a `giropay` PaymentMethod, this hash contains details about the Giropay payment method.
    # @optional @param grabpay [JSON::Any?] If this is a `grabpay` PaymentMethod, this hash contains details about the GrabPay payment method.
    # @optional @param ideal [Stripe::Param15?]
    # @optional @param interac_present [JSON::Any?] If this is an `interac_present` PaymentMethod, this hash contains details about the Interac Present payment method.
    # @optional @param klarna [Stripe::Param16?]
    # @optional @param konbini [JSON::Any?] If this is a `konbini` PaymentMethod, this hash contains details about the Konbini payment method.
    # @optional @param link [JSON::Any?] If this is an `Link` PaymentMethod, this hash contains details about the Link payment method.
    # @optional @param oxxo [JSON::Any?] If this is an `oxxo` PaymentMethod, this hash contains details about the OXXO payment method.
    # @optional @param p24 [Stripe::Param17?]
    # @optional @param payment_method [String?] The PaymentMethod to share.
    # @optional @param paynow [JSON::Any?] If this is a `paynow` PaymentMethod, this hash contains details about the PayNow payment method.
    # @optional @param pix [JSON::Any?] If this is a `pix` PaymentMethod, this hash contains details about the Pix payment method.
    # @optional @param promptpay [JSON::Any?] If this is a `promptpay` PaymentMethod, this hash contains details about the PromptPay payment method.
    # @optional @param radar_options [Stripe::RadarOptions?]
    # @optional @param sepa_debit [Stripe::Param18?]
    # @optional @param sofort [Stripe::Param19?]
    # @optional @param _type [String?] The type of the PaymentMethod. An additional hash is included on the PaymentMethod with a name matching this value. It contains additional information specific to the PaymentMethod type.
    # @optional @param us_bank_account [Stripe::PaymentMethodParam3?]
    # @optional @param wechat_pay [JSON::Any?] If this is an `wechat_pay` PaymentMethod, this hash contains details about the wechat_pay payment method.
    # @return [Array<(PaymentMethod, Integer, Hash)>] PaymentMethod data, response status code and response headers
    def post_payment_methods_with_http_info(*, acss_debit : Stripe::PaymentMethodParam2? = nil, affirm : JSON::Any? = nil, afterpay_clearpay : JSON::Any? = nil, alipay : JSON::Any? = nil, au_becs_debit : Stripe::Param10? = nil, bacs_debit : Stripe::Param11? = nil, bancontact : JSON::Any? = nil, billing_details : Stripe::BillingDetailsInnerParams1? = nil, blik : JSON::Any? = nil, boleto : Stripe::Param12? = nil, card : Stripe::PostPaymentMethodsRequestCard? = nil, customer : String? = nil, customer_balance : JSON::Any? = nil, eps : Stripe::Param13? = nil, expand : Array(String)? = nil, fpx : Stripe::Param14? = nil, giropay : JSON::Any? = nil, grabpay : JSON::Any? = nil, ideal : Stripe::Param15? = nil, interac_present : JSON::Any? = nil, klarna : Stripe::Param16? = nil, konbini : JSON::Any? = nil, link : JSON::Any? = nil, oxxo : JSON::Any? = nil, p24 : Stripe::Param17? = nil, payment_method : String? = nil, paynow : JSON::Any? = nil, pix : JSON::Any? = nil, promptpay : JSON::Any? = nil, radar_options : Stripe::RadarOptions? = nil, sepa_debit : Stripe::Param18? = nil, sofort : Stripe::Param19? = nil, _type : String? = nil, us_bank_account : Stripe::PaymentMethodParam3? = nil, wechat_pay : JSON::Any? = nil)
      request = build_api_request_for_post_payment_methods(acss_debit: acss_debit, affirm: affirm, afterpay_clearpay: afterpay_clearpay, alipay: alipay, au_becs_debit: au_becs_debit, bacs_debit: bacs_debit, bancontact: bancontact, billing_details: billing_details, blik: blik, boleto: boleto, card: card, customer: customer, customer_balance: customer_balance, eps: eps, expand: expand, fpx: fpx, giropay: giropay, grabpay: grabpay, ideal: ideal, interac_present: interac_present, klarna: klarna, konbini: konbini, link: link, oxxo: oxxo, p24: p24, payment_method: payment_method, paynow: paynow, pix: pix, promptpay: promptpay, radar_options: radar_options, sepa_debit: sepa_debit, sofort: sofort, _type: _type, us_bank_account: us_bank_account, wechat_pay: wechat_pay)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_payment_methods\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentMethod.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a PaymentMethod object. Read the &lt;a href&#x3D;\&quot;/docs/stripe-js/reference#stripe-create-payment-method\&quot;&gt;Stripe.js reference&lt;/a&gt; to learn how to create PaymentMethods via Stripe.js.&lt;/p&gt;  &lt;p&gt;Instead of creating a PaymentMethod directly, we recommend using the &lt;a href&#x3D;\&quot;/docs/payments/accept-a-payment\&quot;&gt;PaymentIntents&lt;/a&gt; API to accept a payment immediately or the &lt;a href&#x3D;\&quot;/docs/payments/save-and-reuse\&quot;&gt;SetupIntent&lt;/a&gt; API to collect payment method details ahead of a future payment.&lt;/p&gt;
    # @optional @param acss_debit [Stripe::PaymentMethodParam2?]
    # @optional @param affirm [JSON::Any?] If this is an `affirm` PaymentMethod, this hash contains details about the Affirm payment method.
    # @optional @param afterpay_clearpay [JSON::Any?] If this is an `AfterpayClearpay` PaymentMethod, this hash contains details about the AfterpayClearpay payment method.
    # @optional @param alipay [JSON::Any?] If this is an `Alipay` PaymentMethod, this hash contains details about the Alipay payment method.
    # @optional @param au_becs_debit [Stripe::Param10?]
    # @optional @param bacs_debit [Stripe::Param11?]
    # @optional @param bancontact [JSON::Any?] If this is a `bancontact` PaymentMethod, this hash contains details about the Bancontact payment method.
    # @optional @param billing_details [Stripe::BillingDetailsInnerParams1?]
    # @optional @param blik [JSON::Any?] If this is a `blik` PaymentMethod, this hash contains details about the BLIK payment method.
    # @optional @param boleto [Stripe::Param12?]
    # @optional @param card [Stripe::PostPaymentMethodsRequestCard?]
    # @optional @param customer [String?] The `Customer` to whom the original PaymentMethod is attached.
    # @optional @param customer_balance [JSON::Any?] If this is a `customer_balance` PaymentMethod, this hash contains details about the CustomerBalance payment method.
    # @optional @param eps [Stripe::Param13?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param fpx [Stripe::Param14?]
    # @optional @param giropay [JSON::Any?] If this is a `giropay` PaymentMethod, this hash contains details about the Giropay payment method.
    # @optional @param grabpay [JSON::Any?] If this is a `grabpay` PaymentMethod, this hash contains details about the GrabPay payment method.
    # @optional @param ideal [Stripe::Param15?]
    # @optional @param interac_present [JSON::Any?] If this is an `interac_present` PaymentMethod, this hash contains details about the Interac Present payment method.
    # @optional @param klarna [Stripe::Param16?]
    # @optional @param konbini [JSON::Any?] If this is a `konbini` PaymentMethod, this hash contains details about the Konbini payment method.
    # @optional @param link [JSON::Any?] If this is an `Link` PaymentMethod, this hash contains details about the Link payment method.
    # @optional @param oxxo [JSON::Any?] If this is an `oxxo` PaymentMethod, this hash contains details about the OXXO payment method.
    # @optional @param p24 [Stripe::Param17?]
    # @optional @param payment_method [String?] The PaymentMethod to share.
    # @optional @param paynow [JSON::Any?] If this is a `paynow` PaymentMethod, this hash contains details about the PayNow payment method.
    # @optional @param pix [JSON::Any?] If this is a `pix` PaymentMethod, this hash contains details about the Pix payment method.
    # @optional @param promptpay [JSON::Any?] If this is a `promptpay` PaymentMethod, this hash contains details about the PromptPay payment method.
    # @optional @param radar_options [Stripe::RadarOptions?]
    # @optional @param sepa_debit [Stripe::Param18?]
    # @optional @param sofort [Stripe::Param19?]
    # @optional @param _type [String?] The type of the PaymentMethod. An additional hash is included on the PaymentMethod with a name matching this value. It contains additional information specific to the PaymentMethod type.
    # @optional @param us_bank_account [Stripe::PaymentMethodParam3?]
    # @optional @param wechat_pay [JSON::Any?] If this is an `wechat_pay` PaymentMethod, this hash contains details about the wechat_pay payment method.
    # @return nil
    def post_payment_methods(*, acss_debit : Stripe::PaymentMethodParam2? = nil, affirm : JSON::Any? = nil, afterpay_clearpay : JSON::Any? = nil, alipay : JSON::Any? = nil, au_becs_debit : Stripe::Param10? = nil, bacs_debit : Stripe::Param11? = nil, bancontact : JSON::Any? = nil, billing_details : Stripe::BillingDetailsInnerParams1? = nil, blik : JSON::Any? = nil, boleto : Stripe::Param12? = nil, card : Stripe::PostPaymentMethodsRequestCard? = nil, customer : String? = nil, customer_balance : JSON::Any? = nil, eps : Stripe::Param13? = nil, expand : Array(String)? = nil, fpx : Stripe::Param14? = nil, giropay : JSON::Any? = nil, grabpay : JSON::Any? = nil, ideal : Stripe::Param15? = nil, interac_present : JSON::Any? = nil, klarna : Stripe::Param16? = nil, konbini : JSON::Any? = nil, link : JSON::Any? = nil, oxxo : JSON::Any? = nil, p24 : Stripe::Param17? = nil, payment_method : String? = nil, paynow : JSON::Any? = nil, pix : JSON::Any? = nil, promptpay : JSON::Any? = nil, radar_options : Stripe::RadarOptions? = nil, sepa_debit : Stripe::Param18? = nil, sofort : Stripe::Param19? = nil, _type : String? = nil, us_bank_account : Stripe::PaymentMethodParam3? = nil, wechat_pay : JSON::Any? = nil, &block : Crest::Response ->)
      build_api_request_for_post_payment_methods(acss_debit: acss_debit, affirm: affirm, afterpay_clearpay: afterpay_clearpay, alipay: alipay, au_becs_debit: au_becs_debit, bacs_debit: bacs_debit, bancontact: bancontact, billing_details: billing_details, blik: blik, boleto: boleto, card: card, customer: customer, customer_balance: customer_balance, eps: eps, expand: expand, fpx: fpx, giropay: giropay, grabpay: grabpay, ideal: ideal, interac_present: interac_present, klarna: klarna, konbini: konbini, link: link, oxxo: oxxo, p24: p24, payment_method: payment_method, paynow: paynow, pix: pix, promptpay: promptpay, radar_options: radar_options, sepa_debit: sepa_debit, sofort: sofort, _type: _type, us_bank_account: us_bank_account, wechat_pay: wechat_pay).execute(&block)
    end

    POST_PAYMENT_METHODS_MAX_LENGTH_FOR_CUSTOMER       = 5000
    POST_PAYMENT_METHODS_MAX_LENGTH_FOR_PAYMENT_METHOD = 5000
    POST_PAYMENT_METHODS_VALID_VALUES_FOR__TYPE        = StaticArray["acss_debit", "affirm", "afterpay_clearpay", "alipay", "au_becs_debit", "bacs_debit", "bancontact", "blik", "boleto", "card", "customer_balance", "eps", "fpx", "giropay", "grabpay", "ideal", "klarna", "konbini", "link", "oxxo", "p24", "paynow", "pix", "promptpay", "sepa_debit", "sofort", "us_bank_account", "wechat_pay"]

    # @return Crest::Request
    def build_api_request_for_post_payment_methods(*, acss_debit : Stripe::PaymentMethodParam2? = nil, affirm : JSON::Any? = nil, afterpay_clearpay : JSON::Any? = nil, alipay : JSON::Any? = nil, au_becs_debit : Stripe::Param10? = nil, bacs_debit : Stripe::Param11? = nil, bancontact : JSON::Any? = nil, billing_details : Stripe::BillingDetailsInnerParams1? = nil, blik : JSON::Any? = nil, boleto : Stripe::Param12? = nil, card : Stripe::PostPaymentMethodsRequestCard? = nil, customer : String? = nil, customer_balance : JSON::Any? = nil, eps : Stripe::Param13? = nil, expand : Array(String)? = nil, fpx : Stripe::Param14? = nil, giropay : JSON::Any? = nil, grabpay : JSON::Any? = nil, ideal : Stripe::Param15? = nil, interac_present : JSON::Any? = nil, klarna : Stripe::Param16? = nil, konbini : JSON::Any? = nil, link : JSON::Any? = nil, oxxo : JSON::Any? = nil, p24 : Stripe::Param17? = nil, payment_method : String? = nil, paynow : JSON::Any? = nil, pix : JSON::Any? = nil, promptpay : JSON::Any? = nil, radar_options : Stripe::RadarOptions? = nil, sepa_debit : Stripe::Param18? = nil, sofort : Stripe::Param19? = nil, _type : String? = nil, us_bank_account : Stripe::PaymentMethodParam3? = nil, wechat_pay : JSON::Any? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_payment_methods ..." }
      end

      if client_side_validation
        if _acss_debit = acss_debit
          _acss_debit.validate if _acss_debit.is_a?(OpenApi::Validatable)
        end

        if _au_becs_debit = au_becs_debit
          _au_becs_debit.validate if _au_becs_debit.is_a?(OpenApi::Validatable)
        end
        if _bacs_debit = bacs_debit
          _bacs_debit.validate if _bacs_debit.is_a?(OpenApi::Validatable)
        end

        if _billing_details = billing_details
          _billing_details.validate if _billing_details.is_a?(OpenApi::Validatable)
        end

        if _boleto = boleto
          _boleto.validate if _boleto.is_a?(OpenApi::Validatable)
        end
        if _card = card
          _card.validate if _card.is_a?(OpenApi::Validatable)
        end
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_PAYMENT_METHODS_MAX_LENGTH_FOR_CUSTOMER)
        end

        if _eps = eps
          _eps.validate if _eps.is_a?(OpenApi::Validatable)
        end

        if _fpx = fpx
          _fpx.validate if _fpx.is_a?(OpenApi::Validatable)
        end

        if _ideal = ideal
          _ideal.validate if _ideal.is_a?(OpenApi::Validatable)
        end

        if _klarna = klarna
          _klarna.validate if _klarna.is_a?(OpenApi::Validatable)
        end

        if _p24 = p24
          _p24.validate if _p24.is_a?(OpenApi::Validatable)
        end
        if _payment_method = payment_method
          OpenApi::PrimitiveValidator.validate_max_length("payment_method", payment_method.to_s.size, POST_PAYMENT_METHODS_MAX_LENGTH_FOR_PAYMENT_METHOD)
        end

        if _radar_options = radar_options
          _radar_options.validate if _radar_options.is_a?(OpenApi::Validatable)
        end
        if _sepa_debit = sepa_debit
          _sepa_debit.validate if _sepa_debit.is_a?(OpenApi::Validatable)
        end
        if _sofort = sofort
          _sofort.validate if _sofort.is_a?(OpenApi::Validatable)
        end
        if __type = _type
          OpenApi::EnumValidator.validate("_type", __type, POST_PAYMENT_METHODS_VALID_VALUES_FOR__TYPE)
        end
        if _us_bank_account = us_bank_account
          _us_bank_account.validate if _us_bank_account.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/payment_methods"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["acss_debit"] = acss_debit.to_s if !acss_debit.nil?
      form_params["affirm"] = affirm.to_s if !affirm.nil?
      form_params["afterpay_clearpay"] = afterpay_clearpay.to_s if !afterpay_clearpay.nil?
      form_params["alipay"] = alipay.to_s if !alipay.nil?
      form_params["au_becs_debit"] = au_becs_debit.to_s if !au_becs_debit.nil?
      form_params["bacs_debit"] = bacs_debit.to_s if !bacs_debit.nil?
      form_params["bancontact"] = bancontact.to_s if !bancontact.nil?
      form_params["billing_details"] = billing_details.to_s if !billing_details.nil?
      form_params["blik"] = blik.to_s if !blik.nil?
      form_params["boleto"] = boleto.to_s if !boleto.nil?
      form_params["card"] = card.to_s if !card.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["customer_balance"] = customer_balance.to_s if !customer_balance.nil?
      form_params["eps"] = eps.to_s if !eps.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["fpx"] = fpx.to_s if !fpx.nil?
      form_params["giropay"] = giropay.to_s if !giropay.nil?
      form_params["grabpay"] = grabpay.to_s if !grabpay.nil?
      form_params["ideal"] = ideal.to_s if !ideal.nil?
      form_params["interac_present"] = interac_present.to_s if !interac_present.nil?
      form_params["klarna"] = klarna.to_s if !klarna.nil?
      form_params["konbini"] = konbini.to_s if !konbini.nil?
      form_params["link"] = link.to_s if !link.nil?
      form_params["oxxo"] = oxxo.to_s if !oxxo.nil?
      form_params["p24"] = p24.to_s if !p24.nil?
      form_params["payment_method"] = payment_method.to_s if !payment_method.nil?
      form_params["paynow"] = paynow.to_s if !paynow.nil?
      form_params["pix"] = pix.to_s if !pix.nil?
      form_params["promptpay"] = promptpay.to_s if !promptpay.nil?
      form_params["radar_options"] = radar_options.to_s if !radar_options.nil?
      form_params["sepa_debit"] = sepa_debit.to_s if !sepa_debit.nil?
      form_params["sofort"] = sofort.to_s if !sofort.nil?
      form_params["type"] = _type.to_s if !_type.nil?
      form_params["us_bank_account"] = us_bank_account.to_s if !us_bank_account.nil?
      form_params["wechat_pay"] = wechat_pay.to_s if !wechat_pay.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_payment_methods",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates a PaymentMethod object. A PaymentMethod must be attached a customer to be updated.</p>
    # @param payment_method [String?]
    # @optional @param billing_details [Stripe::BillingDetailsInnerParams1?]
    # @optional @param card [Stripe::UpdateApiParam?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param link [JSON::Any?] If this is an `Link` PaymentMethod, this hash contains details about the Link payment method.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param us_bank_account [Stripe::UpdateParam?]
    # @return [PaymentMethod]
    def post_payment_methods_payment_method(*, payment_method : String? = nil, billing_details : Stripe::BillingDetailsInnerParams1? = nil, card : Stripe::UpdateApiParam? = nil, expand : Array(String)? = nil, link : JSON::Any? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, us_bank_account : Stripe::UpdateParam? = nil)
      data, _status_code, _headers = post_payment_methods_payment_method_with_http_info(payment_method: payment_method, billing_details: billing_details, card: card, expand: expand, link: link, metadata: metadata, us_bank_account: us_bank_account)
      data
    end

    # &lt;p&gt;Updates a PaymentMethod object. A PaymentMethod must be attached a customer to be updated.&lt;/p&gt;
    # @param payment_method [String?]
    # @optional @param billing_details [Stripe::BillingDetailsInnerParams1?]
    # @optional @param card [Stripe::UpdateApiParam?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param link [JSON::Any?] If this is an `Link` PaymentMethod, this hash contains details about the Link payment method.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param us_bank_account [Stripe::UpdateParam?]
    # @return [Array<(PaymentMethod, Integer, Hash)>] PaymentMethod data, response status code and response headers
    def post_payment_methods_payment_method_with_http_info(*, payment_method : String? = nil, billing_details : Stripe::BillingDetailsInnerParams1? = nil, card : Stripe::UpdateApiParam? = nil, expand : Array(String)? = nil, link : JSON::Any? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, us_bank_account : Stripe::UpdateParam? = nil)
      request = build_api_request_for_post_payment_methods_payment_method(payment_method: payment_method, billing_details: billing_details, card: card, expand: expand, link: link, metadata: metadata, us_bank_account: us_bank_account)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_payment_methods_payment_method\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentMethod.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates a PaymentMethod object. A PaymentMethod must be attached a customer to be updated.&lt;/p&gt;
    # @param payment_method [String?]
    # @optional @param billing_details [Stripe::BillingDetailsInnerParams1?]
    # @optional @param card [Stripe::UpdateApiParam?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param link [JSON::Any?] If this is an `Link` PaymentMethod, this hash contains details about the Link payment method.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param us_bank_account [Stripe::UpdateParam?]
    # @return nil
    def post_payment_methods_payment_method(*, payment_method : String? = nil, billing_details : Stripe::BillingDetailsInnerParams1? = nil, card : Stripe::UpdateApiParam? = nil, expand : Array(String)? = nil, link : JSON::Any? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, us_bank_account : Stripe::UpdateParam? = nil, &block : Crest::Response ->)
      build_api_request_for_post_payment_methods_payment_method(payment_method: payment_method, billing_details: billing_details, card: card, expand: expand, link: link, metadata: metadata, us_bank_account: us_bank_account).execute(&block)
    end

    POST_PAYMENT_METHODS_PAYMENT_METHOD_MAX_LENGTH_FOR_PAYMENT_METHOD = 5000

    # @return Crest::Request
    def build_api_request_for_post_payment_methods_payment_method(*, payment_method : String? = nil, billing_details : Stripe::BillingDetailsInnerParams1? = nil, card : Stripe::UpdateApiParam? = nil, expand : Array(String)? = nil, link : JSON::Any? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, us_bank_account : Stripe::UpdateParam? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_payment_methods_payment_method ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"payment_method\" is required and cannot be null") if payment_method.nil?
        if _payment_method = payment_method
          OpenApi::PrimitiveValidator.validate_max_length("payment_method", payment_method.to_s.size, POST_PAYMENT_METHODS_PAYMENT_METHOD_MAX_LENGTH_FOR_PAYMENT_METHOD)
        end
        if _billing_details = billing_details
          _billing_details.validate if _billing_details.is_a?(OpenApi::Validatable)
        end
        if _card = card
          _card.validate if _card.is_a?(OpenApi::Validatable)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _us_bank_account = us_bank_account
          _us_bank_account.validate if _us_bank_account.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/payment_methods/{payment_method}".sub("{" + "payment_method" + "}", URI.encode_path(payment_method.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["billing_details"] = billing_details.to_s if !billing_details.nil?
      form_params["card"] = card.to_s if !card.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["link"] = link.to_s if !link.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["us_bank_account"] = us_bank_account.to_s if !us_bank_account.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_payment_methods_payment_method",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Attaches a PaymentMethod object to a Customer.</p>  <p>To attach a new PaymentMethod to a customer for future payments, we recommend you use a <a href=\"/docs/api/setup_intents\">SetupIntent</a> or a PaymentIntent with <a href=\"/docs/api/payment_intents/create#create_payment_intent-setup_future_usage\">setup_future_usage</a>. These approaches will perform any necessary steps to set up the PaymentMethod for future payments. Using the <code>/v1/payment_methods/:id/attach</code> endpoint without first using a SetupIntent or PaymentIntent with <code>setup_future_usage</code> does not optimize the PaymentMethod for future use, which makes later declines and payment friction more likely. See <a href=\"/docs/payments/payment-intents#future-usage\">Optimizing cards for future payments</a> for more information about setting up future payments.</p>  <p>To use this PaymentMethod as the default for invoice or subscription payments, set <a href=\"/docs/api/customers/update#update_customer-invoice_settings-default_payment_method\"><code>invoice_settings.default_payment_method</code></a>, on the Customer to the PaymentMethod’s ID.</p>
    # @param payment_method [String?]
    # @param customer [String?] The ID of the customer to which to attach the PaymentMethod.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [PaymentMethod]
    def post_payment_methods_payment_method_attach(*, payment_method : String? = nil, customer : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_payment_methods_payment_method_attach_with_http_info(payment_method: payment_method, customer: customer, expand: expand)
      data
    end

    # &lt;p&gt;Attaches a PaymentMethod object to a Customer.&lt;/p&gt;  &lt;p&gt;To attach a new PaymentMethod to a customer for future payments, we recommend you use a &lt;a href&#x3D;\&quot;/docs/api/setup_intents\&quot;&gt;SetupIntent&lt;/a&gt; or a PaymentIntent with &lt;a href&#x3D;\&quot;/docs/api/payment_intents/create#create_payment_intent-setup_future_usage\&quot;&gt;setup_future_usage&lt;/a&gt;. These approaches will perform any necessary steps to set up the PaymentMethod for future payments. Using the &lt;code&gt;/v1/payment_methods/:id/attach&lt;/code&gt; endpoint without first using a SetupIntent or PaymentIntent with &lt;code&gt;setup_future_usage&lt;/code&gt; does not optimize the PaymentMethod for future use, which makes later declines and payment friction more likely. See &lt;a href&#x3D;\&quot;/docs/payments/payment-intents#future-usage\&quot;&gt;Optimizing cards for future payments&lt;/a&gt; for more information about setting up future payments.&lt;/p&gt;  &lt;p&gt;To use this PaymentMethod as the default for invoice or subscription payments, set &lt;a href&#x3D;\&quot;/docs/api/customers/update#update_customer-invoice_settings-default_payment_method\&quot;&gt;&lt;code&gt;invoice_settings.default_payment_method&lt;/code&gt;&lt;/a&gt;, on the Customer to the PaymentMethod’s ID.&lt;/p&gt;
    # @param payment_method [String?]
    # @param customer [String?] The ID of the customer to which to attach the PaymentMethod.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(PaymentMethod, Integer, Hash)>] PaymentMethod data, response status code and response headers
    def post_payment_methods_payment_method_attach_with_http_info(*, payment_method : String? = nil, customer : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_payment_methods_payment_method_attach(payment_method: payment_method, customer: customer, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_payment_methods_payment_method_attach\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentMethod.from_json(data), status_code, headers
    end

    # &lt;p&gt;Attaches a PaymentMethod object to a Customer.&lt;/p&gt;  &lt;p&gt;To attach a new PaymentMethod to a customer for future payments, we recommend you use a &lt;a href&#x3D;\&quot;/docs/api/setup_intents\&quot;&gt;SetupIntent&lt;/a&gt; or a PaymentIntent with &lt;a href&#x3D;\&quot;/docs/api/payment_intents/create#create_payment_intent-setup_future_usage\&quot;&gt;setup_future_usage&lt;/a&gt;. These approaches will perform any necessary steps to set up the PaymentMethod for future payments. Using the &lt;code&gt;/v1/payment_methods/:id/attach&lt;/code&gt; endpoint without first using a SetupIntent or PaymentIntent with &lt;code&gt;setup_future_usage&lt;/code&gt; does not optimize the PaymentMethod for future use, which makes later declines and payment friction more likely. See &lt;a href&#x3D;\&quot;/docs/payments/payment-intents#future-usage\&quot;&gt;Optimizing cards for future payments&lt;/a&gt; for more information about setting up future payments.&lt;/p&gt;  &lt;p&gt;To use this PaymentMethod as the default for invoice or subscription payments, set &lt;a href&#x3D;\&quot;/docs/api/customers/update#update_customer-invoice_settings-default_payment_method\&quot;&gt;&lt;code&gt;invoice_settings.default_payment_method&lt;/code&gt;&lt;/a&gt;, on the Customer to the PaymentMethod’s ID.&lt;/p&gt;
    # @param payment_method [String?]
    # @param customer [String?] The ID of the customer to which to attach the PaymentMethod.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_payment_methods_payment_method_attach(*, payment_method : String? = nil, customer : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_payment_methods_payment_method_attach(payment_method: payment_method, customer: customer, expand: expand).execute(&block)
    end

    POST_PAYMENT_METHODS_PAYMENT_METHOD_ATTACH_MAX_LENGTH_FOR_PAYMENT_METHOD = 5000
    POST_PAYMENT_METHODS_PAYMENT_METHOD_ATTACH_MAX_LENGTH_FOR_CUSTOMER       = 5000

    # @return Crest::Request
    def build_api_request_for_post_payment_methods_payment_method_attach(*, payment_method : String? = nil, customer : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_payment_methods_payment_method_attach ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"payment_method\" is required and cannot be null") if payment_method.nil?
        if _payment_method = payment_method
          OpenApi::PrimitiveValidator.validate_max_length("payment_method", payment_method.to_s.size, POST_PAYMENT_METHODS_PAYMENT_METHOD_ATTACH_MAX_LENGTH_FOR_PAYMENT_METHOD)
        end
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_PAYMENT_METHODS_PAYMENT_METHOD_ATTACH_MAX_LENGTH_FOR_CUSTOMER)
        end
      end

      # resource path
      local_var_path = "/v1/payment_methods/{payment_method}/attach".sub("{" + "payment_method" + "}", URI.encode_path(payment_method.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_payment_methods_payment_method_attach",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Detaches a PaymentMethod object from a Customer. After a PaymentMethod is detached, it can no longer be used for a payment or re-attached to a Customer.</p>
    # @param payment_method [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [PaymentMethod]
    def post_payment_methods_payment_method_detach(*, payment_method : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_payment_methods_payment_method_detach_with_http_info(payment_method: payment_method, expand: expand)
      data
    end

    # &lt;p&gt;Detaches a PaymentMethod object from a Customer. After a PaymentMethod is detached, it can no longer be used for a payment or re-attached to a Customer.&lt;/p&gt;
    # @param payment_method [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(PaymentMethod, Integer, Hash)>] PaymentMethod data, response status code and response headers
    def post_payment_methods_payment_method_detach_with_http_info(*, payment_method : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_payment_methods_payment_method_detach(payment_method: payment_method, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_payment_methods_payment_method_detach\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PaymentMethod.from_json(data), status_code, headers
    end

    # &lt;p&gt;Detaches a PaymentMethod object from a Customer. After a PaymentMethod is detached, it can no longer be used for a payment or re-attached to a Customer.&lt;/p&gt;
    # @param payment_method [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_payment_methods_payment_method_detach(*, payment_method : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_payment_methods_payment_method_detach(payment_method: payment_method, expand: expand).execute(&block)
    end

    POST_PAYMENT_METHODS_PAYMENT_METHOD_DETACH_MAX_LENGTH_FOR_PAYMENT_METHOD = 5000

    # @return Crest::Request
    def build_api_request_for_post_payment_methods_payment_method_detach(*, payment_method : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_payment_methods_payment_method_detach ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"payment_method\" is required and cannot be null") if payment_method.nil?
        if _payment_method = payment_method
          OpenApi::PrimitiveValidator.validate_max_length("payment_method", payment_method.to_s.size, POST_PAYMENT_METHODS_PAYMENT_METHOD_DETACH_MAX_LENGTH_FOR_PAYMENT_METHOD)
        end
      end

      # resource path
      local_var_path = "/v1/payment_methods/{payment_method}/detach".sub("{" + "payment_method" + "}", URI.encode_path(payment_method.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_payment_methods_payment_method_detach",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>To send funds to your own bank account, you create a new payout object. Your <a href=\"#balance\">Stripe balance</a> must be able to cover the payout amount, or you’ll receive an “Insufficient Funds” error.</p>  <p>If your API key is in test mode, money won’t actually be sent, though everything else will occur as if in live mode.</p>  <p>If you are creating a manual payout on a Stripe account that uses multiple payment source types, you’ll need to specify the source type balance that the payout should draw from. The <a href=\"#balance_object\">balance object</a> details available and pending amounts by source type.</p>
    # @param amount [Int64?] A positive integer in cents representing how much to payout.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param destination [String?] The ID of a bank account or a card to send the payout to. If no destination is supplied, the default external account for the specified currency will be used.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param method [String?] The method used to send this payout, which can be `standard` or `instant`. `instant` is only supported for payouts to debit cards. (See [Instant payouts for marketplaces for more information](https://stripe.com/blog/instant-payouts-for-marketplaces).)
    # @optional @param source_type [String?] The balance type of your Stripe balance to draw this payout from. Balances for different payment sources are kept separately. You can find the amounts with the balances API. One of `bank_account`, `card`, or `fpx`.
    # @optional @param statement_descriptor [String?] A string to be displayed on the recipient's bank or card statement. This may be at most 22 characters. Attempting to use a `statement_descriptor` longer than 22 characters will return an error. Note: Most banks will truncate this information and/or display it inconsistently. Some may not display it at all.
    # @return [Payout]
    def post_payouts(*, amount : Int64? = nil, currency : String? = nil, description : String? = nil, destination : String? = nil, expand : Array(String)? = nil, method : String? = nil, source_type : String? = nil, statement_descriptor : String? = nil)
      data, _status_code, _headers = post_payouts_with_http_info(amount: amount, currency: currency, description: description, destination: destination, expand: expand, method: method, source_type: source_type, statement_descriptor: statement_descriptor)
      data
    end

    # &lt;p&gt;To send funds to your own bank account, you create a new payout object. Your &lt;a href&#x3D;\&quot;#balance\&quot;&gt;Stripe balance&lt;/a&gt; must be able to cover the payout amount, or you’ll receive an “Insufficient Funds” error.&lt;/p&gt;  &lt;p&gt;If your API key is in test mode, money won’t actually be sent, though everything else will occur as if in live mode.&lt;/p&gt;  &lt;p&gt;If you are creating a manual payout on a Stripe account that uses multiple payment source types, you’ll need to specify the source type balance that the payout should draw from. The &lt;a href&#x3D;\&quot;#balance_object\&quot;&gt;balance object&lt;/a&gt; details available and pending amounts by source type.&lt;/p&gt;
    # @param amount [Int64?] A positive integer in cents representing how much to payout.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param destination [String?] The ID of a bank account or a card to send the payout to. If no destination is supplied, the default external account for the specified currency will be used.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param method [String?] The method used to send this payout, which can be `standard` or `instant`. `instant` is only supported for payouts to debit cards. (See [Instant payouts for marketplaces for more information](https://stripe.com/blog/instant-payouts-for-marketplaces).)
    # @optional @param source_type [String?] The balance type of your Stripe balance to draw this payout from. Balances for different payment sources are kept separately. You can find the amounts with the balances API. One of `bank_account`, `card`, or `fpx`.
    # @optional @param statement_descriptor [String?] A string to be displayed on the recipient's bank or card statement. This may be at most 22 characters. Attempting to use a `statement_descriptor` longer than 22 characters will return an error. Note: Most banks will truncate this information and/or display it inconsistently. Some may not display it at all.
    # @return [Array<(Payout, Integer, Hash)>] Payout data, response status code and response headers
    def post_payouts_with_http_info(*, amount : Int64? = nil, currency : String? = nil, description : String? = nil, destination : String? = nil, expand : Array(String)? = nil, method : String? = nil, source_type : String? = nil, statement_descriptor : String? = nil)
      request = build_api_request_for_post_payouts(amount: amount, currency: currency, description: description, destination: destination, expand: expand, method: method, source_type: source_type, statement_descriptor: statement_descriptor)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_payouts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Payout.from_json(data), status_code, headers
    end

    # &lt;p&gt;To send funds to your own bank account, you create a new payout object. Your &lt;a href&#x3D;\&quot;#balance\&quot;&gt;Stripe balance&lt;/a&gt; must be able to cover the payout amount, or you’ll receive an “Insufficient Funds” error.&lt;/p&gt;  &lt;p&gt;If your API key is in test mode, money won’t actually be sent, though everything else will occur as if in live mode.&lt;/p&gt;  &lt;p&gt;If you are creating a manual payout on a Stripe account that uses multiple payment source types, you’ll need to specify the source type balance that the payout should draw from. The &lt;a href&#x3D;\&quot;#balance_object\&quot;&gt;balance object&lt;/a&gt; details available and pending amounts by source type.&lt;/p&gt;
    # @param amount [Int64?] A positive integer in cents representing how much to payout.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param destination [String?] The ID of a bank account or a card to send the payout to. If no destination is supplied, the default external account for the specified currency will be used.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param method [String?] The method used to send this payout, which can be `standard` or `instant`. `instant` is only supported for payouts to debit cards. (See [Instant payouts for marketplaces for more information](https://stripe.com/blog/instant-payouts-for-marketplaces).)
    # @optional @param source_type [String?] The balance type of your Stripe balance to draw this payout from. Balances for different payment sources are kept separately. You can find the amounts with the balances API. One of `bank_account`, `card`, or `fpx`.
    # @optional @param statement_descriptor [String?] A string to be displayed on the recipient's bank or card statement. This may be at most 22 characters. Attempting to use a `statement_descriptor` longer than 22 characters will return an error. Note: Most banks will truncate this information and/or display it inconsistently. Some may not display it at all.
    # @return nil
    def post_payouts(*, amount : Int64? = nil, currency : String? = nil, description : String? = nil, destination : String? = nil, expand : Array(String)? = nil, method : String? = nil, source_type : String? = nil, statement_descriptor : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_payouts(amount: amount, currency: currency, description: description, destination: destination, expand: expand, method: method, source_type: source_type, statement_descriptor: statement_descriptor).execute(&block)
    end

    POST_PAYOUTS_MAX_LENGTH_FOR_DESCRIPTION          = 5000
    POST_PAYOUTS_MAX_LENGTH_FOR_METHOD               = 5000
    POST_PAYOUTS_VALID_VALUES_FOR_METHOD             = StaticArray["instant", "standard"]
    POST_PAYOUTS_MAX_LENGTH_FOR_SOURCE_TYPE          = 5000
    POST_PAYOUTS_VALID_VALUES_FOR_SOURCE_TYPE        = StaticArray["bank_account", "card", "fpx"]
    POST_PAYOUTS_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR = 22

    # @return Crest::Request
    def build_api_request_for_post_payouts(*, amount : Int64? = nil, currency : String? = nil, description : String? = nil, destination : String? = nil, expand : Array(String)? = nil, method : String? = nil, source_type : String? = nil, statement_descriptor : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_payouts ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"amount\" is required and cannot be null") if amount.nil?

        raise ArgumentError.new("\"currency\" is required and cannot be null") if currency.nil?

        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_PAYOUTS_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _method = method
          OpenApi::EnumValidator.validate("method", _method, POST_PAYOUTS_VALID_VALUES_FOR_METHOD)
        end
        if _source_type = source_type
          OpenApi::EnumValidator.validate("source_type", _source_type, POST_PAYOUTS_VALID_VALUES_FOR_SOURCE_TYPE)
        end
        if _statement_descriptor = statement_descriptor
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor", statement_descriptor.to_s.size, POST_PAYOUTS_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR)
        end
      end

      # resource path
      local_var_path = "/v1/payouts"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["destination"] = destination.to_s if !destination.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["method"] = method.to_s if !method.nil?
      form_params["source_type"] = source_type.to_s if !source_type.nil?
      form_params["statement_descriptor"] = statement_descriptor.to_s if !statement_descriptor.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_payouts",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the specified payout by setting the values of the parameters passed. Any parameters not provided will be left unchanged. This request accepts only the metadata as arguments.</p>
    # @param payout [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Payout]
    def post_payouts_payout(*, payout : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_payouts_payout_with_http_info(payout: payout, expand: expand, metadata: metadata)
      data
    end

    # &lt;p&gt;Updates the specified payout by setting the values of the parameters passed. Any parameters not provided will be left unchanged. This request accepts only the metadata as arguments.&lt;/p&gt;
    # @param payout [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(Payout, Integer, Hash)>] Payout data, response status code and response headers
    def post_payouts_payout_with_http_info(*, payout : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_payouts_payout(payout: payout, expand: expand, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_payouts_payout\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Payout.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the specified payout by setting the values of the parameters passed. Any parameters not provided will be left unchanged. This request accepts only the metadata as arguments.&lt;/p&gt;
    # @param payout [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_payouts_payout(*, payout : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_payouts_payout(payout: payout, expand: expand, metadata: metadata).execute(&block)
    end

    POST_PAYOUTS_PAYOUT_MAX_LENGTH_FOR_PAYOUT = 5000

    # @return Crest::Request
    def build_api_request_for_post_payouts_payout(*, payout : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_payouts_payout ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"payout\" is required and cannot be null") if payout.nil?
        if _payout = payout
          OpenApi::PrimitiveValidator.validate_max_length("payout", payout.to_s.size, POST_PAYOUTS_PAYOUT_MAX_LENGTH_FOR_PAYOUT)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/payouts/{payout}".sub("{" + "payout" + "}", URI.encode_path(payout.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_payouts_payout",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>A previously created payout can be canceled if it has not yet been paid out. Funds will be refunded to your available balance. You may not cancel automatic Stripe payouts.</p>
    # @param payout [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Payout]
    def post_payouts_payout_cancel(*, payout : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_payouts_payout_cancel_with_http_info(payout: payout, expand: expand)
      data
    end

    # &lt;p&gt;A previously created payout can be canceled if it has not yet been paid out. Funds will be refunded to your available balance. You may not cancel automatic Stripe payouts.&lt;/p&gt;
    # @param payout [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(Payout, Integer, Hash)>] Payout data, response status code and response headers
    def post_payouts_payout_cancel_with_http_info(*, payout : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_payouts_payout_cancel(payout: payout, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_payouts_payout_cancel\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Payout.from_json(data), status_code, headers
    end

    # &lt;p&gt;A previously created payout can be canceled if it has not yet been paid out. Funds will be refunded to your available balance. You may not cancel automatic Stripe payouts.&lt;/p&gt;
    # @param payout [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_payouts_payout_cancel(*, payout : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_payouts_payout_cancel(payout: payout, expand: expand).execute(&block)
    end

    POST_PAYOUTS_PAYOUT_CANCEL_MAX_LENGTH_FOR_PAYOUT = 5000

    # @return Crest::Request
    def build_api_request_for_post_payouts_payout_cancel(*, payout : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_payouts_payout_cancel ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"payout\" is required and cannot be null") if payout.nil?
        if _payout = payout
          OpenApi::PrimitiveValidator.validate_max_length("payout", payout.to_s.size, POST_PAYOUTS_PAYOUT_CANCEL_MAX_LENGTH_FOR_PAYOUT)
        end
      end

      # resource path
      local_var_path = "/v1/payouts/{payout}/cancel".sub("{" + "payout" + "}", URI.encode_path(payout.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_payouts_payout_cancel",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Reverses a payout by debiting the destination bank account. Only payouts for connected accounts to US bank accounts may be reversed at this time. If the payout is in the <code>pending</code> status, <code>/v1/payouts/:id/cancel</code> should be used instead.</p>  <p>By requesting a reversal via <code>/v1/payouts/:id/reverse</code>, you confirm that the authorized signatory of the selected bank account has authorized the debit on the bank account and that no other authorization is required.</p>
    # @param payout [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Payout]
    def post_payouts_payout_reverse(*, payout : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_payouts_payout_reverse_with_http_info(payout: payout, expand: expand)
      data
    end

    # &lt;p&gt;Reverses a payout by debiting the destination bank account. Only payouts for connected accounts to US bank accounts may be reversed at this time. If the payout is in the &lt;code&gt;pending&lt;/code&gt; status, &lt;code&gt;/v1/payouts/:id/cancel&lt;/code&gt; should be used instead.&lt;/p&gt;  &lt;p&gt;By requesting a reversal via &lt;code&gt;/v1/payouts/:id/reverse&lt;/code&gt;, you confirm that the authorized signatory of the selected bank account has authorized the debit on the bank account and that no other authorization is required.&lt;/p&gt;
    # @param payout [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(Payout, Integer, Hash)>] Payout data, response status code and response headers
    def post_payouts_payout_reverse_with_http_info(*, payout : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_payouts_payout_reverse(payout: payout, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_payouts_payout_reverse\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Payout.from_json(data), status_code, headers
    end

    # &lt;p&gt;Reverses a payout by debiting the destination bank account. Only payouts for connected accounts to US bank accounts may be reversed at this time. If the payout is in the &lt;code&gt;pending&lt;/code&gt; status, &lt;code&gt;/v1/payouts/:id/cancel&lt;/code&gt; should be used instead.&lt;/p&gt;  &lt;p&gt;By requesting a reversal via &lt;code&gt;/v1/payouts/:id/reverse&lt;/code&gt;, you confirm that the authorized signatory of the selected bank account has authorized the debit on the bank account and that no other authorization is required.&lt;/p&gt;
    # @param payout [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_payouts_payout_reverse(*, payout : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_payouts_payout_reverse(payout: payout, expand: expand).execute(&block)
    end

    POST_PAYOUTS_PAYOUT_REVERSE_MAX_LENGTH_FOR_PAYOUT = 5000

    # @return Crest::Request
    def build_api_request_for_post_payouts_payout_reverse(*, payout : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_payouts_payout_reverse ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"payout\" is required and cannot be null") if payout.nil?
        if _payout = payout
          OpenApi::PrimitiveValidator.validate_max_length("payout", payout.to_s.size, POST_PAYOUTS_PAYOUT_REVERSE_MAX_LENGTH_FOR_PAYOUT)
        end
      end

      # resource path
      local_var_path = "/v1/payouts/{payout}/reverse".sub("{" + "payout" + "}", URI.encode_path(payout.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_payouts_payout_reverse",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>You can now model subscriptions more flexibly using the <a href=\"#prices\">Prices API</a>. It replaces the Plans API and is backwards compatible to simplify your migration.</p>
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param interval [String?] Specifies billing frequency. Either `day`, `week`, `month` or `year`.
    # @optional @param active [Bool?] Whether the plan is currently available for new subscriptions. Defaults to `true`.
    # @optional @param aggregate_usage [String?] Specifies a usage aggregation strategy for plans of `usage_type=metered`. Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max` which uses the usage record with the maximum reported usage during a period. Defaults to `sum`.
    # @optional @param amount [Int64?] A positive integer in cents (or local equivalent) (or 0 for a free plan) representing how much to charge on a recurring basis.
    # @optional @param amount_decimal [String?] Same as `amount`, but accepts a decimal value with at most 12 decimal places. Only one of `amount` and `amount_decimal` can be set.
    # @optional @param billing_scheme [String?] Describes how to compute the price per period. Either `per_unit` or `tiered`. `per_unit` indicates that the fixed amount (specified in `amount`) will be charged per unit in `quantity` (for plans with `usage_type=licensed`), or per unit of total usage (for plans with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as defined using the `tiers` and `tiers_mode` attributes.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param id [String?] An identifier randomly generated by Stripe. Used to identify this plan when subscribing a customer. You can optionally override this ID, but the ID must be unique across all plans in your Stripe account. You can, however, use the same plan ID in both live and test modes.
    # @optional @param interval_count [Int64?] The number of intervals between subscription billings. For example, `interval=month` and `interval_count=3` bills every 3 months. Maximum of one year interval allowed (1 year, 12 months, or 52 weeks).
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nickname [String?] A brief description of the plan, hidden from customers.
    # @optional @param product [Stripe::PostPlansRequestProduct?]
    # @optional @param tiers [Array(Stripe::Tier)?] Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`. See also the documentation for `billing_scheme`.
    # @optional @param tiers_mode [String?] Defines if the tiering price should be `graduated` or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per unit price, in `graduated` tiering pricing can successively change as the quantity grows.
    # @optional @param transform_usage [Stripe::TransformUsageParam?]
    # @optional @param trial_period_days [Int64?] Default number of trial days when subscribing a customer to this plan using [`trial_from_plan=true`](https://stripe.com/docs/api#create_subscription-trial_from_plan).
    # @optional @param usage_type [String?] Configures how the quantity per period should be determined. Can be either `metered` or `licensed`. `licensed` automatically bills the `quantity` set when adding it to a subscription. `metered` aggregates the total usage based on usage records. Defaults to `licensed`.
    # @return [Plan]
    def post_plans(*, currency : String? = nil, interval : String? = nil, active : Bool? = nil, aggregate_usage : String? = nil, amount : Int64? = nil, amount_decimal : String? = nil, billing_scheme : String? = nil, expand : Array(String)? = nil, id : String? = nil, interval_count : Int64? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nickname : String? = nil, product : Stripe::PostPlansRequestProduct? = nil, tiers : Array(Stripe::Tier)? = nil, tiers_mode : String? = nil, transform_usage : Stripe::TransformUsageParam? = nil, trial_period_days : Int64? = nil, usage_type : String? = nil)
      data, _status_code, _headers = post_plans_with_http_info(currency: currency, interval: interval, active: active, aggregate_usage: aggregate_usage, amount: amount, amount_decimal: amount_decimal, billing_scheme: billing_scheme, expand: expand, id: id, interval_count: interval_count, metadata: metadata, nickname: nickname, product: product, tiers: tiers, tiers_mode: tiers_mode, transform_usage: transform_usage, trial_period_days: trial_period_days, usage_type: usage_type)
      data
    end

    # &lt;p&gt;You can now model subscriptions more flexibly using the &lt;a href&#x3D;\&quot;#prices\&quot;&gt;Prices API&lt;/a&gt;. It replaces the Plans API and is backwards compatible to simplify your migration.&lt;/p&gt;
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param interval [String?] Specifies billing frequency. Either `day`, `week`, `month` or `year`.
    # @optional @param active [Bool?] Whether the plan is currently available for new subscriptions. Defaults to `true`.
    # @optional @param aggregate_usage [String?] Specifies a usage aggregation strategy for plans of `usage_type=metered`. Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max` which uses the usage record with the maximum reported usage during a period. Defaults to `sum`.
    # @optional @param amount [Int64?] A positive integer in cents (or local equivalent) (or 0 for a free plan) representing how much to charge on a recurring basis.
    # @optional @param amount_decimal [String?] Same as `amount`, but accepts a decimal value with at most 12 decimal places. Only one of `amount` and `amount_decimal` can be set.
    # @optional @param billing_scheme [String?] Describes how to compute the price per period. Either `per_unit` or `tiered`. `per_unit` indicates that the fixed amount (specified in `amount`) will be charged per unit in `quantity` (for plans with `usage_type=licensed`), or per unit of total usage (for plans with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as defined using the `tiers` and `tiers_mode` attributes.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param id [String?] An identifier randomly generated by Stripe. Used to identify this plan when subscribing a customer. You can optionally override this ID, but the ID must be unique across all plans in your Stripe account. You can, however, use the same plan ID in both live and test modes.
    # @optional @param interval_count [Int64?] The number of intervals between subscription billings. For example, `interval=month` and `interval_count=3` bills every 3 months. Maximum of one year interval allowed (1 year, 12 months, or 52 weeks).
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nickname [String?] A brief description of the plan, hidden from customers.
    # @optional @param product [Stripe::PostPlansRequestProduct?]
    # @optional @param tiers [Array(Stripe::Tier)?] Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`. See also the documentation for `billing_scheme`.
    # @optional @param tiers_mode [String?] Defines if the tiering price should be `graduated` or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per unit price, in `graduated` tiering pricing can successively change as the quantity grows.
    # @optional @param transform_usage [Stripe::TransformUsageParam?]
    # @optional @param trial_period_days [Int64?] Default number of trial days when subscribing a customer to this plan using [`trial_from_plan=true`](https://stripe.com/docs/api#create_subscription-trial_from_plan).
    # @optional @param usage_type [String?] Configures how the quantity per period should be determined. Can be either `metered` or `licensed`. `licensed` automatically bills the `quantity` set when adding it to a subscription. `metered` aggregates the total usage based on usage records. Defaults to `licensed`.
    # @return [Array<(Plan, Integer, Hash)>] Plan data, response status code and response headers
    def post_plans_with_http_info(*, currency : String? = nil, interval : String? = nil, active : Bool? = nil, aggregate_usage : String? = nil, amount : Int64? = nil, amount_decimal : String? = nil, billing_scheme : String? = nil, expand : Array(String)? = nil, id : String? = nil, interval_count : Int64? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nickname : String? = nil, product : Stripe::PostPlansRequestProduct? = nil, tiers : Array(Stripe::Tier)? = nil, tiers_mode : String? = nil, transform_usage : Stripe::TransformUsageParam? = nil, trial_period_days : Int64? = nil, usage_type : String? = nil)
      request = build_api_request_for_post_plans(currency: currency, interval: interval, active: active, aggregate_usage: aggregate_usage, amount: amount, amount_decimal: amount_decimal, billing_scheme: billing_scheme, expand: expand, id: id, interval_count: interval_count, metadata: metadata, nickname: nickname, product: product, tiers: tiers, tiers_mode: tiers_mode, transform_usage: transform_usage, trial_period_days: trial_period_days, usage_type: usage_type)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_plans\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Plan.from_json(data), status_code, headers
    end

    # &lt;p&gt;You can now model subscriptions more flexibly using the &lt;a href&#x3D;\&quot;#prices\&quot;&gt;Prices API&lt;/a&gt;. It replaces the Plans API and is backwards compatible to simplify your migration.&lt;/p&gt;
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param interval [String?] Specifies billing frequency. Either `day`, `week`, `month` or `year`.
    # @optional @param active [Bool?] Whether the plan is currently available for new subscriptions. Defaults to `true`.
    # @optional @param aggregate_usage [String?] Specifies a usage aggregation strategy for plans of `usage_type=metered`. Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max` which uses the usage record with the maximum reported usage during a period. Defaults to `sum`.
    # @optional @param amount [Int64?] A positive integer in cents (or local equivalent) (or 0 for a free plan) representing how much to charge on a recurring basis.
    # @optional @param amount_decimal [String?] Same as `amount`, but accepts a decimal value with at most 12 decimal places. Only one of `amount` and `amount_decimal` can be set.
    # @optional @param billing_scheme [String?] Describes how to compute the price per period. Either `per_unit` or `tiered`. `per_unit` indicates that the fixed amount (specified in `amount`) will be charged per unit in `quantity` (for plans with `usage_type=licensed`), or per unit of total usage (for plans with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as defined using the `tiers` and `tiers_mode` attributes.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param id [String?] An identifier randomly generated by Stripe. Used to identify this plan when subscribing a customer. You can optionally override this ID, but the ID must be unique across all plans in your Stripe account. You can, however, use the same plan ID in both live and test modes.
    # @optional @param interval_count [Int64?] The number of intervals between subscription billings. For example, `interval=month` and `interval_count=3` bills every 3 months. Maximum of one year interval allowed (1 year, 12 months, or 52 weeks).
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nickname [String?] A brief description of the plan, hidden from customers.
    # @optional @param product [Stripe::PostPlansRequestProduct?]
    # @optional @param tiers [Array(Stripe::Tier)?] Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`. See also the documentation for `billing_scheme`.
    # @optional @param tiers_mode [String?] Defines if the tiering price should be `graduated` or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per unit price, in `graduated` tiering pricing can successively change as the quantity grows.
    # @optional @param transform_usage [Stripe::TransformUsageParam?]
    # @optional @param trial_period_days [Int64?] Default number of trial days when subscribing a customer to this plan using [`trial_from_plan=true`](https://stripe.com/docs/api#create_subscription-trial_from_plan).
    # @optional @param usage_type [String?] Configures how the quantity per period should be determined. Can be either `metered` or `licensed`. `licensed` automatically bills the `quantity` set when adding it to a subscription. `metered` aggregates the total usage based on usage records. Defaults to `licensed`.
    # @return nil
    def post_plans(*, currency : String? = nil, interval : String? = nil, active : Bool? = nil, aggregate_usage : String? = nil, amount : Int64? = nil, amount_decimal : String? = nil, billing_scheme : String? = nil, expand : Array(String)? = nil, id : String? = nil, interval_count : Int64? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nickname : String? = nil, product : Stripe::PostPlansRequestProduct? = nil, tiers : Array(Stripe::Tier)? = nil, tiers_mode : String? = nil, transform_usage : Stripe::TransformUsageParam? = nil, trial_period_days : Int64? = nil, usage_type : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_plans(currency: currency, interval: interval, active: active, aggregate_usage: aggregate_usage, amount: amount, amount_decimal: amount_decimal, billing_scheme: billing_scheme, expand: expand, id: id, interval_count: interval_count, metadata: metadata, nickname: nickname, product: product, tiers: tiers, tiers_mode: tiers_mode, transform_usage: transform_usage, trial_period_days: trial_period_days, usage_type: usage_type).execute(&block)
    end

    POST_PLANS_VALID_VALUES_FOR_INTERVAL        = StaticArray["day", "month", "week", "year"]
    POST_PLANS_VALID_VALUES_FOR_AGGREGATE_USAGE = StaticArray["last_during_period", "last_ever", "max", "sum"]
    POST_PLANS_VALID_VALUES_FOR_BILLING_SCHEME  = StaticArray["per_unit", "tiered"]
    POST_PLANS_MAX_LENGTH_FOR_ID                = 5000
    POST_PLANS_MAX_LENGTH_FOR_NICKNAME          = 5000
    POST_PLANS_VALID_VALUES_FOR_TIERS_MODE      = StaticArray["graduated", "volume"]
    POST_PLANS_VALID_VALUES_FOR_USAGE_TYPE      = StaticArray["licensed", "metered"]

    # @return Crest::Request
    def build_api_request_for_post_plans(*, currency : String? = nil, interval : String? = nil, active : Bool? = nil, aggregate_usage : String? = nil, amount : Int64? = nil, amount_decimal : String? = nil, billing_scheme : String? = nil, expand : Array(String)? = nil, id : String? = nil, interval_count : Int64? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nickname : String? = nil, product : Stripe::PostPlansRequestProduct? = nil, tiers : Array(Stripe::Tier)? = nil, tiers_mode : String? = nil, transform_usage : Stripe::TransformUsageParam? = nil, trial_period_days : Int64? = nil, usage_type : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_plans ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"currency\" is required and cannot be null") if currency.nil?

        raise ArgumentError.new("\"interval\" is required and cannot be null") if interval.nil?
        if _interval = interval
          OpenApi::EnumValidator.validate("interval", _interval, POST_PLANS_VALID_VALUES_FOR_INTERVAL)
        end

        if _aggregate_usage = aggregate_usage
          OpenApi::EnumValidator.validate("aggregate_usage", _aggregate_usage, POST_PLANS_VALID_VALUES_FOR_AGGREGATE_USAGE)
        end

        if _billing_scheme = billing_scheme
          OpenApi::EnumValidator.validate("billing_scheme", _billing_scheme, POST_PLANS_VALID_VALUES_FOR_BILLING_SCHEME)
        end

        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_PLANS_MAX_LENGTH_FOR_ID)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _nickname = nickname
          OpenApi::PrimitiveValidator.validate_max_length("nickname", nickname.to_s.size, POST_PLANS_MAX_LENGTH_FOR_NICKNAME)
        end
        if _product = product
          _product.validate if _product.is_a?(OpenApi::Validatable)
        end
        if _tiers = tiers
          OpenApi::ContainerValidator.validate(container: _tiers) if _tiers.is_a?(Array)
        end
        if _tiers_mode = tiers_mode
          OpenApi::EnumValidator.validate("tiers_mode", _tiers_mode, POST_PLANS_VALID_VALUES_FOR_TIERS_MODE)
        end
        if _transform_usage = transform_usage
          _transform_usage.validate if _transform_usage.is_a?(OpenApi::Validatable)
        end

        if _usage_type = usage_type
          OpenApi::EnumValidator.validate("usage_type", _usage_type, POST_PLANS_VALID_VALUES_FOR_USAGE_TYPE)
        end
      end

      # resource path
      local_var_path = "/v1/plans"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["active"] = active.to_s if !active.nil?
      form_params["aggregate_usage"] = aggregate_usage.to_s if !aggregate_usage.nil?
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["amount_decimal"] = amount_decimal.to_s if !amount_decimal.nil?
      form_params["billing_scheme"] = billing_scheme.to_s if !billing_scheme.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["id"] = id.to_s if !id.nil?
      form_params["interval"] = interval.to_s if !interval.nil?
      form_params["interval_count"] = interval_count.to_s if !interval_count.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["nickname"] = nickname.to_s if !nickname.nil?
      form_params["product"] = product.to_s if !product.nil?
      form_params["tiers"] = @api_client.build_collection_param(tiers, "csv") if !tiers.nil? && !tiers.empty?
      form_params["tiers_mode"] = tiers_mode.to_s if !tiers_mode.nil?
      form_params["transform_usage"] = transform_usage.to_s if !transform_usage.nil?
      form_params["trial_period_days"] = trial_period_days.to_s if !trial_period_days.nil?
      form_params["usage_type"] = usage_type.to_s if !usage_type.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_plans",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the specified plan by setting the values of the parameters passed. Any parameters not provided are left unchanged. By design, you cannot change a plan’s ID, amount, currency, or billing cycle.</p>
    # @param plan [String?]
    # @optional @param active [Bool?] Whether the plan is currently available for new subscriptions.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nickname [String?] A brief description of the plan, hidden from customers.
    # @optional @param product [String?] The product the plan belongs to. This cannot be changed once it has been used in a subscription or subscription schedule.
    # @optional @param trial_period_days [Int64?] Default number of trial days when subscribing a customer to this plan using [`trial_from_plan=true`](https://stripe.com/docs/api#create_subscription-trial_from_plan).
    # @return [Plan]
    def post_plans_plan(*, plan : String? = nil, active : Bool? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nickname : String? = nil, product : String? = nil, trial_period_days : Int64? = nil)
      data, _status_code, _headers = post_plans_plan_with_http_info(plan: plan, active: active, expand: expand, metadata: metadata, nickname: nickname, product: product, trial_period_days: trial_period_days)
      data
    end

    # &lt;p&gt;Updates the specified plan by setting the values of the parameters passed. Any parameters not provided are left unchanged. By design, you cannot change a plan’s ID, amount, currency, or billing cycle.&lt;/p&gt;
    # @param plan [String?]
    # @optional @param active [Bool?] Whether the plan is currently available for new subscriptions.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nickname [String?] A brief description of the plan, hidden from customers.
    # @optional @param product [String?] The product the plan belongs to. This cannot be changed once it has been used in a subscription or subscription schedule.
    # @optional @param trial_period_days [Int64?] Default number of trial days when subscribing a customer to this plan using [`trial_from_plan=true`](https://stripe.com/docs/api#create_subscription-trial_from_plan).
    # @return [Array<(Plan, Integer, Hash)>] Plan data, response status code and response headers
    def post_plans_plan_with_http_info(*, plan : String? = nil, active : Bool? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nickname : String? = nil, product : String? = nil, trial_period_days : Int64? = nil)
      request = build_api_request_for_post_plans_plan(plan: plan, active: active, expand: expand, metadata: metadata, nickname: nickname, product: product, trial_period_days: trial_period_days)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_plans_plan\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Plan.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the specified plan by setting the values of the parameters passed. Any parameters not provided are left unchanged. By design, you cannot change a plan’s ID, amount, currency, or billing cycle.&lt;/p&gt;
    # @param plan [String?]
    # @optional @param active [Bool?] Whether the plan is currently available for new subscriptions.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nickname [String?] A brief description of the plan, hidden from customers.
    # @optional @param product [String?] The product the plan belongs to. This cannot be changed once it has been used in a subscription or subscription schedule.
    # @optional @param trial_period_days [Int64?] Default number of trial days when subscribing a customer to this plan using [`trial_from_plan=true`](https://stripe.com/docs/api#create_subscription-trial_from_plan).
    # @return nil
    def post_plans_plan(*, plan : String? = nil, active : Bool? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nickname : String? = nil, product : String? = nil, trial_period_days : Int64? = nil, &block : Crest::Response ->)
      build_api_request_for_post_plans_plan(plan: plan, active: active, expand: expand, metadata: metadata, nickname: nickname, product: product, trial_period_days: trial_period_days).execute(&block)
    end

    POST_PLANS_PLAN_MAX_LENGTH_FOR_PLAN     = 5000
    POST_PLANS_PLAN_MAX_LENGTH_FOR_NICKNAME = 5000
    POST_PLANS_PLAN_MAX_LENGTH_FOR_PRODUCT  = 5000

    # @return Crest::Request
    def build_api_request_for_post_plans_plan(*, plan : String? = nil, active : Bool? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nickname : String? = nil, product : String? = nil, trial_period_days : Int64? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_plans_plan ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"plan\" is required and cannot be null") if plan.nil?
        if _plan = plan
          OpenApi::PrimitiveValidator.validate_max_length("plan", plan.to_s.size, POST_PLANS_PLAN_MAX_LENGTH_FOR_PLAN)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _nickname = nickname
          OpenApi::PrimitiveValidator.validate_max_length("nickname", nickname.to_s.size, POST_PLANS_PLAN_MAX_LENGTH_FOR_NICKNAME)
        end
        if _product = product
          OpenApi::PrimitiveValidator.validate_max_length("product", product.to_s.size, POST_PLANS_PLAN_MAX_LENGTH_FOR_PRODUCT)
        end
      end

      # resource path
      local_var_path = "/v1/plans/{plan}".sub("{" + "plan" + "}", URI.encode_path(plan.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["active"] = active.to_s if !active.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["nickname"] = nickname.to_s if !nickname.nil?
      form_params["product"] = product.to_s if !product.nil?
      form_params["trial_period_days"] = trial_period_days.to_s if !trial_period_days.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_plans_plan",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new price for an existing product. The price can be recurring or one-time.</p>
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param active [Bool?] Whether the price can be used for new purchases. Defaults to `true`.
    # @optional @param billing_scheme [String?] Describes how to compute the price per period. Either `per_unit` or `tiered`. `per_unit` indicates that the fixed amount (specified in `unit_amount` or `unit_amount_decimal`) will be charged per unit in `quantity` (for prices with `usage_type=licensed`), or per unit of total usage (for prices with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as defined using the `tiers` and `tiers_mode` attributes.
    # @optional @param custom_unit_amount [Stripe::CustomUnitAmount2?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param lookup_key [String?] A lookup key used to retrieve prices dynamically from a static string. This may be up to 200 characters.
    # @optional @param nickname [String?] A brief description of the price, hidden from customers.
    # @optional @param product [String?] The ID of the product that this price will belong to.
    # @optional @param product_data [Stripe::InlineProductParams1?]
    # @optional @param recurring [Stripe::Recurring1?]
    # @optional @param tax_behavior [String?] Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it cannot be changed.
    # @optional @param tiers [Array(Stripe::Tier)?] Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`. See also the documentation for `billing_scheme`.
    # @optional @param tiers_mode [String?] Defines if the tiering price should be `graduated` or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per unit price, in `graduated` tiering pricing can successively change as the quantity grows.
    # @optional @param transfer_lookup_key [Bool?] If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
    # @optional @param transform_quantity [Stripe::TransformUsageParam?]
    # @optional @param unit_amount [Int64?] A positive integer in cents (or local equivalent) (or 0 for a free price) representing how much to charge. One of `unit_amount` or `custom_unit_amount` is required, unless `billing_scheme=tiered`.
    # @optional @param unit_amount_decimal [String?] Same as `unit_amount`, but accepts a decimal value in cents (or local equivalent) with at most 12 decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
    # @return [Price]
    def post_prices(*, currency : String? = nil, active : Bool? = nil, billing_scheme : String? = nil, custom_unit_amount : Stripe::CustomUnitAmount2? = nil, expand : Array(String)? = nil, lookup_key : String? = nil, nickname : String? = nil, product : String? = nil, product_data : Stripe::InlineProductParams1? = nil, recurring : Stripe::Recurring1? = nil, tax_behavior : String? = nil, tiers : Array(Stripe::Tier)? = nil, tiers_mode : String? = nil, transfer_lookup_key : Bool? = nil, transform_quantity : Stripe::TransformUsageParam? = nil, unit_amount : Int64? = nil, unit_amount_decimal : String? = nil)
      data, _status_code, _headers = post_prices_with_http_info(currency: currency, active: active, billing_scheme: billing_scheme, custom_unit_amount: custom_unit_amount, expand: expand, lookup_key: lookup_key, nickname: nickname, product: product, product_data: product_data, recurring: recurring, tax_behavior: tax_behavior, tiers: tiers, tiers_mode: tiers_mode, transfer_lookup_key: transfer_lookup_key, transform_quantity: transform_quantity, unit_amount: unit_amount, unit_amount_decimal: unit_amount_decimal)
      data
    end

    # &lt;p&gt;Creates a new price for an existing product. The price can be recurring or one-time.&lt;/p&gt;
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param active [Bool?] Whether the price can be used for new purchases. Defaults to `true`.
    # @optional @param billing_scheme [String?] Describes how to compute the price per period. Either `per_unit` or `tiered`. `per_unit` indicates that the fixed amount (specified in `unit_amount` or `unit_amount_decimal`) will be charged per unit in `quantity` (for prices with `usage_type=licensed`), or per unit of total usage (for prices with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as defined using the `tiers` and `tiers_mode` attributes.
    # @optional @param custom_unit_amount [Stripe::CustomUnitAmount2?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param lookup_key [String?] A lookup key used to retrieve prices dynamically from a static string. This may be up to 200 characters.
    # @optional @param nickname [String?] A brief description of the price, hidden from customers.
    # @optional @param product [String?] The ID of the product that this price will belong to.
    # @optional @param product_data [Stripe::InlineProductParams1?]
    # @optional @param recurring [Stripe::Recurring1?]
    # @optional @param tax_behavior [String?] Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it cannot be changed.
    # @optional @param tiers [Array(Stripe::Tier)?] Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`. See also the documentation for `billing_scheme`.
    # @optional @param tiers_mode [String?] Defines if the tiering price should be `graduated` or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per unit price, in `graduated` tiering pricing can successively change as the quantity grows.
    # @optional @param transfer_lookup_key [Bool?] If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
    # @optional @param transform_quantity [Stripe::TransformUsageParam?]
    # @optional @param unit_amount [Int64?] A positive integer in cents (or local equivalent) (or 0 for a free price) representing how much to charge. One of `unit_amount` or `custom_unit_amount` is required, unless `billing_scheme=tiered`.
    # @optional @param unit_amount_decimal [String?] Same as `unit_amount`, but accepts a decimal value in cents (or local equivalent) with at most 12 decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
    # @return [Array<(Price, Integer, Hash)>] Price data, response status code and response headers
    def post_prices_with_http_info(*, currency : String? = nil, active : Bool? = nil, billing_scheme : String? = nil, custom_unit_amount : Stripe::CustomUnitAmount2? = nil, expand : Array(String)? = nil, lookup_key : String? = nil, nickname : String? = nil, product : String? = nil, product_data : Stripe::InlineProductParams1? = nil, recurring : Stripe::Recurring1? = nil, tax_behavior : String? = nil, tiers : Array(Stripe::Tier)? = nil, tiers_mode : String? = nil, transfer_lookup_key : Bool? = nil, transform_quantity : Stripe::TransformUsageParam? = nil, unit_amount : Int64? = nil, unit_amount_decimal : String? = nil)
      request = build_api_request_for_post_prices(currency: currency, active: active, billing_scheme: billing_scheme, custom_unit_amount: custom_unit_amount, expand: expand, lookup_key: lookup_key, nickname: nickname, product: product, product_data: product_data, recurring: recurring, tax_behavior: tax_behavior, tiers: tiers, tiers_mode: tiers_mode, transfer_lookup_key: transfer_lookup_key, transform_quantity: transform_quantity, unit_amount: unit_amount, unit_amount_decimal: unit_amount_decimal)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_prices\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Price.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new price for an existing product. The price can be recurring or one-time.&lt;/p&gt;
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param active [Bool?] Whether the price can be used for new purchases. Defaults to `true`.
    # @optional @param billing_scheme [String?] Describes how to compute the price per period. Either `per_unit` or `tiered`. `per_unit` indicates that the fixed amount (specified in `unit_amount` or `unit_amount_decimal`) will be charged per unit in `quantity` (for prices with `usage_type=licensed`), or per unit of total usage (for prices with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as defined using the `tiers` and `tiers_mode` attributes.
    # @optional @param custom_unit_amount [Stripe::CustomUnitAmount2?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param lookup_key [String?] A lookup key used to retrieve prices dynamically from a static string. This may be up to 200 characters.
    # @optional @param nickname [String?] A brief description of the price, hidden from customers.
    # @optional @param product [String?] The ID of the product that this price will belong to.
    # @optional @param product_data [Stripe::InlineProductParams1?]
    # @optional @param recurring [Stripe::Recurring1?]
    # @optional @param tax_behavior [String?] Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it cannot be changed.
    # @optional @param tiers [Array(Stripe::Tier)?] Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`. See also the documentation for `billing_scheme`.
    # @optional @param tiers_mode [String?] Defines if the tiering price should be `graduated` or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per unit price, in `graduated` tiering pricing can successively change as the quantity grows.
    # @optional @param transfer_lookup_key [Bool?] If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
    # @optional @param transform_quantity [Stripe::TransformUsageParam?]
    # @optional @param unit_amount [Int64?] A positive integer in cents (or local equivalent) (or 0 for a free price) representing how much to charge. One of `unit_amount` or `custom_unit_amount` is required, unless `billing_scheme=tiered`.
    # @optional @param unit_amount_decimal [String?] Same as `unit_amount`, but accepts a decimal value in cents (or local equivalent) with at most 12 decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
    # @return nil
    def post_prices(*, currency : String? = nil, active : Bool? = nil, billing_scheme : String? = nil, custom_unit_amount : Stripe::CustomUnitAmount2? = nil, expand : Array(String)? = nil, lookup_key : String? = nil, nickname : String? = nil, product : String? = nil, product_data : Stripe::InlineProductParams1? = nil, recurring : Stripe::Recurring1? = nil, tax_behavior : String? = nil, tiers : Array(Stripe::Tier)? = nil, tiers_mode : String? = nil, transfer_lookup_key : Bool? = nil, transform_quantity : Stripe::TransformUsageParam? = nil, unit_amount : Int64? = nil, unit_amount_decimal : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_prices(currency: currency, active: active, billing_scheme: billing_scheme, custom_unit_amount: custom_unit_amount, expand: expand, lookup_key: lookup_key, nickname: nickname, product: product, product_data: product_data, recurring: recurring, tax_behavior: tax_behavior, tiers: tiers, tiers_mode: tiers_mode, transfer_lookup_key: transfer_lookup_key, transform_quantity: transform_quantity, unit_amount: unit_amount, unit_amount_decimal: unit_amount_decimal).execute(&block)
    end

    POST_PRICES_VALID_VALUES_FOR_BILLING_SCHEME = StaticArray["per_unit", "tiered"]
    POST_PRICES_MAX_LENGTH_FOR_LOOKUP_KEY       =  200
    POST_PRICES_MAX_LENGTH_FOR_NICKNAME         = 5000
    POST_PRICES_MAX_LENGTH_FOR_PRODUCT          = 5000
    POST_PRICES_VALID_VALUES_FOR_TAX_BEHAVIOR   = StaticArray["exclusive", "inclusive", "unspecified"]
    POST_PRICES_VALID_VALUES_FOR_TIERS_MODE     = StaticArray["graduated", "volume"]

    # @return Crest::Request
    def build_api_request_for_post_prices(*, currency : String? = nil, active : Bool? = nil, billing_scheme : String? = nil, custom_unit_amount : Stripe::CustomUnitAmount2? = nil, expand : Array(String)? = nil, lookup_key : String? = nil, nickname : String? = nil, product : String? = nil, product_data : Stripe::InlineProductParams1? = nil, recurring : Stripe::Recurring1? = nil, tax_behavior : String? = nil, tiers : Array(Stripe::Tier)? = nil, tiers_mode : String? = nil, transfer_lookup_key : Bool? = nil, transform_quantity : Stripe::TransformUsageParam? = nil, unit_amount : Int64? = nil, unit_amount_decimal : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_prices ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"currency\" is required and cannot be null") if currency.nil?

        if _billing_scheme = billing_scheme
          OpenApi::EnumValidator.validate("billing_scheme", _billing_scheme, POST_PRICES_VALID_VALUES_FOR_BILLING_SCHEME)
        end
        if _custom_unit_amount = custom_unit_amount
          _custom_unit_amount.validate if _custom_unit_amount.is_a?(OpenApi::Validatable)
        end

        if _lookup_key = lookup_key
          OpenApi::PrimitiveValidator.validate_max_length("lookup_key", lookup_key.to_s.size, POST_PRICES_MAX_LENGTH_FOR_LOOKUP_KEY)
        end
        if _nickname = nickname
          OpenApi::PrimitiveValidator.validate_max_length("nickname", nickname.to_s.size, POST_PRICES_MAX_LENGTH_FOR_NICKNAME)
        end
        if _product = product
          OpenApi::PrimitiveValidator.validate_max_length("product", product.to_s.size, POST_PRICES_MAX_LENGTH_FOR_PRODUCT)
        end
        if _product_data = product_data
          _product_data.validate if _product_data.is_a?(OpenApi::Validatable)
        end
        if _recurring = recurring
          _recurring.validate if _recurring.is_a?(OpenApi::Validatable)
        end
        if _tax_behavior = tax_behavior
          OpenApi::EnumValidator.validate("tax_behavior", _tax_behavior, POST_PRICES_VALID_VALUES_FOR_TAX_BEHAVIOR)
        end
        if _tiers = tiers
          OpenApi::ContainerValidator.validate(container: _tiers) if _tiers.is_a?(Array)
        end
        if _tiers_mode = tiers_mode
          OpenApi::EnumValidator.validate("tiers_mode", _tiers_mode, POST_PRICES_VALID_VALUES_FOR_TIERS_MODE)
        end

        if _transform_quantity = transform_quantity
          _transform_quantity.validate if _transform_quantity.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/prices"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["active"] = active.to_s if !active.nil?
      form_params["billing_scheme"] = billing_scheme.to_s if !billing_scheme.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["custom_unit_amount"] = custom_unit_amount.to_s if !custom_unit_amount.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["lookup_key"] = lookup_key.to_s if !lookup_key.nil?
      form_params["nickname"] = nickname.to_s if !nickname.nil?
      form_params["product"] = product.to_s if !product.nil?
      form_params["product_data"] = product_data.to_s if !product_data.nil?
      form_params["recurring"] = recurring.to_s if !recurring.nil?
      form_params["tax_behavior"] = tax_behavior.to_s if !tax_behavior.nil?
      form_params["tiers"] = @api_client.build_collection_param(tiers, "csv") if !tiers.nil? && !tiers.empty?
      form_params["tiers_mode"] = tiers_mode.to_s if !tiers_mode.nil?
      form_params["transfer_lookup_key"] = transfer_lookup_key.to_s if !transfer_lookup_key.nil?
      form_params["transform_quantity"] = transform_quantity.to_s if !transform_quantity.nil?
      form_params["unit_amount"] = unit_amount.to_s if !unit_amount.nil?
      form_params["unit_amount_decimal"] = unit_amount_decimal.to_s if !unit_amount_decimal.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_prices",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the specified price by setting the values of the parameters passed. Any parameters not provided are left unchanged.</p>
    # @param price [String?]
    # @optional @param active [Bool?] Whether the price can be used for new purchases. Defaults to `true`.
    # @optional @param currency_options [Stripe::PostPricesPriceRequestCurrencyOptions?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param lookup_key [String?] A lookup key used to retrieve prices dynamically from a static string. This may be up to 200 characters.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nickname [String?] A brief description of the price, hidden from customers.
    # @optional @param tax_behavior [String?] Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it cannot be changed.
    # @optional @param transfer_lookup_key [Bool?] If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
    # @return [Price]
    def post_prices_price(*, price : String? = nil, active : Bool? = nil, currency_options : Stripe::PostPricesPriceRequestCurrencyOptions? = nil, expand : Array(String)? = nil, lookup_key : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nickname : String? = nil, tax_behavior : String? = nil, transfer_lookup_key : Bool? = nil)
      data, _status_code, _headers = post_prices_price_with_http_info(price: price, active: active, currency_options: currency_options, expand: expand, lookup_key: lookup_key, metadata: metadata, nickname: nickname, tax_behavior: tax_behavior, transfer_lookup_key: transfer_lookup_key)
      data
    end

    # &lt;p&gt;Updates the specified price by setting the values of the parameters passed. Any parameters not provided are left unchanged.&lt;/p&gt;
    # @param price [String?]
    # @optional @param active [Bool?] Whether the price can be used for new purchases. Defaults to `true`.
    # @optional @param currency_options [Stripe::PostPricesPriceRequestCurrencyOptions?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param lookup_key [String?] A lookup key used to retrieve prices dynamically from a static string. This may be up to 200 characters.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nickname [String?] A brief description of the price, hidden from customers.
    # @optional @param tax_behavior [String?] Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it cannot be changed.
    # @optional @param transfer_lookup_key [Bool?] If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
    # @return [Array<(Price, Integer, Hash)>] Price data, response status code and response headers
    def post_prices_price_with_http_info(*, price : String? = nil, active : Bool? = nil, currency_options : Stripe::PostPricesPriceRequestCurrencyOptions? = nil, expand : Array(String)? = nil, lookup_key : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nickname : String? = nil, tax_behavior : String? = nil, transfer_lookup_key : Bool? = nil)
      request = build_api_request_for_post_prices_price(price: price, active: active, currency_options: currency_options, expand: expand, lookup_key: lookup_key, metadata: metadata, nickname: nickname, tax_behavior: tax_behavior, transfer_lookup_key: transfer_lookup_key)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_prices_price\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Price.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the specified price by setting the values of the parameters passed. Any parameters not provided are left unchanged.&lt;/p&gt;
    # @param price [String?]
    # @optional @param active [Bool?] Whether the price can be used for new purchases. Defaults to `true`.
    # @optional @param currency_options [Stripe::PostPricesPriceRequestCurrencyOptions?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param lookup_key [String?] A lookup key used to retrieve prices dynamically from a static string. This may be up to 200 characters.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param nickname [String?] A brief description of the price, hidden from customers.
    # @optional @param tax_behavior [String?] Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it cannot be changed.
    # @optional @param transfer_lookup_key [Bool?] If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
    # @return nil
    def post_prices_price(*, price : String? = nil, active : Bool? = nil, currency_options : Stripe::PostPricesPriceRequestCurrencyOptions? = nil, expand : Array(String)? = nil, lookup_key : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nickname : String? = nil, tax_behavior : String? = nil, transfer_lookup_key : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_post_prices_price(price: price, active: active, currency_options: currency_options, expand: expand, lookup_key: lookup_key, metadata: metadata, nickname: nickname, tax_behavior: tax_behavior, transfer_lookup_key: transfer_lookup_key).execute(&block)
    end

    POST_PRICES_PRICE_MAX_LENGTH_FOR_PRICE          = 5000
    POST_PRICES_PRICE_MAX_LENGTH_FOR_LOOKUP_KEY     =  200
    POST_PRICES_PRICE_MAX_LENGTH_FOR_NICKNAME       = 5000
    POST_PRICES_PRICE_VALID_VALUES_FOR_TAX_BEHAVIOR = StaticArray["exclusive", "inclusive", "unspecified"]

    # @return Crest::Request
    def build_api_request_for_post_prices_price(*, price : String? = nil, active : Bool? = nil, currency_options : Stripe::PostPricesPriceRequestCurrencyOptions? = nil, expand : Array(String)? = nil, lookup_key : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, nickname : String? = nil, tax_behavior : String? = nil, transfer_lookup_key : Bool? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_prices_price ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"price\" is required and cannot be null") if price.nil?
        if _price = price
          OpenApi::PrimitiveValidator.validate_max_length("price", price.to_s.size, POST_PRICES_PRICE_MAX_LENGTH_FOR_PRICE)
        end

        if _currency_options = currency_options
          _currency_options.validate if _currency_options.is_a?(OpenApi::Validatable)
        end

        if _lookup_key = lookup_key
          OpenApi::PrimitiveValidator.validate_max_length("lookup_key", lookup_key.to_s.size, POST_PRICES_PRICE_MAX_LENGTH_FOR_LOOKUP_KEY)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _nickname = nickname
          OpenApi::PrimitiveValidator.validate_max_length("nickname", nickname.to_s.size, POST_PRICES_PRICE_MAX_LENGTH_FOR_NICKNAME)
        end
        if _tax_behavior = tax_behavior
          OpenApi::EnumValidator.validate("tax_behavior", _tax_behavior, POST_PRICES_PRICE_VALID_VALUES_FOR_TAX_BEHAVIOR)
        end
      end

      # resource path
      local_var_path = "/v1/prices/{price}".sub("{" + "price" + "}", URI.encode_path(price.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["active"] = active.to_s if !active.nil?
      form_params["currency_options"] = currency_options.to_s if !currency_options.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["lookup_key"] = lookup_key.to_s if !lookup_key.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["nickname"] = nickname.to_s if !nickname.nil?
      form_params["tax_behavior"] = tax_behavior.to_s if !tax_behavior.nil?
      form_params["transfer_lookup_key"] = transfer_lookup_key.to_s if !transfer_lookup_key.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_prices_price",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new product object.</p>
    # @param name [String?] The product's name, meant to be displayable to the customer.
    # @optional @param active [Bool?] Whether the product is currently available for purchase. Defaults to `true`.
    # @optional @param default_price_data [Stripe::PriceDataWithoutProduct?]
    # @optional @param description [String?] The product's description, meant to be displayable to the customer. Use this field to optionally store a long form explanation of the product being sold for your own rendering purposes.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param id [String?] An identifier will be randomly generated by Stripe. You can optionally override this ID, but the ID must be unique across all products in your Stripe account.
    # @optional @param images [Array(String)?] A list of up to 8 URLs of images for this product, meant to be displayable to the customer.
    # @optional @param package_dimensions [Stripe::PackageDimensionsSpecs1?]
    # @optional @param shippable [Bool?] Whether this product is shipped (i.e., physical goods).
    # @optional @param statement_descriptor [String?] An arbitrary string to be displayed on your customer's credit card or bank statement. While most banks display this information consistently, some may display it incorrectly or not at all.  This may be up to 22 characters. The statement description may not include `<`, `>`, `\\\\`, `\\\"`, `'` characters, and will appear on your customer's statement in capital letters. Non-ASCII characters are automatically stripped.  It must contain at least one letter.
    # @optional @param tax_code [String?] A [tax code](https://stripe.com/docs/tax/tax-categories) ID.
    # @optional @param unit_label [String?] A label that represents units of this product in Stripe and on customers’ receipts and invoices. When set, this will be included in associated invoice line item descriptions.
    # @optional @param url [String?] A URL of a publicly-accessible webpage for this product.
    # @return [Product]
    def post_products(*, name : String? = nil, active : Bool? = nil, default_price_data : Stripe::PriceDataWithoutProduct? = nil, description : String? = nil, expand : Array(String)? = nil, id : String? = nil, images : Array(String)? = nil, package_dimensions : Stripe::PackageDimensionsSpecs1? = nil, shippable : Bool? = nil, statement_descriptor : String? = nil, tax_code : String? = nil, unit_label : String? = nil, url : String? = nil)
      data, _status_code, _headers = post_products_with_http_info(name: name, active: active, default_price_data: default_price_data, description: description, expand: expand, id: id, images: images, package_dimensions: package_dimensions, shippable: shippable, statement_descriptor: statement_descriptor, tax_code: tax_code, unit_label: unit_label, url: url)
      data
    end

    # &lt;p&gt;Creates a new product object.&lt;/p&gt;
    # @param name [String?] The product's name, meant to be displayable to the customer.
    # @optional @param active [Bool?] Whether the product is currently available for purchase. Defaults to `true`.
    # @optional @param default_price_data [Stripe::PriceDataWithoutProduct?]
    # @optional @param description [String?] The product's description, meant to be displayable to the customer. Use this field to optionally store a long form explanation of the product being sold for your own rendering purposes.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param id [String?] An identifier will be randomly generated by Stripe. You can optionally override this ID, but the ID must be unique across all products in your Stripe account.
    # @optional @param images [Array(String)?] A list of up to 8 URLs of images for this product, meant to be displayable to the customer.
    # @optional @param package_dimensions [Stripe::PackageDimensionsSpecs1?]
    # @optional @param shippable [Bool?] Whether this product is shipped (i.e., physical goods).
    # @optional @param statement_descriptor [String?] An arbitrary string to be displayed on your customer's credit card or bank statement. While most banks display this information consistently, some may display it incorrectly or not at all.  This may be up to 22 characters. The statement description may not include `<`, `>`, `\\\\`, `\\\"`, `'` characters, and will appear on your customer's statement in capital letters. Non-ASCII characters are automatically stripped.  It must contain at least one letter.
    # @optional @param tax_code [String?] A [tax code](https://stripe.com/docs/tax/tax-categories) ID.
    # @optional @param unit_label [String?] A label that represents units of this product in Stripe and on customers’ receipts and invoices. When set, this will be included in associated invoice line item descriptions.
    # @optional @param url [String?] A URL of a publicly-accessible webpage for this product.
    # @return [Array<(Product, Integer, Hash)>] Product data, response status code and response headers
    def post_products_with_http_info(*, name : String? = nil, active : Bool? = nil, default_price_data : Stripe::PriceDataWithoutProduct? = nil, description : String? = nil, expand : Array(String)? = nil, id : String? = nil, images : Array(String)? = nil, package_dimensions : Stripe::PackageDimensionsSpecs1? = nil, shippable : Bool? = nil, statement_descriptor : String? = nil, tax_code : String? = nil, unit_label : String? = nil, url : String? = nil)
      request = build_api_request_for_post_products(name: name, active: active, default_price_data: default_price_data, description: description, expand: expand, id: id, images: images, package_dimensions: package_dimensions, shippable: shippable, statement_descriptor: statement_descriptor, tax_code: tax_code, unit_label: unit_label, url: url)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_products\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Product.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new product object.&lt;/p&gt;
    # @param name [String?] The product's name, meant to be displayable to the customer.
    # @optional @param active [Bool?] Whether the product is currently available for purchase. Defaults to `true`.
    # @optional @param default_price_data [Stripe::PriceDataWithoutProduct?]
    # @optional @param description [String?] The product's description, meant to be displayable to the customer. Use this field to optionally store a long form explanation of the product being sold for your own rendering purposes.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param id [String?] An identifier will be randomly generated by Stripe. You can optionally override this ID, but the ID must be unique across all products in your Stripe account.
    # @optional @param images [Array(String)?] A list of up to 8 URLs of images for this product, meant to be displayable to the customer.
    # @optional @param package_dimensions [Stripe::PackageDimensionsSpecs1?]
    # @optional @param shippable [Bool?] Whether this product is shipped (i.e., physical goods).
    # @optional @param statement_descriptor [String?] An arbitrary string to be displayed on your customer's credit card or bank statement. While most banks display this information consistently, some may display it incorrectly or not at all.  This may be up to 22 characters. The statement description may not include `<`, `>`, `\\\\`, `\\\"`, `'` characters, and will appear on your customer's statement in capital letters. Non-ASCII characters are automatically stripped.  It must contain at least one letter.
    # @optional @param tax_code [String?] A [tax code](https://stripe.com/docs/tax/tax-categories) ID.
    # @optional @param unit_label [String?] A label that represents units of this product in Stripe and on customers’ receipts and invoices. When set, this will be included in associated invoice line item descriptions.
    # @optional @param url [String?] A URL of a publicly-accessible webpage for this product.
    # @return nil
    def post_products(*, name : String? = nil, active : Bool? = nil, default_price_data : Stripe::PriceDataWithoutProduct? = nil, description : String? = nil, expand : Array(String)? = nil, id : String? = nil, images : Array(String)? = nil, package_dimensions : Stripe::PackageDimensionsSpecs1? = nil, shippable : Bool? = nil, statement_descriptor : String? = nil, tax_code : String? = nil, unit_label : String? = nil, url : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_products(name: name, active: active, default_price_data: default_price_data, description: description, expand: expand, id: id, images: images, package_dimensions: package_dimensions, shippable: shippable, statement_descriptor: statement_descriptor, tax_code: tax_code, unit_label: unit_label, url: url).execute(&block)
    end

    POST_PRODUCTS_MAX_LENGTH_FOR_NAME                 =  5000
    POST_PRODUCTS_MAX_LENGTH_FOR_DESCRIPTION          = 40000
    POST_PRODUCTS_MAX_LENGTH_FOR_ID                   =  5000
    POST_PRODUCTS_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR =    22
    POST_PRODUCTS_MAX_LENGTH_FOR_UNIT_LABEL           =    12
    POST_PRODUCTS_MAX_LENGTH_FOR_URL                  =  5000

    # @return Crest::Request
    def build_api_request_for_post_products(*, name : String? = nil, active : Bool? = nil, default_price_data : Stripe::PriceDataWithoutProduct? = nil, description : String? = nil, expand : Array(String)? = nil, id : String? = nil, images : Array(String)? = nil, package_dimensions : Stripe::PackageDimensionsSpecs1? = nil, shippable : Bool? = nil, statement_descriptor : String? = nil, tax_code : String? = nil, unit_label : String? = nil, url : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_products ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"name\" is required and cannot be null") if name.nil?
        if _name = name
          OpenApi::PrimitiveValidator.validate_max_length("name", name.to_s.size, POST_PRODUCTS_MAX_LENGTH_FOR_NAME)
        end

        if _default_price_data = default_price_data
          _default_price_data.validate if _default_price_data.is_a?(OpenApi::Validatable)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_PRODUCTS_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_PRODUCTS_MAX_LENGTH_FOR_ID)
        end

        if _package_dimensions = package_dimensions
          _package_dimensions.validate if _package_dimensions.is_a?(OpenApi::Validatable)
        end

        if _statement_descriptor = statement_descriptor
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor", statement_descriptor.to_s.size, POST_PRODUCTS_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR)
        end

        if _unit_label = unit_label
          OpenApi::PrimitiveValidator.validate_max_length("unit_label", unit_label.to_s.size, POST_PRODUCTS_MAX_LENGTH_FOR_UNIT_LABEL)
        end
        if _url = url
          OpenApi::PrimitiveValidator.validate_max_length("url", url.to_s.size, POST_PRODUCTS_MAX_LENGTH_FOR_URL)
        end
      end

      # resource path
      local_var_path = "/v1/products"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["active"] = active.to_s if !active.nil?
      form_params["default_price_data"] = default_price_data.to_s if !default_price_data.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["id"] = id.to_s if !id.nil?
      form_params["images"] = @api_client.build_collection_param(images, "csv") if !images.nil? && !images.empty?
      form_params["name"] = name.to_s if !name.nil?
      form_params["package_dimensions"] = package_dimensions.to_s if !package_dimensions.nil?
      form_params["shippable"] = shippable.to_s if !shippable.nil?
      form_params["statement_descriptor"] = statement_descriptor.to_s if !statement_descriptor.nil?
      form_params["tax_code"] = tax_code.to_s if !tax_code.nil?
      form_params["unit_label"] = unit_label.to_s if !unit_label.nil?
      form_params["url"] = url.to_s if !url.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_products",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the specific product by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
    # @param id [String?]
    # @optional @param active [Bool?] Whether the product is available for purchase.
    # @optional @param default_price [String?] The ID of the [Price](https://stripe.com/docs/api/prices) object that is the default price for this product.
    # @optional @param description [String?] The product's description, meant to be displayable to the customer. Use this field to optionally store a long form explanation of the product being sold for your own rendering purposes.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param images [Stripe::PostProductsIdRequestImages?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] The product's name, meant to be displayable to the customer.
    # @optional @param package_dimensions [Stripe::PostProductsIdRequestPackageDimensions?]
    # @optional @param shippable [Bool?] Whether this product is shipped (i.e., physical goods).
    # @optional @param statement_descriptor [String?] An arbitrary string to be displayed on your customer's credit card or bank statement. While most banks display this information consistently, some may display it incorrectly or not at all.  This may be up to 22 characters. The statement description may not include `<`, `>`, `\\\\`, `\\\"`, `'` characters, and will appear on your customer's statement in capital letters. Non-ASCII characters are automatically stripped.  It must contain at least one letter. May only be set if `type=service`.
    # @optional @param tax_code [Stripe::PostProductsIdRequestTaxCode?]
    # @optional @param unit_label [String?] A label that represents units of this product in Stripe and on customers’ receipts and invoices. When set, this will be included in associated invoice line item descriptions. May only be set if `type=service`.
    # @optional @param url [Stripe::PostProductsIdRequestUrl?]
    # @return [Product]
    def post_products_id(*, id : String? = nil, active : Bool? = nil, default_price : String? = nil, description : String? = nil, expand : Array(String)? = nil, images : Stripe::PostProductsIdRequestImages? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, package_dimensions : Stripe::PostProductsIdRequestPackageDimensions? = nil, shippable : Bool? = nil, statement_descriptor : String? = nil, tax_code : Stripe::PostProductsIdRequestTaxCode? = nil, unit_label : String? = nil, url : Stripe::PostProductsIdRequestUrl? = nil)
      data, _status_code, _headers = post_products_id_with_http_info(id: id, active: active, default_price: default_price, description: description, expand: expand, images: images, metadata: metadata, name: name, package_dimensions: package_dimensions, shippable: shippable, statement_descriptor: statement_descriptor, tax_code: tax_code, unit_label: unit_label, url: url)
      data
    end

    # &lt;p&gt;Updates the specific product by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;
    # @param id [String?]
    # @optional @param active [Bool?] Whether the product is available for purchase.
    # @optional @param default_price [String?] The ID of the [Price](https://stripe.com/docs/api/prices) object that is the default price for this product.
    # @optional @param description [String?] The product's description, meant to be displayable to the customer. Use this field to optionally store a long form explanation of the product being sold for your own rendering purposes.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param images [Stripe::PostProductsIdRequestImages?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] The product's name, meant to be displayable to the customer.
    # @optional @param package_dimensions [Stripe::PostProductsIdRequestPackageDimensions?]
    # @optional @param shippable [Bool?] Whether this product is shipped (i.e., physical goods).
    # @optional @param statement_descriptor [String?] An arbitrary string to be displayed on your customer's credit card or bank statement. While most banks display this information consistently, some may display it incorrectly or not at all.  This may be up to 22 characters. The statement description may not include `<`, `>`, `\\\\`, `\\\"`, `'` characters, and will appear on your customer's statement in capital letters. Non-ASCII characters are automatically stripped.  It must contain at least one letter. May only be set if `type=service`.
    # @optional @param tax_code [Stripe::PostProductsIdRequestTaxCode?]
    # @optional @param unit_label [String?] A label that represents units of this product in Stripe and on customers’ receipts and invoices. When set, this will be included in associated invoice line item descriptions. May only be set if `type=service`.
    # @optional @param url [Stripe::PostProductsIdRequestUrl?]
    # @return [Array<(Product, Integer, Hash)>] Product data, response status code and response headers
    def post_products_id_with_http_info(*, id : String? = nil, active : Bool? = nil, default_price : String? = nil, description : String? = nil, expand : Array(String)? = nil, images : Stripe::PostProductsIdRequestImages? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, package_dimensions : Stripe::PostProductsIdRequestPackageDimensions? = nil, shippable : Bool? = nil, statement_descriptor : String? = nil, tax_code : Stripe::PostProductsIdRequestTaxCode? = nil, unit_label : String? = nil, url : Stripe::PostProductsIdRequestUrl? = nil)
      request = build_api_request_for_post_products_id(id: id, active: active, default_price: default_price, description: description, expand: expand, images: images, metadata: metadata, name: name, package_dimensions: package_dimensions, shippable: shippable, statement_descriptor: statement_descriptor, tax_code: tax_code, unit_label: unit_label, url: url)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_products_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Product.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the specific product by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;
    # @param id [String?]
    # @optional @param active [Bool?] Whether the product is available for purchase.
    # @optional @param default_price [String?] The ID of the [Price](https://stripe.com/docs/api/prices) object that is the default price for this product.
    # @optional @param description [String?] The product's description, meant to be displayable to the customer. Use this field to optionally store a long form explanation of the product being sold for your own rendering purposes.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param images [Stripe::PostProductsIdRequestImages?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param name [String?] The product's name, meant to be displayable to the customer.
    # @optional @param package_dimensions [Stripe::PostProductsIdRequestPackageDimensions?]
    # @optional @param shippable [Bool?] Whether this product is shipped (i.e., physical goods).
    # @optional @param statement_descriptor [String?] An arbitrary string to be displayed on your customer's credit card or bank statement. While most banks display this information consistently, some may display it incorrectly or not at all.  This may be up to 22 characters. The statement description may not include `<`, `>`, `\\\\`, `\\\"`, `'` characters, and will appear on your customer's statement in capital letters. Non-ASCII characters are automatically stripped.  It must contain at least one letter. May only be set if `type=service`.
    # @optional @param tax_code [Stripe::PostProductsIdRequestTaxCode?]
    # @optional @param unit_label [String?] A label that represents units of this product in Stripe and on customers’ receipts and invoices. When set, this will be included in associated invoice line item descriptions. May only be set if `type=service`.
    # @optional @param url [Stripe::PostProductsIdRequestUrl?]
    # @return nil
    def post_products_id(*, id : String? = nil, active : Bool? = nil, default_price : String? = nil, description : String? = nil, expand : Array(String)? = nil, images : Stripe::PostProductsIdRequestImages? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, package_dimensions : Stripe::PostProductsIdRequestPackageDimensions? = nil, shippable : Bool? = nil, statement_descriptor : String? = nil, tax_code : Stripe::PostProductsIdRequestTaxCode? = nil, unit_label : String? = nil, url : Stripe::PostProductsIdRequestUrl? = nil, &block : Crest::Response ->)
      build_api_request_for_post_products_id(id: id, active: active, default_price: default_price, description: description, expand: expand, images: images, metadata: metadata, name: name, package_dimensions: package_dimensions, shippable: shippable, statement_descriptor: statement_descriptor, tax_code: tax_code, unit_label: unit_label, url: url).execute(&block)
    end

    POST_PRODUCTS_ID_MAX_LENGTH_FOR_ID                   =  5000
    POST_PRODUCTS_ID_MAX_LENGTH_FOR_DEFAULT_PRICE        =  5000
    POST_PRODUCTS_ID_MAX_LENGTH_FOR_DESCRIPTION          = 40000
    POST_PRODUCTS_ID_MAX_LENGTH_FOR_NAME                 =  5000
    POST_PRODUCTS_ID_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR =    22
    POST_PRODUCTS_ID_MAX_LENGTH_FOR_UNIT_LABEL           =    12

    # @return Crest::Request
    def build_api_request_for_post_products_id(*, id : String? = nil, active : Bool? = nil, default_price : String? = nil, description : String? = nil, expand : Array(String)? = nil, images : Stripe::PostProductsIdRequestImages? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, name : String? = nil, package_dimensions : Stripe::PostProductsIdRequestPackageDimensions? = nil, shippable : Bool? = nil, statement_descriptor : String? = nil, tax_code : Stripe::PostProductsIdRequestTaxCode? = nil, unit_label : String? = nil, url : Stripe::PostProductsIdRequestUrl? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_products_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_PRODUCTS_ID_MAX_LENGTH_FOR_ID)
        end

        if _default_price = default_price
          OpenApi::PrimitiveValidator.validate_max_length("default_price", default_price.to_s.size, POST_PRODUCTS_ID_MAX_LENGTH_FOR_DEFAULT_PRICE)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_PRODUCTS_ID_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _images = images
          _images.validate if _images.is_a?(OpenApi::Validatable)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _name = name
          OpenApi::PrimitiveValidator.validate_max_length("name", name.to_s.size, POST_PRODUCTS_ID_MAX_LENGTH_FOR_NAME)
        end
        if _package_dimensions = package_dimensions
          _package_dimensions.validate if _package_dimensions.is_a?(OpenApi::Validatable)
        end

        if _statement_descriptor = statement_descriptor
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor", statement_descriptor.to_s.size, POST_PRODUCTS_ID_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR)
        end
        if _tax_code = tax_code
          _tax_code.validate if _tax_code.is_a?(OpenApi::Validatable)
        end
        if _unit_label = unit_label
          OpenApi::PrimitiveValidator.validate_max_length("unit_label", unit_label.to_s.size, POST_PRODUCTS_ID_MAX_LENGTH_FOR_UNIT_LABEL)
        end
        if _url = url
          _url.validate if _url.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/products/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["active"] = active.to_s if !active.nil?
      form_params["default_price"] = default_price.to_s if !default_price.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["images"] = images.to_s if !images.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["name"] = name.to_s if !name.nil?
      form_params["package_dimensions"] = package_dimensions.to_s if !package_dimensions.nil?
      form_params["shippable"] = shippable.to_s if !shippable.nil?
      form_params["statement_descriptor"] = statement_descriptor.to_s if !statement_descriptor.nil?
      form_params["tax_code"] = tax_code.to_s if !tax_code.nil?
      form_params["unit_label"] = unit_label.to_s if !unit_label.nil?
      form_params["url"] = url.to_s if !url.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_products_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>A promotion code points to a coupon. You can optionally restrict the code to a specific customer, redemption limit, and expiration date.</p>
    # @param coupon [String?] The coupon for this promotion code.
    # @optional @param active [Bool?] Whether the promotion code is currently active.
    # @optional @param code [String?] The customer-facing code. Regardless of case, this code must be unique across all active promotion codes for a specific customer. If left blank, we will generate one automatically.
    # @optional @param customer [String?] The customer that this promotion code can be used by. If not set, the promotion code can be used by all customers.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] The timestamp at which this promotion code will expire. If the coupon has specified a `redeems_by`, then this value cannot be after the coupon's `redeems_by`.
    # @optional @param max_redemptions [Int64?] A positive integer specifying the number of times the promotion code can be redeemed. If the coupon has specified a `max_redemptions`, then this value cannot be greater than the coupon's `max_redemptions`.
    # @optional @param restrictions [Stripe::RestrictionsParams?]
    # @return [PromotionCode]
    def post_promotion_codes(*, coupon : String? = nil, active : Bool? = nil, code : String? = nil, customer : String? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, max_redemptions : Int64? = nil, restrictions : Stripe::RestrictionsParams? = nil)
      data, _status_code, _headers = post_promotion_codes_with_http_info(coupon: coupon, active: active, code: code, customer: customer, expand: expand, expires_at: expires_at, max_redemptions: max_redemptions, restrictions: restrictions)
      data
    end

    # &lt;p&gt;A promotion code points to a coupon. You can optionally restrict the code to a specific customer, redemption limit, and expiration date.&lt;/p&gt;
    # @param coupon [String?] The coupon for this promotion code.
    # @optional @param active [Bool?] Whether the promotion code is currently active.
    # @optional @param code [String?] The customer-facing code. Regardless of case, this code must be unique across all active promotion codes for a specific customer. If left blank, we will generate one automatically.
    # @optional @param customer [String?] The customer that this promotion code can be used by. If not set, the promotion code can be used by all customers.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] The timestamp at which this promotion code will expire. If the coupon has specified a `redeems_by`, then this value cannot be after the coupon's `redeems_by`.
    # @optional @param max_redemptions [Int64?] A positive integer specifying the number of times the promotion code can be redeemed. If the coupon has specified a `max_redemptions`, then this value cannot be greater than the coupon's `max_redemptions`.
    # @optional @param restrictions [Stripe::RestrictionsParams?]
    # @return [Array<(PromotionCode, Integer, Hash)>] PromotionCode data, response status code and response headers
    def post_promotion_codes_with_http_info(*, coupon : String? = nil, active : Bool? = nil, code : String? = nil, customer : String? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, max_redemptions : Int64? = nil, restrictions : Stripe::RestrictionsParams? = nil)
      request = build_api_request_for_post_promotion_codes(coupon: coupon, active: active, code: code, customer: customer, expand: expand, expires_at: expires_at, max_redemptions: max_redemptions, restrictions: restrictions)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_promotion_codes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PromotionCode.from_json(data), status_code, headers
    end

    # &lt;p&gt;A promotion code points to a coupon. You can optionally restrict the code to a specific customer, redemption limit, and expiration date.&lt;/p&gt;
    # @param coupon [String?] The coupon for this promotion code.
    # @optional @param active [Bool?] Whether the promotion code is currently active.
    # @optional @param code [String?] The customer-facing code. Regardless of case, this code must be unique across all active promotion codes for a specific customer. If left blank, we will generate one automatically.
    # @optional @param customer [String?] The customer that this promotion code can be used by. If not set, the promotion code can be used by all customers.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] The timestamp at which this promotion code will expire. If the coupon has specified a `redeems_by`, then this value cannot be after the coupon's `redeems_by`.
    # @optional @param max_redemptions [Int64?] A positive integer specifying the number of times the promotion code can be redeemed. If the coupon has specified a `max_redemptions`, then this value cannot be greater than the coupon's `max_redemptions`.
    # @optional @param restrictions [Stripe::RestrictionsParams?]
    # @return nil
    def post_promotion_codes(*, coupon : String? = nil, active : Bool? = nil, code : String? = nil, customer : String? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, max_redemptions : Int64? = nil, restrictions : Stripe::RestrictionsParams? = nil, &block : Crest::Response ->)
      build_api_request_for_post_promotion_codes(coupon: coupon, active: active, code: code, customer: customer, expand: expand, expires_at: expires_at, max_redemptions: max_redemptions, restrictions: restrictions).execute(&block)
    end

    POST_PROMOTION_CODES_MAX_LENGTH_FOR_COUPON   = 5000
    POST_PROMOTION_CODES_MAX_LENGTH_FOR_CODE     =  500
    POST_PROMOTION_CODES_MAX_LENGTH_FOR_CUSTOMER = 5000

    # @return Crest::Request
    def build_api_request_for_post_promotion_codes(*, coupon : String? = nil, active : Bool? = nil, code : String? = nil, customer : String? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, max_redemptions : Int64? = nil, restrictions : Stripe::RestrictionsParams? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_promotion_codes ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"coupon\" is required and cannot be null") if coupon.nil?
        if _coupon = coupon
          OpenApi::PrimitiveValidator.validate_max_length("coupon", coupon.to_s.size, POST_PROMOTION_CODES_MAX_LENGTH_FOR_COUPON)
        end

        if _code = code
          OpenApi::PrimitiveValidator.validate_max_length("code", code.to_s.size, POST_PROMOTION_CODES_MAX_LENGTH_FOR_CODE)
        end
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_PROMOTION_CODES_MAX_LENGTH_FOR_CUSTOMER)
        end

        if _restrictions = restrictions
          _restrictions.validate if _restrictions.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/promotion_codes"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["active"] = active.to_s if !active.nil?
      form_params["code"] = code.to_s if !code.nil?
      form_params["coupon"] = coupon.to_s if !coupon.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["expires_at"] = expires_at.to_s if !expires_at.nil?
      form_params["max_redemptions"] = max_redemptions.to_s if !max_redemptions.nil?
      form_params["restrictions"] = restrictions.to_s if !restrictions.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_promotion_codes",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the specified promotion code by setting the values of the parameters passed. Most fields are, by design, not editable.</p>
    # @param promotion_code [String?]
    # @optional @param active [Bool?] Whether the promotion code is currently active. A promotion code can only be reactivated when the coupon is still valid and the promotion code is otherwise redeemable.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param restrictions [Stripe::RestrictionsParams1?]
    # @return [PromotionCode]
    def post_promotion_codes_promotion_code(*, promotion_code : String? = nil, active : Bool? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, restrictions : Stripe::RestrictionsParams1? = nil)
      data, _status_code, _headers = post_promotion_codes_promotion_code_with_http_info(promotion_code: promotion_code, active: active, expand: expand, metadata: metadata, restrictions: restrictions)
      data
    end

    # &lt;p&gt;Updates the specified promotion code by setting the values of the parameters passed. Most fields are, by design, not editable.&lt;/p&gt;
    # @param promotion_code [String?]
    # @optional @param active [Bool?] Whether the promotion code is currently active. A promotion code can only be reactivated when the coupon is still valid and the promotion code is otherwise redeemable.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param restrictions [Stripe::RestrictionsParams1?]
    # @return [Array<(PromotionCode, Integer, Hash)>] PromotionCode data, response status code and response headers
    def post_promotion_codes_promotion_code_with_http_info(*, promotion_code : String? = nil, active : Bool? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, restrictions : Stripe::RestrictionsParams1? = nil)
      request = build_api_request_for_post_promotion_codes_promotion_code(promotion_code: promotion_code, active: active, expand: expand, metadata: metadata, restrictions: restrictions)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_promotion_codes_promotion_code\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return PromotionCode.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the specified promotion code by setting the values of the parameters passed. Most fields are, by design, not editable.&lt;/p&gt;
    # @param promotion_code [String?]
    # @optional @param active [Bool?] Whether the promotion code is currently active. A promotion code can only be reactivated when the coupon is still valid and the promotion code is otherwise redeemable.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param restrictions [Stripe::RestrictionsParams1?]
    # @return nil
    def post_promotion_codes_promotion_code(*, promotion_code : String? = nil, active : Bool? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, restrictions : Stripe::RestrictionsParams1? = nil, &block : Crest::Response ->)
      build_api_request_for_post_promotion_codes_promotion_code(promotion_code: promotion_code, active: active, expand: expand, metadata: metadata, restrictions: restrictions).execute(&block)
    end

    POST_PROMOTION_CODES_PROMOTION_CODE_MAX_LENGTH_FOR_PROMOTION_CODE = 5000

    # @return Crest::Request
    def build_api_request_for_post_promotion_codes_promotion_code(*, promotion_code : String? = nil, active : Bool? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, restrictions : Stripe::RestrictionsParams1? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_promotion_codes_promotion_code ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"promotion_code\" is required and cannot be null") if promotion_code.nil?
        if _promotion_code = promotion_code
          OpenApi::PrimitiveValidator.validate_max_length("promotion_code", promotion_code.to_s.size, POST_PROMOTION_CODES_PROMOTION_CODE_MAX_LENGTH_FOR_PROMOTION_CODE)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _restrictions = restrictions
          _restrictions.validate if _restrictions.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/promotion_codes/{promotion_code}".sub("{" + "promotion_code" + "}", URI.encode_path(promotion_code.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["active"] = active.to_s if !active.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["restrictions"] = restrictions.to_s if !restrictions.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_promotion_codes_promotion_code",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>A quote models prices and services for a customer. Default options for <code>header</code>, <code>description</code>, <code>footer</code>, and <code>expires_at</code> can be set in the dashboard via the <a href=\"https://dashboard.stripe.com/settings/billing/quote\">quote template</a>.</p>
    # @optional @param application_fee_amount [Stripe::PostQuotesRequestApplicationFeeAmount?]
    # @optional @param application_fee_percent [Stripe::PostQuotesRequestApplicationFeePercent?]
    # @optional @param automatic_tax [Stripe::AutomaticTaxParam2?]
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay invoices at the end of the subscription cycle or at invoice finalization using the default payment method attached to the subscription or customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
    # @optional @param customer [String?] The customer for which this quote belongs to. A customer is required before finalizing the quote. Once specified, it cannot be changed.
    # @optional @param default_tax_rates [Stripe::PostQuotesRequestDefaultTaxRates?]
    # @optional @param description [String?] A description that will be displayed on the quote PDF. If no value is passed, the default description configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
    # @optional @param discounts [Stripe::PostQuotesRequestDiscounts?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] A future timestamp on which the quote will be canceled if in `open` or `draft` status. Measured in seconds since the Unix epoch. If no value is passed, the default expiration date configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
    # @optional @param footer [String?] A footer that will be displayed on the quote PDF. If no value is passed, the default footer configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
    # @optional @param from_quote [Stripe::FromQuoteParams?]
    # @optional @param header [String?] A header that will be displayed on the quote PDF. If no value is passed, the default header configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
    # @optional @param invoice_settings [Stripe::QuoteParam?]
    # @optional @param line_items [Array(Stripe::LineItemCreateParams)?] A list of line items the customer is being quoted for. Each line item includes information about the product, the quantity, and the resulting cost.
    # @optional @param on_behalf_of [Stripe::PostQuotesRequestOnBehalfOf?]
    # @optional @param subscription_data [Stripe::SubscriptionDataCreateParams?]
    # @optional @param test_clock [String?] ID of the test clock to attach to the quote.
    # @optional @param transfer_data [Stripe::PostQuotesRequestTransferData?]
    # @return [Quote]
    def post_quotes(*, application_fee_amount : Stripe::PostQuotesRequestApplicationFeeAmount? = nil, application_fee_percent : Stripe::PostQuotesRequestApplicationFeePercent? = nil, automatic_tax : Stripe::AutomaticTaxParam2? = nil, collection_method : String? = nil, customer : String? = nil, default_tax_rates : Stripe::PostQuotesRequestDefaultTaxRates? = nil, description : String? = nil, discounts : Stripe::PostQuotesRequestDiscounts? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, footer : String? = nil, from_quote : Stripe::FromQuoteParams? = nil, header : String? = nil, invoice_settings : Stripe::QuoteParam? = nil, line_items : Array(Stripe::LineItemCreateParams)? = nil, on_behalf_of : Stripe::PostQuotesRequestOnBehalfOf? = nil, subscription_data : Stripe::SubscriptionDataCreateParams? = nil, test_clock : String? = nil, transfer_data : Stripe::PostQuotesRequestTransferData? = nil)
      data, _status_code, _headers = post_quotes_with_http_info(application_fee_amount: application_fee_amount, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, collection_method: collection_method, customer: customer, default_tax_rates: default_tax_rates, description: description, discounts: discounts, expand: expand, expires_at: expires_at, footer: footer, from_quote: from_quote, header: header, invoice_settings: invoice_settings, line_items: line_items, on_behalf_of: on_behalf_of, subscription_data: subscription_data, test_clock: test_clock, transfer_data: transfer_data)
      data
    end

    # &lt;p&gt;A quote models prices and services for a customer. Default options for &lt;code&gt;header&lt;/code&gt;, &lt;code&gt;description&lt;/code&gt;, &lt;code&gt;footer&lt;/code&gt;, and &lt;code&gt;expires_at&lt;/code&gt; can be set in the dashboard via the &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/settings/billing/quote\&quot;&gt;quote template&lt;/a&gt;.&lt;/p&gt;
    # @optional @param application_fee_amount [Stripe::PostQuotesRequestApplicationFeeAmount?]
    # @optional @param application_fee_percent [Stripe::PostQuotesRequestApplicationFeePercent?]
    # @optional @param automatic_tax [Stripe::AutomaticTaxParam2?]
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay invoices at the end of the subscription cycle or at invoice finalization using the default payment method attached to the subscription or customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
    # @optional @param customer [String?] The customer for which this quote belongs to. A customer is required before finalizing the quote. Once specified, it cannot be changed.
    # @optional @param default_tax_rates [Stripe::PostQuotesRequestDefaultTaxRates?]
    # @optional @param description [String?] A description that will be displayed on the quote PDF. If no value is passed, the default description configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
    # @optional @param discounts [Stripe::PostQuotesRequestDiscounts?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] A future timestamp on which the quote will be canceled if in `open` or `draft` status. Measured in seconds since the Unix epoch. If no value is passed, the default expiration date configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
    # @optional @param footer [String?] A footer that will be displayed on the quote PDF. If no value is passed, the default footer configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
    # @optional @param from_quote [Stripe::FromQuoteParams?]
    # @optional @param header [String?] A header that will be displayed on the quote PDF. If no value is passed, the default header configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
    # @optional @param invoice_settings [Stripe::QuoteParam?]
    # @optional @param line_items [Array(Stripe::LineItemCreateParams)?] A list of line items the customer is being quoted for. Each line item includes information about the product, the quantity, and the resulting cost.
    # @optional @param on_behalf_of [Stripe::PostQuotesRequestOnBehalfOf?]
    # @optional @param subscription_data [Stripe::SubscriptionDataCreateParams?]
    # @optional @param test_clock [String?] ID of the test clock to attach to the quote.
    # @optional @param transfer_data [Stripe::PostQuotesRequestTransferData?]
    # @return [Array<(Quote, Integer, Hash)>] Quote data, response status code and response headers
    def post_quotes_with_http_info(*, application_fee_amount : Stripe::PostQuotesRequestApplicationFeeAmount? = nil, application_fee_percent : Stripe::PostQuotesRequestApplicationFeePercent? = nil, automatic_tax : Stripe::AutomaticTaxParam2? = nil, collection_method : String? = nil, customer : String? = nil, default_tax_rates : Stripe::PostQuotesRequestDefaultTaxRates? = nil, description : String? = nil, discounts : Stripe::PostQuotesRequestDiscounts? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, footer : String? = nil, from_quote : Stripe::FromQuoteParams? = nil, header : String? = nil, invoice_settings : Stripe::QuoteParam? = nil, line_items : Array(Stripe::LineItemCreateParams)? = nil, on_behalf_of : Stripe::PostQuotesRequestOnBehalfOf? = nil, subscription_data : Stripe::SubscriptionDataCreateParams? = nil, test_clock : String? = nil, transfer_data : Stripe::PostQuotesRequestTransferData? = nil)
      request = build_api_request_for_post_quotes(application_fee_amount: application_fee_amount, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, collection_method: collection_method, customer: customer, default_tax_rates: default_tax_rates, description: description, discounts: discounts, expand: expand, expires_at: expires_at, footer: footer, from_quote: from_quote, header: header, invoice_settings: invoice_settings, line_items: line_items, on_behalf_of: on_behalf_of, subscription_data: subscription_data, test_clock: test_clock, transfer_data: transfer_data)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_quotes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Quote.from_json(data), status_code, headers
    end

    # &lt;p&gt;A quote models prices and services for a customer. Default options for &lt;code&gt;header&lt;/code&gt;, &lt;code&gt;description&lt;/code&gt;, &lt;code&gt;footer&lt;/code&gt;, and &lt;code&gt;expires_at&lt;/code&gt; can be set in the dashboard via the &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/settings/billing/quote\&quot;&gt;quote template&lt;/a&gt;.&lt;/p&gt;
    # @optional @param application_fee_amount [Stripe::PostQuotesRequestApplicationFeeAmount?]
    # @optional @param application_fee_percent [Stripe::PostQuotesRequestApplicationFeePercent?]
    # @optional @param automatic_tax [Stripe::AutomaticTaxParam2?]
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay invoices at the end of the subscription cycle or at invoice finalization using the default payment method attached to the subscription or customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
    # @optional @param customer [String?] The customer for which this quote belongs to. A customer is required before finalizing the quote. Once specified, it cannot be changed.
    # @optional @param default_tax_rates [Stripe::PostQuotesRequestDefaultTaxRates?]
    # @optional @param description [String?] A description that will be displayed on the quote PDF. If no value is passed, the default description configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
    # @optional @param discounts [Stripe::PostQuotesRequestDiscounts?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] A future timestamp on which the quote will be canceled if in `open` or `draft` status. Measured in seconds since the Unix epoch. If no value is passed, the default expiration date configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
    # @optional @param footer [String?] A footer that will be displayed on the quote PDF. If no value is passed, the default footer configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
    # @optional @param from_quote [Stripe::FromQuoteParams?]
    # @optional @param header [String?] A header that will be displayed on the quote PDF. If no value is passed, the default header configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
    # @optional @param invoice_settings [Stripe::QuoteParam?]
    # @optional @param line_items [Array(Stripe::LineItemCreateParams)?] A list of line items the customer is being quoted for. Each line item includes information about the product, the quantity, and the resulting cost.
    # @optional @param on_behalf_of [Stripe::PostQuotesRequestOnBehalfOf?]
    # @optional @param subscription_data [Stripe::SubscriptionDataCreateParams?]
    # @optional @param test_clock [String?] ID of the test clock to attach to the quote.
    # @optional @param transfer_data [Stripe::PostQuotesRequestTransferData?]
    # @return nil
    def post_quotes(*, application_fee_amount : Stripe::PostQuotesRequestApplicationFeeAmount? = nil, application_fee_percent : Stripe::PostQuotesRequestApplicationFeePercent? = nil, automatic_tax : Stripe::AutomaticTaxParam2? = nil, collection_method : String? = nil, customer : String? = nil, default_tax_rates : Stripe::PostQuotesRequestDefaultTaxRates? = nil, description : String? = nil, discounts : Stripe::PostQuotesRequestDiscounts? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, footer : String? = nil, from_quote : Stripe::FromQuoteParams? = nil, header : String? = nil, invoice_settings : Stripe::QuoteParam? = nil, line_items : Array(Stripe::LineItemCreateParams)? = nil, on_behalf_of : Stripe::PostQuotesRequestOnBehalfOf? = nil, subscription_data : Stripe::SubscriptionDataCreateParams? = nil, test_clock : String? = nil, transfer_data : Stripe::PostQuotesRequestTransferData? = nil, &block : Crest::Response ->)
      build_api_request_for_post_quotes(application_fee_amount: application_fee_amount, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, collection_method: collection_method, customer: customer, default_tax_rates: default_tax_rates, description: description, discounts: discounts, expand: expand, expires_at: expires_at, footer: footer, from_quote: from_quote, header: header, invoice_settings: invoice_settings, line_items: line_items, on_behalf_of: on_behalf_of, subscription_data: subscription_data, test_clock: test_clock, transfer_data: transfer_data).execute(&block)
    end

    POST_QUOTES_VALID_VALUES_FOR_COLLECTION_METHOD = StaticArray["charge_automatically", "send_invoice"]
    POST_QUOTES_MAX_LENGTH_FOR_CUSTOMER            = 5000
    POST_QUOTES_MAX_LENGTH_FOR_DESCRIPTION         =  500
    POST_QUOTES_MAX_LENGTH_FOR_FOOTER              =  500
    POST_QUOTES_MAX_LENGTH_FOR_HEADER              =   50
    POST_QUOTES_MAX_LENGTH_FOR_TEST_CLOCK          = 5000

    # @return Crest::Request
    def build_api_request_for_post_quotes(*, application_fee_amount : Stripe::PostQuotesRequestApplicationFeeAmount? = nil, application_fee_percent : Stripe::PostQuotesRequestApplicationFeePercent? = nil, automatic_tax : Stripe::AutomaticTaxParam2? = nil, collection_method : String? = nil, customer : String? = nil, default_tax_rates : Stripe::PostQuotesRequestDefaultTaxRates? = nil, description : String? = nil, discounts : Stripe::PostQuotesRequestDiscounts? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, footer : String? = nil, from_quote : Stripe::FromQuoteParams? = nil, header : String? = nil, invoice_settings : Stripe::QuoteParam? = nil, line_items : Array(Stripe::LineItemCreateParams)? = nil, on_behalf_of : Stripe::PostQuotesRequestOnBehalfOf? = nil, subscription_data : Stripe::SubscriptionDataCreateParams? = nil, test_clock : String? = nil, transfer_data : Stripe::PostQuotesRequestTransferData? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_quotes ..." }
      end

      if client_side_validation
        if _application_fee_amount = application_fee_amount
          _application_fee_amount.validate if _application_fee_amount.is_a?(OpenApi::Validatable)
        end
        if _application_fee_percent = application_fee_percent
          _application_fee_percent.validate if _application_fee_percent.is_a?(OpenApi::Validatable)
        end
        if _automatic_tax = automatic_tax
          _automatic_tax.validate if _automatic_tax.is_a?(OpenApi::Validatable)
        end
        if _collection_method = collection_method
          OpenApi::EnumValidator.validate("collection_method", _collection_method, POST_QUOTES_VALID_VALUES_FOR_COLLECTION_METHOD)
        end
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_QUOTES_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _default_tax_rates = default_tax_rates
          _default_tax_rates.validate if _default_tax_rates.is_a?(OpenApi::Validatable)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_QUOTES_MAX_LENGTH_FOR_DESCRIPTION)
        end
        if _discounts = discounts
          _discounts.validate if _discounts.is_a?(OpenApi::Validatable)
        end

        if _footer = footer
          OpenApi::PrimitiveValidator.validate_max_length("footer", footer.to_s.size, POST_QUOTES_MAX_LENGTH_FOR_FOOTER)
        end
        if _from_quote = from_quote
          _from_quote.validate if _from_quote.is_a?(OpenApi::Validatable)
        end
        if _header = header
          OpenApi::PrimitiveValidator.validate_max_length("header", header.to_s.size, POST_QUOTES_MAX_LENGTH_FOR_HEADER)
        end
        if _invoice_settings = invoice_settings
          _invoice_settings.validate if _invoice_settings.is_a?(OpenApi::Validatable)
        end
        if _line_items = line_items
          OpenApi::ContainerValidator.validate(container: _line_items) if _line_items.is_a?(Array)
        end
        if _on_behalf_of = on_behalf_of
          _on_behalf_of.validate if _on_behalf_of.is_a?(OpenApi::Validatable)
        end
        if _subscription_data = subscription_data
          _subscription_data.validate if _subscription_data.is_a?(OpenApi::Validatable)
        end
        if _test_clock = test_clock
          OpenApi::PrimitiveValidator.validate_max_length("test_clock", test_clock.to_s.size, POST_QUOTES_MAX_LENGTH_FOR_TEST_CLOCK)
        end
        if _transfer_data = transfer_data
          _transfer_data.validate if _transfer_data.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/quotes"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["application_fee_amount"] = application_fee_amount.to_s if !application_fee_amount.nil?
      form_params["application_fee_percent"] = application_fee_percent.to_s if !application_fee_percent.nil?
      form_params["automatic_tax"] = automatic_tax.to_s if !automatic_tax.nil?
      form_params["collection_method"] = collection_method.to_s if !collection_method.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["default_tax_rates"] = default_tax_rates.to_s if !default_tax_rates.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["discounts"] = discounts.to_s if !discounts.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["expires_at"] = expires_at.to_s if !expires_at.nil?
      form_params["footer"] = footer.to_s if !footer.nil?
      form_params["from_quote"] = from_quote.to_s if !from_quote.nil?
      form_params["header"] = header.to_s if !header.nil?
      form_params["invoice_settings"] = invoice_settings.to_s if !invoice_settings.nil?
      form_params["line_items"] = @api_client.build_collection_param(line_items, "csv") if !line_items.nil? && !line_items.empty?
      form_params["on_behalf_of"] = on_behalf_of.to_s if !on_behalf_of.nil?
      form_params["subscription_data"] = subscription_data.to_s if !subscription_data.nil?
      form_params["test_clock"] = test_clock.to_s if !test_clock.nil?
      form_params["transfer_data"] = transfer_data.to_s if !transfer_data.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_quotes",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>A quote models prices and services for a customer.</p>
    # @param quote [String?]
    # @optional @param application_fee_amount [Stripe::PostQuotesRequestApplicationFeeAmount?]
    # @optional @param application_fee_percent [Stripe::PostQuotesRequestApplicationFeePercent?]
    # @optional @param automatic_tax [Stripe::AutomaticTaxParam2?]
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay invoices at the end of the subscription cycle or at invoice finalization using the default payment method attached to the subscription or customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
    # @optional @param customer [String?] The customer for which this quote belongs to. A customer is required before finalizing the quote. Once specified, it cannot be changed.
    # @optional @param default_tax_rates [Stripe::PostQuotesRequestDefaultTaxRates?]
    # @optional @param description [String?] A description that will be displayed on the quote PDF.
    # @optional @param discounts [Stripe::PostQuotesRequestDiscounts?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] A future timestamp on which the quote will be canceled if in `open` or `draft` status. Measured in seconds since the Unix epoch.
    # @optional @param footer [String?] A footer that will be displayed on the quote PDF.
    # @optional @param header [String?] A header that will be displayed on the quote PDF.
    # @optional @param invoice_settings [Stripe::QuoteParam?]
    # @optional @param line_items [Array(Stripe::LineItemUpdateParams)?] A list of line items the customer is being quoted for. Each line item includes information about the product, the quantity, and the resulting cost.
    # @optional @param on_behalf_of [Stripe::PostQuotesRequestOnBehalfOf?]
    # @optional @param subscription_data [Stripe::SubscriptionDataUpdateParams?]
    # @optional @param transfer_data [Stripe::PostQuotesRequestTransferData?]
    # @return [Quote]
    def post_quotes_quote(*, quote : String? = nil, application_fee_amount : Stripe::PostQuotesRequestApplicationFeeAmount? = nil, application_fee_percent : Stripe::PostQuotesRequestApplicationFeePercent? = nil, automatic_tax : Stripe::AutomaticTaxParam2? = nil, collection_method : String? = nil, customer : String? = nil, default_tax_rates : Stripe::PostQuotesRequestDefaultTaxRates? = nil, description : String? = nil, discounts : Stripe::PostQuotesRequestDiscounts? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, footer : String? = nil, header : String? = nil, invoice_settings : Stripe::QuoteParam? = nil, line_items : Array(Stripe::LineItemUpdateParams)? = nil, on_behalf_of : Stripe::PostQuotesRequestOnBehalfOf? = nil, subscription_data : Stripe::SubscriptionDataUpdateParams? = nil, transfer_data : Stripe::PostQuotesRequestTransferData? = nil)
      data, _status_code, _headers = post_quotes_quote_with_http_info(quote: quote, application_fee_amount: application_fee_amount, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, collection_method: collection_method, customer: customer, default_tax_rates: default_tax_rates, description: description, discounts: discounts, expand: expand, expires_at: expires_at, footer: footer, header: header, invoice_settings: invoice_settings, line_items: line_items, on_behalf_of: on_behalf_of, subscription_data: subscription_data, transfer_data: transfer_data)
      data
    end

    # &lt;p&gt;A quote models prices and services for a customer.&lt;/p&gt;
    # @param quote [String?]
    # @optional @param application_fee_amount [Stripe::PostQuotesRequestApplicationFeeAmount?]
    # @optional @param application_fee_percent [Stripe::PostQuotesRequestApplicationFeePercent?]
    # @optional @param automatic_tax [Stripe::AutomaticTaxParam2?]
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay invoices at the end of the subscription cycle or at invoice finalization using the default payment method attached to the subscription or customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
    # @optional @param customer [String?] The customer for which this quote belongs to. A customer is required before finalizing the quote. Once specified, it cannot be changed.
    # @optional @param default_tax_rates [Stripe::PostQuotesRequestDefaultTaxRates?]
    # @optional @param description [String?] A description that will be displayed on the quote PDF.
    # @optional @param discounts [Stripe::PostQuotesRequestDiscounts?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] A future timestamp on which the quote will be canceled if in `open` or `draft` status. Measured in seconds since the Unix epoch.
    # @optional @param footer [String?] A footer that will be displayed on the quote PDF.
    # @optional @param header [String?] A header that will be displayed on the quote PDF.
    # @optional @param invoice_settings [Stripe::QuoteParam?]
    # @optional @param line_items [Array(Stripe::LineItemUpdateParams)?] A list of line items the customer is being quoted for. Each line item includes information about the product, the quantity, and the resulting cost.
    # @optional @param on_behalf_of [Stripe::PostQuotesRequestOnBehalfOf?]
    # @optional @param subscription_data [Stripe::SubscriptionDataUpdateParams?]
    # @optional @param transfer_data [Stripe::PostQuotesRequestTransferData?]
    # @return [Array<(Quote, Integer, Hash)>] Quote data, response status code and response headers
    def post_quotes_quote_with_http_info(*, quote : String? = nil, application_fee_amount : Stripe::PostQuotesRequestApplicationFeeAmount? = nil, application_fee_percent : Stripe::PostQuotesRequestApplicationFeePercent? = nil, automatic_tax : Stripe::AutomaticTaxParam2? = nil, collection_method : String? = nil, customer : String? = nil, default_tax_rates : Stripe::PostQuotesRequestDefaultTaxRates? = nil, description : String? = nil, discounts : Stripe::PostQuotesRequestDiscounts? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, footer : String? = nil, header : String? = nil, invoice_settings : Stripe::QuoteParam? = nil, line_items : Array(Stripe::LineItemUpdateParams)? = nil, on_behalf_of : Stripe::PostQuotesRequestOnBehalfOf? = nil, subscription_data : Stripe::SubscriptionDataUpdateParams? = nil, transfer_data : Stripe::PostQuotesRequestTransferData? = nil)
      request = build_api_request_for_post_quotes_quote(quote: quote, application_fee_amount: application_fee_amount, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, collection_method: collection_method, customer: customer, default_tax_rates: default_tax_rates, description: description, discounts: discounts, expand: expand, expires_at: expires_at, footer: footer, header: header, invoice_settings: invoice_settings, line_items: line_items, on_behalf_of: on_behalf_of, subscription_data: subscription_data, transfer_data: transfer_data)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_quotes_quote\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Quote.from_json(data), status_code, headers
    end

    # &lt;p&gt;A quote models prices and services for a customer.&lt;/p&gt;
    # @param quote [String?]
    # @optional @param application_fee_amount [Stripe::PostQuotesRequestApplicationFeeAmount?]
    # @optional @param application_fee_percent [Stripe::PostQuotesRequestApplicationFeePercent?]
    # @optional @param automatic_tax [Stripe::AutomaticTaxParam2?]
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay invoices at the end of the subscription cycle or at invoice finalization using the default payment method attached to the subscription or customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
    # @optional @param customer [String?] The customer for which this quote belongs to. A customer is required before finalizing the quote. Once specified, it cannot be changed.
    # @optional @param default_tax_rates [Stripe::PostQuotesRequestDefaultTaxRates?]
    # @optional @param description [String?] A description that will be displayed on the quote PDF.
    # @optional @param discounts [Stripe::PostQuotesRequestDiscounts?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] A future timestamp on which the quote will be canceled if in `open` or `draft` status. Measured in seconds since the Unix epoch.
    # @optional @param footer [String?] A footer that will be displayed on the quote PDF.
    # @optional @param header [String?] A header that will be displayed on the quote PDF.
    # @optional @param invoice_settings [Stripe::QuoteParam?]
    # @optional @param line_items [Array(Stripe::LineItemUpdateParams)?] A list of line items the customer is being quoted for. Each line item includes information about the product, the quantity, and the resulting cost.
    # @optional @param on_behalf_of [Stripe::PostQuotesRequestOnBehalfOf?]
    # @optional @param subscription_data [Stripe::SubscriptionDataUpdateParams?]
    # @optional @param transfer_data [Stripe::PostQuotesRequestTransferData?]
    # @return nil
    def post_quotes_quote(*, quote : String? = nil, application_fee_amount : Stripe::PostQuotesRequestApplicationFeeAmount? = nil, application_fee_percent : Stripe::PostQuotesRequestApplicationFeePercent? = nil, automatic_tax : Stripe::AutomaticTaxParam2? = nil, collection_method : String? = nil, customer : String? = nil, default_tax_rates : Stripe::PostQuotesRequestDefaultTaxRates? = nil, description : String? = nil, discounts : Stripe::PostQuotesRequestDiscounts? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, footer : String? = nil, header : String? = nil, invoice_settings : Stripe::QuoteParam? = nil, line_items : Array(Stripe::LineItemUpdateParams)? = nil, on_behalf_of : Stripe::PostQuotesRequestOnBehalfOf? = nil, subscription_data : Stripe::SubscriptionDataUpdateParams? = nil, transfer_data : Stripe::PostQuotesRequestTransferData? = nil, &block : Crest::Response ->)
      build_api_request_for_post_quotes_quote(quote: quote, application_fee_amount: application_fee_amount, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, collection_method: collection_method, customer: customer, default_tax_rates: default_tax_rates, description: description, discounts: discounts, expand: expand, expires_at: expires_at, footer: footer, header: header, invoice_settings: invoice_settings, line_items: line_items, on_behalf_of: on_behalf_of, subscription_data: subscription_data, transfer_data: transfer_data).execute(&block)
    end

    POST_QUOTES_QUOTE_MAX_LENGTH_FOR_QUOTE               = 5000
    POST_QUOTES_QUOTE_VALID_VALUES_FOR_COLLECTION_METHOD = StaticArray["charge_automatically", "send_invoice"]
    POST_QUOTES_QUOTE_MAX_LENGTH_FOR_CUSTOMER            = 5000
    POST_QUOTES_QUOTE_MAX_LENGTH_FOR_DESCRIPTION         =  500
    POST_QUOTES_QUOTE_MAX_LENGTH_FOR_FOOTER              =  500
    POST_QUOTES_QUOTE_MAX_LENGTH_FOR_HEADER              =   50

    # @return Crest::Request
    def build_api_request_for_post_quotes_quote(*, quote : String? = nil, application_fee_amount : Stripe::PostQuotesRequestApplicationFeeAmount? = nil, application_fee_percent : Stripe::PostQuotesRequestApplicationFeePercent? = nil, automatic_tax : Stripe::AutomaticTaxParam2? = nil, collection_method : String? = nil, customer : String? = nil, default_tax_rates : Stripe::PostQuotesRequestDefaultTaxRates? = nil, description : String? = nil, discounts : Stripe::PostQuotesRequestDiscounts? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, footer : String? = nil, header : String? = nil, invoice_settings : Stripe::QuoteParam? = nil, line_items : Array(Stripe::LineItemUpdateParams)? = nil, on_behalf_of : Stripe::PostQuotesRequestOnBehalfOf? = nil, subscription_data : Stripe::SubscriptionDataUpdateParams? = nil, transfer_data : Stripe::PostQuotesRequestTransferData? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_quotes_quote ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"quote\" is required and cannot be null") if quote.nil?
        if _quote = quote
          OpenApi::PrimitiveValidator.validate_max_length("quote", quote.to_s.size, POST_QUOTES_QUOTE_MAX_LENGTH_FOR_QUOTE)
        end
        if _application_fee_amount = application_fee_amount
          _application_fee_amount.validate if _application_fee_amount.is_a?(OpenApi::Validatable)
        end
        if _application_fee_percent = application_fee_percent
          _application_fee_percent.validate if _application_fee_percent.is_a?(OpenApi::Validatable)
        end
        if _automatic_tax = automatic_tax
          _automatic_tax.validate if _automatic_tax.is_a?(OpenApi::Validatable)
        end
        if _collection_method = collection_method
          OpenApi::EnumValidator.validate("collection_method", _collection_method, POST_QUOTES_QUOTE_VALID_VALUES_FOR_COLLECTION_METHOD)
        end
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_QUOTES_QUOTE_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _default_tax_rates = default_tax_rates
          _default_tax_rates.validate if _default_tax_rates.is_a?(OpenApi::Validatable)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_QUOTES_QUOTE_MAX_LENGTH_FOR_DESCRIPTION)
        end
        if _discounts = discounts
          _discounts.validate if _discounts.is_a?(OpenApi::Validatable)
        end

        if _footer = footer
          OpenApi::PrimitiveValidator.validate_max_length("footer", footer.to_s.size, POST_QUOTES_QUOTE_MAX_LENGTH_FOR_FOOTER)
        end
        if _header = header
          OpenApi::PrimitiveValidator.validate_max_length("header", header.to_s.size, POST_QUOTES_QUOTE_MAX_LENGTH_FOR_HEADER)
        end
        if _invoice_settings = invoice_settings
          _invoice_settings.validate if _invoice_settings.is_a?(OpenApi::Validatable)
        end
        if _line_items = line_items
          OpenApi::ContainerValidator.validate(container: _line_items) if _line_items.is_a?(Array)
        end
        if _on_behalf_of = on_behalf_of
          _on_behalf_of.validate if _on_behalf_of.is_a?(OpenApi::Validatable)
        end
        if _subscription_data = subscription_data
          _subscription_data.validate if _subscription_data.is_a?(OpenApi::Validatable)
        end
        if _transfer_data = transfer_data
          _transfer_data.validate if _transfer_data.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/quotes/{quote}".sub("{" + "quote" + "}", URI.encode_path(quote.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["application_fee_amount"] = application_fee_amount.to_s if !application_fee_amount.nil?
      form_params["application_fee_percent"] = application_fee_percent.to_s if !application_fee_percent.nil?
      form_params["automatic_tax"] = automatic_tax.to_s if !automatic_tax.nil?
      form_params["collection_method"] = collection_method.to_s if !collection_method.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["default_tax_rates"] = default_tax_rates.to_s if !default_tax_rates.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["discounts"] = discounts.to_s if !discounts.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["expires_at"] = expires_at.to_s if !expires_at.nil?
      form_params["footer"] = footer.to_s if !footer.nil?
      form_params["header"] = header.to_s if !header.nil?
      form_params["invoice_settings"] = invoice_settings.to_s if !invoice_settings.nil?
      form_params["line_items"] = @api_client.build_collection_param(line_items, "csv") if !line_items.nil? && !line_items.empty?
      form_params["on_behalf_of"] = on_behalf_of.to_s if !on_behalf_of.nil?
      form_params["subscription_data"] = subscription_data.to_s if !subscription_data.nil?
      form_params["transfer_data"] = transfer_data.to_s if !transfer_data.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_quotes_quote",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Accepts the specified quote.</p>
    # @param quote [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Quote]
    def post_quotes_quote_accept(*, quote : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_quotes_quote_accept_with_http_info(quote: quote, expand: expand)
      data
    end

    # &lt;p&gt;Accepts the specified quote.&lt;/p&gt;
    # @param quote [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(Quote, Integer, Hash)>] Quote data, response status code and response headers
    def post_quotes_quote_accept_with_http_info(*, quote : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_quotes_quote_accept(quote: quote, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_quotes_quote_accept\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Quote.from_json(data), status_code, headers
    end

    # &lt;p&gt;Accepts the specified quote.&lt;/p&gt;
    # @param quote [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_quotes_quote_accept(*, quote : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_quotes_quote_accept(quote: quote, expand: expand).execute(&block)
    end

    POST_QUOTES_QUOTE_ACCEPT_MAX_LENGTH_FOR_QUOTE = 5000

    # @return Crest::Request
    def build_api_request_for_post_quotes_quote_accept(*, quote : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_quotes_quote_accept ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"quote\" is required and cannot be null") if quote.nil?
        if _quote = quote
          OpenApi::PrimitiveValidator.validate_max_length("quote", quote.to_s.size, POST_QUOTES_QUOTE_ACCEPT_MAX_LENGTH_FOR_QUOTE)
        end
      end

      # resource path
      local_var_path = "/v1/quotes/{quote}/accept".sub("{" + "quote" + "}", URI.encode_path(quote.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_quotes_quote_accept",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Cancels the quote.</p>
    # @param quote [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Quote]
    def post_quotes_quote_cancel(*, quote : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_quotes_quote_cancel_with_http_info(quote: quote, expand: expand)
      data
    end

    # &lt;p&gt;Cancels the quote.&lt;/p&gt;
    # @param quote [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(Quote, Integer, Hash)>] Quote data, response status code and response headers
    def post_quotes_quote_cancel_with_http_info(*, quote : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_quotes_quote_cancel(quote: quote, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_quotes_quote_cancel\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Quote.from_json(data), status_code, headers
    end

    # &lt;p&gt;Cancels the quote.&lt;/p&gt;
    # @param quote [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_quotes_quote_cancel(*, quote : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_quotes_quote_cancel(quote: quote, expand: expand).execute(&block)
    end

    POST_QUOTES_QUOTE_CANCEL_MAX_LENGTH_FOR_QUOTE = 5000

    # @return Crest::Request
    def build_api_request_for_post_quotes_quote_cancel(*, quote : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_quotes_quote_cancel ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"quote\" is required and cannot be null") if quote.nil?
        if _quote = quote
          OpenApi::PrimitiveValidator.validate_max_length("quote", quote.to_s.size, POST_QUOTES_QUOTE_CANCEL_MAX_LENGTH_FOR_QUOTE)
        end
      end

      # resource path
      local_var_path = "/v1/quotes/{quote}/cancel".sub("{" + "quote" + "}", URI.encode_path(quote.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_quotes_quote_cancel",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Finalizes the quote.</p>
    # @param quote [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] A future timestamp on which the quote will be canceled if in `open` or `draft` status. Measured in seconds since the Unix epoch.
    # @return [Quote]
    def post_quotes_quote_finalize(*, quote : String? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil)
      data, _status_code, _headers = post_quotes_quote_finalize_with_http_info(quote: quote, expand: expand, expires_at: expires_at)
      data
    end

    # &lt;p&gt;Finalizes the quote.&lt;/p&gt;
    # @param quote [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] A future timestamp on which the quote will be canceled if in `open` or `draft` status. Measured in seconds since the Unix epoch.
    # @return [Array<(Quote, Integer, Hash)>] Quote data, response status code and response headers
    def post_quotes_quote_finalize_with_http_info(*, quote : String? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil)
      request = build_api_request_for_post_quotes_quote_finalize(quote: quote, expand: expand, expires_at: expires_at)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_quotes_quote_finalize\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Quote.from_json(data), status_code, headers
    end

    # &lt;p&gt;Finalizes the quote.&lt;/p&gt;
    # @param quote [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param expires_at [Int64?] A future timestamp on which the quote will be canceled if in `open` or `draft` status. Measured in seconds since the Unix epoch.
    # @return nil
    def post_quotes_quote_finalize(*, quote : String? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil, &block : Crest::Response ->)
      build_api_request_for_post_quotes_quote_finalize(quote: quote, expand: expand, expires_at: expires_at).execute(&block)
    end

    POST_QUOTES_QUOTE_FINALIZE_MAX_LENGTH_FOR_QUOTE = 5000

    # @return Crest::Request
    def build_api_request_for_post_quotes_quote_finalize(*, quote : String? = nil, expand : Array(String)? = nil, expires_at : Int64? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_quotes_quote_finalize ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"quote\" is required and cannot be null") if quote.nil?
        if _quote = quote
          OpenApi::PrimitiveValidator.validate_max_length("quote", quote.to_s.size, POST_QUOTES_QUOTE_FINALIZE_MAX_LENGTH_FOR_QUOTE)
        end
      end

      # resource path
      local_var_path = "/v1/quotes/{quote}/finalize".sub("{" + "quote" + "}", URI.encode_path(quote.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["expires_at"] = expires_at.to_s if !expires_at.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_quotes_quote_finalize",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new <code>ValueListItem</code> object, which is added to the specified parent value list.</p>
    # @param value [String?] The value of the item (whose type must match the type of the parent value list).
    # @param value_list [String?] The identifier of the value list which the created item will be added to.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [RadarValueListItem]
    def post_radar_value_list_items(*, value : String? = nil, value_list : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_radar_value_list_items_with_http_info(value: value, value_list: value_list, expand: expand)
      data
    end

    # &lt;p&gt;Creates a new &lt;code&gt;ValueListItem&lt;/code&gt; object, which is added to the specified parent value list.&lt;/p&gt;
    # @param value [String?] The value of the item (whose type must match the type of the parent value list).
    # @param value_list [String?] The identifier of the value list which the created item will be added to.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(RadarValueListItem, Integer, Hash)>] RadarValueListItem data, response status code and response headers
    def post_radar_value_list_items_with_http_info(*, value : String? = nil, value_list : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_radar_value_list_items(value: value, value_list: value_list, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_radar_value_list_items\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return RadarValueListItem.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new &lt;code&gt;ValueListItem&lt;/code&gt; object, which is added to the specified parent value list.&lt;/p&gt;
    # @param value [String?] The value of the item (whose type must match the type of the parent value list).
    # @param value_list [String?] The identifier of the value list which the created item will be added to.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_radar_value_list_items(*, value : String? = nil, value_list : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_radar_value_list_items(value: value, value_list: value_list, expand: expand).execute(&block)
    end

    POST_RADAR_VALUE_LIST_ITEMS_MAX_LENGTH_FOR_VALUE      =  800
    POST_RADAR_VALUE_LIST_ITEMS_MAX_LENGTH_FOR_VALUE_LIST = 5000

    # @return Crest::Request
    def build_api_request_for_post_radar_value_list_items(*, value : String? = nil, value_list : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_radar_value_list_items ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"value\" is required and cannot be null") if value.nil?
        if _value = value
          OpenApi::PrimitiveValidator.validate_max_length("value", value.to_s.size, POST_RADAR_VALUE_LIST_ITEMS_MAX_LENGTH_FOR_VALUE)
        end
        raise ArgumentError.new("\"value_list\" is required and cannot be null") if value_list.nil?
        if _value_list = value_list
          OpenApi::PrimitiveValidator.validate_max_length("value_list", value_list.to_s.size, POST_RADAR_VALUE_LIST_ITEMS_MAX_LENGTH_FOR_VALUE_LIST)
        end
      end

      # resource path
      local_var_path = "/v1/radar/value_list_items"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["value"] = value.to_s if !value.nil?
      form_params["value_list"] = value_list.to_s if !value_list.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_radar_value_list_items",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new <code>ValueList</code> object, which can then be referenced in rules.</p>
    # @param _alias [String?] The name of the value list for use in rules.
    # @param name [String?] The human-readable name of the value list.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param item_type [String?] Type of the items in the value list. One of `card_fingerprint`, `card_bin`, `email`, `ip_address`, `country`, `string`, `case_sensitive_string`, or `customer_id`. Use `string` if the item type is unknown or mixed.
    # @return [RadarValueList]
    def post_radar_value_lists(*, _alias : String? = nil, name : String? = nil, expand : Array(String)? = nil, item_type : String? = nil)
      data, _status_code, _headers = post_radar_value_lists_with_http_info(_alias: _alias, name: name, expand: expand, item_type: item_type)
      data
    end

    # &lt;p&gt;Creates a new &lt;code&gt;ValueList&lt;/code&gt; object, which can then be referenced in rules.&lt;/p&gt;
    # @param _alias [String?] The name of the value list for use in rules.
    # @param name [String?] The human-readable name of the value list.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param item_type [String?] Type of the items in the value list. One of `card_fingerprint`, `card_bin`, `email`, `ip_address`, `country`, `string`, `case_sensitive_string`, or `customer_id`. Use `string` if the item type is unknown or mixed.
    # @return [Array<(RadarValueList, Integer, Hash)>] RadarValueList data, response status code and response headers
    def post_radar_value_lists_with_http_info(*, _alias : String? = nil, name : String? = nil, expand : Array(String)? = nil, item_type : String? = nil)
      request = build_api_request_for_post_radar_value_lists(_alias: _alias, name: name, expand: expand, item_type: item_type)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_radar_value_lists\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return RadarValueList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new &lt;code&gt;ValueList&lt;/code&gt; object, which can then be referenced in rules.&lt;/p&gt;
    # @param _alias [String?] The name of the value list for use in rules.
    # @param name [String?] The human-readable name of the value list.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param item_type [String?] Type of the items in the value list. One of `card_fingerprint`, `card_bin`, `email`, `ip_address`, `country`, `string`, `case_sensitive_string`, or `customer_id`. Use `string` if the item type is unknown or mixed.
    # @return nil
    def post_radar_value_lists(*, _alias : String? = nil, name : String? = nil, expand : Array(String)? = nil, item_type : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_radar_value_lists(_alias: _alias, name: name, expand: expand, item_type: item_type).execute(&block)
    end

    POST_RADAR_VALUE_LISTS_MAX_LENGTH_FOR__ALIAS      =  100
    POST_RADAR_VALUE_LISTS_MAX_LENGTH_FOR_NAME        =  100
    POST_RADAR_VALUE_LISTS_MAX_LENGTH_FOR_ITEM_TYPE   = 5000
    POST_RADAR_VALUE_LISTS_VALID_VALUES_FOR_ITEM_TYPE = StaticArray["card_bin", "card_fingerprint", "case_sensitive_string", "country", "customer_id", "email", "ip_address", "string"]

    # @return Crest::Request
    def build_api_request_for_post_radar_value_lists(*, _alias : String? = nil, name : String? = nil, expand : Array(String)? = nil, item_type : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_radar_value_lists ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"_alias\" is required and cannot be null") if _alias.nil?
        if __alias = _alias
          OpenApi::PrimitiveValidator.validate_max_length("_alias", _alias.to_s.size, POST_RADAR_VALUE_LISTS_MAX_LENGTH_FOR__ALIAS)
        end
        raise ArgumentError.new("\"name\" is required and cannot be null") if name.nil?
        if _name = name
          OpenApi::PrimitiveValidator.validate_max_length("name", name.to_s.size, POST_RADAR_VALUE_LISTS_MAX_LENGTH_FOR_NAME)
        end

        if _item_type = item_type
          OpenApi::EnumValidator.validate("item_type", _item_type, POST_RADAR_VALUE_LISTS_VALID_VALUES_FOR_ITEM_TYPE)
        end
      end

      # resource path
      local_var_path = "/v1/radar/value_lists"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["alias"] = _alias.to_s if !_alias.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["item_type"] = item_type.to_s if !item_type.nil?
      form_params["name"] = name.to_s if !name.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_radar_value_lists",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates a <code>ValueList</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged. Note that <code>item_type</code> is immutable.</p>
    # @param value_list [String?]
    # @optional @param _alias [String?] The name of the value list for use in rules.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param name [String?] The human-readable name of the value list.
    # @return [RadarValueList]
    def post_radar_value_lists_value_list(*, value_list : String? = nil, _alias : String? = nil, expand : Array(String)? = nil, name : String? = nil)
      data, _status_code, _headers = post_radar_value_lists_value_list_with_http_info(value_list: value_list, _alias: _alias, expand: expand, name: name)
      data
    end

    # &lt;p&gt;Updates a &lt;code&gt;ValueList&lt;/code&gt; object by setting the values of the parameters passed. Any parameters not provided will be left unchanged. Note that &lt;code&gt;item_type&lt;/code&gt; is immutable.&lt;/p&gt;
    # @param value_list [String?]
    # @optional @param _alias [String?] The name of the value list for use in rules.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param name [String?] The human-readable name of the value list.
    # @return [Array<(RadarValueList, Integer, Hash)>] RadarValueList data, response status code and response headers
    def post_radar_value_lists_value_list_with_http_info(*, value_list : String? = nil, _alias : String? = nil, expand : Array(String)? = nil, name : String? = nil)
      request = build_api_request_for_post_radar_value_lists_value_list(value_list: value_list, _alias: _alias, expand: expand, name: name)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_radar_value_lists_value_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return RadarValueList.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates a &lt;code&gt;ValueList&lt;/code&gt; object by setting the values of the parameters passed. Any parameters not provided will be left unchanged. Note that &lt;code&gt;item_type&lt;/code&gt; is immutable.&lt;/p&gt;
    # @param value_list [String?]
    # @optional @param _alias [String?] The name of the value list for use in rules.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param name [String?] The human-readable name of the value list.
    # @return nil
    def post_radar_value_lists_value_list(*, value_list : String? = nil, _alias : String? = nil, expand : Array(String)? = nil, name : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_radar_value_lists_value_list(value_list: value_list, _alias: _alias, expand: expand, name: name).execute(&block)
    end

    POST_RADAR_VALUE_LISTS_VALUE_LIST_MAX_LENGTH_FOR_VALUE_LIST = 5000
    POST_RADAR_VALUE_LISTS_VALUE_LIST_MAX_LENGTH_FOR__ALIAS     =  100
    POST_RADAR_VALUE_LISTS_VALUE_LIST_MAX_LENGTH_FOR_NAME       =  100

    # @return Crest::Request
    def build_api_request_for_post_radar_value_lists_value_list(*, value_list : String? = nil, _alias : String? = nil, expand : Array(String)? = nil, name : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_radar_value_lists_value_list ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"value_list\" is required and cannot be null") if value_list.nil?
        if _value_list = value_list
          OpenApi::PrimitiveValidator.validate_max_length("value_list", value_list.to_s.size, POST_RADAR_VALUE_LISTS_VALUE_LIST_MAX_LENGTH_FOR_VALUE_LIST)
        end
        if __alias = _alias
          OpenApi::PrimitiveValidator.validate_max_length("_alias", _alias.to_s.size, POST_RADAR_VALUE_LISTS_VALUE_LIST_MAX_LENGTH_FOR__ALIAS)
        end

        if _name = name
          OpenApi::PrimitiveValidator.validate_max_length("name", name.to_s.size, POST_RADAR_VALUE_LISTS_VALUE_LIST_MAX_LENGTH_FOR_NAME)
        end
      end

      # resource path
      local_var_path = "/v1/radar/value_lists/{value_list}".sub("{" + "value_list" + "}", URI.encode_path(value_list.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["alias"] = _alias.to_s if !_alias.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["name"] = name.to_s if !name.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_radar_value_lists_value_list",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Create a refund.</p>
    # @optional @param amount [Int64?] A positive integer representing how much to refund.
    # @optional @param charge [String?]
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param customer [String?] Customer whose customer balance to refund from.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param instructions_email [String?] Address to send refund email, use customer email if not specified
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param origin [String?] Origin of the refund
    # @optional @param payment_intent [String?]
    # @optional @param reason [String?]
    # @optional @param refund_application_fee [Bool?]
    # @optional @param reverse_transfer [Bool?]
    # @return [Refund]
    def post_refunds(*, amount : Int64? = nil, charge : String? = nil, currency : String? = nil, customer : String? = nil, expand : Array(String)? = nil, instructions_email : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, origin : String? = nil, payment_intent : String? = nil, reason : String? = nil, refund_application_fee : Bool? = nil, reverse_transfer : Bool? = nil)
      data, _status_code, _headers = post_refunds_with_http_info(amount: amount, charge: charge, currency: currency, customer: customer, expand: expand, instructions_email: instructions_email, metadata: metadata, origin: origin, payment_intent: payment_intent, reason: reason, refund_application_fee: refund_application_fee, reverse_transfer: reverse_transfer)
      data
    end

    # &lt;p&gt;Create a refund.&lt;/p&gt;
    # @optional @param amount [Int64?] A positive integer representing how much to refund.
    # @optional @param charge [String?]
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param customer [String?] Customer whose customer balance to refund from.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param instructions_email [String?] Address to send refund email, use customer email if not specified
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param origin [String?] Origin of the refund
    # @optional @param payment_intent [String?]
    # @optional @param reason [String?]
    # @optional @param refund_application_fee [Bool?]
    # @optional @param reverse_transfer [Bool?]
    # @return [Array<(Refund, Integer, Hash)>] Refund data, response status code and response headers
    def post_refunds_with_http_info(*, amount : Int64? = nil, charge : String? = nil, currency : String? = nil, customer : String? = nil, expand : Array(String)? = nil, instructions_email : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, origin : String? = nil, payment_intent : String? = nil, reason : String? = nil, refund_application_fee : Bool? = nil, reverse_transfer : Bool? = nil)
      request = build_api_request_for_post_refunds(amount: amount, charge: charge, currency: currency, customer: customer, expand: expand, instructions_email: instructions_email, metadata: metadata, origin: origin, payment_intent: payment_intent, reason: reason, refund_application_fee: refund_application_fee, reverse_transfer: reverse_transfer)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_refunds\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Refund.from_json(data), status_code, headers
    end

    # &lt;p&gt;Create a refund.&lt;/p&gt;
    # @optional @param amount [Int64?] A positive integer representing how much to refund.
    # @optional @param charge [String?]
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param customer [String?] Customer whose customer balance to refund from.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param instructions_email [String?] Address to send refund email, use customer email if not specified
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param origin [String?] Origin of the refund
    # @optional @param payment_intent [String?]
    # @optional @param reason [String?]
    # @optional @param refund_application_fee [Bool?]
    # @optional @param reverse_transfer [Bool?]
    # @return nil
    def post_refunds(*, amount : Int64? = nil, charge : String? = nil, currency : String? = nil, customer : String? = nil, expand : Array(String)? = nil, instructions_email : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, origin : String? = nil, payment_intent : String? = nil, reason : String? = nil, refund_application_fee : Bool? = nil, reverse_transfer : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_post_refunds(amount: amount, charge: charge, currency: currency, customer: customer, expand: expand, instructions_email: instructions_email, metadata: metadata, origin: origin, payment_intent: payment_intent, reason: reason, refund_application_fee: refund_application_fee, reverse_transfer: reverse_transfer).execute(&block)
    end

    POST_REFUNDS_MAX_LENGTH_FOR_CHARGE         = 5000
    POST_REFUNDS_MAX_LENGTH_FOR_CUSTOMER       = 5000
    POST_REFUNDS_VALID_VALUES_FOR_ORIGIN       = StaticArray["customer_balance"]
    POST_REFUNDS_MAX_LENGTH_FOR_PAYMENT_INTENT = 5000
    POST_REFUNDS_MAX_LENGTH_FOR_REASON         = 5000
    POST_REFUNDS_VALID_VALUES_FOR_REASON       = StaticArray["duplicate", "fraudulent", "requested_by_customer"]

    # @return Crest::Request
    def build_api_request_for_post_refunds(*, amount : Int64? = nil, charge : String? = nil, currency : String? = nil, customer : String? = nil, expand : Array(String)? = nil, instructions_email : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, origin : String? = nil, payment_intent : String? = nil, reason : String? = nil, refund_application_fee : Bool? = nil, reverse_transfer : Bool? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_refunds ..." }
      end

      if client_side_validation
        if _charge = charge
          OpenApi::PrimitiveValidator.validate_max_length("charge", charge.to_s.size, POST_REFUNDS_MAX_LENGTH_FOR_CHARGE)
        end

        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_REFUNDS_MAX_LENGTH_FOR_CUSTOMER)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _origin = origin
          OpenApi::EnumValidator.validate("origin", _origin, POST_REFUNDS_VALID_VALUES_FOR_ORIGIN)
        end
        if _payment_intent = payment_intent
          OpenApi::PrimitiveValidator.validate_max_length("payment_intent", payment_intent.to_s.size, POST_REFUNDS_MAX_LENGTH_FOR_PAYMENT_INTENT)
        end
        if _reason = reason
          OpenApi::EnumValidator.validate("reason", _reason, POST_REFUNDS_VALID_VALUES_FOR_REASON)
        end
      end

      # resource path
      local_var_path = "/v1/refunds"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["charge"] = charge.to_s if !charge.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["instructions_email"] = instructions_email.to_s if !instructions_email.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["origin"] = origin.to_s if !origin.nil?
      form_params["payment_intent"] = payment_intent.to_s if !payment_intent.nil?
      form_params["reason"] = reason.to_s if !reason.nil?
      form_params["refund_application_fee"] = refund_application_fee.to_s if !refund_application_fee.nil?
      form_params["reverse_transfer"] = reverse_transfer.to_s if !reverse_transfer.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_refunds",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the specified refund by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>  <p>This request only accepts <code>metadata</code> as an argument.</p>
    # @param refund [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Refund]
    def post_refunds_refund(*, refund : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_refunds_refund_with_http_info(refund: refund, expand: expand, metadata: metadata)
      data
    end

    # &lt;p&gt;Updates the specified refund by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;  &lt;p&gt;This request only accepts &lt;code&gt;metadata&lt;/code&gt; as an argument.&lt;/p&gt;
    # @param refund [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(Refund, Integer, Hash)>] Refund data, response status code and response headers
    def post_refunds_refund_with_http_info(*, refund : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_refunds_refund(refund: refund, expand: expand, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_refunds_refund\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Refund.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the specified refund by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;  &lt;p&gt;This request only accepts &lt;code&gt;metadata&lt;/code&gt; as an argument.&lt;/p&gt;
    # @param refund [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_refunds_refund(*, refund : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_refunds_refund(refund: refund, expand: expand, metadata: metadata).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_post_refunds_refund(*, refund : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_refunds_refund ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"refund\" is required and cannot be null") if refund.nil?

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/refunds/{refund}".sub("{" + "refund" + "}", URI.encode_path(refund.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_refunds_refund",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Cancels a refund with a status of <code>requires_action</code>.</p>  <p>Refunds in other states cannot be canceled, and only refunds for payment methods that require customer action will enter the <code>requires_action</code> state.</p>
    # @param refund [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Refund]
    def post_refunds_refund_cancel(*, refund : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_refunds_refund_cancel_with_http_info(refund: refund, expand: expand)
      data
    end

    # &lt;p&gt;Cancels a refund with a status of &lt;code&gt;requires_action&lt;/code&gt;.&lt;/p&gt;  &lt;p&gt;Refunds in other states cannot be canceled, and only refunds for payment methods that require customer action will enter the &lt;code&gt;requires_action&lt;/code&gt; state.&lt;/p&gt;
    # @param refund [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(Refund, Integer, Hash)>] Refund data, response status code and response headers
    def post_refunds_refund_cancel_with_http_info(*, refund : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_refunds_refund_cancel(refund: refund, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_refunds_refund_cancel\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Refund.from_json(data), status_code, headers
    end

    # &lt;p&gt;Cancels a refund with a status of &lt;code&gt;requires_action&lt;/code&gt;.&lt;/p&gt;  &lt;p&gt;Refunds in other states cannot be canceled, and only refunds for payment methods that require customer action will enter the &lt;code&gt;requires_action&lt;/code&gt; state.&lt;/p&gt;
    # @param refund [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_refunds_refund_cancel(*, refund : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_refunds_refund_cancel(refund: refund, expand: expand).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_post_refunds_refund_cancel(*, refund : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_refunds_refund_cancel ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"refund\" is required and cannot be null") if refund.nil?
      end

      # resource path
      local_var_path = "/v1/refunds/{refund}/cancel".sub("{" + "refund" + "}", URI.encode_path(refund.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_refunds_refund_cancel",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new object and begin running the report. (Certain report types require a <a href=\"https://stripe.com/docs/keys#test-live-modes\">live-mode API key</a>.)</p>
    # @param report_type [String?] The ID of the [report type](https://stripe.com/docs/reporting/statements/api#report-types) to run, such as `\\\"balance.summary.1\\\"`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param parameters [Stripe::RunParameterSpecs?]
    # @return [ReportingReportRun]
    def post_reporting_report_runs(*, report_type : String? = nil, expand : Array(String)? = nil, parameters : Stripe::RunParameterSpecs? = nil)
      data, _status_code, _headers = post_reporting_report_runs_with_http_info(report_type: report_type, expand: expand, parameters: parameters)
      data
    end

    # &lt;p&gt;Creates a new object and begin running the report. (Certain report types require a &lt;a href&#x3D;\&quot;https://stripe.com/docs/keys#test-live-modes\&quot;&gt;live-mode API key&lt;/a&gt;.)&lt;/p&gt;
    # @param report_type [String?] The ID of the [report type](https://stripe.com/docs/reporting/statements/api#report-types) to run, such as `\\\"balance.summary.1\\\"`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param parameters [Stripe::RunParameterSpecs?]
    # @return [Array<(ReportingReportRun, Integer, Hash)>] ReportingReportRun data, response status code and response headers
    def post_reporting_report_runs_with_http_info(*, report_type : String? = nil, expand : Array(String)? = nil, parameters : Stripe::RunParameterSpecs? = nil)
      request = build_api_request_for_post_reporting_report_runs(report_type: report_type, expand: expand, parameters: parameters)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_reporting_report_runs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ReportingReportRun.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new object and begin running the report. (Certain report types require a &lt;a href&#x3D;\&quot;https://stripe.com/docs/keys#test-live-modes\&quot;&gt;live-mode API key&lt;/a&gt;.)&lt;/p&gt;
    # @param report_type [String?] The ID of the [report type](https://stripe.com/docs/reporting/statements/api#report-types) to run, such as `\\\"balance.summary.1\\\"`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param parameters [Stripe::RunParameterSpecs?]
    # @return nil
    def post_reporting_report_runs(*, report_type : String? = nil, expand : Array(String)? = nil, parameters : Stripe::RunParameterSpecs? = nil, &block : Crest::Response ->)
      build_api_request_for_post_reporting_report_runs(report_type: report_type, expand: expand, parameters: parameters).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_post_reporting_report_runs(*, report_type : String? = nil, expand : Array(String)? = nil, parameters : Stripe::RunParameterSpecs? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_reporting_report_runs ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"report_type\" is required and cannot be null") if report_type.nil?

        if _parameters = parameters
          _parameters.validate if _parameters.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/reporting/report_runs"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["parameters"] = parameters.to_s if !parameters.nil?
      form_params["report_type"] = report_type.to_s if !report_type.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_reporting_report_runs",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Approves a <code>Review</code> object, closing it and removing it from the list of reviews.</p>
    # @param review [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Review]
    def post_reviews_review_approve(*, review : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_reviews_review_approve_with_http_info(review: review, expand: expand)
      data
    end

    # &lt;p&gt;Approves a &lt;code&gt;Review&lt;/code&gt; object, closing it and removing it from the list of reviews.&lt;/p&gt;
    # @param review [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(Review, Integer, Hash)>] Review data, response status code and response headers
    def post_reviews_review_approve_with_http_info(*, review : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_reviews_review_approve(review: review, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_reviews_review_approve\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Review.from_json(data), status_code, headers
    end

    # &lt;p&gt;Approves a &lt;code&gt;Review&lt;/code&gt; object, closing it and removing it from the list of reviews.&lt;/p&gt;
    # @param review [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_reviews_review_approve(*, review : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_reviews_review_approve(review: review, expand: expand).execute(&block)
    end

    POST_REVIEWS_REVIEW_APPROVE_MAX_LENGTH_FOR_REVIEW = 5000

    # @return Crest::Request
    def build_api_request_for_post_reviews_review_approve(*, review : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_reviews_review_approve ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"review\" is required and cannot be null") if review.nil?
        if _review = review
          OpenApi::PrimitiveValidator.validate_max_length("review", review.to_s.size, POST_REVIEWS_REVIEW_APPROVE_MAX_LENGTH_FOR_REVIEW)
        end
      end

      # resource path
      local_var_path = "/v1/reviews/{review}/approve".sub("{" + "review" + "}", URI.encode_path(review.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_reviews_review_approve",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a SetupIntent object.</p>  <p>After the SetupIntent is created, attach a payment method and <a href=\"/docs/api/setup_intents/confirm\">confirm</a> to collect any required permissions to charge the payment method later.</p>
    # @optional @param attach_to_self [Bool?] If present, the SetupIntent's payment method will be attached to the in-context Stripe Account.  It can only be used for this Stripe Account’s own money movement flows like InboundTransfer and OutboundTransfers. It cannot be set to true when setting up a PaymentMethod for a Customer, and defaults to false when attaching a PaymentMethod to a Customer.
    # @optional @param confirm [Bool?] Set to `true` to attempt to confirm this SetupIntent immediately. This parameter defaults to `false`. If the payment method attached is a card, a return_url may be provided in case additional authentication is required.
    # @optional @param customer [String?] ID of the Customer this SetupIntent belongs to, if one exists.  If present, the SetupIntent's payment method will be attached to the Customer on successful setup. Payment methods attached to other Customers cannot be used with this SetupIntent.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param flow_directions [Array(String)?] Indicates the directions of money movement for which this payment method is intended to be used.  Include `inbound` if you intend to use the payment method as the origin to pull funds from. Include `outbound` if you intend to use the payment method as the destination to send funds to. You can include both if you intend to use the payment method for both purposes.
    # @optional @param mandate_data [Stripe::SecretKeyParam2?]
    # @optional @param on_behalf_of [String?] The Stripe account ID for which this SetupIntent is created.
    # @optional @param payment_method [String?] ID of the payment method (a PaymentMethod, Card, or saved Source object) to attach to this SetupIntent.
    # @optional @param payment_method_data [Stripe::PaymentMethodDataParams1?]
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam22?]
    # @optional @param payment_method_types [Array(String)?] The list of payment method types (e.g. card) that this SetupIntent is allowed to use. If this is not provided, defaults to [\\\"card\\\"].
    # @optional @param return_url [String?] The URL to redirect your customer back to after they authenticate or cancel their payment on the payment method's app or site. If you'd prefer to redirect to a mobile application, you can alternatively supply an application URI scheme. This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/setup_intents/create#create_setup_intent-confirm).
    # @optional @param single_use [Stripe::SetupIntentSingleUseParams?]
    # @optional @param usage [String?] Indicates how the payment method is intended to be used in the future. If not provided, this value defaults to `off_session`.
    # @return [SetupIntent]
    def post_setup_intents(*, attach_to_self : Bool? = nil, confirm : Bool? = nil, customer : String? = nil, description : String? = nil, expand : Array(String)? = nil, flow_directions : Array(String)? = nil, mandate_data : Stripe::SecretKeyParam2? = nil, on_behalf_of : String? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams1? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam22? = nil, payment_method_types : Array(String)? = nil, return_url : String? = nil, single_use : Stripe::SetupIntentSingleUseParams? = nil, usage : String? = nil)
      data, _status_code, _headers = post_setup_intents_with_http_info(attach_to_self: attach_to_self, confirm: confirm, customer: customer, description: description, expand: expand, flow_directions: flow_directions, mandate_data: mandate_data, on_behalf_of: on_behalf_of, payment_method: payment_method, payment_method_data: payment_method_data, payment_method_options: payment_method_options, payment_method_types: payment_method_types, return_url: return_url, single_use: single_use, usage: usage)
      data
    end

    # &lt;p&gt;Creates a SetupIntent object.&lt;/p&gt;  &lt;p&gt;After the SetupIntent is created, attach a payment method and &lt;a href&#x3D;\&quot;/docs/api/setup_intents/confirm\&quot;&gt;confirm&lt;/a&gt; to collect any required permissions to charge the payment method later.&lt;/p&gt;
    # @optional @param attach_to_self [Bool?] If present, the SetupIntent's payment method will be attached to the in-context Stripe Account.  It can only be used for this Stripe Account’s own money movement flows like InboundTransfer and OutboundTransfers. It cannot be set to true when setting up a PaymentMethod for a Customer, and defaults to false when attaching a PaymentMethod to a Customer.
    # @optional @param confirm [Bool?] Set to `true` to attempt to confirm this SetupIntent immediately. This parameter defaults to `false`. If the payment method attached is a card, a return_url may be provided in case additional authentication is required.
    # @optional @param customer [String?] ID of the Customer this SetupIntent belongs to, if one exists.  If present, the SetupIntent's payment method will be attached to the Customer on successful setup. Payment methods attached to other Customers cannot be used with this SetupIntent.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param flow_directions [Array(String)?] Indicates the directions of money movement for which this payment method is intended to be used.  Include `inbound` if you intend to use the payment method as the origin to pull funds from. Include `outbound` if you intend to use the payment method as the destination to send funds to. You can include both if you intend to use the payment method for both purposes.
    # @optional @param mandate_data [Stripe::SecretKeyParam2?]
    # @optional @param on_behalf_of [String?] The Stripe account ID for which this SetupIntent is created.
    # @optional @param payment_method [String?] ID of the payment method (a PaymentMethod, Card, or saved Source object) to attach to this SetupIntent.
    # @optional @param payment_method_data [Stripe::PaymentMethodDataParams1?]
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam22?]
    # @optional @param payment_method_types [Array(String)?] The list of payment method types (e.g. card) that this SetupIntent is allowed to use. If this is not provided, defaults to [\\\"card\\\"].
    # @optional @param return_url [String?] The URL to redirect your customer back to after they authenticate or cancel their payment on the payment method's app or site. If you'd prefer to redirect to a mobile application, you can alternatively supply an application URI scheme. This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/setup_intents/create#create_setup_intent-confirm).
    # @optional @param single_use [Stripe::SetupIntentSingleUseParams?]
    # @optional @param usage [String?] Indicates how the payment method is intended to be used in the future. If not provided, this value defaults to `off_session`.
    # @return [Array<(SetupIntent, Integer, Hash)>] SetupIntent data, response status code and response headers
    def post_setup_intents_with_http_info(*, attach_to_self : Bool? = nil, confirm : Bool? = nil, customer : String? = nil, description : String? = nil, expand : Array(String)? = nil, flow_directions : Array(String)? = nil, mandate_data : Stripe::SecretKeyParam2? = nil, on_behalf_of : String? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams1? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam22? = nil, payment_method_types : Array(String)? = nil, return_url : String? = nil, single_use : Stripe::SetupIntentSingleUseParams? = nil, usage : String? = nil)
      request = build_api_request_for_post_setup_intents(attach_to_self: attach_to_self, confirm: confirm, customer: customer, description: description, expand: expand, flow_directions: flow_directions, mandate_data: mandate_data, on_behalf_of: on_behalf_of, payment_method: payment_method, payment_method_data: payment_method_data, payment_method_options: payment_method_options, payment_method_types: payment_method_types, return_url: return_url, single_use: single_use, usage: usage)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_setup_intents\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SetupIntent.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a SetupIntent object.&lt;/p&gt;  &lt;p&gt;After the SetupIntent is created, attach a payment method and &lt;a href&#x3D;\&quot;/docs/api/setup_intents/confirm\&quot;&gt;confirm&lt;/a&gt; to collect any required permissions to charge the payment method later.&lt;/p&gt;
    # @optional @param attach_to_self [Bool?] If present, the SetupIntent's payment method will be attached to the in-context Stripe Account.  It can only be used for this Stripe Account’s own money movement flows like InboundTransfer and OutboundTransfers. It cannot be set to true when setting up a PaymentMethod for a Customer, and defaults to false when attaching a PaymentMethod to a Customer.
    # @optional @param confirm [Bool?] Set to `true` to attempt to confirm this SetupIntent immediately. This parameter defaults to `false`. If the payment method attached is a card, a return_url may be provided in case additional authentication is required.
    # @optional @param customer [String?] ID of the Customer this SetupIntent belongs to, if one exists.  If present, the SetupIntent's payment method will be attached to the Customer on successful setup. Payment methods attached to other Customers cannot be used with this SetupIntent.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param flow_directions [Array(String)?] Indicates the directions of money movement for which this payment method is intended to be used.  Include `inbound` if you intend to use the payment method as the origin to pull funds from. Include `outbound` if you intend to use the payment method as the destination to send funds to. You can include both if you intend to use the payment method for both purposes.
    # @optional @param mandate_data [Stripe::SecretKeyParam2?]
    # @optional @param on_behalf_of [String?] The Stripe account ID for which this SetupIntent is created.
    # @optional @param payment_method [String?] ID of the payment method (a PaymentMethod, Card, or saved Source object) to attach to this SetupIntent.
    # @optional @param payment_method_data [Stripe::PaymentMethodDataParams1?]
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam22?]
    # @optional @param payment_method_types [Array(String)?] The list of payment method types (e.g. card) that this SetupIntent is allowed to use. If this is not provided, defaults to [\\\"card\\\"].
    # @optional @param return_url [String?] The URL to redirect your customer back to after they authenticate or cancel their payment on the payment method's app or site. If you'd prefer to redirect to a mobile application, you can alternatively supply an application URI scheme. This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/setup_intents/create#create_setup_intent-confirm).
    # @optional @param single_use [Stripe::SetupIntentSingleUseParams?]
    # @optional @param usage [String?] Indicates how the payment method is intended to be used in the future. If not provided, this value defaults to `off_session`.
    # @return nil
    def post_setup_intents(*, attach_to_self : Bool? = nil, confirm : Bool? = nil, customer : String? = nil, description : String? = nil, expand : Array(String)? = nil, flow_directions : Array(String)? = nil, mandate_data : Stripe::SecretKeyParam2? = nil, on_behalf_of : String? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams1? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam22? = nil, payment_method_types : Array(String)? = nil, return_url : String? = nil, single_use : Stripe::SetupIntentSingleUseParams? = nil, usage : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_setup_intents(attach_to_self: attach_to_self, confirm: confirm, customer: customer, description: description, expand: expand, flow_directions: flow_directions, mandate_data: mandate_data, on_behalf_of: on_behalf_of, payment_method: payment_method, payment_method_data: payment_method_data, payment_method_options: payment_method_options, payment_method_types: payment_method_types, return_url: return_url, single_use: single_use, usage: usage).execute(&block)
    end

    POST_SETUP_INTENTS_MAX_LENGTH_FOR_CUSTOMER          = 5000
    POST_SETUP_INTENTS_MAX_LENGTH_FOR_DESCRIPTION       = 1000
    POST_SETUP_INTENTS_VALID_VALUES_FOR_FLOW_DIRECTIONS = StaticArray["inbound", "outbound"]
    POST_SETUP_INTENTS_MAX_LENGTH_FOR_PAYMENT_METHOD    = 5000
    POST_SETUP_INTENTS_VALID_VALUES_FOR_USAGE           = StaticArray["off_session", "on_session"]

    # @return Crest::Request
    def build_api_request_for_post_setup_intents(*, attach_to_self : Bool? = nil, confirm : Bool? = nil, customer : String? = nil, description : String? = nil, expand : Array(String)? = nil, flow_directions : Array(String)? = nil, mandate_data : Stripe::SecretKeyParam2? = nil, on_behalf_of : String? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams1? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam22? = nil, payment_method_types : Array(String)? = nil, return_url : String? = nil, single_use : Stripe::SetupIntentSingleUseParams? = nil, usage : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_setup_intents ..." }
      end

      if client_side_validation
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_SETUP_INTENTS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_SETUP_INTENTS_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _flow_directions = flow_directions
          OpenApi::EnumValidator.validate("flow_directions", _flow_directions, POST_SETUP_INTENTS_VALID_VALUES_FOR_FLOW_DIRECTIONS)
        end
        if _mandate_data = mandate_data
          _mandate_data.validate if _mandate_data.is_a?(OpenApi::Validatable)
        end

        if _payment_method = payment_method
          OpenApi::PrimitiveValidator.validate_max_length("payment_method", payment_method.to_s.size, POST_SETUP_INTENTS_MAX_LENGTH_FOR_PAYMENT_METHOD)
        end
        if _payment_method_data = payment_method_data
          _payment_method_data.validate if _payment_method_data.is_a?(OpenApi::Validatable)
        end
        if _payment_method_options = payment_method_options
          _payment_method_options.validate if _payment_method_options.is_a?(OpenApi::Validatable)
        end

        if _single_use = single_use
          _single_use.validate if _single_use.is_a?(OpenApi::Validatable)
        end
        if _usage = usage
          OpenApi::EnumValidator.validate("usage", _usage, POST_SETUP_INTENTS_VALID_VALUES_FOR_USAGE)
        end
      end

      # resource path
      local_var_path = "/v1/setup_intents"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["attach_to_self"] = attach_to_self.to_s if !attach_to_self.nil?
      form_params["confirm"] = confirm.to_s if !confirm.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["flow_directions"] = @api_client.build_collection_param(flow_directions, "csv") if !flow_directions.nil? && !flow_directions.empty?
      form_params["mandate_data"] = mandate_data.to_s if !mandate_data.nil?
      form_params["on_behalf_of"] = on_behalf_of.to_s if !on_behalf_of.nil?
      form_params["payment_method"] = payment_method.to_s if !payment_method.nil?
      form_params["payment_method_data"] = payment_method_data.to_s if !payment_method_data.nil?
      form_params["payment_method_options"] = payment_method_options.to_s if !payment_method_options.nil?
      form_params["payment_method_types"] = @api_client.build_collection_param(payment_method_types, "csv") if !payment_method_types.nil? && !payment_method_types.empty?
      form_params["return_url"] = return_url.to_s if !return_url.nil?
      form_params["single_use"] = single_use.to_s if !single_use.nil?
      form_params["usage"] = usage.to_s if !usage.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_setup_intents",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates a SetupIntent object.</p>
    # @param intent [String?]
    # @optional @param attach_to_self [Bool?] If present, the SetupIntent's payment method will be attached to the in-context Stripe Account.  It can only be used for this Stripe Account’s own money movement flows like InboundTransfer and OutboundTransfers. It cannot be set to true when setting up a PaymentMethod for a Customer, and defaults to false when attaching a PaymentMethod to a Customer.
    # @optional @param customer [String?] ID of the Customer this SetupIntent belongs to, if one exists.  If present, the SetupIntent's payment method will be attached to the Customer on successful setup. Payment methods attached to other Customers cannot be used with this SetupIntent.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param flow_directions [Array(String)?] Indicates the directions of money movement for which this payment method is intended to be used.  Include `inbound` if you intend to use the payment method as the origin to pull funds from. Include `outbound` if you intend to use the payment method as the destination to send funds to. You can include both if you intend to use the payment method for both purposes.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param payment_method [String?] ID of the payment method (a PaymentMethod, Card, or saved Source object) to attach to this SetupIntent.
    # @optional @param payment_method_data [Stripe::PaymentMethodDataParams1?]
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam22?]
    # @optional @param payment_method_types [Array(String)?] The list of payment method types (e.g. card) that this SetupIntent is allowed to set up. If this is not provided, defaults to [\\\"card\\\"].
    # @return [SetupIntent]
    def post_setup_intents_intent(*, intent : String? = nil, attach_to_self : Bool? = nil, customer : String? = nil, description : String? = nil, expand : Array(String)? = nil, flow_directions : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams1? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam22? = nil, payment_method_types : Array(String)? = nil)
      data, _status_code, _headers = post_setup_intents_intent_with_http_info(intent: intent, attach_to_self: attach_to_self, customer: customer, description: description, expand: expand, flow_directions: flow_directions, metadata: metadata, payment_method: payment_method, payment_method_data: payment_method_data, payment_method_options: payment_method_options, payment_method_types: payment_method_types)
      data
    end

    # &lt;p&gt;Updates a SetupIntent object.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param attach_to_self [Bool?] If present, the SetupIntent's payment method will be attached to the in-context Stripe Account.  It can only be used for this Stripe Account’s own money movement flows like InboundTransfer and OutboundTransfers. It cannot be set to true when setting up a PaymentMethod for a Customer, and defaults to false when attaching a PaymentMethod to a Customer.
    # @optional @param customer [String?] ID of the Customer this SetupIntent belongs to, if one exists.  If present, the SetupIntent's payment method will be attached to the Customer on successful setup. Payment methods attached to other Customers cannot be used with this SetupIntent.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param flow_directions [Array(String)?] Indicates the directions of money movement for which this payment method is intended to be used.  Include `inbound` if you intend to use the payment method as the origin to pull funds from. Include `outbound` if you intend to use the payment method as the destination to send funds to. You can include both if you intend to use the payment method for both purposes.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param payment_method [String?] ID of the payment method (a PaymentMethod, Card, or saved Source object) to attach to this SetupIntent.
    # @optional @param payment_method_data [Stripe::PaymentMethodDataParams1?]
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam22?]
    # @optional @param payment_method_types [Array(String)?] The list of payment method types (e.g. card) that this SetupIntent is allowed to set up. If this is not provided, defaults to [\\\"card\\\"].
    # @return [Array<(SetupIntent, Integer, Hash)>] SetupIntent data, response status code and response headers
    def post_setup_intents_intent_with_http_info(*, intent : String? = nil, attach_to_self : Bool? = nil, customer : String? = nil, description : String? = nil, expand : Array(String)? = nil, flow_directions : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams1? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam22? = nil, payment_method_types : Array(String)? = nil)
      request = build_api_request_for_post_setup_intents_intent(intent: intent, attach_to_self: attach_to_self, customer: customer, description: description, expand: expand, flow_directions: flow_directions, metadata: metadata, payment_method: payment_method, payment_method_data: payment_method_data, payment_method_options: payment_method_options, payment_method_types: payment_method_types)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_setup_intents_intent\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SetupIntent.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates a SetupIntent object.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param attach_to_self [Bool?] If present, the SetupIntent's payment method will be attached to the in-context Stripe Account.  It can only be used for this Stripe Account’s own money movement flows like InboundTransfer and OutboundTransfers. It cannot be set to true when setting up a PaymentMethod for a Customer, and defaults to false when attaching a PaymentMethod to a Customer.
    # @optional @param customer [String?] ID of the Customer this SetupIntent belongs to, if one exists.  If present, the SetupIntent's payment method will be attached to the Customer on successful setup. Payment methods attached to other Customers cannot be used with this SetupIntent.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param flow_directions [Array(String)?] Indicates the directions of money movement for which this payment method is intended to be used.  Include `inbound` if you intend to use the payment method as the origin to pull funds from. Include `outbound` if you intend to use the payment method as the destination to send funds to. You can include both if you intend to use the payment method for both purposes.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param payment_method [String?] ID of the payment method (a PaymentMethod, Card, or saved Source object) to attach to this SetupIntent.
    # @optional @param payment_method_data [Stripe::PaymentMethodDataParams1?]
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam22?]
    # @optional @param payment_method_types [Array(String)?] The list of payment method types (e.g. card) that this SetupIntent is allowed to set up. If this is not provided, defaults to [\\\"card\\\"].
    # @return nil
    def post_setup_intents_intent(*, intent : String? = nil, attach_to_self : Bool? = nil, customer : String? = nil, description : String? = nil, expand : Array(String)? = nil, flow_directions : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams1? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam22? = nil, payment_method_types : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_setup_intents_intent(intent: intent, attach_to_self: attach_to_self, customer: customer, description: description, expand: expand, flow_directions: flow_directions, metadata: metadata, payment_method: payment_method, payment_method_data: payment_method_data, payment_method_options: payment_method_options, payment_method_types: payment_method_types).execute(&block)
    end

    POST_SETUP_INTENTS_INTENT_MAX_LENGTH_FOR_INTENT            = 5000
    POST_SETUP_INTENTS_INTENT_MAX_LENGTH_FOR_CUSTOMER          = 5000
    POST_SETUP_INTENTS_INTENT_MAX_LENGTH_FOR_DESCRIPTION       = 1000
    POST_SETUP_INTENTS_INTENT_VALID_VALUES_FOR_FLOW_DIRECTIONS = StaticArray["inbound", "outbound"]
    POST_SETUP_INTENTS_INTENT_MAX_LENGTH_FOR_PAYMENT_METHOD    = 5000

    # @return Crest::Request
    def build_api_request_for_post_setup_intents_intent(*, intent : String? = nil, attach_to_self : Bool? = nil, customer : String? = nil, description : String? = nil, expand : Array(String)? = nil, flow_directions : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams1? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam22? = nil, payment_method_types : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_setup_intents_intent ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"intent\" is required and cannot be null") if intent.nil?
        if _intent = intent
          OpenApi::PrimitiveValidator.validate_max_length("intent", intent.to_s.size, POST_SETUP_INTENTS_INTENT_MAX_LENGTH_FOR_INTENT)
        end

        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_SETUP_INTENTS_INTENT_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_SETUP_INTENTS_INTENT_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _flow_directions = flow_directions
          OpenApi::EnumValidator.validate("flow_directions", _flow_directions, POST_SETUP_INTENTS_INTENT_VALID_VALUES_FOR_FLOW_DIRECTIONS)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _payment_method = payment_method
          OpenApi::PrimitiveValidator.validate_max_length("payment_method", payment_method.to_s.size, POST_SETUP_INTENTS_INTENT_MAX_LENGTH_FOR_PAYMENT_METHOD)
        end
        if _payment_method_data = payment_method_data
          _payment_method_data.validate if _payment_method_data.is_a?(OpenApi::Validatable)
        end
        if _payment_method_options = payment_method_options
          _payment_method_options.validate if _payment_method_options.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/setup_intents/{intent}".sub("{" + "intent" + "}", URI.encode_path(intent.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["attach_to_self"] = attach_to_self.to_s if !attach_to_self.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["flow_directions"] = @api_client.build_collection_param(flow_directions, "csv") if !flow_directions.nil? && !flow_directions.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["payment_method"] = payment_method.to_s if !payment_method.nil?
      form_params["payment_method_data"] = payment_method_data.to_s if !payment_method_data.nil?
      form_params["payment_method_options"] = payment_method_options.to_s if !payment_method_options.nil?
      form_params["payment_method_types"] = @api_client.build_collection_param(payment_method_types, "csv") if !payment_method_types.nil? && !payment_method_types.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_setup_intents_intent",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>A SetupIntent object can be canceled when it is in one of these statuses: <code>requires_payment_method</code>, <code>requires_confirmation</code>, or <code>requires_action</code>. </p>  <p>Once canceled, setup is abandoned and any operations on the SetupIntent will fail with an error.</p>
    # @param intent [String?]
    # @optional @param cancellation_reason [String?] Reason for canceling this SetupIntent. Possible values are `abandoned`, `requested_by_customer`, or `duplicate`
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [SetupIntent]
    def post_setup_intents_intent_cancel(*, intent : String? = nil, cancellation_reason : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_setup_intents_intent_cancel_with_http_info(intent: intent, cancellation_reason: cancellation_reason, expand: expand)
      data
    end

    # &lt;p&gt;A SetupIntent object can be canceled when it is in one of these statuses: &lt;code&gt;requires_payment_method&lt;/code&gt;, &lt;code&gt;requires_confirmation&lt;/code&gt;, or &lt;code&gt;requires_action&lt;/code&gt;. &lt;/p&gt;  &lt;p&gt;Once canceled, setup is abandoned and any operations on the SetupIntent will fail with an error.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param cancellation_reason [String?] Reason for canceling this SetupIntent. Possible values are `abandoned`, `requested_by_customer`, or `duplicate`
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(SetupIntent, Integer, Hash)>] SetupIntent data, response status code and response headers
    def post_setup_intents_intent_cancel_with_http_info(*, intent : String? = nil, cancellation_reason : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_setup_intents_intent_cancel(intent: intent, cancellation_reason: cancellation_reason, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_setup_intents_intent_cancel\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SetupIntent.from_json(data), status_code, headers
    end

    # &lt;p&gt;A SetupIntent object can be canceled when it is in one of these statuses: &lt;code&gt;requires_payment_method&lt;/code&gt;, &lt;code&gt;requires_confirmation&lt;/code&gt;, or &lt;code&gt;requires_action&lt;/code&gt;. &lt;/p&gt;  &lt;p&gt;Once canceled, setup is abandoned and any operations on the SetupIntent will fail with an error.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param cancellation_reason [String?] Reason for canceling this SetupIntent. Possible values are `abandoned`, `requested_by_customer`, or `duplicate`
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_setup_intents_intent_cancel(*, intent : String? = nil, cancellation_reason : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_setup_intents_intent_cancel(intent: intent, cancellation_reason: cancellation_reason, expand: expand).execute(&block)
    end

    POST_SETUP_INTENTS_INTENT_CANCEL_MAX_LENGTH_FOR_INTENT                = 5000
    POST_SETUP_INTENTS_INTENT_CANCEL_MAX_LENGTH_FOR_CANCELLATION_REASON   = 5000
    POST_SETUP_INTENTS_INTENT_CANCEL_VALID_VALUES_FOR_CANCELLATION_REASON = StaticArray["abandoned", "duplicate", "requested_by_customer"]

    # @return Crest::Request
    def build_api_request_for_post_setup_intents_intent_cancel(*, intent : String? = nil, cancellation_reason : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_setup_intents_intent_cancel ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"intent\" is required and cannot be null") if intent.nil?
        if _intent = intent
          OpenApi::PrimitiveValidator.validate_max_length("intent", intent.to_s.size, POST_SETUP_INTENTS_INTENT_CANCEL_MAX_LENGTH_FOR_INTENT)
        end
        if _cancellation_reason = cancellation_reason
          OpenApi::EnumValidator.validate("cancellation_reason", _cancellation_reason, POST_SETUP_INTENTS_INTENT_CANCEL_VALID_VALUES_FOR_CANCELLATION_REASON)
        end
      end

      # resource path
      local_var_path = "/v1/setup_intents/{intent}/cancel".sub("{" + "intent" + "}", URI.encode_path(intent.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["cancellation_reason"] = cancellation_reason.to_s if !cancellation_reason.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_setup_intents_intent_cancel",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Confirm that your customer intends to set up the current or provided payment method. For example, you would confirm a SetupIntent when a customer hits the “Save” button on a payment method management page on your website.</p>  <p>If the selected payment method does not require any additional steps from the customer, the SetupIntent will transition to the <code>succeeded</code> status.</p>  <p>Otherwise, it will transition to the <code>requires_action</code> status and suggest additional actions via <code>next_action</code>. If setup fails, the SetupIntent will transition to the <code>requires_payment_method</code> status.</p>
    # @param intent [String?]
    # @optional @param client_secret [String?] The client secret of the SetupIntent.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param mandate_data [Stripe::PostPaymentIntentsIntentConfirmRequestMandateData?]
    # @optional @param payment_method [String?] ID of the payment method (a PaymentMethod, Card, or saved Source object) to attach to this SetupIntent.
    # @optional @param payment_method_data [Stripe::PaymentMethodDataParams1?]
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam22?]
    # @optional @param return_url [String?] The URL to redirect your customer back to after they authenticate on the payment method's app or site. If you'd prefer to redirect to a mobile application, you can alternatively supply an application URI scheme. This parameter is only used for cards and other redirect-based payment methods.
    # @return [SetupIntent]
    def post_setup_intents_intent_confirm(*, intent : String? = nil, client_secret : String? = nil, expand : Array(String)? = nil, mandate_data : Stripe::PostPaymentIntentsIntentConfirmRequestMandateData? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams1? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam22? = nil, return_url : String? = nil)
      data, _status_code, _headers = post_setup_intents_intent_confirm_with_http_info(intent: intent, client_secret: client_secret, expand: expand, mandate_data: mandate_data, payment_method: payment_method, payment_method_data: payment_method_data, payment_method_options: payment_method_options, return_url: return_url)
      data
    end

    # &lt;p&gt;Confirm that your customer intends to set up the current or provided payment method. For example, you would confirm a SetupIntent when a customer hits the “Save” button on a payment method management page on your website.&lt;/p&gt;  &lt;p&gt;If the selected payment method does not require any additional steps from the customer, the SetupIntent will transition to the &lt;code&gt;succeeded&lt;/code&gt; status.&lt;/p&gt;  &lt;p&gt;Otherwise, it will transition to the &lt;code&gt;requires_action&lt;/code&gt; status and suggest additional actions via &lt;code&gt;next_action&lt;/code&gt;. If setup fails, the SetupIntent will transition to the &lt;code&gt;requires_payment_method&lt;/code&gt; status.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param client_secret [String?] The client secret of the SetupIntent.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param mandate_data [Stripe::PostPaymentIntentsIntentConfirmRequestMandateData?]
    # @optional @param payment_method [String?] ID of the payment method (a PaymentMethod, Card, or saved Source object) to attach to this SetupIntent.
    # @optional @param payment_method_data [Stripe::PaymentMethodDataParams1?]
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam22?]
    # @optional @param return_url [String?] The URL to redirect your customer back to after they authenticate on the payment method's app or site. If you'd prefer to redirect to a mobile application, you can alternatively supply an application URI scheme. This parameter is only used for cards and other redirect-based payment methods.
    # @return [Array<(SetupIntent, Integer, Hash)>] SetupIntent data, response status code and response headers
    def post_setup_intents_intent_confirm_with_http_info(*, intent : String? = nil, client_secret : String? = nil, expand : Array(String)? = nil, mandate_data : Stripe::PostPaymentIntentsIntentConfirmRequestMandateData? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams1? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam22? = nil, return_url : String? = nil)
      request = build_api_request_for_post_setup_intents_intent_confirm(intent: intent, client_secret: client_secret, expand: expand, mandate_data: mandate_data, payment_method: payment_method, payment_method_data: payment_method_data, payment_method_options: payment_method_options, return_url: return_url)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_setup_intents_intent_confirm\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SetupIntent.from_json(data), status_code, headers
    end

    # &lt;p&gt;Confirm that your customer intends to set up the current or provided payment method. For example, you would confirm a SetupIntent when a customer hits the “Save” button on a payment method management page on your website.&lt;/p&gt;  &lt;p&gt;If the selected payment method does not require any additional steps from the customer, the SetupIntent will transition to the &lt;code&gt;succeeded&lt;/code&gt; status.&lt;/p&gt;  &lt;p&gt;Otherwise, it will transition to the &lt;code&gt;requires_action&lt;/code&gt; status and suggest additional actions via &lt;code&gt;next_action&lt;/code&gt;. If setup fails, the SetupIntent will transition to the &lt;code&gt;requires_payment_method&lt;/code&gt; status.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param client_secret [String?] The client secret of the SetupIntent.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param mandate_data [Stripe::PostPaymentIntentsIntentConfirmRequestMandateData?]
    # @optional @param payment_method [String?] ID of the payment method (a PaymentMethod, Card, or saved Source object) to attach to this SetupIntent.
    # @optional @param payment_method_data [Stripe::PaymentMethodDataParams1?]
    # @optional @param payment_method_options [Stripe::PaymentMethodOptionsParam22?]
    # @optional @param return_url [String?] The URL to redirect your customer back to after they authenticate on the payment method's app or site. If you'd prefer to redirect to a mobile application, you can alternatively supply an application URI scheme. This parameter is only used for cards and other redirect-based payment methods.
    # @return nil
    def post_setup_intents_intent_confirm(*, intent : String? = nil, client_secret : String? = nil, expand : Array(String)? = nil, mandate_data : Stripe::PostPaymentIntentsIntentConfirmRequestMandateData? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams1? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam22? = nil, return_url : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_setup_intents_intent_confirm(intent: intent, client_secret: client_secret, expand: expand, mandate_data: mandate_data, payment_method: payment_method, payment_method_data: payment_method_data, payment_method_options: payment_method_options, return_url: return_url).execute(&block)
    end

    POST_SETUP_INTENTS_INTENT_CONFIRM_MAX_LENGTH_FOR_INTENT         = 5000
    POST_SETUP_INTENTS_INTENT_CONFIRM_MAX_LENGTH_FOR_CLIENT_SECRET  = 5000
    POST_SETUP_INTENTS_INTENT_CONFIRM_MAX_LENGTH_FOR_PAYMENT_METHOD = 5000

    # @return Crest::Request
    def build_api_request_for_post_setup_intents_intent_confirm(*, intent : String? = nil, client_secret : String? = nil, expand : Array(String)? = nil, mandate_data : Stripe::PostPaymentIntentsIntentConfirmRequestMandateData? = nil, payment_method : String? = nil, payment_method_data : Stripe::PaymentMethodDataParams1? = nil, payment_method_options : Stripe::PaymentMethodOptionsParam22? = nil, return_url : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_setup_intents_intent_confirm ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"intent\" is required and cannot be null") if intent.nil?
        if _intent = intent
          OpenApi::PrimitiveValidator.validate_max_length("intent", intent.to_s.size, POST_SETUP_INTENTS_INTENT_CONFIRM_MAX_LENGTH_FOR_INTENT)
        end
        if _client_secret = client_secret
          OpenApi::PrimitiveValidator.validate_max_length("client_secret", client_secret.to_s.size, POST_SETUP_INTENTS_INTENT_CONFIRM_MAX_LENGTH_FOR_CLIENT_SECRET)
        end

        if _mandate_data = mandate_data
          _mandate_data.validate if _mandate_data.is_a?(OpenApi::Validatable)
        end
        if _payment_method = payment_method
          OpenApi::PrimitiveValidator.validate_max_length("payment_method", payment_method.to_s.size, POST_SETUP_INTENTS_INTENT_CONFIRM_MAX_LENGTH_FOR_PAYMENT_METHOD)
        end
        if _payment_method_data = payment_method_data
          _payment_method_data.validate if _payment_method_data.is_a?(OpenApi::Validatable)
        end
        if _payment_method_options = payment_method_options
          _payment_method_options.validate if _payment_method_options.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/setup_intents/{intent}/confirm".sub("{" + "intent" + "}", URI.encode_path(intent.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["client_secret"] = client_secret.to_s if !client_secret.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["mandate_data"] = mandate_data.to_s if !mandate_data.nil?
      form_params["payment_method"] = payment_method.to_s if !payment_method.nil?
      form_params["payment_method_data"] = payment_method_data.to_s if !payment_method_data.nil?
      form_params["payment_method_options"] = payment_method_options.to_s if !payment_method_options.nil?
      form_params["return_url"] = return_url.to_s if !return_url.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_setup_intents_intent_confirm",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Verifies microdeposits on a SetupIntent object.</p>
    # @param intent [String?]
    # @optional @param amounts [Array(Int64)?] Two positive integers, in *cents*, equal to the values of the microdeposits sent to the bank account.
    # @optional @param client_secret [String?] The client secret of the SetupIntent.
    # @optional @param descriptor_code [String?] A six-character code starting with SM present in the microdeposit sent to the bank account.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [SetupIntent]
    def post_setup_intents_intent_verify_microdeposits(*, intent : String? = nil, amounts : Array(Int64)? = nil, client_secret : String? = nil, descriptor_code : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_setup_intents_intent_verify_microdeposits_with_http_info(intent: intent, amounts: amounts, client_secret: client_secret, descriptor_code: descriptor_code, expand: expand)
      data
    end

    # &lt;p&gt;Verifies microdeposits on a SetupIntent object.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param amounts [Array(Int64)?] Two positive integers, in *cents*, equal to the values of the microdeposits sent to the bank account.
    # @optional @param client_secret [String?] The client secret of the SetupIntent.
    # @optional @param descriptor_code [String?] A six-character code starting with SM present in the microdeposit sent to the bank account.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(SetupIntent, Integer, Hash)>] SetupIntent data, response status code and response headers
    def post_setup_intents_intent_verify_microdeposits_with_http_info(*, intent : String? = nil, amounts : Array(Int64)? = nil, client_secret : String? = nil, descriptor_code : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_setup_intents_intent_verify_microdeposits(intent: intent, amounts: amounts, client_secret: client_secret, descriptor_code: descriptor_code, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_setup_intents_intent_verify_microdeposits\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SetupIntent.from_json(data), status_code, headers
    end

    # &lt;p&gt;Verifies microdeposits on a SetupIntent object.&lt;/p&gt;
    # @param intent [String?]
    # @optional @param amounts [Array(Int64)?] Two positive integers, in *cents*, equal to the values of the microdeposits sent to the bank account.
    # @optional @param client_secret [String?] The client secret of the SetupIntent.
    # @optional @param descriptor_code [String?] A six-character code starting with SM present in the microdeposit sent to the bank account.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_setup_intents_intent_verify_microdeposits(*, intent : String? = nil, amounts : Array(Int64)? = nil, client_secret : String? = nil, descriptor_code : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_setup_intents_intent_verify_microdeposits(intent: intent, amounts: amounts, client_secret: client_secret, descriptor_code: descriptor_code, expand: expand).execute(&block)
    end

    POST_SETUP_INTENTS_INTENT_VERIFY_MICRODEPOSITS_MAX_LENGTH_FOR_INTENT          = 5000
    POST_SETUP_INTENTS_INTENT_VERIFY_MICRODEPOSITS_MAX_LENGTH_FOR_CLIENT_SECRET   = 5000
    POST_SETUP_INTENTS_INTENT_VERIFY_MICRODEPOSITS_MAX_LENGTH_FOR_DESCRIPTOR_CODE = 5000

    # @return Crest::Request
    def build_api_request_for_post_setup_intents_intent_verify_microdeposits(*, intent : String? = nil, amounts : Array(Int64)? = nil, client_secret : String? = nil, descriptor_code : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_setup_intents_intent_verify_microdeposits ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"intent\" is required and cannot be null") if intent.nil?
        if _intent = intent
          OpenApi::PrimitiveValidator.validate_max_length("intent", intent.to_s.size, POST_SETUP_INTENTS_INTENT_VERIFY_MICRODEPOSITS_MAX_LENGTH_FOR_INTENT)
        end

        if _client_secret = client_secret
          OpenApi::PrimitiveValidator.validate_max_length("client_secret", client_secret.to_s.size, POST_SETUP_INTENTS_INTENT_VERIFY_MICRODEPOSITS_MAX_LENGTH_FOR_CLIENT_SECRET)
        end
        if _descriptor_code = descriptor_code
          OpenApi::PrimitiveValidator.validate_max_length("descriptor_code", descriptor_code.to_s.size, POST_SETUP_INTENTS_INTENT_VERIFY_MICRODEPOSITS_MAX_LENGTH_FOR_DESCRIPTOR_CODE)
        end
      end

      # resource path
      local_var_path = "/v1/setup_intents/{intent}/verify_microdeposits".sub("{" + "intent" + "}", URI.encode_path(intent.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amounts"] = @api_client.build_collection_param(amounts, "csv") if !amounts.nil? && !amounts.empty?
      form_params["client_secret"] = client_secret.to_s if !client_secret.nil?
      form_params["descriptor_code"] = descriptor_code.to_s if !descriptor_code.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_setup_intents_intent_verify_microdeposits",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new shipping rate object.</p>
    # @param display_name [String?] The name of the shipping rate, meant to be displayable to the customer. This will appear on CheckoutSessions.
    # @optional @param delivery_estimate [Stripe::DeliveryEstimate1?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param fixed_amount [Stripe::FixedAmount1?]
    # @optional @param tax_behavior [String?] Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`.
    # @optional @param tax_code [String?] A [tax code](https://stripe.com/docs/tax/tax-categories) ID. The Shipping tax code is `txcd_92010001`.
    # @optional @param _type [String?] The type of calculation to use on the shipping rate. Can only be `fixed_amount` for now.
    # @return [ShippingRate]
    def post_shipping_rates(*, display_name : String? = nil, delivery_estimate : Stripe::DeliveryEstimate1? = nil, expand : Array(String)? = nil, fixed_amount : Stripe::FixedAmount1? = nil, tax_behavior : String? = nil, tax_code : String? = nil, _type : String? = nil)
      data, _status_code, _headers = post_shipping_rates_with_http_info(display_name: display_name, delivery_estimate: delivery_estimate, expand: expand, fixed_amount: fixed_amount, tax_behavior: tax_behavior, tax_code: tax_code, _type: _type)
      data
    end

    # &lt;p&gt;Creates a new shipping rate object.&lt;/p&gt;
    # @param display_name [String?] The name of the shipping rate, meant to be displayable to the customer. This will appear on CheckoutSessions.
    # @optional @param delivery_estimate [Stripe::DeliveryEstimate1?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param fixed_amount [Stripe::FixedAmount1?]
    # @optional @param tax_behavior [String?] Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`.
    # @optional @param tax_code [String?] A [tax code](https://stripe.com/docs/tax/tax-categories) ID. The Shipping tax code is `txcd_92010001`.
    # @optional @param _type [String?] The type of calculation to use on the shipping rate. Can only be `fixed_amount` for now.
    # @return [Array<(ShippingRate, Integer, Hash)>] ShippingRate data, response status code and response headers
    def post_shipping_rates_with_http_info(*, display_name : String? = nil, delivery_estimate : Stripe::DeliveryEstimate1? = nil, expand : Array(String)? = nil, fixed_amount : Stripe::FixedAmount1? = nil, tax_behavior : String? = nil, tax_code : String? = nil, _type : String? = nil)
      request = build_api_request_for_post_shipping_rates(display_name: display_name, delivery_estimate: delivery_estimate, expand: expand, fixed_amount: fixed_amount, tax_behavior: tax_behavior, tax_code: tax_code, _type: _type)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_shipping_rates\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ShippingRate.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new shipping rate object.&lt;/p&gt;
    # @param display_name [String?] The name of the shipping rate, meant to be displayable to the customer. This will appear on CheckoutSessions.
    # @optional @param delivery_estimate [Stripe::DeliveryEstimate1?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param fixed_amount [Stripe::FixedAmount1?]
    # @optional @param tax_behavior [String?] Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`.
    # @optional @param tax_code [String?] A [tax code](https://stripe.com/docs/tax/tax-categories) ID. The Shipping tax code is `txcd_92010001`.
    # @optional @param _type [String?] The type of calculation to use on the shipping rate. Can only be `fixed_amount` for now.
    # @return nil
    def post_shipping_rates(*, display_name : String? = nil, delivery_estimate : Stripe::DeliveryEstimate1? = nil, expand : Array(String)? = nil, fixed_amount : Stripe::FixedAmount1? = nil, tax_behavior : String? = nil, tax_code : String? = nil, _type : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_shipping_rates(display_name: display_name, delivery_estimate: delivery_estimate, expand: expand, fixed_amount: fixed_amount, tax_behavior: tax_behavior, tax_code: tax_code, _type: _type).execute(&block)
    end

    POST_SHIPPING_RATES_MAX_LENGTH_FOR_DISPLAY_NAME   = 100
    POST_SHIPPING_RATES_VALID_VALUES_FOR_TAX_BEHAVIOR = StaticArray["exclusive", "inclusive", "unspecified"]
    POST_SHIPPING_RATES_VALID_VALUES_FOR__TYPE        = StaticArray["fixed_amount"]

    # @return Crest::Request
    def build_api_request_for_post_shipping_rates(*, display_name : String? = nil, delivery_estimate : Stripe::DeliveryEstimate1? = nil, expand : Array(String)? = nil, fixed_amount : Stripe::FixedAmount1? = nil, tax_behavior : String? = nil, tax_code : String? = nil, _type : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_shipping_rates ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"display_name\" is required and cannot be null") if display_name.nil?
        if _display_name = display_name
          OpenApi::PrimitiveValidator.validate_max_length("display_name", display_name.to_s.size, POST_SHIPPING_RATES_MAX_LENGTH_FOR_DISPLAY_NAME)
        end
        if _delivery_estimate = delivery_estimate
          _delivery_estimate.validate if _delivery_estimate.is_a?(OpenApi::Validatable)
        end

        if _fixed_amount = fixed_amount
          _fixed_amount.validate if _fixed_amount.is_a?(OpenApi::Validatable)
        end
        if _tax_behavior = tax_behavior
          OpenApi::EnumValidator.validate("tax_behavior", _tax_behavior, POST_SHIPPING_RATES_VALID_VALUES_FOR_TAX_BEHAVIOR)
        end

        if __type = _type
          OpenApi::EnumValidator.validate("_type", __type, POST_SHIPPING_RATES_VALID_VALUES_FOR__TYPE)
        end
      end

      # resource path
      local_var_path = "/v1/shipping_rates"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["delivery_estimate"] = delivery_estimate.to_s if !delivery_estimate.nil?
      form_params["display_name"] = display_name.to_s if !display_name.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["fixed_amount"] = fixed_amount.to_s if !fixed_amount.nil?
      form_params["tax_behavior"] = tax_behavior.to_s if !tax_behavior.nil?
      form_params["tax_code"] = tax_code.to_s if !tax_code.nil?
      form_params["type"] = _type.to_s if !_type.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_shipping_rates",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates an existing shipping rate object.</p>
    # @param shipping_rate_token [String?]
    # @optional @param active [Bool?] Whether the shipping rate can be used for new purchases. Defaults to `true`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param fixed_amount [Stripe::FixedAmountUpdate?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param tax_behavior [String?] Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`.
    # @return [ShippingRate]
    def post_shipping_rates_shipping_rate_token(*, shipping_rate_token : String? = nil, active : Bool? = nil, expand : Array(String)? = nil, fixed_amount : Stripe::FixedAmountUpdate? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, tax_behavior : String? = nil)
      data, _status_code, _headers = post_shipping_rates_shipping_rate_token_with_http_info(shipping_rate_token: shipping_rate_token, active: active, expand: expand, fixed_amount: fixed_amount, metadata: metadata, tax_behavior: tax_behavior)
      data
    end

    # &lt;p&gt;Updates an existing shipping rate object.&lt;/p&gt;
    # @param shipping_rate_token [String?]
    # @optional @param active [Bool?] Whether the shipping rate can be used for new purchases. Defaults to `true`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param fixed_amount [Stripe::FixedAmountUpdate?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param tax_behavior [String?] Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`.
    # @return [Array<(ShippingRate, Integer, Hash)>] ShippingRate data, response status code and response headers
    def post_shipping_rates_shipping_rate_token_with_http_info(*, shipping_rate_token : String? = nil, active : Bool? = nil, expand : Array(String)? = nil, fixed_amount : Stripe::FixedAmountUpdate? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, tax_behavior : String? = nil)
      request = build_api_request_for_post_shipping_rates_shipping_rate_token(shipping_rate_token: shipping_rate_token, active: active, expand: expand, fixed_amount: fixed_amount, metadata: metadata, tax_behavior: tax_behavior)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_shipping_rates_shipping_rate_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return ShippingRate.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates an existing shipping rate object.&lt;/p&gt;
    # @param shipping_rate_token [String?]
    # @optional @param active [Bool?] Whether the shipping rate can be used for new purchases. Defaults to `true`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param fixed_amount [Stripe::FixedAmountUpdate?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param tax_behavior [String?] Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`.
    # @return nil
    def post_shipping_rates_shipping_rate_token(*, shipping_rate_token : String? = nil, active : Bool? = nil, expand : Array(String)? = nil, fixed_amount : Stripe::FixedAmountUpdate? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, tax_behavior : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_shipping_rates_shipping_rate_token(shipping_rate_token: shipping_rate_token, active: active, expand: expand, fixed_amount: fixed_amount, metadata: metadata, tax_behavior: tax_behavior).execute(&block)
    end

    POST_SHIPPING_RATES_SHIPPING_RATE_TOKEN_MAX_LENGTH_FOR_SHIPPING_RATE_TOKEN = 5000
    POST_SHIPPING_RATES_SHIPPING_RATE_TOKEN_VALID_VALUES_FOR_TAX_BEHAVIOR      = StaticArray["exclusive", "inclusive", "unspecified"]

    # @return Crest::Request
    def build_api_request_for_post_shipping_rates_shipping_rate_token(*, shipping_rate_token : String? = nil, active : Bool? = nil, expand : Array(String)? = nil, fixed_amount : Stripe::FixedAmountUpdate? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, tax_behavior : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_shipping_rates_shipping_rate_token ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"shipping_rate_token\" is required and cannot be null") if shipping_rate_token.nil?
        if _shipping_rate_token = shipping_rate_token
          OpenApi::PrimitiveValidator.validate_max_length("shipping_rate_token", shipping_rate_token.to_s.size, POST_SHIPPING_RATES_SHIPPING_RATE_TOKEN_MAX_LENGTH_FOR_SHIPPING_RATE_TOKEN)
        end

        if _fixed_amount = fixed_amount
          _fixed_amount.validate if _fixed_amount.is_a?(OpenApi::Validatable)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _tax_behavior = tax_behavior
          OpenApi::EnumValidator.validate("tax_behavior", _tax_behavior, POST_SHIPPING_RATES_SHIPPING_RATE_TOKEN_VALID_VALUES_FOR_TAX_BEHAVIOR)
        end
      end

      # resource path
      local_var_path = "/v1/shipping_rates/{shipping_rate_token}".sub("{" + "shipping_rate_token" + "}", URI.encode_path(shipping_rate_token.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["active"] = active.to_s if !active.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["fixed_amount"] = fixed_amount.to_s if !fixed_amount.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["tax_behavior"] = tax_behavior.to_s if !tax_behavior.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_shipping_rates_shipping_rate_token",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new SKU associated with a product.</p>
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param inventory [Stripe::InventoryCreateSpecs?]
    # @param price [Int64?] The cost of the item as a nonnegative integer in the smallest currency unit (that is, 100 cents to charge $1.00, or 100 to charge ¥100, Japanese Yen being a zero-decimal currency).
    # @param product [String?] The ID of the product this SKU is associated with. Must be a product with type `good`.
    # @optional @param active [Bool?] Whether the SKU is available for purchase. Default to `true`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param id [String?] The identifier for the SKU. Must be unique. If not provided, an identifier will be randomly generated.
    # @optional @param image [String?] The URL of an image for this SKU, meant to be displayable to the customer.
    # @optional @param package_dimensions [Stripe::PackageDimensionsSpecs2?]
    # @return [Sku]
    def post_skus(*, currency : String? = nil, inventory : Stripe::InventoryCreateSpecs? = nil, price : Int64? = nil, product : String? = nil, active : Bool? = nil, expand : Array(String)? = nil, id : String? = nil, image : String? = nil, package_dimensions : Stripe::PackageDimensionsSpecs2? = nil)
      data, _status_code, _headers = post_skus_with_http_info(currency: currency, inventory: inventory, price: price, product: product, active: active, expand: expand, id: id, image: image, package_dimensions: package_dimensions)
      data
    end

    # &lt;p&gt;Creates a new SKU associated with a product.&lt;/p&gt;
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param inventory [Stripe::InventoryCreateSpecs?]
    # @param price [Int64?] The cost of the item as a nonnegative integer in the smallest currency unit (that is, 100 cents to charge $1.00, or 100 to charge ¥100, Japanese Yen being a zero-decimal currency).
    # @param product [String?] The ID of the product this SKU is associated with. Must be a product with type `good`.
    # @optional @param active [Bool?] Whether the SKU is available for purchase. Default to `true`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param id [String?] The identifier for the SKU. Must be unique. If not provided, an identifier will be randomly generated.
    # @optional @param image [String?] The URL of an image for this SKU, meant to be displayable to the customer.
    # @optional @param package_dimensions [Stripe::PackageDimensionsSpecs2?]
    # @return [Array<(Sku, Integer, Hash)>] Sku data, response status code and response headers
    def post_skus_with_http_info(*, currency : String? = nil, inventory : Stripe::InventoryCreateSpecs? = nil, price : Int64? = nil, product : String? = nil, active : Bool? = nil, expand : Array(String)? = nil, id : String? = nil, image : String? = nil, package_dimensions : Stripe::PackageDimensionsSpecs2? = nil)
      request = build_api_request_for_post_skus(currency: currency, inventory: inventory, price: price, product: product, active: active, expand: expand, id: id, image: image, package_dimensions: package_dimensions)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_skus\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Sku.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new SKU associated with a product.&lt;/p&gt;
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param inventory [Stripe::InventoryCreateSpecs?]
    # @param price [Int64?] The cost of the item as a nonnegative integer in the smallest currency unit (that is, 100 cents to charge $1.00, or 100 to charge ¥100, Japanese Yen being a zero-decimal currency).
    # @param product [String?] The ID of the product this SKU is associated with. Must be a product with type `good`.
    # @optional @param active [Bool?] Whether the SKU is available for purchase. Default to `true`.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param id [String?] The identifier for the SKU. Must be unique. If not provided, an identifier will be randomly generated.
    # @optional @param image [String?] The URL of an image for this SKU, meant to be displayable to the customer.
    # @optional @param package_dimensions [Stripe::PackageDimensionsSpecs2?]
    # @return nil
    def post_skus(*, currency : String? = nil, inventory : Stripe::InventoryCreateSpecs? = nil, price : Int64? = nil, product : String? = nil, active : Bool? = nil, expand : Array(String)? = nil, id : String? = nil, image : String? = nil, package_dimensions : Stripe::PackageDimensionsSpecs2? = nil, &block : Crest::Response ->)
      build_api_request_for_post_skus(currency: currency, inventory: inventory, price: price, product: product, active: active, expand: expand, id: id, image: image, package_dimensions: package_dimensions).execute(&block)
    end

    POST_SKUS_MAX_LENGTH_FOR_PRODUCT = 5000
    POST_SKUS_MAX_LENGTH_FOR_IMAGE   = 5000

    # @return Crest::Request
    def build_api_request_for_post_skus(*, currency : String? = nil, inventory : Stripe::InventoryCreateSpecs? = nil, price : Int64? = nil, product : String? = nil, active : Bool? = nil, expand : Array(String)? = nil, id : String? = nil, image : String? = nil, package_dimensions : Stripe::PackageDimensionsSpecs2? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_skus ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"currency\" is required and cannot be null") if currency.nil?

        raise ArgumentError.new("\"inventory\" is required and cannot be null") if inventory.nil?
        if _inventory = inventory
          _inventory.validate if _inventory.is_a?(OpenApi::Validatable)
        end
        raise ArgumentError.new("\"price\" is required and cannot be null") if price.nil?

        raise ArgumentError.new("\"product\" is required and cannot be null") if product.nil?
        if _product = product
          OpenApi::PrimitiveValidator.validate_max_length("product", product.to_s.size, POST_SKUS_MAX_LENGTH_FOR_PRODUCT)
        end

        if _image = image
          OpenApi::PrimitiveValidator.validate_max_length("image", image.to_s.size, POST_SKUS_MAX_LENGTH_FOR_IMAGE)
        end
        if _package_dimensions = package_dimensions
          _package_dimensions.validate if _package_dimensions.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/skus"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["active"] = active.to_s if !active.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["id"] = id.to_s if !id.nil?
      form_params["image"] = image.to_s if !image.nil?
      form_params["inventory"] = inventory.to_s if !inventory.nil?
      form_params["package_dimensions"] = package_dimensions.to_s if !package_dimensions.nil?
      form_params["price"] = price.to_s if !price.nil?
      form_params["product"] = product.to_s if !product.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_skus",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the specific SKU by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>  <p>Note that a SKU’s <code>attributes</code> are not editable. Instead, you would need to deactivate the existing SKU and create a new one with the new attribute values.</p>
    # @param id [String?]
    # @optional @param active [Bool?] Whether this SKU is available for purchase.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param image [String?] The URL of an image for this SKU, meant to be displayable to the customer.
    # @optional @param inventory [Stripe::InventoryUpdateSpecs?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param package_dimensions [Stripe::PostSkusIdRequestPackageDimensions?]
    # @optional @param price [Int64?] The cost of the item as a positive integer in the smallest currency unit (that is, 100 cents to charge $1.00, or 100 to charge ¥100, Japanese Yen being a zero-decimal currency).
    # @optional @param product [String?] The ID of the product that this SKU should belong to. The product must exist, have the same set of attribute names as the SKU's current product, and be of type `good`.
    # @return [Sku]
    def post_skus_id(*, id : String? = nil, active : Bool? = nil, currency : String? = nil, expand : Array(String)? = nil, image : String? = nil, inventory : Stripe::InventoryUpdateSpecs? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, package_dimensions : Stripe::PostSkusIdRequestPackageDimensions? = nil, price : Int64? = nil, product : String? = nil)
      data, _status_code, _headers = post_skus_id_with_http_info(id: id, active: active, currency: currency, expand: expand, image: image, inventory: inventory, metadata: metadata, package_dimensions: package_dimensions, price: price, product: product)
      data
    end

    # &lt;p&gt;Updates the specific SKU by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;  &lt;p&gt;Note that a SKU’s &lt;code&gt;attributes&lt;/code&gt; are not editable. Instead, you would need to deactivate the existing SKU and create a new one with the new attribute values.&lt;/p&gt;
    # @param id [String?]
    # @optional @param active [Bool?] Whether this SKU is available for purchase.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param image [String?] The URL of an image for this SKU, meant to be displayable to the customer.
    # @optional @param inventory [Stripe::InventoryUpdateSpecs?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param package_dimensions [Stripe::PostSkusIdRequestPackageDimensions?]
    # @optional @param price [Int64?] The cost of the item as a positive integer in the smallest currency unit (that is, 100 cents to charge $1.00, or 100 to charge ¥100, Japanese Yen being a zero-decimal currency).
    # @optional @param product [String?] The ID of the product that this SKU should belong to. The product must exist, have the same set of attribute names as the SKU's current product, and be of type `good`.
    # @return [Array<(Sku, Integer, Hash)>] Sku data, response status code and response headers
    def post_skus_id_with_http_info(*, id : String? = nil, active : Bool? = nil, currency : String? = nil, expand : Array(String)? = nil, image : String? = nil, inventory : Stripe::InventoryUpdateSpecs? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, package_dimensions : Stripe::PostSkusIdRequestPackageDimensions? = nil, price : Int64? = nil, product : String? = nil)
      request = build_api_request_for_post_skus_id(id: id, active: active, currency: currency, expand: expand, image: image, inventory: inventory, metadata: metadata, package_dimensions: package_dimensions, price: price, product: product)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_skus_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Sku.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the specific SKU by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;  &lt;p&gt;Note that a SKU’s &lt;code&gt;attributes&lt;/code&gt; are not editable. Instead, you would need to deactivate the existing SKU and create a new one with the new attribute values.&lt;/p&gt;
    # @param id [String?]
    # @optional @param active [Bool?] Whether this SKU is available for purchase.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param image [String?] The URL of an image for this SKU, meant to be displayable to the customer.
    # @optional @param inventory [Stripe::InventoryUpdateSpecs?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param package_dimensions [Stripe::PostSkusIdRequestPackageDimensions?]
    # @optional @param price [Int64?] The cost of the item as a positive integer in the smallest currency unit (that is, 100 cents to charge $1.00, or 100 to charge ¥100, Japanese Yen being a zero-decimal currency).
    # @optional @param product [String?] The ID of the product that this SKU should belong to. The product must exist, have the same set of attribute names as the SKU's current product, and be of type `good`.
    # @return nil
    def post_skus_id(*, id : String? = nil, active : Bool? = nil, currency : String? = nil, expand : Array(String)? = nil, image : String? = nil, inventory : Stripe::InventoryUpdateSpecs? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, package_dimensions : Stripe::PostSkusIdRequestPackageDimensions? = nil, price : Int64? = nil, product : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_skus_id(id: id, active: active, currency: currency, expand: expand, image: image, inventory: inventory, metadata: metadata, package_dimensions: package_dimensions, price: price, product: product).execute(&block)
    end

    POST_SKUS_ID_MAX_LENGTH_FOR_ID      = 5000
    POST_SKUS_ID_MAX_LENGTH_FOR_IMAGE   = 5000
    POST_SKUS_ID_MAX_LENGTH_FOR_PRODUCT = 5000

    # @return Crest::Request
    def build_api_request_for_post_skus_id(*, id : String? = nil, active : Bool? = nil, currency : String? = nil, expand : Array(String)? = nil, image : String? = nil, inventory : Stripe::InventoryUpdateSpecs? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, package_dimensions : Stripe::PostSkusIdRequestPackageDimensions? = nil, price : Int64? = nil, product : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_skus_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_SKUS_ID_MAX_LENGTH_FOR_ID)
        end

        if _image = image
          OpenApi::PrimitiveValidator.validate_max_length("image", image.to_s.size, POST_SKUS_ID_MAX_LENGTH_FOR_IMAGE)
        end
        if _inventory = inventory
          _inventory.validate if _inventory.is_a?(OpenApi::Validatable)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _package_dimensions = package_dimensions
          _package_dimensions.validate if _package_dimensions.is_a?(OpenApi::Validatable)
        end

        if _product = product
          OpenApi::PrimitiveValidator.validate_max_length("product", product.to_s.size, POST_SKUS_ID_MAX_LENGTH_FOR_PRODUCT)
        end
      end

      # resource path
      local_var_path = "/v1/skus/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["active"] = active.to_s if !active.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["image"] = image.to_s if !image.nil?
      form_params["inventory"] = inventory.to_s if !inventory.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["package_dimensions"] = package_dimensions.to_s if !package_dimensions.nil?
      form_params["price"] = price.to_s if !price.nil?
      form_params["product"] = product.to_s if !product.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_skus_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new source object.</p>
    # @optional @param amount [Int64?] Amount associated with the source. This is the amount for which the source will be chargeable once ready. Required for `single_use` sources. Not supported for `receiver` type sources, where charge amount may not be specified until funds land.
    # @optional @param currency [String?] Three-letter [ISO code for the currency](https://stripe.com/docs/currencies) associated with the source. This is the currency for which the source will be chargeable once ready.
    # @optional @param customer [String?] The `Customer` to whom the original source is attached to. Must be set when the original source is not a `Source` (e.g., `Card`).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param flow [String?] The authentication `flow` of the source to create. `flow` is one of `redirect`, `receiver`, `code_verification`, `none`. It is generally inferred unless a type supports multiple flows.
    # @optional @param mandate [Stripe::MandateParams?]
    # @optional @param original_source [String?] The source to share.
    # @optional @param owner [Stripe::Owner1?]
    # @optional @param receiver [Stripe::ReceiverParams?]
    # @optional @param redirect [Stripe::RedirectParams?]
    # @optional @param source_order [Stripe::ShallowOrderSpecs?]
    # @optional @param statement_descriptor [String?] An arbitrary string to be displayed on your customer's statement. As an example, if your website is `RunClub` and the item you're charging for is a race ticket, you may want to specify a `statement_descriptor` of `RunClub 5K race ticket.` While many payment types will display this information, some may not display it at all.
    # @optional @param token [String?] An optional token used to create the source. When passed, token properties will override source parameters.
    # @optional @param _type [String?] The `type` of the source to create. Required unless `customer` and `original_source` are specified (see the [Cloning card Sources](https://stripe.com/docs/sources/connect#cloning-card-sources) guide)
    # @optional @param usage [String?]
    # @return [Source]
    def post_sources(*, amount : Int64? = nil, currency : String? = nil, customer : String? = nil, expand : Array(String)? = nil, flow : String? = nil, mandate : Stripe::MandateParams? = nil, original_source : String? = nil, owner : Stripe::Owner1? = nil, receiver : Stripe::ReceiverParams? = nil, redirect : Stripe::RedirectParams? = nil, source_order : Stripe::ShallowOrderSpecs? = nil, statement_descriptor : String? = nil, token : String? = nil, _type : String? = nil, usage : String? = nil)
      data, _status_code, _headers = post_sources_with_http_info(amount: amount, currency: currency, customer: customer, expand: expand, flow: flow, mandate: mandate, original_source: original_source, owner: owner, receiver: receiver, redirect: redirect, source_order: source_order, statement_descriptor: statement_descriptor, token: token, _type: _type, usage: usage)
      data
    end

    # &lt;p&gt;Creates a new source object.&lt;/p&gt;
    # @optional @param amount [Int64?] Amount associated with the source. This is the amount for which the source will be chargeable once ready. Required for `single_use` sources. Not supported for `receiver` type sources, where charge amount may not be specified until funds land.
    # @optional @param currency [String?] Three-letter [ISO code for the currency](https://stripe.com/docs/currencies) associated with the source. This is the currency for which the source will be chargeable once ready.
    # @optional @param customer [String?] The `Customer` to whom the original source is attached to. Must be set when the original source is not a `Source` (e.g., `Card`).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param flow [String?] The authentication `flow` of the source to create. `flow` is one of `redirect`, `receiver`, `code_verification`, `none`. It is generally inferred unless a type supports multiple flows.
    # @optional @param mandate [Stripe::MandateParams?]
    # @optional @param original_source [String?] The source to share.
    # @optional @param owner [Stripe::Owner1?]
    # @optional @param receiver [Stripe::ReceiverParams?]
    # @optional @param redirect [Stripe::RedirectParams?]
    # @optional @param source_order [Stripe::ShallowOrderSpecs?]
    # @optional @param statement_descriptor [String?] An arbitrary string to be displayed on your customer's statement. As an example, if your website is `RunClub` and the item you're charging for is a race ticket, you may want to specify a `statement_descriptor` of `RunClub 5K race ticket.` While many payment types will display this information, some may not display it at all.
    # @optional @param token [String?] An optional token used to create the source. When passed, token properties will override source parameters.
    # @optional @param _type [String?] The `type` of the source to create. Required unless `customer` and `original_source` are specified (see the [Cloning card Sources](https://stripe.com/docs/sources/connect#cloning-card-sources) guide)
    # @optional @param usage [String?]
    # @return [Array<(Source, Integer, Hash)>] Source data, response status code and response headers
    def post_sources_with_http_info(*, amount : Int64? = nil, currency : String? = nil, customer : String? = nil, expand : Array(String)? = nil, flow : String? = nil, mandate : Stripe::MandateParams? = nil, original_source : String? = nil, owner : Stripe::Owner1? = nil, receiver : Stripe::ReceiverParams? = nil, redirect : Stripe::RedirectParams? = nil, source_order : Stripe::ShallowOrderSpecs? = nil, statement_descriptor : String? = nil, token : String? = nil, _type : String? = nil, usage : String? = nil)
      request = build_api_request_for_post_sources(amount: amount, currency: currency, customer: customer, expand: expand, flow: flow, mandate: mandate, original_source: original_source, owner: owner, receiver: receiver, redirect: redirect, source_order: source_order, statement_descriptor: statement_descriptor, token: token, _type: _type, usage: usage)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_sources\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Source.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new source object.&lt;/p&gt;
    # @optional @param amount [Int64?] Amount associated with the source. This is the amount for which the source will be chargeable once ready. Required for `single_use` sources. Not supported for `receiver` type sources, where charge amount may not be specified until funds land.
    # @optional @param currency [String?] Three-letter [ISO code for the currency](https://stripe.com/docs/currencies) associated with the source. This is the currency for which the source will be chargeable once ready.
    # @optional @param customer [String?] The `Customer` to whom the original source is attached to. Must be set when the original source is not a `Source` (e.g., `Card`).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param flow [String?] The authentication `flow` of the source to create. `flow` is one of `redirect`, `receiver`, `code_verification`, `none`. It is generally inferred unless a type supports multiple flows.
    # @optional @param mandate [Stripe::MandateParams?]
    # @optional @param original_source [String?] The source to share.
    # @optional @param owner [Stripe::Owner1?]
    # @optional @param receiver [Stripe::ReceiverParams?]
    # @optional @param redirect [Stripe::RedirectParams?]
    # @optional @param source_order [Stripe::ShallowOrderSpecs?]
    # @optional @param statement_descriptor [String?] An arbitrary string to be displayed on your customer's statement. As an example, if your website is `RunClub` and the item you're charging for is a race ticket, you may want to specify a `statement_descriptor` of `RunClub 5K race ticket.` While many payment types will display this information, some may not display it at all.
    # @optional @param token [String?] An optional token used to create the source. When passed, token properties will override source parameters.
    # @optional @param _type [String?] The `type` of the source to create. Required unless `customer` and `original_source` are specified (see the [Cloning card Sources](https://stripe.com/docs/sources/connect#cloning-card-sources) guide)
    # @optional @param usage [String?]
    # @return nil
    def post_sources(*, amount : Int64? = nil, currency : String? = nil, customer : String? = nil, expand : Array(String)? = nil, flow : String? = nil, mandate : Stripe::MandateParams? = nil, original_source : String? = nil, owner : Stripe::Owner1? = nil, receiver : Stripe::ReceiverParams? = nil, redirect : Stripe::RedirectParams? = nil, source_order : Stripe::ShallowOrderSpecs? = nil, statement_descriptor : String? = nil, token : String? = nil, _type : String? = nil, usage : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_sources(amount: amount, currency: currency, customer: customer, expand: expand, flow: flow, mandate: mandate, original_source: original_source, owner: owner, receiver: receiver, redirect: redirect, source_order: source_order, statement_descriptor: statement_descriptor, token: token, _type: _type, usage: usage).execute(&block)
    end

    POST_SOURCES_MAX_LENGTH_FOR_CUSTOMER             =  500
    POST_SOURCES_MAX_LENGTH_FOR_FLOW                 = 5000
    POST_SOURCES_VALID_VALUES_FOR_FLOW               = StaticArray["code_verification", "none", "receiver", "redirect"]
    POST_SOURCES_MAX_LENGTH_FOR_ORIGINAL_SOURCE      = 5000
    POST_SOURCES_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR = 5000
    POST_SOURCES_MAX_LENGTH_FOR_TOKEN                = 5000
    POST_SOURCES_MAX_LENGTH_FOR__TYPE                = 5000
    POST_SOURCES_MAX_LENGTH_FOR_USAGE                = 5000
    POST_SOURCES_VALID_VALUES_FOR_USAGE              = StaticArray["reusable", "single_use"]

    # @return Crest::Request
    def build_api_request_for_post_sources(*, amount : Int64? = nil, currency : String? = nil, customer : String? = nil, expand : Array(String)? = nil, flow : String? = nil, mandate : Stripe::MandateParams? = nil, original_source : String? = nil, owner : Stripe::Owner1? = nil, receiver : Stripe::ReceiverParams? = nil, redirect : Stripe::RedirectParams? = nil, source_order : Stripe::ShallowOrderSpecs? = nil, statement_descriptor : String? = nil, token : String? = nil, _type : String? = nil, usage : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_sources ..." }
      end

      if client_side_validation
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_SOURCES_MAX_LENGTH_FOR_CUSTOMER)
        end

        if _flow = flow
          OpenApi::EnumValidator.validate("flow", _flow, POST_SOURCES_VALID_VALUES_FOR_FLOW)
        end
        if _mandate = mandate
          _mandate.validate if _mandate.is_a?(OpenApi::Validatable)
        end
        if _original_source = original_source
          OpenApi::PrimitiveValidator.validate_max_length("original_source", original_source.to_s.size, POST_SOURCES_MAX_LENGTH_FOR_ORIGINAL_SOURCE)
        end
        if _owner = owner
          _owner.validate if _owner.is_a?(OpenApi::Validatable)
        end
        if _receiver = receiver
          _receiver.validate if _receiver.is_a?(OpenApi::Validatable)
        end
        if _redirect = redirect
          _redirect.validate if _redirect.is_a?(OpenApi::Validatable)
        end
        if _source_order = source_order
          _source_order.validate if _source_order.is_a?(OpenApi::Validatable)
        end
        if _statement_descriptor = statement_descriptor
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor", statement_descriptor.to_s.size, POST_SOURCES_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR)
        end
        if _token = token
          OpenApi::PrimitiveValidator.validate_max_length("token", token.to_s.size, POST_SOURCES_MAX_LENGTH_FOR_TOKEN)
        end
        if __type = _type
          OpenApi::PrimitiveValidator.validate_max_length("_type", _type.to_s.size, POST_SOURCES_MAX_LENGTH_FOR__TYPE)
        end
        if _usage = usage
          OpenApi::EnumValidator.validate("usage", _usage, POST_SOURCES_VALID_VALUES_FOR_USAGE)
        end
      end

      # resource path
      local_var_path = "/v1/sources"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["flow"] = flow.to_s if !flow.nil?
      form_params["mandate"] = mandate.to_s if !mandate.nil?
      form_params["original_source"] = original_source.to_s if !original_source.nil?
      form_params["owner"] = owner.to_s if !owner.nil?
      form_params["receiver"] = receiver.to_s if !receiver.nil?
      form_params["redirect"] = redirect.to_s if !redirect.nil?
      form_params["source_order"] = source_order.to_s if !source_order.nil?
      form_params["statement_descriptor"] = statement_descriptor.to_s if !statement_descriptor.nil?
      form_params["token"] = token.to_s if !token.nil?
      form_params["type"] = _type.to_s if !_type.nil?
      form_params["usage"] = usage.to_s if !usage.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_sources",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the specified source by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>  <p>This request accepts the <code>metadata</code> and <code>owner</code> as arguments. It is also possible to update type specific information for selected payment methods. Please refer to our <a href=\"/docs/sources\">payment method guides</a> for more detail.</p>
    # @param source [String?]
    # @optional @param amount [Int64?] Amount associated with the source.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param mandate [Stripe::MandateParams?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param owner [Stripe::Owner1?]
    # @optional @param source_order [Stripe::OrderParams?]
    # @return [Source]
    def post_sources_source(*, source : String? = nil, amount : Int64? = nil, expand : Array(String)? = nil, mandate : Stripe::MandateParams? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, owner : Stripe::Owner1? = nil, source_order : Stripe::OrderParams? = nil)
      data, _status_code, _headers = post_sources_source_with_http_info(source: source, amount: amount, expand: expand, mandate: mandate, metadata: metadata, owner: owner, source_order: source_order)
      data
    end

    # &lt;p&gt;Updates the specified source by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;  &lt;p&gt;This request accepts the &lt;code&gt;metadata&lt;/code&gt; and &lt;code&gt;owner&lt;/code&gt; as arguments. It is also possible to update type specific information for selected payment methods. Please refer to our &lt;a href&#x3D;\&quot;/docs/sources\&quot;&gt;payment method guides&lt;/a&gt; for more detail.&lt;/p&gt;
    # @param source [String?]
    # @optional @param amount [Int64?] Amount associated with the source.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param mandate [Stripe::MandateParams?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param owner [Stripe::Owner1?]
    # @optional @param source_order [Stripe::OrderParams?]
    # @return [Array<(Source, Integer, Hash)>] Source data, response status code and response headers
    def post_sources_source_with_http_info(*, source : String? = nil, amount : Int64? = nil, expand : Array(String)? = nil, mandate : Stripe::MandateParams? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, owner : Stripe::Owner1? = nil, source_order : Stripe::OrderParams? = nil)
      request = build_api_request_for_post_sources_source(source: source, amount: amount, expand: expand, mandate: mandate, metadata: metadata, owner: owner, source_order: source_order)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_sources_source\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Source.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the specified source by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;  &lt;p&gt;This request accepts the &lt;code&gt;metadata&lt;/code&gt; and &lt;code&gt;owner&lt;/code&gt; as arguments. It is also possible to update type specific information for selected payment methods. Please refer to our &lt;a href&#x3D;\&quot;/docs/sources\&quot;&gt;payment method guides&lt;/a&gt; for more detail.&lt;/p&gt;
    # @param source [String?]
    # @optional @param amount [Int64?] Amount associated with the source.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param mandate [Stripe::MandateParams?]
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param owner [Stripe::Owner1?]
    # @optional @param source_order [Stripe::OrderParams?]
    # @return nil
    def post_sources_source(*, source : String? = nil, amount : Int64? = nil, expand : Array(String)? = nil, mandate : Stripe::MandateParams? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, owner : Stripe::Owner1? = nil, source_order : Stripe::OrderParams? = nil, &block : Crest::Response ->)
      build_api_request_for_post_sources_source(source: source, amount: amount, expand: expand, mandate: mandate, metadata: metadata, owner: owner, source_order: source_order).execute(&block)
    end

    POST_SOURCES_SOURCE_MAX_LENGTH_FOR_SOURCE = 5000

    # @return Crest::Request
    def build_api_request_for_post_sources_source(*, source : String? = nil, amount : Int64? = nil, expand : Array(String)? = nil, mandate : Stripe::MandateParams? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, owner : Stripe::Owner1? = nil, source_order : Stripe::OrderParams? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_sources_source ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"source\" is required and cannot be null") if source.nil?
        if _source = source
          OpenApi::PrimitiveValidator.validate_max_length("source", source.to_s.size, POST_SOURCES_SOURCE_MAX_LENGTH_FOR_SOURCE)
        end

        if _mandate = mandate
          _mandate.validate if _mandate.is_a?(OpenApi::Validatable)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _owner = owner
          _owner.validate if _owner.is_a?(OpenApi::Validatable)
        end
        if _source_order = source_order
          _source_order.validate if _source_order.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/sources/{source}".sub("{" + "source" + "}", URI.encode_path(source.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["mandate"] = mandate.to_s if !mandate.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["owner"] = owner.to_s if !owner.nil?
      form_params["source_order"] = source_order.to_s if !source_order.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_sources_source",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Verify a given source.</p>
    # @param source [String?]
    # @param values [Array(String)?] The values needed to verify the source.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Source]
    def post_sources_source_verify(*, source : String? = nil, values : Array(String)? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_sources_source_verify_with_http_info(source: source, values: values, expand: expand)
      data
    end

    # &lt;p&gt;Verify a given source.&lt;/p&gt;
    # @param source [String?]
    # @param values [Array(String)?] The values needed to verify the source.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(Source, Integer, Hash)>] Source data, response status code and response headers
    def post_sources_source_verify_with_http_info(*, source : String? = nil, values : Array(String)? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_sources_source_verify(source: source, values: values, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_sources_source_verify\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Source.from_json(data), status_code, headers
    end

    # &lt;p&gt;Verify a given source.&lt;/p&gt;
    # @param source [String?]
    # @param values [Array(String)?] The values needed to verify the source.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_sources_source_verify(*, source : String? = nil, values : Array(String)? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_sources_source_verify(source: source, values: values, expand: expand).execute(&block)
    end

    POST_SOURCES_SOURCE_VERIFY_MAX_LENGTH_FOR_SOURCE = 5000

    # @return Crest::Request
    def build_api_request_for_post_sources_source_verify(*, source : String? = nil, values : Array(String)? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_sources_source_verify ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"source\" is required and cannot be null") if source.nil?
        if _source = source
          OpenApi::PrimitiveValidator.validate_max_length("source", source.to_s.size, POST_SOURCES_SOURCE_VERIFY_MAX_LENGTH_FOR_SOURCE)
        end
        raise ArgumentError.new("\"values\" is required and cannot be null") if values.nil?
      end

      # resource path
      local_var_path = "/v1/sources/{source}/verify".sub("{" + "source" + "}", URI.encode_path(source.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["values"] = @api_client.build_collection_param(values, "csv") if !values.nil? && !values.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_sources_source_verify",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Adds a new item to an existing subscription. No existing items will be changed or replaced.</p>
    # @param subscription [String?] The identifier of the subscription to modify.
    # @optional @param billing_thresholds [Stripe::PostSubscriptionItemsRequestBillingThresholds?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param payment_behavior [String?] Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.  Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).  Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
    # @optional @param price [String?] The ID of the price object.
    # @optional @param price_data [Stripe::RecurringPriceData1?]
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param proration_date [Int64?] If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply the same proration that was previewed with the [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint.
    # @optional @param quantity [Int64?] The quantity you'd like to apply to the subscription item you're creating.
    # @optional @param tax_rates [Stripe::PostSubscriptionItemsRequestTaxRates?]
    # @return [SubscriptionItem]
    def post_subscription_items(*, subscription : String? = nil, billing_thresholds : Stripe::PostSubscriptionItemsRequestBillingThresholds? = nil, expand : Array(String)? = nil, payment_behavior : String? = nil, price : String? = nil, price_data : Stripe::RecurringPriceData1? = nil, proration_behavior : String? = nil, proration_date : Int64? = nil, quantity : Int64? = nil, tax_rates : Stripe::PostSubscriptionItemsRequestTaxRates? = nil)
      data, _status_code, _headers = post_subscription_items_with_http_info(subscription: subscription, billing_thresholds: billing_thresholds, expand: expand, payment_behavior: payment_behavior, price: price, price_data: price_data, proration_behavior: proration_behavior, proration_date: proration_date, quantity: quantity, tax_rates: tax_rates)
      data
    end

    # &lt;p&gt;Adds a new item to an existing subscription. No existing items will be changed or replaced.&lt;/p&gt;
    # @param subscription [String?] The identifier of the subscription to modify.
    # @optional @param billing_thresholds [Stripe::PostSubscriptionItemsRequestBillingThresholds?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param payment_behavior [String?] Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.  Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).  Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
    # @optional @param price [String?] The ID of the price object.
    # @optional @param price_data [Stripe::RecurringPriceData1?]
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param proration_date [Int64?] If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply the same proration that was previewed with the [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint.
    # @optional @param quantity [Int64?] The quantity you'd like to apply to the subscription item you're creating.
    # @optional @param tax_rates [Stripe::PostSubscriptionItemsRequestTaxRates?]
    # @return [Array<(SubscriptionItem, Integer, Hash)>] SubscriptionItem data, response status code and response headers
    def post_subscription_items_with_http_info(*, subscription : String? = nil, billing_thresholds : Stripe::PostSubscriptionItemsRequestBillingThresholds? = nil, expand : Array(String)? = nil, payment_behavior : String? = nil, price : String? = nil, price_data : Stripe::RecurringPriceData1? = nil, proration_behavior : String? = nil, proration_date : Int64? = nil, quantity : Int64? = nil, tax_rates : Stripe::PostSubscriptionItemsRequestTaxRates? = nil)
      request = build_api_request_for_post_subscription_items(subscription: subscription, billing_thresholds: billing_thresholds, expand: expand, payment_behavior: payment_behavior, price: price, price_data: price_data, proration_behavior: proration_behavior, proration_date: proration_date, quantity: quantity, tax_rates: tax_rates)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_subscription_items\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SubscriptionItem.from_json(data), status_code, headers
    end

    # &lt;p&gt;Adds a new item to an existing subscription. No existing items will be changed or replaced.&lt;/p&gt;
    # @param subscription [String?] The identifier of the subscription to modify.
    # @optional @param billing_thresholds [Stripe::PostSubscriptionItemsRequestBillingThresholds?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param payment_behavior [String?] Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.  Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).  Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
    # @optional @param price [String?] The ID of the price object.
    # @optional @param price_data [Stripe::RecurringPriceData1?]
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param proration_date [Int64?] If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply the same proration that was previewed with the [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint.
    # @optional @param quantity [Int64?] The quantity you'd like to apply to the subscription item you're creating.
    # @optional @param tax_rates [Stripe::PostSubscriptionItemsRequestTaxRates?]
    # @return nil
    def post_subscription_items(*, subscription : String? = nil, billing_thresholds : Stripe::PostSubscriptionItemsRequestBillingThresholds? = nil, expand : Array(String)? = nil, payment_behavior : String? = nil, price : String? = nil, price_data : Stripe::RecurringPriceData1? = nil, proration_behavior : String? = nil, proration_date : Int64? = nil, quantity : Int64? = nil, tax_rates : Stripe::PostSubscriptionItemsRequestTaxRates? = nil, &block : Crest::Response ->)
      build_api_request_for_post_subscription_items(subscription: subscription, billing_thresholds: billing_thresholds, expand: expand, payment_behavior: payment_behavior, price: price, price_data: price_data, proration_behavior: proration_behavior, proration_date: proration_date, quantity: quantity, tax_rates: tax_rates).execute(&block)
    end

    POST_SUBSCRIPTION_ITEMS_MAX_LENGTH_FOR_SUBSCRIPTION         = 5000
    POST_SUBSCRIPTION_ITEMS_VALID_VALUES_FOR_PAYMENT_BEHAVIOR   = StaticArray["allow_incomplete", "default_incomplete", "error_if_incomplete", "pending_if_incomplete"]
    POST_SUBSCRIPTION_ITEMS_MAX_LENGTH_FOR_PRICE                = 5000
    POST_SUBSCRIPTION_ITEMS_VALID_VALUES_FOR_PRORATION_BEHAVIOR = StaticArray["always_invoice", "create_prorations", "none"]

    # @return Crest::Request
    def build_api_request_for_post_subscription_items(*, subscription : String? = nil, billing_thresholds : Stripe::PostSubscriptionItemsRequestBillingThresholds? = nil, expand : Array(String)? = nil, payment_behavior : String? = nil, price : String? = nil, price_data : Stripe::RecurringPriceData1? = nil, proration_behavior : String? = nil, proration_date : Int64? = nil, quantity : Int64? = nil, tax_rates : Stripe::PostSubscriptionItemsRequestTaxRates? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_subscription_items ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"subscription\" is required and cannot be null") if subscription.nil?
        if _subscription = subscription
          OpenApi::PrimitiveValidator.validate_max_length("subscription", subscription.to_s.size, POST_SUBSCRIPTION_ITEMS_MAX_LENGTH_FOR_SUBSCRIPTION)
        end
        if _billing_thresholds = billing_thresholds
          _billing_thresholds.validate if _billing_thresholds.is_a?(OpenApi::Validatable)
        end

        if _payment_behavior = payment_behavior
          OpenApi::EnumValidator.validate("payment_behavior", _payment_behavior, POST_SUBSCRIPTION_ITEMS_VALID_VALUES_FOR_PAYMENT_BEHAVIOR)
        end
        if _price = price
          OpenApi::PrimitiveValidator.validate_max_length("price", price.to_s.size, POST_SUBSCRIPTION_ITEMS_MAX_LENGTH_FOR_PRICE)
        end
        if _price_data = price_data
          _price_data.validate if _price_data.is_a?(OpenApi::Validatable)
        end
        if _proration_behavior = proration_behavior
          OpenApi::EnumValidator.validate("proration_behavior", _proration_behavior, POST_SUBSCRIPTION_ITEMS_VALID_VALUES_FOR_PRORATION_BEHAVIOR)
        end

        if _tax_rates = tax_rates
          _tax_rates.validate if _tax_rates.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/subscription_items"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["billing_thresholds"] = billing_thresholds.to_s if !billing_thresholds.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["payment_behavior"] = payment_behavior.to_s if !payment_behavior.nil?
      form_params["price"] = price.to_s if !price.nil?
      form_params["price_data"] = price_data.to_s if !price_data.nil?
      form_params["proration_behavior"] = proration_behavior.to_s if !proration_behavior.nil?
      form_params["proration_date"] = proration_date.to_s if !proration_date.nil?
      form_params["quantity"] = quantity.to_s if !quantity.nil?
      form_params["subscription"] = subscription.to_s if !subscription.nil?
      form_params["tax_rates"] = tax_rates.to_s if !tax_rates.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_subscription_items",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the plan or quantity of an item on a current subscription.</p>
    # @param item [String?]
    # @optional @param billing_thresholds [Stripe::PostSubscriptionItemsRequestBillingThresholds?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param off_session [Bool?] Indicates if a customer is on or off-session while an invoice payment is attempted.
    # @optional @param payment_behavior [String?] Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.  Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).  Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
    # @optional @param price [String?] The ID of the price object. When changing a subscription item's price, `quantity` is set to 1 unless a `quantity` parameter is provided.
    # @optional @param price_data [Stripe::RecurringPriceData1?]
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param proration_date [Int64?] If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply the same proration that was previewed with the [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint.
    # @optional @param quantity [Int64?] The quantity you'd like to apply to the subscription item you're creating.
    # @optional @param tax_rates [Stripe::PostSubscriptionItemsRequestTaxRates?]
    # @return [SubscriptionItem]
    def post_subscription_items_item(*, item : String? = nil, billing_thresholds : Stripe::PostSubscriptionItemsRequestBillingThresholds? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, off_session : Bool? = nil, payment_behavior : String? = nil, price : String? = nil, price_data : Stripe::RecurringPriceData1? = nil, proration_behavior : String? = nil, proration_date : Int64? = nil, quantity : Int64? = nil, tax_rates : Stripe::PostSubscriptionItemsRequestTaxRates? = nil)
      data, _status_code, _headers = post_subscription_items_item_with_http_info(item: item, billing_thresholds: billing_thresholds, expand: expand, metadata: metadata, off_session: off_session, payment_behavior: payment_behavior, price: price, price_data: price_data, proration_behavior: proration_behavior, proration_date: proration_date, quantity: quantity, tax_rates: tax_rates)
      data
    end

    # &lt;p&gt;Updates the plan or quantity of an item on a current subscription.&lt;/p&gt;
    # @param item [String?]
    # @optional @param billing_thresholds [Stripe::PostSubscriptionItemsRequestBillingThresholds?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param off_session [Bool?] Indicates if a customer is on or off-session while an invoice payment is attempted.
    # @optional @param payment_behavior [String?] Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.  Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).  Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
    # @optional @param price [String?] The ID of the price object. When changing a subscription item's price, `quantity` is set to 1 unless a `quantity` parameter is provided.
    # @optional @param price_data [Stripe::RecurringPriceData1?]
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param proration_date [Int64?] If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply the same proration that was previewed with the [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint.
    # @optional @param quantity [Int64?] The quantity you'd like to apply to the subscription item you're creating.
    # @optional @param tax_rates [Stripe::PostSubscriptionItemsRequestTaxRates?]
    # @return [Array<(SubscriptionItem, Integer, Hash)>] SubscriptionItem data, response status code and response headers
    def post_subscription_items_item_with_http_info(*, item : String? = nil, billing_thresholds : Stripe::PostSubscriptionItemsRequestBillingThresholds? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, off_session : Bool? = nil, payment_behavior : String? = nil, price : String? = nil, price_data : Stripe::RecurringPriceData1? = nil, proration_behavior : String? = nil, proration_date : Int64? = nil, quantity : Int64? = nil, tax_rates : Stripe::PostSubscriptionItemsRequestTaxRates? = nil)
      request = build_api_request_for_post_subscription_items_item(item: item, billing_thresholds: billing_thresholds, expand: expand, metadata: metadata, off_session: off_session, payment_behavior: payment_behavior, price: price, price_data: price_data, proration_behavior: proration_behavior, proration_date: proration_date, quantity: quantity, tax_rates: tax_rates)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_subscription_items_item\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SubscriptionItem.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the plan or quantity of an item on a current subscription.&lt;/p&gt;
    # @param item [String?]
    # @optional @param billing_thresholds [Stripe::PostSubscriptionItemsRequestBillingThresholds?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param off_session [Bool?] Indicates if a customer is on or off-session while an invoice payment is attempted.
    # @optional @param payment_behavior [String?] Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.  Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).  Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
    # @optional @param price [String?] The ID of the price object. When changing a subscription item's price, `quantity` is set to 1 unless a `quantity` parameter is provided.
    # @optional @param price_data [Stripe::RecurringPriceData1?]
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param proration_date [Int64?] If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply the same proration that was previewed with the [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint.
    # @optional @param quantity [Int64?] The quantity you'd like to apply to the subscription item you're creating.
    # @optional @param tax_rates [Stripe::PostSubscriptionItemsRequestTaxRates?]
    # @return nil
    def post_subscription_items_item(*, item : String? = nil, billing_thresholds : Stripe::PostSubscriptionItemsRequestBillingThresholds? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, off_session : Bool? = nil, payment_behavior : String? = nil, price : String? = nil, price_data : Stripe::RecurringPriceData1? = nil, proration_behavior : String? = nil, proration_date : Int64? = nil, quantity : Int64? = nil, tax_rates : Stripe::PostSubscriptionItemsRequestTaxRates? = nil, &block : Crest::Response ->)
      build_api_request_for_post_subscription_items_item(item: item, billing_thresholds: billing_thresholds, expand: expand, metadata: metadata, off_session: off_session, payment_behavior: payment_behavior, price: price, price_data: price_data, proration_behavior: proration_behavior, proration_date: proration_date, quantity: quantity, tax_rates: tax_rates).execute(&block)
    end

    POST_SUBSCRIPTION_ITEMS_ITEM_MAX_LENGTH_FOR_ITEM                 = 5000
    POST_SUBSCRIPTION_ITEMS_ITEM_VALID_VALUES_FOR_PAYMENT_BEHAVIOR   = StaticArray["allow_incomplete", "default_incomplete", "error_if_incomplete", "pending_if_incomplete"]
    POST_SUBSCRIPTION_ITEMS_ITEM_MAX_LENGTH_FOR_PRICE                = 5000
    POST_SUBSCRIPTION_ITEMS_ITEM_VALID_VALUES_FOR_PRORATION_BEHAVIOR = StaticArray["always_invoice", "create_prorations", "none"]

    # @return Crest::Request
    def build_api_request_for_post_subscription_items_item(*, item : String? = nil, billing_thresholds : Stripe::PostSubscriptionItemsRequestBillingThresholds? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, off_session : Bool? = nil, payment_behavior : String? = nil, price : String? = nil, price_data : Stripe::RecurringPriceData1? = nil, proration_behavior : String? = nil, proration_date : Int64? = nil, quantity : Int64? = nil, tax_rates : Stripe::PostSubscriptionItemsRequestTaxRates? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_subscription_items_item ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"item\" is required and cannot be null") if item.nil?
        if _item = item
          OpenApi::PrimitiveValidator.validate_max_length("item", item.to_s.size, POST_SUBSCRIPTION_ITEMS_ITEM_MAX_LENGTH_FOR_ITEM)
        end
        if _billing_thresholds = billing_thresholds
          _billing_thresholds.validate if _billing_thresholds.is_a?(OpenApi::Validatable)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end

        if _payment_behavior = payment_behavior
          OpenApi::EnumValidator.validate("payment_behavior", _payment_behavior, POST_SUBSCRIPTION_ITEMS_ITEM_VALID_VALUES_FOR_PAYMENT_BEHAVIOR)
        end
        if _price = price
          OpenApi::PrimitiveValidator.validate_max_length("price", price.to_s.size, POST_SUBSCRIPTION_ITEMS_ITEM_MAX_LENGTH_FOR_PRICE)
        end
        if _price_data = price_data
          _price_data.validate if _price_data.is_a?(OpenApi::Validatable)
        end
        if _proration_behavior = proration_behavior
          OpenApi::EnumValidator.validate("proration_behavior", _proration_behavior, POST_SUBSCRIPTION_ITEMS_ITEM_VALID_VALUES_FOR_PRORATION_BEHAVIOR)
        end

        if _tax_rates = tax_rates
          _tax_rates.validate if _tax_rates.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/subscription_items/{item}".sub("{" + "item" + "}", URI.encode_path(item.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["billing_thresholds"] = billing_thresholds.to_s if !billing_thresholds.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["off_session"] = off_session.to_s if !off_session.nil?
      form_params["payment_behavior"] = payment_behavior.to_s if !payment_behavior.nil?
      form_params["price"] = price.to_s if !price.nil?
      form_params["price_data"] = price_data.to_s if !price_data.nil?
      form_params["proration_behavior"] = proration_behavior.to_s if !proration_behavior.nil?
      form_params["proration_date"] = proration_date.to_s if !proration_date.nil?
      form_params["quantity"] = quantity.to_s if !quantity.nil?
      form_params["tax_rates"] = tax_rates.to_s if !tax_rates.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_subscription_items_item",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a usage record for a specified subscription item and date, and fills it with a quantity.</p>  <p>Usage records provide <code>quantity</code> information that Stripe uses to track how much a customer is using your service. With usage information and the pricing model set up by the <a href=\"https://stripe.com/docs/billing/subscriptions/metered-billing\">metered billing</a> plan, Stripe helps you send accurate invoices to your customers.</p>  <p>The default calculation for usage is to add up all the <code>quantity</code> values of the usage records within a billing period. You can change this default behavior with the billing plan’s <code>aggregate_usage</code> <a href=\"/docs/api/plans/create#create_plan-aggregate_usage\">parameter</a>. When there is more than one usage record with the same timestamp, Stripe adds the <code>quantity</code> values together. In most cases, this is the desired resolution, however, you can change this behavior with the <code>action</code> parameter.</p>  <p>The default pricing model for metered billing is <a href=\"/docs/api/plans/object#plan_object-billing_scheme\">per-unit pricing</a>. For finer granularity, you can configure metered billing to have a <a href=\"https://stripe.com/docs/billing/subscriptions/tiers\">tiered pricing</a> model.</p>
    # @param subscription_item [String?]
    # @param quantity [Int64?] The usage quantity for the specified timestamp.
    # @optional @param action [String?] Valid values are `increment` (default) or `set`. When using `increment` the specified `quantity` will be added to the usage at the specified timestamp. The `set` action will overwrite the usage quantity at that timestamp. If the subscription has [billing thresholds](https://stripe.com/docs/api/subscriptions/object#subscription_object-billing_thresholds), `increment` is the only allowed value.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param timestamp [Stripe::PostSubscriptionItemsSubscriptionItemUsageRecordsRequestTimestamp?]
    # @return [UsageRecord]
    def post_subscription_items_subscription_item_usage_records(*, subscription_item : String? = nil, quantity : Int64? = nil, action : String? = nil, expand : Array(String)? = nil, timestamp : Stripe::PostSubscriptionItemsSubscriptionItemUsageRecordsRequestTimestamp? = nil)
      data, _status_code, _headers = post_subscription_items_subscription_item_usage_records_with_http_info(subscription_item: subscription_item, quantity: quantity, action: action, expand: expand, timestamp: timestamp)
      data
    end

    # &lt;p&gt;Creates a usage record for a specified subscription item and date, and fills it with a quantity.&lt;/p&gt;  &lt;p&gt;Usage records provide &lt;code&gt;quantity&lt;/code&gt; information that Stripe uses to track how much a customer is using your service. With usage information and the pricing model set up by the &lt;a href&#x3D;\&quot;https://stripe.com/docs/billing/subscriptions/metered-billing\&quot;&gt;metered billing&lt;/a&gt; plan, Stripe helps you send accurate invoices to your customers.&lt;/p&gt;  &lt;p&gt;The default calculation for usage is to add up all the &lt;code&gt;quantity&lt;/code&gt; values of the usage records within a billing period. You can change this default behavior with the billing plan’s &lt;code&gt;aggregate_usage&lt;/code&gt; &lt;a href&#x3D;\&quot;/docs/api/plans/create#create_plan-aggregate_usage\&quot;&gt;parameter&lt;/a&gt;. When there is more than one usage record with the same timestamp, Stripe adds the &lt;code&gt;quantity&lt;/code&gt; values together. In most cases, this is the desired resolution, however, you can change this behavior with the &lt;code&gt;action&lt;/code&gt; parameter.&lt;/p&gt;  &lt;p&gt;The default pricing model for metered billing is &lt;a href&#x3D;\&quot;/docs/api/plans/object#plan_object-billing_scheme\&quot;&gt;per-unit pricing&lt;/a&gt;. For finer granularity, you can configure metered billing to have a &lt;a href&#x3D;\&quot;https://stripe.com/docs/billing/subscriptions/tiers\&quot;&gt;tiered pricing&lt;/a&gt; model.&lt;/p&gt;
    # @param subscription_item [String?]
    # @param quantity [Int64?] The usage quantity for the specified timestamp.
    # @optional @param action [String?] Valid values are `increment` (default) or `set`. When using `increment` the specified `quantity` will be added to the usage at the specified timestamp. The `set` action will overwrite the usage quantity at that timestamp. If the subscription has [billing thresholds](https://stripe.com/docs/api/subscriptions/object#subscription_object-billing_thresholds), `increment` is the only allowed value.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param timestamp [Stripe::PostSubscriptionItemsSubscriptionItemUsageRecordsRequestTimestamp?]
    # @return [Array<(UsageRecord, Integer, Hash)>] UsageRecord data, response status code and response headers
    def post_subscription_items_subscription_item_usage_records_with_http_info(*, subscription_item : String? = nil, quantity : Int64? = nil, action : String? = nil, expand : Array(String)? = nil, timestamp : Stripe::PostSubscriptionItemsSubscriptionItemUsageRecordsRequestTimestamp? = nil)
      request = build_api_request_for_post_subscription_items_subscription_item_usage_records(subscription_item: subscription_item, quantity: quantity, action: action, expand: expand, timestamp: timestamp)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_subscription_items_subscription_item_usage_records\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return UsageRecord.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a usage record for a specified subscription item and date, and fills it with a quantity.&lt;/p&gt;  &lt;p&gt;Usage records provide &lt;code&gt;quantity&lt;/code&gt; information that Stripe uses to track how much a customer is using your service. With usage information and the pricing model set up by the &lt;a href&#x3D;\&quot;https://stripe.com/docs/billing/subscriptions/metered-billing\&quot;&gt;metered billing&lt;/a&gt; plan, Stripe helps you send accurate invoices to your customers.&lt;/p&gt;  &lt;p&gt;The default calculation for usage is to add up all the &lt;code&gt;quantity&lt;/code&gt; values of the usage records within a billing period. You can change this default behavior with the billing plan’s &lt;code&gt;aggregate_usage&lt;/code&gt; &lt;a href&#x3D;\&quot;/docs/api/plans/create#create_plan-aggregate_usage\&quot;&gt;parameter&lt;/a&gt;. When there is more than one usage record with the same timestamp, Stripe adds the &lt;code&gt;quantity&lt;/code&gt; values together. In most cases, this is the desired resolution, however, you can change this behavior with the &lt;code&gt;action&lt;/code&gt; parameter.&lt;/p&gt;  &lt;p&gt;The default pricing model for metered billing is &lt;a href&#x3D;\&quot;/docs/api/plans/object#plan_object-billing_scheme\&quot;&gt;per-unit pricing&lt;/a&gt;. For finer granularity, you can configure metered billing to have a &lt;a href&#x3D;\&quot;https://stripe.com/docs/billing/subscriptions/tiers\&quot;&gt;tiered pricing&lt;/a&gt; model.&lt;/p&gt;
    # @param subscription_item [String?]
    # @param quantity [Int64?] The usage quantity for the specified timestamp.
    # @optional @param action [String?] Valid values are `increment` (default) or `set`. When using `increment` the specified `quantity` will be added to the usage at the specified timestamp. The `set` action will overwrite the usage quantity at that timestamp. If the subscription has [billing thresholds](https://stripe.com/docs/api/subscriptions/object#subscription_object-billing_thresholds), `increment` is the only allowed value.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param timestamp [Stripe::PostSubscriptionItemsSubscriptionItemUsageRecordsRequestTimestamp?]
    # @return nil
    def post_subscription_items_subscription_item_usage_records(*, subscription_item : String? = nil, quantity : Int64? = nil, action : String? = nil, expand : Array(String)? = nil, timestamp : Stripe::PostSubscriptionItemsSubscriptionItemUsageRecordsRequestTimestamp? = nil, &block : Crest::Response ->)
      build_api_request_for_post_subscription_items_subscription_item_usage_records(subscription_item: subscription_item, quantity: quantity, action: action, expand: expand, timestamp: timestamp).execute(&block)
    end

    POST_SUBSCRIPTION_ITEMS_SUBSCRIPTION_ITEM_USAGE_RECORDS_VALID_VALUES_FOR_ACTION = StaticArray["increment", "set"]

    # @return Crest::Request
    def build_api_request_for_post_subscription_items_subscription_item_usage_records(*, subscription_item : String? = nil, quantity : Int64? = nil, action : String? = nil, expand : Array(String)? = nil, timestamp : Stripe::PostSubscriptionItemsSubscriptionItemUsageRecordsRequestTimestamp? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_subscription_items_subscription_item_usage_records ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"subscription_item\" is required and cannot be null") if subscription_item.nil?

        raise ArgumentError.new("\"quantity\" is required and cannot be null") if quantity.nil?

        if _action = action
          OpenApi::EnumValidator.validate("action", _action, POST_SUBSCRIPTION_ITEMS_SUBSCRIPTION_ITEM_USAGE_RECORDS_VALID_VALUES_FOR_ACTION)
        end

        if _timestamp = timestamp
          _timestamp.validate if _timestamp.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/subscription_items/{subscription_item}/usage_records".sub("{" + "subscription_item" + "}", URI.encode_path(subscription_item.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["action"] = action.to_s if !action.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["quantity"] = quantity.to_s if !quantity.nil?
      form_params["timestamp"] = timestamp.to_s if !timestamp.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_subscription_items_subscription_item_usage_records",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new subscription schedule object. Each customer can have up to 500 active or scheduled subscriptions.</p>
    # @optional @param customer [String?] The identifier of the customer to create the subscription schedule for.
    # @optional @param default_settings [Stripe::DefaultSettingsParams?]
    # @optional @param end_behavior [String?] Configures how the subscription schedule behaves when it ends. Possible values are `release` or `cancel` with the default being `release`. `release` will end the subscription schedule and keep the underlying subscription running.`cancel` will end the subscription schedule and cancel the underlying subscription.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param from_subscription [String?] Migrate an existing subscription to be managed by a subscription schedule. If this parameter is set, a subscription schedule will be created using the subscription's item(s), set to auto-renew using the subscription's interval. When using this parameter, other parameters (such as phase values) cannot be set. To create a subscription schedule with other modifications, we recommend making two separate API calls.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param phases [Array(Stripe::PhaseConfigurationParams)?] List representing phases of the subscription schedule. Each phase can be customized to have different durations, plans, and coupons. If there are multiple phases, the `end_date` of one phase will always equal the `start_date` of the next phase.
    # @optional @param start_date [Stripe::PostSubscriptionSchedulesRequestStartDate?]
    # @return [SubscriptionSchedule]
    def post_subscription_schedules(*, customer : String? = nil, default_settings : Stripe::DefaultSettingsParams? = nil, end_behavior : String? = nil, expand : Array(String)? = nil, from_subscription : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, phases : Array(Stripe::PhaseConfigurationParams)? = nil, start_date : Stripe::PostSubscriptionSchedulesRequestStartDate? = nil)
      data, _status_code, _headers = post_subscription_schedules_with_http_info(customer: customer, default_settings: default_settings, end_behavior: end_behavior, expand: expand, from_subscription: from_subscription, metadata: metadata, phases: phases, start_date: start_date)
      data
    end

    # &lt;p&gt;Creates a new subscription schedule object. Each customer can have up to 500 active or scheduled subscriptions.&lt;/p&gt;
    # @optional @param customer [String?] The identifier of the customer to create the subscription schedule for.
    # @optional @param default_settings [Stripe::DefaultSettingsParams?]
    # @optional @param end_behavior [String?] Configures how the subscription schedule behaves when it ends. Possible values are `release` or `cancel` with the default being `release`. `release` will end the subscription schedule and keep the underlying subscription running.`cancel` will end the subscription schedule and cancel the underlying subscription.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param from_subscription [String?] Migrate an existing subscription to be managed by a subscription schedule. If this parameter is set, a subscription schedule will be created using the subscription's item(s), set to auto-renew using the subscription's interval. When using this parameter, other parameters (such as phase values) cannot be set. To create a subscription schedule with other modifications, we recommend making two separate API calls.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param phases [Array(Stripe::PhaseConfigurationParams)?] List representing phases of the subscription schedule. Each phase can be customized to have different durations, plans, and coupons. If there are multiple phases, the `end_date` of one phase will always equal the `start_date` of the next phase.
    # @optional @param start_date [Stripe::PostSubscriptionSchedulesRequestStartDate?]
    # @return [Array<(SubscriptionSchedule, Integer, Hash)>] SubscriptionSchedule data, response status code and response headers
    def post_subscription_schedules_with_http_info(*, customer : String? = nil, default_settings : Stripe::DefaultSettingsParams? = nil, end_behavior : String? = nil, expand : Array(String)? = nil, from_subscription : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, phases : Array(Stripe::PhaseConfigurationParams)? = nil, start_date : Stripe::PostSubscriptionSchedulesRequestStartDate? = nil)
      request = build_api_request_for_post_subscription_schedules(customer: customer, default_settings: default_settings, end_behavior: end_behavior, expand: expand, from_subscription: from_subscription, metadata: metadata, phases: phases, start_date: start_date)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_subscription_schedules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SubscriptionSchedule.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new subscription schedule object. Each customer can have up to 500 active or scheduled subscriptions.&lt;/p&gt;
    # @optional @param customer [String?] The identifier of the customer to create the subscription schedule for.
    # @optional @param default_settings [Stripe::DefaultSettingsParams?]
    # @optional @param end_behavior [String?] Configures how the subscription schedule behaves when it ends. Possible values are `release` or `cancel` with the default being `release`. `release` will end the subscription schedule and keep the underlying subscription running.`cancel` will end the subscription schedule and cancel the underlying subscription.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param from_subscription [String?] Migrate an existing subscription to be managed by a subscription schedule. If this parameter is set, a subscription schedule will be created using the subscription's item(s), set to auto-renew using the subscription's interval. When using this parameter, other parameters (such as phase values) cannot be set. To create a subscription schedule with other modifications, we recommend making two separate API calls.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param phases [Array(Stripe::PhaseConfigurationParams)?] List representing phases of the subscription schedule. Each phase can be customized to have different durations, plans, and coupons. If there are multiple phases, the `end_date` of one phase will always equal the `start_date` of the next phase.
    # @optional @param start_date [Stripe::PostSubscriptionSchedulesRequestStartDate?]
    # @return nil
    def post_subscription_schedules(*, customer : String? = nil, default_settings : Stripe::DefaultSettingsParams? = nil, end_behavior : String? = nil, expand : Array(String)? = nil, from_subscription : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, phases : Array(Stripe::PhaseConfigurationParams)? = nil, start_date : Stripe::PostSubscriptionSchedulesRequestStartDate? = nil, &block : Crest::Response ->)
      build_api_request_for_post_subscription_schedules(customer: customer, default_settings: default_settings, end_behavior: end_behavior, expand: expand, from_subscription: from_subscription, metadata: metadata, phases: phases, start_date: start_date).execute(&block)
    end

    POST_SUBSCRIPTION_SCHEDULES_MAX_LENGTH_FOR_CUSTOMER          = 5000
    POST_SUBSCRIPTION_SCHEDULES_VALID_VALUES_FOR_END_BEHAVIOR    = StaticArray["cancel", "none", "release", "renew"]
    POST_SUBSCRIPTION_SCHEDULES_MAX_LENGTH_FOR_FROM_SUBSCRIPTION = 5000

    # @return Crest::Request
    def build_api_request_for_post_subscription_schedules(*, customer : String? = nil, default_settings : Stripe::DefaultSettingsParams? = nil, end_behavior : String? = nil, expand : Array(String)? = nil, from_subscription : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, phases : Array(Stripe::PhaseConfigurationParams)? = nil, start_date : Stripe::PostSubscriptionSchedulesRequestStartDate? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_subscription_schedules ..." }
      end

      if client_side_validation
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_SUBSCRIPTION_SCHEDULES_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _default_settings = default_settings
          _default_settings.validate if _default_settings.is_a?(OpenApi::Validatable)
        end
        if _end_behavior = end_behavior
          OpenApi::EnumValidator.validate("end_behavior", _end_behavior, POST_SUBSCRIPTION_SCHEDULES_VALID_VALUES_FOR_END_BEHAVIOR)
        end

        if _from_subscription = from_subscription
          OpenApi::PrimitiveValidator.validate_max_length("from_subscription", from_subscription.to_s.size, POST_SUBSCRIPTION_SCHEDULES_MAX_LENGTH_FOR_FROM_SUBSCRIPTION)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _phases = phases
          OpenApi::ContainerValidator.validate(container: _phases) if _phases.is_a?(Array)
        end
        if _start_date = start_date
          _start_date.validate if _start_date.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/subscription_schedules"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["default_settings"] = default_settings.to_s if !default_settings.nil?
      form_params["end_behavior"] = end_behavior.to_s if !end_behavior.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["from_subscription"] = from_subscription.to_s if !from_subscription.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["phases"] = @api_client.build_collection_param(phases, "csv") if !phases.nil? && !phases.empty?
      form_params["start_date"] = start_date.to_s if !start_date.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_subscription_schedules",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates an existing subscription schedule.</p>
    # @param schedule [String?]
    # @optional @param default_settings [Stripe::DefaultSettingsParams?]
    # @optional @param end_behavior [String?] Configures how the subscription schedule behaves when it ends. Possible values are `release` or `cancel` with the default being `release`. `release` will end the subscription schedule and keep the underlying subscription running.`cancel` will end the subscription schedule and cancel the underlying subscription.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param phases [Array(Stripe::PhaseConfigurationParams1)?] List representing phases of the subscription schedule. Each phase can be customized to have different durations, plans, and coupons. If there are multiple phases, the `end_date` of one phase will always equal the `start_date` of the next phase. Note that past phases can be omitted.
    # @optional @param proration_behavior [String?] If the update changes the current phase, indicates whether the changes should be prorated. The default value is `create_prorations`.
    # @return [SubscriptionSchedule]
    def post_subscription_schedules_schedule(*, schedule : String? = nil, default_settings : Stripe::DefaultSettingsParams? = nil, end_behavior : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, phases : Array(Stripe::PhaseConfigurationParams1)? = nil, proration_behavior : String? = nil)
      data, _status_code, _headers = post_subscription_schedules_schedule_with_http_info(schedule: schedule, default_settings: default_settings, end_behavior: end_behavior, expand: expand, metadata: metadata, phases: phases, proration_behavior: proration_behavior)
      data
    end

    # &lt;p&gt;Updates an existing subscription schedule.&lt;/p&gt;
    # @param schedule [String?]
    # @optional @param default_settings [Stripe::DefaultSettingsParams?]
    # @optional @param end_behavior [String?] Configures how the subscription schedule behaves when it ends. Possible values are `release` or `cancel` with the default being `release`. `release` will end the subscription schedule and keep the underlying subscription running.`cancel` will end the subscription schedule and cancel the underlying subscription.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param phases [Array(Stripe::PhaseConfigurationParams1)?] List representing phases of the subscription schedule. Each phase can be customized to have different durations, plans, and coupons. If there are multiple phases, the `end_date` of one phase will always equal the `start_date` of the next phase. Note that past phases can be omitted.
    # @optional @param proration_behavior [String?] If the update changes the current phase, indicates whether the changes should be prorated. The default value is `create_prorations`.
    # @return [Array<(SubscriptionSchedule, Integer, Hash)>] SubscriptionSchedule data, response status code and response headers
    def post_subscription_schedules_schedule_with_http_info(*, schedule : String? = nil, default_settings : Stripe::DefaultSettingsParams? = nil, end_behavior : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, phases : Array(Stripe::PhaseConfigurationParams1)? = nil, proration_behavior : String? = nil)
      request = build_api_request_for_post_subscription_schedules_schedule(schedule: schedule, default_settings: default_settings, end_behavior: end_behavior, expand: expand, metadata: metadata, phases: phases, proration_behavior: proration_behavior)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_subscription_schedules_schedule\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SubscriptionSchedule.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates an existing subscription schedule.&lt;/p&gt;
    # @param schedule [String?]
    # @optional @param default_settings [Stripe::DefaultSettingsParams?]
    # @optional @param end_behavior [String?] Configures how the subscription schedule behaves when it ends. Possible values are `release` or `cancel` with the default being `release`. `release` will end the subscription schedule and keep the underlying subscription running.`cancel` will end the subscription schedule and cancel the underlying subscription.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param phases [Array(Stripe::PhaseConfigurationParams1)?] List representing phases of the subscription schedule. Each phase can be customized to have different durations, plans, and coupons. If there are multiple phases, the `end_date` of one phase will always equal the `start_date` of the next phase. Note that past phases can be omitted.
    # @optional @param proration_behavior [String?] If the update changes the current phase, indicates whether the changes should be prorated. The default value is `create_prorations`.
    # @return nil
    def post_subscription_schedules_schedule(*, schedule : String? = nil, default_settings : Stripe::DefaultSettingsParams? = nil, end_behavior : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, phases : Array(Stripe::PhaseConfigurationParams1)? = nil, proration_behavior : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_subscription_schedules_schedule(schedule: schedule, default_settings: default_settings, end_behavior: end_behavior, expand: expand, metadata: metadata, phases: phases, proration_behavior: proration_behavior).execute(&block)
    end

    POST_SUBSCRIPTION_SCHEDULES_SCHEDULE_MAX_LENGTH_FOR_SCHEDULE             = 5000
    POST_SUBSCRIPTION_SCHEDULES_SCHEDULE_VALID_VALUES_FOR_END_BEHAVIOR       = StaticArray["cancel", "none", "release", "renew"]
    POST_SUBSCRIPTION_SCHEDULES_SCHEDULE_VALID_VALUES_FOR_PRORATION_BEHAVIOR = StaticArray["always_invoice", "create_prorations", "none"]

    # @return Crest::Request
    def build_api_request_for_post_subscription_schedules_schedule(*, schedule : String? = nil, default_settings : Stripe::DefaultSettingsParams? = nil, end_behavior : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, phases : Array(Stripe::PhaseConfigurationParams1)? = nil, proration_behavior : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_subscription_schedules_schedule ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"schedule\" is required and cannot be null") if schedule.nil?
        if _schedule = schedule
          OpenApi::PrimitiveValidator.validate_max_length("schedule", schedule.to_s.size, POST_SUBSCRIPTION_SCHEDULES_SCHEDULE_MAX_LENGTH_FOR_SCHEDULE)
        end
        if _default_settings = default_settings
          _default_settings.validate if _default_settings.is_a?(OpenApi::Validatable)
        end
        if _end_behavior = end_behavior
          OpenApi::EnumValidator.validate("end_behavior", _end_behavior, POST_SUBSCRIPTION_SCHEDULES_SCHEDULE_VALID_VALUES_FOR_END_BEHAVIOR)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _phases = phases
          OpenApi::ContainerValidator.validate(container: _phases) if _phases.is_a?(Array)
        end
        if _proration_behavior = proration_behavior
          OpenApi::EnumValidator.validate("proration_behavior", _proration_behavior, POST_SUBSCRIPTION_SCHEDULES_SCHEDULE_VALID_VALUES_FOR_PRORATION_BEHAVIOR)
        end
      end

      # resource path
      local_var_path = "/v1/subscription_schedules/{schedule}".sub("{" + "schedule" + "}", URI.encode_path(schedule.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["default_settings"] = default_settings.to_s if !default_settings.nil?
      form_params["end_behavior"] = end_behavior.to_s if !end_behavior.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["phases"] = @api_client.build_collection_param(phases, "csv") if !phases.nil? && !phases.empty?
      form_params["proration_behavior"] = proration_behavior.to_s if !proration_behavior.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_subscription_schedules_schedule",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Cancels a subscription schedule and its associated subscription immediately (if the subscription schedule has an active subscription). A subscription schedule can only be canceled if its status is <code>not_started</code> or <code>active</code>.</p>
    # @param schedule [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_now [Bool?] If the subscription schedule is `active`, indicates if a final invoice will be generated that contains any un-invoiced metered usage and new/pending proration invoice items. Defaults to `true`.
    # @optional @param prorate [Bool?] If the subscription schedule is `active`, indicates if the cancellation should be prorated. Defaults to `true`.
    # @return [SubscriptionSchedule]
    def post_subscription_schedules_schedule_cancel(*, schedule : String? = nil, expand : Array(String)? = nil, invoice_now : Bool? = nil, prorate : Bool? = nil)
      data, _status_code, _headers = post_subscription_schedules_schedule_cancel_with_http_info(schedule: schedule, expand: expand, invoice_now: invoice_now, prorate: prorate)
      data
    end

    # &lt;p&gt;Cancels a subscription schedule and its associated subscription immediately (if the subscription schedule has an active subscription). A subscription schedule can only be canceled if its status is &lt;code&gt;not_started&lt;/code&gt; or &lt;code&gt;active&lt;/code&gt;.&lt;/p&gt;
    # @param schedule [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_now [Bool?] If the subscription schedule is `active`, indicates if a final invoice will be generated that contains any un-invoiced metered usage and new/pending proration invoice items. Defaults to `true`.
    # @optional @param prorate [Bool?] If the subscription schedule is `active`, indicates if the cancellation should be prorated. Defaults to `true`.
    # @return [Array<(SubscriptionSchedule, Integer, Hash)>] SubscriptionSchedule data, response status code and response headers
    def post_subscription_schedules_schedule_cancel_with_http_info(*, schedule : String? = nil, expand : Array(String)? = nil, invoice_now : Bool? = nil, prorate : Bool? = nil)
      request = build_api_request_for_post_subscription_schedules_schedule_cancel(schedule: schedule, expand: expand, invoice_now: invoice_now, prorate: prorate)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_subscription_schedules_schedule_cancel\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SubscriptionSchedule.from_json(data), status_code, headers
    end

    # &lt;p&gt;Cancels a subscription schedule and its associated subscription immediately (if the subscription schedule has an active subscription). A subscription schedule can only be canceled if its status is &lt;code&gt;not_started&lt;/code&gt; or &lt;code&gt;active&lt;/code&gt;.&lt;/p&gt;
    # @param schedule [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param invoice_now [Bool?] If the subscription schedule is `active`, indicates if a final invoice will be generated that contains any un-invoiced metered usage and new/pending proration invoice items. Defaults to `true`.
    # @optional @param prorate [Bool?] If the subscription schedule is `active`, indicates if the cancellation should be prorated. Defaults to `true`.
    # @return nil
    def post_subscription_schedules_schedule_cancel(*, schedule : String? = nil, expand : Array(String)? = nil, invoice_now : Bool? = nil, prorate : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_post_subscription_schedules_schedule_cancel(schedule: schedule, expand: expand, invoice_now: invoice_now, prorate: prorate).execute(&block)
    end

    POST_SUBSCRIPTION_SCHEDULES_SCHEDULE_CANCEL_MAX_LENGTH_FOR_SCHEDULE = 5000

    # @return Crest::Request
    def build_api_request_for_post_subscription_schedules_schedule_cancel(*, schedule : String? = nil, expand : Array(String)? = nil, invoice_now : Bool? = nil, prorate : Bool? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_subscription_schedules_schedule_cancel ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"schedule\" is required and cannot be null") if schedule.nil?
        if _schedule = schedule
          OpenApi::PrimitiveValidator.validate_max_length("schedule", schedule.to_s.size, POST_SUBSCRIPTION_SCHEDULES_SCHEDULE_CANCEL_MAX_LENGTH_FOR_SCHEDULE)
        end
      end

      # resource path
      local_var_path = "/v1/subscription_schedules/{schedule}/cancel".sub("{" + "schedule" + "}", URI.encode_path(schedule.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["invoice_now"] = invoice_now.to_s if !invoice_now.nil?
      form_params["prorate"] = prorate.to_s if !prorate.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_subscription_schedules_schedule_cancel",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Releases the subscription schedule immediately, which will stop scheduling of its phases, but leave any existing subscription in place. A schedule can only be released if its status is <code>not_started</code> or <code>active</code>. If the subscription schedule is currently associated with a subscription, releasing it will remove its <code>subscription</code> property and set the subscription’s ID to the <code>released_subscription</code> property.</p>
    # @param schedule [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param preserve_cancel_date [Bool?] Keep any cancellation on the subscription that the schedule has set
    # @return [SubscriptionSchedule]
    def post_subscription_schedules_schedule_release(*, schedule : String? = nil, expand : Array(String)? = nil, preserve_cancel_date : Bool? = nil)
      data, _status_code, _headers = post_subscription_schedules_schedule_release_with_http_info(schedule: schedule, expand: expand, preserve_cancel_date: preserve_cancel_date)
      data
    end

    # &lt;p&gt;Releases the subscription schedule immediately, which will stop scheduling of its phases, but leave any existing subscription in place. A schedule can only be released if its status is &lt;code&gt;not_started&lt;/code&gt; or &lt;code&gt;active&lt;/code&gt;. If the subscription schedule is currently associated with a subscription, releasing it will remove its &lt;code&gt;subscription&lt;/code&gt; property and set the subscription’s ID to the &lt;code&gt;released_subscription&lt;/code&gt; property.&lt;/p&gt;
    # @param schedule [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param preserve_cancel_date [Bool?] Keep any cancellation on the subscription that the schedule has set
    # @return [Array<(SubscriptionSchedule, Integer, Hash)>] SubscriptionSchedule data, response status code and response headers
    def post_subscription_schedules_schedule_release_with_http_info(*, schedule : String? = nil, expand : Array(String)? = nil, preserve_cancel_date : Bool? = nil)
      request = build_api_request_for_post_subscription_schedules_schedule_release(schedule: schedule, expand: expand, preserve_cancel_date: preserve_cancel_date)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_subscription_schedules_schedule_release\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return SubscriptionSchedule.from_json(data), status_code, headers
    end

    # &lt;p&gt;Releases the subscription schedule immediately, which will stop scheduling of its phases, but leave any existing subscription in place. A schedule can only be released if its status is &lt;code&gt;not_started&lt;/code&gt; or &lt;code&gt;active&lt;/code&gt;. If the subscription schedule is currently associated with a subscription, releasing it will remove its &lt;code&gt;subscription&lt;/code&gt; property and set the subscription’s ID to the &lt;code&gt;released_subscription&lt;/code&gt; property.&lt;/p&gt;
    # @param schedule [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param preserve_cancel_date [Bool?] Keep any cancellation on the subscription that the schedule has set
    # @return nil
    def post_subscription_schedules_schedule_release(*, schedule : String? = nil, expand : Array(String)? = nil, preserve_cancel_date : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_post_subscription_schedules_schedule_release(schedule: schedule, expand: expand, preserve_cancel_date: preserve_cancel_date).execute(&block)
    end

    POST_SUBSCRIPTION_SCHEDULES_SCHEDULE_RELEASE_MAX_LENGTH_FOR_SCHEDULE = 5000

    # @return Crest::Request
    def build_api_request_for_post_subscription_schedules_schedule_release(*, schedule : String? = nil, expand : Array(String)? = nil, preserve_cancel_date : Bool? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_subscription_schedules_schedule_release ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"schedule\" is required and cannot be null") if schedule.nil?
        if _schedule = schedule
          OpenApi::PrimitiveValidator.validate_max_length("schedule", schedule.to_s.size, POST_SUBSCRIPTION_SCHEDULES_SCHEDULE_RELEASE_MAX_LENGTH_FOR_SCHEDULE)
        end
      end

      # resource path
      local_var_path = "/v1/subscription_schedules/{schedule}/release".sub("{" + "schedule" + "}", URI.encode_path(schedule.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["preserve_cancel_date"] = preserve_cancel_date.to_s if !preserve_cancel_date.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_subscription_schedules_schedule_release",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new subscription on an existing customer. Each customer can have up to 500 active or scheduled subscriptions.</p>  <p>When you create a subscription with <code>collection_method=charge_automatically</code>, the first invoice is finalized as part of the request. The <code>payment_behavior</code> parameter determines the exact behavior of the initial payment.</p>  <p>To start subscriptions where the first invoice always begins in a <code>draft</code> status, use <a href=\"/docs/billing/subscriptions/subscription-schedules#managing\">subscription schedules</a> instead. Schedules provide the flexibility to model more complex billing configurations that change over time.</p>
    # @param customer [String?] The identifier of the customer to subscribe.
    # @optional @param add_invoice_items [Array(Stripe::AddInvoiceItemEntry)?] A list of prices and quantities that will generate invoice items appended to the next invoice for this subscription. You may pass up to 20 items.
    # @optional @param application_fee_percent [Float64?] A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. The request must be made by a platform account on a connected account in order to set an application fee percentage. For more information, see the application fees [documentation](https://stripe.com/docs/connect/subscriptions#collecting-fees-on-subscriptions).
    # @optional @param automatic_tax [Stripe::AutomaticTaxConfig?]
    # @optional @param backdate_start_date [Int64?] For new subscriptions, a past timestamp to backdate the subscription's start date to. If set, the first invoice will contain a proration for the timespan between the start date and the current time. Can be combined with trials and the billing cycle anchor.
    # @optional @param billing_cycle_anchor [Int64?] A future timestamp to anchor the subscription's [billing cycle](https://stripe.com/docs/subscriptions/billing-cycle). This is used to determine the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices. The timestamp is in UTC format.
    # @optional @param billing_thresholds [Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds?]
    # @optional @param cancel_at [Int64?] A timestamp at which the subscription should cancel. If set to a date before the current period ends, this will cause a proration if prorations have been enabled using `proration_behavior`. If set during a future period, this will always cause a proration for that period.
    # @optional @param cancel_at_period_end [Bool?] Boolean indicating whether this subscription should cancel at the end of the current period.
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
    # @optional @param coupon [String?] The ID of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param days_until_due [Int64?] Number of days a customer has to pay invoices generated by this subscription. Valid only for subscriptions where `collection_method` is set to `send_invoice`.
    # @optional @param default_payment_method [String?] ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over `default_source`. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_source [String?] ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If `default_payment_method` is also set, `default_payment_method` will take precedence. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_tax_rates [Stripe::PostCustomersCustomerSubscriptionsRequestDefaultTaxRates?]
    # @optional @param description [String?] The subscription's description, meant to be displayable to the customer. Use this field to optionally store an explanation of the subscription for rendering in Stripe surfaces.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param items [Array(Stripe::SubscriptionItemCreateParams)?] A list of up to 20 subscription items, each with an attached price.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param off_session [Bool?] Indicates if a customer is on or off-session while an invoice payment is attempted.
    # @optional @param payment_behavior [String?] Use `allow_incomplete` to create subscriptions with `status=incomplete` if the first invoice cannot be paid. Creating subscriptions with this status allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use `default_incomplete` to create Subscriptions with `status=incomplete` when the first invoice requires payment, otherwise start as active. Subscriptions transition to `status=active` when successfully confirming the payment intent on the first invoice. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method. If the payment intent is not confirmed within 23 hours subscriptions transition to `status=incomplete_expired`, which is a terminal state.  Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's first invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not create a subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.  `pending_if_incomplete` is only used with updates and cannot be passed when creating a subscription.
    # @optional @param payment_settings [Stripe::PaymentSettings?]
    # @optional @param pending_invoice_item_interval [Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval?]
    # @optional @param promotion_code [String?] The API ID of a promotion code to apply to this subscription. A promotion code applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) resulting from the `billing_cycle_anchor`. If no value is passed, the default is `create_prorations`.
    # @optional @param transfer_data [Stripe::TransferDataSpecs3?]
    # @optional @param trial_end [Stripe::PostCustomersCustomerSubscriptionsRequestTrialEnd?]
    # @optional @param trial_from_plan [Bool?] Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @optional @param trial_period_days [Int64?] Integer representing the number of trial period days before the customer is charged for the first time. This will always overwrite any trials that might apply via a subscribed plan. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @return [Subscription]
    def post_subscriptions(*, customer : String? = nil, add_invoice_items : Array(Stripe::AddInvoiceItemEntry)? = nil, application_fee_percent : Float64? = nil, automatic_tax : Stripe::AutomaticTaxConfig? = nil, backdate_start_date : Int64? = nil, billing_cycle_anchor : Int64? = nil, billing_thresholds : Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds? = nil, cancel_at : Int64? = nil, cancel_at_period_end : Bool? = nil, collection_method : String? = nil, coupon : String? = nil, currency : String? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Stripe::PostCustomersCustomerSubscriptionsRequestDefaultTaxRates? = nil, description : String? = nil, expand : Array(String)? = nil, items : Array(Stripe::SubscriptionItemCreateParams)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, off_session : Bool? = nil, payment_behavior : String? = nil, payment_settings : Stripe::PaymentSettings? = nil, pending_invoice_item_interval : Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval? = nil, promotion_code : String? = nil, proration_behavior : String? = nil, transfer_data : Stripe::TransferDataSpecs3? = nil, trial_end : Stripe::PostCustomersCustomerSubscriptionsRequestTrialEnd? = nil, trial_from_plan : Bool? = nil, trial_period_days : Int64? = nil)
      data, _status_code, _headers = post_subscriptions_with_http_info(customer: customer, add_invoice_items: add_invoice_items, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, backdate_start_date: backdate_start_date, billing_cycle_anchor: billing_cycle_anchor, billing_thresholds: billing_thresholds, cancel_at: cancel_at, cancel_at_period_end: cancel_at_period_end, collection_method: collection_method, coupon: coupon, currency: currency, days_until_due: days_until_due, default_payment_method: default_payment_method, default_source: default_source, default_tax_rates: default_tax_rates, description: description, expand: expand, items: items, metadata: metadata, off_session: off_session, payment_behavior: payment_behavior, payment_settings: payment_settings, pending_invoice_item_interval: pending_invoice_item_interval, promotion_code: promotion_code, proration_behavior: proration_behavior, transfer_data: transfer_data, trial_end: trial_end, trial_from_plan: trial_from_plan, trial_period_days: trial_period_days)
      data
    end

    # &lt;p&gt;Creates a new subscription on an existing customer. Each customer can have up to 500 active or scheduled subscriptions.&lt;/p&gt;  &lt;p&gt;When you create a subscription with &lt;code&gt;collection_method&#x3D;charge_automatically&lt;/code&gt;, the first invoice is finalized as part of the request. The &lt;code&gt;payment_behavior&lt;/code&gt; parameter determines the exact behavior of the initial payment.&lt;/p&gt;  &lt;p&gt;To start subscriptions where the first invoice always begins in a &lt;code&gt;draft&lt;/code&gt; status, use &lt;a href&#x3D;\&quot;/docs/billing/subscriptions/subscription-schedules#managing\&quot;&gt;subscription schedules&lt;/a&gt; instead. Schedules provide the flexibility to model more complex billing configurations that change over time.&lt;/p&gt;
    # @param customer [String?] The identifier of the customer to subscribe.
    # @optional @param add_invoice_items [Array(Stripe::AddInvoiceItemEntry)?] A list of prices and quantities that will generate invoice items appended to the next invoice for this subscription. You may pass up to 20 items.
    # @optional @param application_fee_percent [Float64?] A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. The request must be made by a platform account on a connected account in order to set an application fee percentage. For more information, see the application fees [documentation](https://stripe.com/docs/connect/subscriptions#collecting-fees-on-subscriptions).
    # @optional @param automatic_tax [Stripe::AutomaticTaxConfig?]
    # @optional @param backdate_start_date [Int64?] For new subscriptions, a past timestamp to backdate the subscription's start date to. If set, the first invoice will contain a proration for the timespan between the start date and the current time. Can be combined with trials and the billing cycle anchor.
    # @optional @param billing_cycle_anchor [Int64?] A future timestamp to anchor the subscription's [billing cycle](https://stripe.com/docs/subscriptions/billing-cycle). This is used to determine the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices. The timestamp is in UTC format.
    # @optional @param billing_thresholds [Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds?]
    # @optional @param cancel_at [Int64?] A timestamp at which the subscription should cancel. If set to a date before the current period ends, this will cause a proration if prorations have been enabled using `proration_behavior`. If set during a future period, this will always cause a proration for that period.
    # @optional @param cancel_at_period_end [Bool?] Boolean indicating whether this subscription should cancel at the end of the current period.
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
    # @optional @param coupon [String?] The ID of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param days_until_due [Int64?] Number of days a customer has to pay invoices generated by this subscription. Valid only for subscriptions where `collection_method` is set to `send_invoice`.
    # @optional @param default_payment_method [String?] ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over `default_source`. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_source [String?] ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If `default_payment_method` is also set, `default_payment_method` will take precedence. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_tax_rates [Stripe::PostCustomersCustomerSubscriptionsRequestDefaultTaxRates?]
    # @optional @param description [String?] The subscription's description, meant to be displayable to the customer. Use this field to optionally store an explanation of the subscription for rendering in Stripe surfaces.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param items [Array(Stripe::SubscriptionItemCreateParams)?] A list of up to 20 subscription items, each with an attached price.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param off_session [Bool?] Indicates if a customer is on or off-session while an invoice payment is attempted.
    # @optional @param payment_behavior [String?] Use `allow_incomplete` to create subscriptions with `status=incomplete` if the first invoice cannot be paid. Creating subscriptions with this status allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use `default_incomplete` to create Subscriptions with `status=incomplete` when the first invoice requires payment, otherwise start as active. Subscriptions transition to `status=active` when successfully confirming the payment intent on the first invoice. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method. If the payment intent is not confirmed within 23 hours subscriptions transition to `status=incomplete_expired`, which is a terminal state.  Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's first invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not create a subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.  `pending_if_incomplete` is only used with updates and cannot be passed when creating a subscription.
    # @optional @param payment_settings [Stripe::PaymentSettings?]
    # @optional @param pending_invoice_item_interval [Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval?]
    # @optional @param promotion_code [String?] The API ID of a promotion code to apply to this subscription. A promotion code applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) resulting from the `billing_cycle_anchor`. If no value is passed, the default is `create_prorations`.
    # @optional @param transfer_data [Stripe::TransferDataSpecs3?]
    # @optional @param trial_end [Stripe::PostCustomersCustomerSubscriptionsRequestTrialEnd?]
    # @optional @param trial_from_plan [Bool?] Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @optional @param trial_period_days [Int64?] Integer representing the number of trial period days before the customer is charged for the first time. This will always overwrite any trials that might apply via a subscribed plan. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @return [Array<(Subscription, Integer, Hash)>] Subscription data, response status code and response headers
    def post_subscriptions_with_http_info(*, customer : String? = nil, add_invoice_items : Array(Stripe::AddInvoiceItemEntry)? = nil, application_fee_percent : Float64? = nil, automatic_tax : Stripe::AutomaticTaxConfig? = nil, backdate_start_date : Int64? = nil, billing_cycle_anchor : Int64? = nil, billing_thresholds : Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds? = nil, cancel_at : Int64? = nil, cancel_at_period_end : Bool? = nil, collection_method : String? = nil, coupon : String? = nil, currency : String? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Stripe::PostCustomersCustomerSubscriptionsRequestDefaultTaxRates? = nil, description : String? = nil, expand : Array(String)? = nil, items : Array(Stripe::SubscriptionItemCreateParams)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, off_session : Bool? = nil, payment_behavior : String? = nil, payment_settings : Stripe::PaymentSettings? = nil, pending_invoice_item_interval : Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval? = nil, promotion_code : String? = nil, proration_behavior : String? = nil, transfer_data : Stripe::TransferDataSpecs3? = nil, trial_end : Stripe::PostCustomersCustomerSubscriptionsRequestTrialEnd? = nil, trial_from_plan : Bool? = nil, trial_period_days : Int64? = nil)
      request = build_api_request_for_post_subscriptions(customer: customer, add_invoice_items: add_invoice_items, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, backdate_start_date: backdate_start_date, billing_cycle_anchor: billing_cycle_anchor, billing_thresholds: billing_thresholds, cancel_at: cancel_at, cancel_at_period_end: cancel_at_period_end, collection_method: collection_method, coupon: coupon, currency: currency, days_until_due: days_until_due, default_payment_method: default_payment_method, default_source: default_source, default_tax_rates: default_tax_rates, description: description, expand: expand, items: items, metadata: metadata, off_session: off_session, payment_behavior: payment_behavior, payment_settings: payment_settings, pending_invoice_item_interval: pending_invoice_item_interval, promotion_code: promotion_code, proration_behavior: proration_behavior, transfer_data: transfer_data, trial_end: trial_end, trial_from_plan: trial_from_plan, trial_period_days: trial_period_days)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_subscriptions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Subscription.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new subscription on an existing customer. Each customer can have up to 500 active or scheduled subscriptions.&lt;/p&gt;  &lt;p&gt;When you create a subscription with &lt;code&gt;collection_method&#x3D;charge_automatically&lt;/code&gt;, the first invoice is finalized as part of the request. The &lt;code&gt;payment_behavior&lt;/code&gt; parameter determines the exact behavior of the initial payment.&lt;/p&gt;  &lt;p&gt;To start subscriptions where the first invoice always begins in a &lt;code&gt;draft&lt;/code&gt; status, use &lt;a href&#x3D;\&quot;/docs/billing/subscriptions/subscription-schedules#managing\&quot;&gt;subscription schedules&lt;/a&gt; instead. Schedules provide the flexibility to model more complex billing configurations that change over time.&lt;/p&gt;
    # @param customer [String?] The identifier of the customer to subscribe.
    # @optional @param add_invoice_items [Array(Stripe::AddInvoiceItemEntry)?] A list of prices and quantities that will generate invoice items appended to the next invoice for this subscription. You may pass up to 20 items.
    # @optional @param application_fee_percent [Float64?] A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. The request must be made by a platform account on a connected account in order to set an application fee percentage. For more information, see the application fees [documentation](https://stripe.com/docs/connect/subscriptions#collecting-fees-on-subscriptions).
    # @optional @param automatic_tax [Stripe::AutomaticTaxConfig?]
    # @optional @param backdate_start_date [Int64?] For new subscriptions, a past timestamp to backdate the subscription's start date to. If set, the first invoice will contain a proration for the timespan between the start date and the current time. Can be combined with trials and the billing cycle anchor.
    # @optional @param billing_cycle_anchor [Int64?] A future timestamp to anchor the subscription's [billing cycle](https://stripe.com/docs/subscriptions/billing-cycle). This is used to determine the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices. The timestamp is in UTC format.
    # @optional @param billing_thresholds [Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds?]
    # @optional @param cancel_at [Int64?] A timestamp at which the subscription should cancel. If set to a date before the current period ends, this will cause a proration if prorations have been enabled using `proration_behavior`. If set during a future period, this will always cause a proration for that period.
    # @optional @param cancel_at_period_end [Bool?] Boolean indicating whether this subscription should cancel at the end of the current period.
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
    # @optional @param coupon [String?] The ID of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param days_until_due [Int64?] Number of days a customer has to pay invoices generated by this subscription. Valid only for subscriptions where `collection_method` is set to `send_invoice`.
    # @optional @param default_payment_method [String?] ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over `default_source`. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_source [String?] ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If `default_payment_method` is also set, `default_payment_method` will take precedence. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_tax_rates [Stripe::PostCustomersCustomerSubscriptionsRequestDefaultTaxRates?]
    # @optional @param description [String?] The subscription's description, meant to be displayable to the customer. Use this field to optionally store an explanation of the subscription for rendering in Stripe surfaces.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param items [Array(Stripe::SubscriptionItemCreateParams)?] A list of up to 20 subscription items, each with an attached price.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param off_session [Bool?] Indicates if a customer is on or off-session while an invoice payment is attempted.
    # @optional @param payment_behavior [String?] Use `allow_incomplete` to create subscriptions with `status=incomplete` if the first invoice cannot be paid. Creating subscriptions with this status allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use `default_incomplete` to create Subscriptions with `status=incomplete` when the first invoice requires payment, otherwise start as active. Subscriptions transition to `status=active` when successfully confirming the payment intent on the first invoice. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method. If the payment intent is not confirmed within 23 hours subscriptions transition to `status=incomplete_expired`, which is a terminal state.  Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's first invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not create a subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.  `pending_if_incomplete` is only used with updates and cannot be passed when creating a subscription.
    # @optional @param payment_settings [Stripe::PaymentSettings?]
    # @optional @param pending_invoice_item_interval [Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval?]
    # @optional @param promotion_code [String?] The API ID of a promotion code to apply to this subscription. A promotion code applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) resulting from the `billing_cycle_anchor`. If no value is passed, the default is `create_prorations`.
    # @optional @param transfer_data [Stripe::TransferDataSpecs3?]
    # @optional @param trial_end [Stripe::PostCustomersCustomerSubscriptionsRequestTrialEnd?]
    # @optional @param trial_from_plan [Bool?] Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @optional @param trial_period_days [Int64?] Integer representing the number of trial period days before the customer is charged for the first time. This will always overwrite any trials that might apply via a subscribed plan. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @return nil
    def post_subscriptions(*, customer : String? = nil, add_invoice_items : Array(Stripe::AddInvoiceItemEntry)? = nil, application_fee_percent : Float64? = nil, automatic_tax : Stripe::AutomaticTaxConfig? = nil, backdate_start_date : Int64? = nil, billing_cycle_anchor : Int64? = nil, billing_thresholds : Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds? = nil, cancel_at : Int64? = nil, cancel_at_period_end : Bool? = nil, collection_method : String? = nil, coupon : String? = nil, currency : String? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Stripe::PostCustomersCustomerSubscriptionsRequestDefaultTaxRates? = nil, description : String? = nil, expand : Array(String)? = nil, items : Array(Stripe::SubscriptionItemCreateParams)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, off_session : Bool? = nil, payment_behavior : String? = nil, payment_settings : Stripe::PaymentSettings? = nil, pending_invoice_item_interval : Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval? = nil, promotion_code : String? = nil, proration_behavior : String? = nil, transfer_data : Stripe::TransferDataSpecs3? = nil, trial_end : Stripe::PostCustomersCustomerSubscriptionsRequestTrialEnd? = nil, trial_from_plan : Bool? = nil, trial_period_days : Int64? = nil, &block : Crest::Response ->)
      build_api_request_for_post_subscriptions(customer: customer, add_invoice_items: add_invoice_items, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, backdate_start_date: backdate_start_date, billing_cycle_anchor: billing_cycle_anchor, billing_thresholds: billing_thresholds, cancel_at: cancel_at, cancel_at_period_end: cancel_at_period_end, collection_method: collection_method, coupon: coupon, currency: currency, days_until_due: days_until_due, default_payment_method: default_payment_method, default_source: default_source, default_tax_rates: default_tax_rates, description: description, expand: expand, items: items, metadata: metadata, off_session: off_session, payment_behavior: payment_behavior, payment_settings: payment_settings, pending_invoice_item_interval: pending_invoice_item_interval, promotion_code: promotion_code, proration_behavior: proration_behavior, transfer_data: transfer_data, trial_end: trial_end, trial_from_plan: trial_from_plan, trial_period_days: trial_period_days).execute(&block)
    end

    POST_SUBSCRIPTIONS_MAX_LENGTH_FOR_CUSTOMER               = 5000
    POST_SUBSCRIPTIONS_VALID_VALUES_FOR_COLLECTION_METHOD    = StaticArray["charge_automatically", "send_invoice"]
    POST_SUBSCRIPTIONS_MAX_LENGTH_FOR_COUPON                 = 5000
    POST_SUBSCRIPTIONS_MAX_LENGTH_FOR_DEFAULT_PAYMENT_METHOD = 5000
    POST_SUBSCRIPTIONS_MAX_LENGTH_FOR_DEFAULT_SOURCE         = 5000
    POST_SUBSCRIPTIONS_MAX_LENGTH_FOR_DESCRIPTION            =  500
    POST_SUBSCRIPTIONS_VALID_VALUES_FOR_PAYMENT_BEHAVIOR     = StaticArray["allow_incomplete", "default_incomplete", "error_if_incomplete", "pending_if_incomplete"]
    POST_SUBSCRIPTIONS_MAX_LENGTH_FOR_PROMOTION_CODE         = 5000
    POST_SUBSCRIPTIONS_VALID_VALUES_FOR_PRORATION_BEHAVIOR   = StaticArray["always_invoice", "create_prorations", "none"]

    # @return Crest::Request
    def build_api_request_for_post_subscriptions(*, customer : String? = nil, add_invoice_items : Array(Stripe::AddInvoiceItemEntry)? = nil, application_fee_percent : Float64? = nil, automatic_tax : Stripe::AutomaticTaxConfig? = nil, backdate_start_date : Int64? = nil, billing_cycle_anchor : Int64? = nil, billing_thresholds : Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds? = nil, cancel_at : Int64? = nil, cancel_at_period_end : Bool? = nil, collection_method : String? = nil, coupon : String? = nil, currency : String? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Stripe::PostCustomersCustomerSubscriptionsRequestDefaultTaxRates? = nil, description : String? = nil, expand : Array(String)? = nil, items : Array(Stripe::SubscriptionItemCreateParams)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, off_session : Bool? = nil, payment_behavior : String? = nil, payment_settings : Stripe::PaymentSettings? = nil, pending_invoice_item_interval : Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval? = nil, promotion_code : String? = nil, proration_behavior : String? = nil, transfer_data : Stripe::TransferDataSpecs3? = nil, trial_end : Stripe::PostCustomersCustomerSubscriptionsRequestTrialEnd? = nil, trial_from_plan : Bool? = nil, trial_period_days : Int64? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_subscriptions ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_SUBSCRIPTIONS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _add_invoice_items = add_invoice_items
          OpenApi::ContainerValidator.validate(container: _add_invoice_items) if _add_invoice_items.is_a?(Array)
        end

        if _automatic_tax = automatic_tax
          _automatic_tax.validate if _automatic_tax.is_a?(OpenApi::Validatable)
        end

        if _billing_thresholds = billing_thresholds
          _billing_thresholds.validate if _billing_thresholds.is_a?(OpenApi::Validatable)
        end

        if _collection_method = collection_method
          OpenApi::EnumValidator.validate("collection_method", _collection_method, POST_SUBSCRIPTIONS_VALID_VALUES_FOR_COLLECTION_METHOD)
        end
        if _coupon = coupon
          OpenApi::PrimitiveValidator.validate_max_length("coupon", coupon.to_s.size, POST_SUBSCRIPTIONS_MAX_LENGTH_FOR_COUPON)
        end

        if _default_payment_method = default_payment_method
          OpenApi::PrimitiveValidator.validate_max_length("default_payment_method", default_payment_method.to_s.size, POST_SUBSCRIPTIONS_MAX_LENGTH_FOR_DEFAULT_PAYMENT_METHOD)
        end
        if _default_source = default_source
          OpenApi::PrimitiveValidator.validate_max_length("default_source", default_source.to_s.size, POST_SUBSCRIPTIONS_MAX_LENGTH_FOR_DEFAULT_SOURCE)
        end
        if _default_tax_rates = default_tax_rates
          _default_tax_rates.validate if _default_tax_rates.is_a?(OpenApi::Validatable)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_SUBSCRIPTIONS_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _items = items
          OpenApi::ContainerValidator.validate(container: _items) if _items.is_a?(Array)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end

        if _payment_behavior = payment_behavior
          OpenApi::EnumValidator.validate("payment_behavior", _payment_behavior, POST_SUBSCRIPTIONS_VALID_VALUES_FOR_PAYMENT_BEHAVIOR)
        end
        if _payment_settings = payment_settings
          _payment_settings.validate if _payment_settings.is_a?(OpenApi::Validatable)
        end
        if _pending_invoice_item_interval = pending_invoice_item_interval
          _pending_invoice_item_interval.validate if _pending_invoice_item_interval.is_a?(OpenApi::Validatable)
        end
        if _promotion_code = promotion_code
          OpenApi::PrimitiveValidator.validate_max_length("promotion_code", promotion_code.to_s.size, POST_SUBSCRIPTIONS_MAX_LENGTH_FOR_PROMOTION_CODE)
        end
        if _proration_behavior = proration_behavior
          OpenApi::EnumValidator.validate("proration_behavior", _proration_behavior, POST_SUBSCRIPTIONS_VALID_VALUES_FOR_PRORATION_BEHAVIOR)
        end
        if _transfer_data = transfer_data
          _transfer_data.validate if _transfer_data.is_a?(OpenApi::Validatable)
        end
        if _trial_end = trial_end
          _trial_end.validate if _trial_end.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/subscriptions"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["add_invoice_items"] = @api_client.build_collection_param(add_invoice_items, "csv") if !add_invoice_items.nil? && !add_invoice_items.empty?
      form_params["application_fee_percent"] = application_fee_percent.to_s if !application_fee_percent.nil?
      form_params["automatic_tax"] = automatic_tax.to_s if !automatic_tax.nil?
      form_params["backdate_start_date"] = backdate_start_date.to_s if !backdate_start_date.nil?
      form_params["billing_cycle_anchor"] = billing_cycle_anchor.to_s if !billing_cycle_anchor.nil?
      form_params["billing_thresholds"] = billing_thresholds.to_s if !billing_thresholds.nil?
      form_params["cancel_at"] = cancel_at.to_s if !cancel_at.nil?
      form_params["cancel_at_period_end"] = cancel_at_period_end.to_s if !cancel_at_period_end.nil?
      form_params["collection_method"] = collection_method.to_s if !collection_method.nil?
      form_params["coupon"] = coupon.to_s if !coupon.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["days_until_due"] = days_until_due.to_s if !days_until_due.nil?
      form_params["default_payment_method"] = default_payment_method.to_s if !default_payment_method.nil?
      form_params["default_source"] = default_source.to_s if !default_source.nil?
      form_params["default_tax_rates"] = default_tax_rates.to_s if !default_tax_rates.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["items"] = @api_client.build_collection_param(items, "csv") if !items.nil? && !items.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["off_session"] = off_session.to_s if !off_session.nil?
      form_params["payment_behavior"] = payment_behavior.to_s if !payment_behavior.nil?
      form_params["payment_settings"] = payment_settings.to_s if !payment_settings.nil?
      form_params["pending_invoice_item_interval"] = pending_invoice_item_interval.to_s if !pending_invoice_item_interval.nil?
      form_params["promotion_code"] = promotion_code.to_s if !promotion_code.nil?
      form_params["proration_behavior"] = proration_behavior.to_s if !proration_behavior.nil?
      form_params["transfer_data"] = transfer_data.to_s if !transfer_data.nil?
      form_params["trial_end"] = trial_end.to_s if !trial_end.nil?
      form_params["trial_from_plan"] = trial_from_plan.to_s if !trial_from_plan.nil?
      form_params["trial_period_days"] = trial_period_days.to_s if !trial_period_days.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_subscriptions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates an existing subscription on a customer to match the specified parameters. When changing plans or quantities, we will optionally prorate the price we charge next month to make up for any price changes. To preview how the proration will be calculated, use the <a href=\"#upcoming_invoice\">upcoming invoice</a> endpoint.</p>
    # @param subscription_exposed_id [String?]
    # @optional @param add_invoice_items [Array(Stripe::AddInvoiceItemEntry)?] A list of prices and quantities that will generate invoice items appended to the next invoice for this subscription. You may pass up to 20 items.
    # @optional @param application_fee_percent [Float64?] A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. The request must be made by a platform account on a connected account in order to set an application fee percentage. For more information, see the application fees [documentation](https://stripe.com/docs/connect/subscriptions#collecting-fees-on-subscriptions).
    # @optional @param automatic_tax [Stripe::AutomaticTaxConfig?]
    # @optional @param billing_cycle_anchor [String?] Either `now` or `unchanged`. Setting the value to `now` resets the subscription's billing cycle anchor to the current time (in UTC). For more information, see the billing cycle [documentation](https://stripe.com/docs/billing/subscriptions/billing-cycle).
    # @optional @param billing_thresholds [Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds?]
    # @optional @param cancel_at [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestCancelAt?]
    # @optional @param cancel_at_period_end [Bool?] Boolean indicating whether this subscription should cancel at the end of the current period.
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
    # @optional @param coupon [String?] The ID of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param days_until_due [Int64?] Number of days a customer has to pay invoices generated by this subscription. Valid only for subscriptions where `collection_method` is set to `send_invoice`.
    # @optional @param default_payment_method [String?] ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over `default_source`. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_source [String?] ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If `default_payment_method` is also set, `default_payment_method` will take precedence. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_tax_rates [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestDefaultTaxRates?]
    # @optional @param description [String?] The subscription's description, meant to be displayable to the customer. Use this field to optionally store an explanation of the subscription for rendering in Stripe surfaces.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param items [Array(Stripe::SubscriptionItemUpdateParams)?] A list of up to 20 subscription items, each with an attached price.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param off_session [Bool?] Indicates if a customer is on or off-session while an invoice payment is attempted.
    # @optional @param pause_collection [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestPauseCollection?]
    # @optional @param payment_behavior [String?] Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.  Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).  Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
    # @optional @param payment_settings [Stripe::PaymentSettings?]
    # @optional @param pending_invoice_item_interval [Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval?]
    # @optional @param promotion_code [String?] The promotion code to apply to this subscription. A promotion code applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param proration_date [Int64?] If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply exactly the same proration that was previewed with [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint. It can also be used to implement custom proration logic, such as prorating by day instead of by second, by providing the time that you wish to use for proration calculations.
    # @optional @param transfer_data [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTransferData?]
    # @optional @param trial_end [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTrialEnd?]
    # @optional @param trial_from_plan [Bool?] Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @return [Subscription]
    def post_subscriptions_subscription_exposed_id(*, subscription_exposed_id : String? = nil, add_invoice_items : Array(Stripe::AddInvoiceItemEntry)? = nil, application_fee_percent : Float64? = nil, automatic_tax : Stripe::AutomaticTaxConfig? = nil, billing_cycle_anchor : String? = nil, billing_thresholds : Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds? = nil, cancel_at : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestCancelAt? = nil, cancel_at_period_end : Bool? = nil, collection_method : String? = nil, coupon : String? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestDefaultTaxRates? = nil, description : String? = nil, expand : Array(String)? = nil, items : Array(Stripe::SubscriptionItemUpdateParams)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, off_session : Bool? = nil, pause_collection : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestPauseCollection? = nil, payment_behavior : String? = nil, payment_settings : Stripe::PaymentSettings? = nil, pending_invoice_item_interval : Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval? = nil, promotion_code : String? = nil, proration_behavior : String? = nil, proration_date : Int64? = nil, transfer_data : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTransferData? = nil, trial_end : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTrialEnd? = nil, trial_from_plan : Bool? = nil)
      data, _status_code, _headers = post_subscriptions_subscription_exposed_id_with_http_info(subscription_exposed_id: subscription_exposed_id, add_invoice_items: add_invoice_items, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, billing_cycle_anchor: billing_cycle_anchor, billing_thresholds: billing_thresholds, cancel_at: cancel_at, cancel_at_period_end: cancel_at_period_end, collection_method: collection_method, coupon: coupon, days_until_due: days_until_due, default_payment_method: default_payment_method, default_source: default_source, default_tax_rates: default_tax_rates, description: description, expand: expand, items: items, metadata: metadata, off_session: off_session, pause_collection: pause_collection, payment_behavior: payment_behavior, payment_settings: payment_settings, pending_invoice_item_interval: pending_invoice_item_interval, promotion_code: promotion_code, proration_behavior: proration_behavior, proration_date: proration_date, transfer_data: transfer_data, trial_end: trial_end, trial_from_plan: trial_from_plan)
      data
    end

    # &lt;p&gt;Updates an existing subscription on a customer to match the specified parameters. When changing plans or quantities, we will optionally prorate the price we charge next month to make up for any price changes. To preview how the proration will be calculated, use the &lt;a href&#x3D;\&quot;#upcoming_invoice\&quot;&gt;upcoming invoice&lt;/a&gt; endpoint.&lt;/p&gt;
    # @param subscription_exposed_id [String?]
    # @optional @param add_invoice_items [Array(Stripe::AddInvoiceItemEntry)?] A list of prices and quantities that will generate invoice items appended to the next invoice for this subscription. You may pass up to 20 items.
    # @optional @param application_fee_percent [Float64?] A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. The request must be made by a platform account on a connected account in order to set an application fee percentage. For more information, see the application fees [documentation](https://stripe.com/docs/connect/subscriptions#collecting-fees-on-subscriptions).
    # @optional @param automatic_tax [Stripe::AutomaticTaxConfig?]
    # @optional @param billing_cycle_anchor [String?] Either `now` or `unchanged`. Setting the value to `now` resets the subscription's billing cycle anchor to the current time (in UTC). For more information, see the billing cycle [documentation](https://stripe.com/docs/billing/subscriptions/billing-cycle).
    # @optional @param billing_thresholds [Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds?]
    # @optional @param cancel_at [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestCancelAt?]
    # @optional @param cancel_at_period_end [Bool?] Boolean indicating whether this subscription should cancel at the end of the current period.
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
    # @optional @param coupon [String?] The ID of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param days_until_due [Int64?] Number of days a customer has to pay invoices generated by this subscription. Valid only for subscriptions where `collection_method` is set to `send_invoice`.
    # @optional @param default_payment_method [String?] ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over `default_source`. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_source [String?] ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If `default_payment_method` is also set, `default_payment_method` will take precedence. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_tax_rates [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestDefaultTaxRates?]
    # @optional @param description [String?] The subscription's description, meant to be displayable to the customer. Use this field to optionally store an explanation of the subscription for rendering in Stripe surfaces.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param items [Array(Stripe::SubscriptionItemUpdateParams)?] A list of up to 20 subscription items, each with an attached price.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param off_session [Bool?] Indicates if a customer is on or off-session while an invoice payment is attempted.
    # @optional @param pause_collection [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestPauseCollection?]
    # @optional @param payment_behavior [String?] Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.  Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).  Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
    # @optional @param payment_settings [Stripe::PaymentSettings?]
    # @optional @param pending_invoice_item_interval [Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval?]
    # @optional @param promotion_code [String?] The promotion code to apply to this subscription. A promotion code applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param proration_date [Int64?] If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply exactly the same proration that was previewed with [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint. It can also be used to implement custom proration logic, such as prorating by day instead of by second, by providing the time that you wish to use for proration calculations.
    # @optional @param transfer_data [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTransferData?]
    # @optional @param trial_end [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTrialEnd?]
    # @optional @param trial_from_plan [Bool?] Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @return [Array<(Subscription, Integer, Hash)>] Subscription data, response status code and response headers
    def post_subscriptions_subscription_exposed_id_with_http_info(*, subscription_exposed_id : String? = nil, add_invoice_items : Array(Stripe::AddInvoiceItemEntry)? = nil, application_fee_percent : Float64? = nil, automatic_tax : Stripe::AutomaticTaxConfig? = nil, billing_cycle_anchor : String? = nil, billing_thresholds : Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds? = nil, cancel_at : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestCancelAt? = nil, cancel_at_period_end : Bool? = nil, collection_method : String? = nil, coupon : String? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestDefaultTaxRates? = nil, description : String? = nil, expand : Array(String)? = nil, items : Array(Stripe::SubscriptionItemUpdateParams)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, off_session : Bool? = nil, pause_collection : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestPauseCollection? = nil, payment_behavior : String? = nil, payment_settings : Stripe::PaymentSettings? = nil, pending_invoice_item_interval : Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval? = nil, promotion_code : String? = nil, proration_behavior : String? = nil, proration_date : Int64? = nil, transfer_data : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTransferData? = nil, trial_end : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTrialEnd? = nil, trial_from_plan : Bool? = nil)
      request = build_api_request_for_post_subscriptions_subscription_exposed_id(subscription_exposed_id: subscription_exposed_id, add_invoice_items: add_invoice_items, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, billing_cycle_anchor: billing_cycle_anchor, billing_thresholds: billing_thresholds, cancel_at: cancel_at, cancel_at_period_end: cancel_at_period_end, collection_method: collection_method, coupon: coupon, days_until_due: days_until_due, default_payment_method: default_payment_method, default_source: default_source, default_tax_rates: default_tax_rates, description: description, expand: expand, items: items, metadata: metadata, off_session: off_session, pause_collection: pause_collection, payment_behavior: payment_behavior, payment_settings: payment_settings, pending_invoice_item_interval: pending_invoice_item_interval, promotion_code: promotion_code, proration_behavior: proration_behavior, proration_date: proration_date, transfer_data: transfer_data, trial_end: trial_end, trial_from_plan: trial_from_plan)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_subscriptions_subscription_exposed_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Subscription.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates an existing subscription on a customer to match the specified parameters. When changing plans or quantities, we will optionally prorate the price we charge next month to make up for any price changes. To preview how the proration will be calculated, use the &lt;a href&#x3D;\&quot;#upcoming_invoice\&quot;&gt;upcoming invoice&lt;/a&gt; endpoint.&lt;/p&gt;
    # @param subscription_exposed_id [String?]
    # @optional @param add_invoice_items [Array(Stripe::AddInvoiceItemEntry)?] A list of prices and quantities that will generate invoice items appended to the next invoice for this subscription. You may pass up to 20 items.
    # @optional @param application_fee_percent [Float64?] A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. The request must be made by a platform account on a connected account in order to set an application fee percentage. For more information, see the application fees [documentation](https://stripe.com/docs/connect/subscriptions#collecting-fees-on-subscriptions).
    # @optional @param automatic_tax [Stripe::AutomaticTaxConfig?]
    # @optional @param billing_cycle_anchor [String?] Either `now` or `unchanged`. Setting the value to `now` resets the subscription's billing cycle anchor to the current time (in UTC). For more information, see the billing cycle [documentation](https://stripe.com/docs/billing/subscriptions/billing-cycle).
    # @optional @param billing_thresholds [Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds?]
    # @optional @param cancel_at [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestCancelAt?]
    # @optional @param cancel_at_period_end [Bool?] Boolean indicating whether this subscription should cancel at the end of the current period.
    # @optional @param collection_method [String?] Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
    # @optional @param coupon [String?] The ID of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param days_until_due [Int64?] Number of days a customer has to pay invoices generated by this subscription. Valid only for subscriptions where `collection_method` is set to `send_invoice`.
    # @optional @param default_payment_method [String?] ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over `default_source`. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_source [String?] ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If `default_payment_method` is also set, `default_payment_method` will take precedence. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
    # @optional @param default_tax_rates [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestDefaultTaxRates?]
    # @optional @param description [String?] The subscription's description, meant to be displayable to the customer. Use this field to optionally store an explanation of the subscription for rendering in Stripe surfaces.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param items [Array(Stripe::SubscriptionItemUpdateParams)?] A list of up to 20 subscription items, each with an attached price.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param off_session [Bool?] Indicates if a customer is on or off-session while an invoice payment is attempted.
    # @optional @param pause_collection [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestPauseCollection?]
    # @optional @param payment_behavior [String?] Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.  Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).  Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
    # @optional @param payment_settings [Stripe::PaymentSettings?]
    # @optional @param pending_invoice_item_interval [Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval?]
    # @optional @param promotion_code [String?] The promotion code to apply to this subscription. A promotion code applied to a subscription will only affect invoices created for that particular subscription.
    # @optional @param proration_behavior [String?] Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes.
    # @optional @param proration_date [Int64?] If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply exactly the same proration that was previewed with [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint. It can also be used to implement custom proration logic, such as prorating by day instead of by second, by providing the time that you wish to use for proration calculations.
    # @optional @param transfer_data [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTransferData?]
    # @optional @param trial_end [Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTrialEnd?]
    # @optional @param trial_from_plan [Bool?] Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
    # @return nil
    def post_subscriptions_subscription_exposed_id(*, subscription_exposed_id : String? = nil, add_invoice_items : Array(Stripe::AddInvoiceItemEntry)? = nil, application_fee_percent : Float64? = nil, automatic_tax : Stripe::AutomaticTaxConfig? = nil, billing_cycle_anchor : String? = nil, billing_thresholds : Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds? = nil, cancel_at : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestCancelAt? = nil, cancel_at_period_end : Bool? = nil, collection_method : String? = nil, coupon : String? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestDefaultTaxRates? = nil, description : String? = nil, expand : Array(String)? = nil, items : Array(Stripe::SubscriptionItemUpdateParams)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, off_session : Bool? = nil, pause_collection : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestPauseCollection? = nil, payment_behavior : String? = nil, payment_settings : Stripe::PaymentSettings? = nil, pending_invoice_item_interval : Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval? = nil, promotion_code : String? = nil, proration_behavior : String? = nil, proration_date : Int64? = nil, transfer_data : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTransferData? = nil, trial_end : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTrialEnd? = nil, trial_from_plan : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_post_subscriptions_subscription_exposed_id(subscription_exposed_id: subscription_exposed_id, add_invoice_items: add_invoice_items, application_fee_percent: application_fee_percent, automatic_tax: automatic_tax, billing_cycle_anchor: billing_cycle_anchor, billing_thresholds: billing_thresholds, cancel_at: cancel_at, cancel_at_period_end: cancel_at_period_end, collection_method: collection_method, coupon: coupon, days_until_due: days_until_due, default_payment_method: default_payment_method, default_source: default_source, default_tax_rates: default_tax_rates, description: description, expand: expand, items: items, metadata: metadata, off_session: off_session, pause_collection: pause_collection, payment_behavior: payment_behavior, payment_settings: payment_settings, pending_invoice_item_interval: pending_invoice_item_interval, promotion_code: promotion_code, proration_behavior: proration_behavior, proration_date: proration_date, transfer_data: transfer_data, trial_end: trial_end, trial_from_plan: trial_from_plan).execute(&block)
    end

    POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID = 5000
    POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_BILLING_CYCLE_ANCHOR    = 5000
    POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_VALID_VALUES_FOR_BILLING_CYCLE_ANCHOR  = StaticArray["now", "unchanged"]
    POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_VALID_VALUES_FOR_COLLECTION_METHOD     = StaticArray["charge_automatically", "send_invoice"]
    POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_COUPON                  = 5000
    POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_DEFAULT_PAYMENT_METHOD  = 5000
    POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_DEFAULT_SOURCE          = 5000
    POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_DESCRIPTION             =  500
    POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_VALID_VALUES_FOR_PAYMENT_BEHAVIOR      = StaticArray["allow_incomplete", "default_incomplete", "error_if_incomplete", "pending_if_incomplete"]
    POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_PROMOTION_CODE          = 5000
    POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_VALID_VALUES_FOR_PRORATION_BEHAVIOR    = StaticArray["always_invoice", "create_prorations", "none"]

    # @return Crest::Request
    def build_api_request_for_post_subscriptions_subscription_exposed_id(*, subscription_exposed_id : String? = nil, add_invoice_items : Array(Stripe::AddInvoiceItemEntry)? = nil, application_fee_percent : Float64? = nil, automatic_tax : Stripe::AutomaticTaxConfig? = nil, billing_cycle_anchor : String? = nil, billing_thresholds : Stripe::PostCustomersCustomerSubscriptionsRequestBillingThresholds? = nil, cancel_at : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestCancelAt? = nil, cancel_at_period_end : Bool? = nil, collection_method : String? = nil, coupon : String? = nil, days_until_due : Int64? = nil, default_payment_method : String? = nil, default_source : String? = nil, default_tax_rates : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestDefaultTaxRates? = nil, description : String? = nil, expand : Array(String)? = nil, items : Array(Stripe::SubscriptionItemUpdateParams)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, off_session : Bool? = nil, pause_collection : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestPauseCollection? = nil, payment_behavior : String? = nil, payment_settings : Stripe::PaymentSettings? = nil, pending_invoice_item_interval : Stripe::PostCustomersCustomerSubscriptionsRequestPendingInvoiceItemInterval? = nil, promotion_code : String? = nil, proration_behavior : String? = nil, proration_date : Int64? = nil, transfer_data : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTransferData? = nil, trial_end : Stripe::PostCustomersCustomerSubscriptionsSubscriptionExposedIdRequestTrialEnd? = nil, trial_from_plan : Bool? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_subscriptions_subscription_exposed_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"subscription_exposed_id\" is required and cannot be null") if subscription_exposed_id.nil?
        if _subscription_exposed_id = subscription_exposed_id
          OpenApi::PrimitiveValidator.validate_max_length("subscription_exposed_id", subscription_exposed_id.to_s.size, POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID)
        end
        if _add_invoice_items = add_invoice_items
          OpenApi::ContainerValidator.validate(container: _add_invoice_items) if _add_invoice_items.is_a?(Array)
        end

        if _automatic_tax = automatic_tax
          _automatic_tax.validate if _automatic_tax.is_a?(OpenApi::Validatable)
        end
        if _billing_cycle_anchor = billing_cycle_anchor
          OpenApi::EnumValidator.validate("billing_cycle_anchor", _billing_cycle_anchor, POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_VALID_VALUES_FOR_BILLING_CYCLE_ANCHOR)
        end
        if _billing_thresholds = billing_thresholds
          _billing_thresholds.validate if _billing_thresholds.is_a?(OpenApi::Validatable)
        end
        if _cancel_at = cancel_at
          _cancel_at.validate if _cancel_at.is_a?(OpenApi::Validatable)
        end

        if _collection_method = collection_method
          OpenApi::EnumValidator.validate("collection_method", _collection_method, POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_VALID_VALUES_FOR_COLLECTION_METHOD)
        end
        if _coupon = coupon
          OpenApi::PrimitiveValidator.validate_max_length("coupon", coupon.to_s.size, POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_COUPON)
        end

        if _default_payment_method = default_payment_method
          OpenApi::PrimitiveValidator.validate_max_length("default_payment_method", default_payment_method.to_s.size, POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_DEFAULT_PAYMENT_METHOD)
        end
        if _default_source = default_source
          OpenApi::PrimitiveValidator.validate_max_length("default_source", default_source.to_s.size, POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_DEFAULT_SOURCE)
        end
        if _default_tax_rates = default_tax_rates
          _default_tax_rates.validate if _default_tax_rates.is_a?(OpenApi::Validatable)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _items = items
          OpenApi::ContainerValidator.validate(container: _items) if _items.is_a?(Array)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end

        if _pause_collection = pause_collection
          _pause_collection.validate if _pause_collection.is_a?(OpenApi::Validatable)
        end
        if _payment_behavior = payment_behavior
          OpenApi::EnumValidator.validate("payment_behavior", _payment_behavior, POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_VALID_VALUES_FOR_PAYMENT_BEHAVIOR)
        end
        if _payment_settings = payment_settings
          _payment_settings.validate if _payment_settings.is_a?(OpenApi::Validatable)
        end
        if _pending_invoice_item_interval = pending_invoice_item_interval
          _pending_invoice_item_interval.validate if _pending_invoice_item_interval.is_a?(OpenApi::Validatable)
        end
        if _promotion_code = promotion_code
          OpenApi::PrimitiveValidator.validate_max_length("promotion_code", promotion_code.to_s.size, POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_PROMOTION_CODE)
        end
        if _proration_behavior = proration_behavior
          OpenApi::EnumValidator.validate("proration_behavior", _proration_behavior, POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_VALID_VALUES_FOR_PRORATION_BEHAVIOR)
        end

        if _transfer_data = transfer_data
          _transfer_data.validate if _transfer_data.is_a?(OpenApi::Validatable)
        end
        if _trial_end = trial_end
          _trial_end.validate if _trial_end.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/subscriptions/{subscription_exposed_id}".sub("{" + "subscription_exposed_id" + "}", URI.encode_path(subscription_exposed_id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["add_invoice_items"] = @api_client.build_collection_param(add_invoice_items, "csv") if !add_invoice_items.nil? && !add_invoice_items.empty?
      form_params["application_fee_percent"] = application_fee_percent.to_s if !application_fee_percent.nil?
      form_params["automatic_tax"] = automatic_tax.to_s if !automatic_tax.nil?
      form_params["billing_cycle_anchor"] = billing_cycle_anchor.to_s if !billing_cycle_anchor.nil?
      form_params["billing_thresholds"] = billing_thresholds.to_s if !billing_thresholds.nil?
      form_params["cancel_at"] = cancel_at.to_s if !cancel_at.nil?
      form_params["cancel_at_period_end"] = cancel_at_period_end.to_s if !cancel_at_period_end.nil?
      form_params["collection_method"] = collection_method.to_s if !collection_method.nil?
      form_params["coupon"] = coupon.to_s if !coupon.nil?
      form_params["days_until_due"] = days_until_due.to_s if !days_until_due.nil?
      form_params["default_payment_method"] = default_payment_method.to_s if !default_payment_method.nil?
      form_params["default_source"] = default_source.to_s if !default_source.nil?
      form_params["default_tax_rates"] = default_tax_rates.to_s if !default_tax_rates.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["items"] = @api_client.build_collection_param(items, "csv") if !items.nil? && !items.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["off_session"] = off_session.to_s if !off_session.nil?
      form_params["pause_collection"] = pause_collection.to_s if !pause_collection.nil?
      form_params["payment_behavior"] = payment_behavior.to_s if !payment_behavior.nil?
      form_params["payment_settings"] = payment_settings.to_s if !payment_settings.nil?
      form_params["pending_invoice_item_interval"] = pending_invoice_item_interval.to_s if !pending_invoice_item_interval.nil?
      form_params["promotion_code"] = promotion_code.to_s if !promotion_code.nil?
      form_params["proration_behavior"] = proration_behavior.to_s if !proration_behavior.nil?
      form_params["proration_date"] = proration_date.to_s if !proration_date.nil?
      form_params["transfer_data"] = transfer_data.to_s if !transfer_data.nil?
      form_params["trial_end"] = trial_end.to_s if !trial_end.nil?
      form_params["trial_from_plan"] = trial_from_plan.to_s if !trial_from_plan.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_subscriptions_subscription_exposed_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new tax rate.</p>
    # @param display_name [String?] The display name of the tax rate, which will be shown to users.
    # @param inclusive [Bool?] This specifies if the tax rate is inclusive or exclusive.
    # @param percentage [Float64?] This represents the tax rate percent out of 100.
    # @optional @param active [Bool?] Flag determining whether the tax rate is active or inactive (archived). Inactive tax rates cannot be used with new applications or Checkout Sessions, but will still work for subscriptions and invoices that already have it set.
    # @optional @param country [String?] Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
    # @optional @param description [String?] An arbitrary string attached to the tax rate for your internal use only. It will not be visible to your customers.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param jurisdiction [String?] The jurisdiction for the tax rate. You can use this label field for tax reporting purposes. It also appears on your customer’s invoice.
    # @optional @param state [String?] [ISO 3166-2 subdivision code](https://en.wikipedia.org/wiki/ISO_3166-2:US), without country prefix. For example, \\\"NY\\\" for New York, United States.
    # @optional @param tax_type [String?] The high-level tax type, such as `vat` or `sales_tax`.
    # @return [TaxRate]
    def post_tax_rates(*, display_name : String? = nil, inclusive : Bool? = nil, percentage : Float64? = nil, active : Bool? = nil, country : String? = nil, description : String? = nil, expand : Array(String)? = nil, jurisdiction : String? = nil, state : String? = nil, tax_type : String? = nil)
      data, _status_code, _headers = post_tax_rates_with_http_info(display_name: display_name, inclusive: inclusive, percentage: percentage, active: active, country: country, description: description, expand: expand, jurisdiction: jurisdiction, state: state, tax_type: tax_type)
      data
    end

    # &lt;p&gt;Creates a new tax rate.&lt;/p&gt;
    # @param display_name [String?] The display name of the tax rate, which will be shown to users.
    # @param inclusive [Bool?] This specifies if the tax rate is inclusive or exclusive.
    # @param percentage [Float64?] This represents the tax rate percent out of 100.
    # @optional @param active [Bool?] Flag determining whether the tax rate is active or inactive (archived). Inactive tax rates cannot be used with new applications or Checkout Sessions, but will still work for subscriptions and invoices that already have it set.
    # @optional @param country [String?] Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
    # @optional @param description [String?] An arbitrary string attached to the tax rate for your internal use only. It will not be visible to your customers.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param jurisdiction [String?] The jurisdiction for the tax rate. You can use this label field for tax reporting purposes. It also appears on your customer’s invoice.
    # @optional @param state [String?] [ISO 3166-2 subdivision code](https://en.wikipedia.org/wiki/ISO_3166-2:US), without country prefix. For example, \\\"NY\\\" for New York, United States.
    # @optional @param tax_type [String?] The high-level tax type, such as `vat` or `sales_tax`.
    # @return [Array<(TaxRate, Integer, Hash)>] TaxRate data, response status code and response headers
    def post_tax_rates_with_http_info(*, display_name : String? = nil, inclusive : Bool? = nil, percentage : Float64? = nil, active : Bool? = nil, country : String? = nil, description : String? = nil, expand : Array(String)? = nil, jurisdiction : String? = nil, state : String? = nil, tax_type : String? = nil)
      request = build_api_request_for_post_tax_rates(display_name: display_name, inclusive: inclusive, percentage: percentage, active: active, country: country, description: description, expand: expand, jurisdiction: jurisdiction, state: state, tax_type: tax_type)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_tax_rates\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TaxRate.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new tax rate.&lt;/p&gt;
    # @param display_name [String?] The display name of the tax rate, which will be shown to users.
    # @param inclusive [Bool?] This specifies if the tax rate is inclusive or exclusive.
    # @param percentage [Float64?] This represents the tax rate percent out of 100.
    # @optional @param active [Bool?] Flag determining whether the tax rate is active or inactive (archived). Inactive tax rates cannot be used with new applications or Checkout Sessions, but will still work for subscriptions and invoices that already have it set.
    # @optional @param country [String?] Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
    # @optional @param description [String?] An arbitrary string attached to the tax rate for your internal use only. It will not be visible to your customers.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param jurisdiction [String?] The jurisdiction for the tax rate. You can use this label field for tax reporting purposes. It also appears on your customer’s invoice.
    # @optional @param state [String?] [ISO 3166-2 subdivision code](https://en.wikipedia.org/wiki/ISO_3166-2:US), without country prefix. For example, \\\"NY\\\" for New York, United States.
    # @optional @param tax_type [String?] The high-level tax type, such as `vat` or `sales_tax`.
    # @return nil
    def post_tax_rates(*, display_name : String? = nil, inclusive : Bool? = nil, percentage : Float64? = nil, active : Bool? = nil, country : String? = nil, description : String? = nil, expand : Array(String)? = nil, jurisdiction : String? = nil, state : String? = nil, tax_type : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_tax_rates(display_name: display_name, inclusive: inclusive, percentage: percentage, active: active, country: country, description: description, expand: expand, jurisdiction: jurisdiction, state: state, tax_type: tax_type).execute(&block)
    end

    POST_TAX_RATES_MAX_LENGTH_FOR_DISPLAY_NAME =   50
    POST_TAX_RATES_MAX_LENGTH_FOR_COUNTRY      = 5000
    POST_TAX_RATES_MAX_LENGTH_FOR_DESCRIPTION  = 5000
    POST_TAX_RATES_MAX_LENGTH_FOR_JURISDICTION =   50
    POST_TAX_RATES_MAX_LENGTH_FOR_STATE        =    2
    POST_TAX_RATES_VALID_VALUES_FOR_TAX_TYPE   = StaticArray["gst", "hst", "jct", "pst", "qst", "rst", "sales_tax", "vat"]

    # @return Crest::Request
    def build_api_request_for_post_tax_rates(*, display_name : String? = nil, inclusive : Bool? = nil, percentage : Float64? = nil, active : Bool? = nil, country : String? = nil, description : String? = nil, expand : Array(String)? = nil, jurisdiction : String? = nil, state : String? = nil, tax_type : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_tax_rates ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"display_name\" is required and cannot be null") if display_name.nil?
        if _display_name = display_name
          OpenApi::PrimitiveValidator.validate_max_length("display_name", display_name.to_s.size, POST_TAX_RATES_MAX_LENGTH_FOR_DISPLAY_NAME)
        end
        raise ArgumentError.new("\"inclusive\" is required and cannot be null") if inclusive.nil?

        raise ArgumentError.new("\"percentage\" is required and cannot be null") if percentage.nil?

        if _country = country
          OpenApi::PrimitiveValidator.validate_max_length("country", country.to_s.size, POST_TAX_RATES_MAX_LENGTH_FOR_COUNTRY)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_TAX_RATES_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _jurisdiction = jurisdiction
          OpenApi::PrimitiveValidator.validate_max_length("jurisdiction", jurisdiction.to_s.size, POST_TAX_RATES_MAX_LENGTH_FOR_JURISDICTION)
        end
        if _state = state
          OpenApi::PrimitiveValidator.validate_max_length("state", state.to_s.size, POST_TAX_RATES_MAX_LENGTH_FOR_STATE)
        end
        if _tax_type = tax_type
          OpenApi::EnumValidator.validate("tax_type", _tax_type, POST_TAX_RATES_VALID_VALUES_FOR_TAX_TYPE)
        end
      end

      # resource path
      local_var_path = "/v1/tax_rates"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["active"] = active.to_s if !active.nil?
      form_params["country"] = country.to_s if !country.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["display_name"] = display_name.to_s if !display_name.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["inclusive"] = inclusive.to_s if !inclusive.nil?
      form_params["jurisdiction"] = jurisdiction.to_s if !jurisdiction.nil?
      form_params["percentage"] = percentage.to_s if !percentage.nil?
      form_params["state"] = state.to_s if !state.nil?
      form_params["tax_type"] = tax_type.to_s if !tax_type.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_tax_rates",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates an existing tax rate.</p>
    # @param tax_rate [String?]
    # @optional @param active [Bool?] Flag determining whether the tax rate is active or inactive (archived). Inactive tax rates cannot be used with new applications or Checkout Sessions, but will still work for subscriptions and invoices that already have it set.
    # @optional @param country [String?] Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
    # @optional @param description [String?] An arbitrary string attached to the tax rate for your internal use only. It will not be visible to your customers.
    # @optional @param display_name [String?] The display name of the tax rate, which will be shown to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param jurisdiction [String?] The jurisdiction for the tax rate. You can use this label field for tax reporting purposes. It also appears on your customer’s invoice.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param state [String?] [ISO 3166-2 subdivision code](https://en.wikipedia.org/wiki/ISO_3166-2:US), without country prefix. For example, \\\"NY\\\" for New York, United States.
    # @optional @param tax_type [String?] The high-level tax type, such as `vat` or `sales_tax`.
    # @return [TaxRate]
    def post_tax_rates_tax_rate(*, tax_rate : String? = nil, active : Bool? = nil, country : String? = nil, description : String? = nil, display_name : String? = nil, expand : Array(String)? = nil, jurisdiction : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, state : String? = nil, tax_type : String? = nil)
      data, _status_code, _headers = post_tax_rates_tax_rate_with_http_info(tax_rate: tax_rate, active: active, country: country, description: description, display_name: display_name, expand: expand, jurisdiction: jurisdiction, metadata: metadata, state: state, tax_type: tax_type)
      data
    end

    # &lt;p&gt;Updates an existing tax rate.&lt;/p&gt;
    # @param tax_rate [String?]
    # @optional @param active [Bool?] Flag determining whether the tax rate is active or inactive (archived). Inactive tax rates cannot be used with new applications or Checkout Sessions, but will still work for subscriptions and invoices that already have it set.
    # @optional @param country [String?] Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
    # @optional @param description [String?] An arbitrary string attached to the tax rate for your internal use only. It will not be visible to your customers.
    # @optional @param display_name [String?] The display name of the tax rate, which will be shown to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param jurisdiction [String?] The jurisdiction for the tax rate. You can use this label field for tax reporting purposes. It also appears on your customer’s invoice.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param state [String?] [ISO 3166-2 subdivision code](https://en.wikipedia.org/wiki/ISO_3166-2:US), without country prefix. For example, \\\"NY\\\" for New York, United States.
    # @optional @param tax_type [String?] The high-level tax type, such as `vat` or `sales_tax`.
    # @return [Array<(TaxRate, Integer, Hash)>] TaxRate data, response status code and response headers
    def post_tax_rates_tax_rate_with_http_info(*, tax_rate : String? = nil, active : Bool? = nil, country : String? = nil, description : String? = nil, display_name : String? = nil, expand : Array(String)? = nil, jurisdiction : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, state : String? = nil, tax_type : String? = nil)
      request = build_api_request_for_post_tax_rates_tax_rate(tax_rate: tax_rate, active: active, country: country, description: description, display_name: display_name, expand: expand, jurisdiction: jurisdiction, metadata: metadata, state: state, tax_type: tax_type)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_tax_rates_tax_rate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TaxRate.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates an existing tax rate.&lt;/p&gt;
    # @param tax_rate [String?]
    # @optional @param active [Bool?] Flag determining whether the tax rate is active or inactive (archived). Inactive tax rates cannot be used with new applications or Checkout Sessions, but will still work for subscriptions and invoices that already have it set.
    # @optional @param country [String?] Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
    # @optional @param description [String?] An arbitrary string attached to the tax rate for your internal use only. It will not be visible to your customers.
    # @optional @param display_name [String?] The display name of the tax rate, which will be shown to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param jurisdiction [String?] The jurisdiction for the tax rate. You can use this label field for tax reporting purposes. It also appears on your customer’s invoice.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param state [String?] [ISO 3166-2 subdivision code](https://en.wikipedia.org/wiki/ISO_3166-2:US), without country prefix. For example, \\\"NY\\\" for New York, United States.
    # @optional @param tax_type [String?] The high-level tax type, such as `vat` or `sales_tax`.
    # @return nil
    def post_tax_rates_tax_rate(*, tax_rate : String? = nil, active : Bool? = nil, country : String? = nil, description : String? = nil, display_name : String? = nil, expand : Array(String)? = nil, jurisdiction : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, state : String? = nil, tax_type : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_tax_rates_tax_rate(tax_rate: tax_rate, active: active, country: country, description: description, display_name: display_name, expand: expand, jurisdiction: jurisdiction, metadata: metadata, state: state, tax_type: tax_type).execute(&block)
    end

    POST_TAX_RATES_TAX_RATE_MAX_LENGTH_FOR_TAX_RATE     = 5000
    POST_TAX_RATES_TAX_RATE_MAX_LENGTH_FOR_COUNTRY      = 5000
    POST_TAX_RATES_TAX_RATE_MAX_LENGTH_FOR_DESCRIPTION  = 5000
    POST_TAX_RATES_TAX_RATE_MAX_LENGTH_FOR_DISPLAY_NAME =   50
    POST_TAX_RATES_TAX_RATE_MAX_LENGTH_FOR_JURISDICTION =   50
    POST_TAX_RATES_TAX_RATE_MAX_LENGTH_FOR_STATE        =    2
    POST_TAX_RATES_TAX_RATE_VALID_VALUES_FOR_TAX_TYPE   = StaticArray["gst", "hst", "jct", "pst", "qst", "rst", "sales_tax", "vat"]

    # @return Crest::Request
    def build_api_request_for_post_tax_rates_tax_rate(*, tax_rate : String? = nil, active : Bool? = nil, country : String? = nil, description : String? = nil, display_name : String? = nil, expand : Array(String)? = nil, jurisdiction : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, state : String? = nil, tax_type : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_tax_rates_tax_rate ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"tax_rate\" is required and cannot be null") if tax_rate.nil?
        if _tax_rate = tax_rate
          OpenApi::PrimitiveValidator.validate_max_length("tax_rate", tax_rate.to_s.size, POST_TAX_RATES_TAX_RATE_MAX_LENGTH_FOR_TAX_RATE)
        end

        if _country = country
          OpenApi::PrimitiveValidator.validate_max_length("country", country.to_s.size, POST_TAX_RATES_TAX_RATE_MAX_LENGTH_FOR_COUNTRY)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_TAX_RATES_TAX_RATE_MAX_LENGTH_FOR_DESCRIPTION)
        end
        if _display_name = display_name
          OpenApi::PrimitiveValidator.validate_max_length("display_name", display_name.to_s.size, POST_TAX_RATES_TAX_RATE_MAX_LENGTH_FOR_DISPLAY_NAME)
        end

        if _jurisdiction = jurisdiction
          OpenApi::PrimitiveValidator.validate_max_length("jurisdiction", jurisdiction.to_s.size, POST_TAX_RATES_TAX_RATE_MAX_LENGTH_FOR_JURISDICTION)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _state = state
          OpenApi::PrimitiveValidator.validate_max_length("state", state.to_s.size, POST_TAX_RATES_TAX_RATE_MAX_LENGTH_FOR_STATE)
        end
        if _tax_type = tax_type
          OpenApi::EnumValidator.validate("tax_type", _tax_type, POST_TAX_RATES_TAX_RATE_VALID_VALUES_FOR_TAX_TYPE)
        end
      end

      # resource path
      local_var_path = "/v1/tax_rates/{tax_rate}".sub("{" + "tax_rate" + "}", URI.encode_path(tax_rate.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["active"] = active.to_s if !active.nil?
      form_params["country"] = country.to_s if !country.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["display_name"] = display_name.to_s if !display_name.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["jurisdiction"] = jurisdiction.to_s if !jurisdiction.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["state"] = state.to_s if !state.nil?
      form_params["tax_type"] = tax_type.to_s if !tax_type.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_tax_rates_tax_rate",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new <code>Configuration</code> object.</p>
    # @optional @param bbpos_wisepos_e [Stripe::BbposWisePose?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param tipping [Stripe::PostTerminalConfigurationsRequestTipping?]
    # @optional @param verifone_p400 [Stripe::VerifoneP400?]
    # @return [TerminalConfiguration]
    def post_terminal_configurations(*, bbpos_wisepos_e : Stripe::BbposWisePose? = nil, expand : Array(String)? = nil, tipping : Stripe::PostTerminalConfigurationsRequestTipping? = nil, verifone_p400 : Stripe::VerifoneP400? = nil)
      data, _status_code, _headers = post_terminal_configurations_with_http_info(bbpos_wisepos_e: bbpos_wisepos_e, expand: expand, tipping: tipping, verifone_p400: verifone_p400)
      data
    end

    # &lt;p&gt;Creates a new &lt;code&gt;Configuration&lt;/code&gt; object.&lt;/p&gt;
    # @optional @param bbpos_wisepos_e [Stripe::BbposWisePose?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param tipping [Stripe::PostTerminalConfigurationsRequestTipping?]
    # @optional @param verifone_p400 [Stripe::VerifoneP400?]
    # @return [Array<(TerminalConfiguration, Integer, Hash)>] TerminalConfiguration data, response status code and response headers
    def post_terminal_configurations_with_http_info(*, bbpos_wisepos_e : Stripe::BbposWisePose? = nil, expand : Array(String)? = nil, tipping : Stripe::PostTerminalConfigurationsRequestTipping? = nil, verifone_p400 : Stripe::VerifoneP400? = nil)
      request = build_api_request_for_post_terminal_configurations(bbpos_wisepos_e: bbpos_wisepos_e, expand: expand, tipping: tipping, verifone_p400: verifone_p400)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_terminal_configurations\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TerminalConfiguration.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new &lt;code&gt;Configuration&lt;/code&gt; object.&lt;/p&gt;
    # @optional @param bbpos_wisepos_e [Stripe::BbposWisePose?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param tipping [Stripe::PostTerminalConfigurationsRequestTipping?]
    # @optional @param verifone_p400 [Stripe::VerifoneP400?]
    # @return nil
    def post_terminal_configurations(*, bbpos_wisepos_e : Stripe::BbposWisePose? = nil, expand : Array(String)? = nil, tipping : Stripe::PostTerminalConfigurationsRequestTipping? = nil, verifone_p400 : Stripe::VerifoneP400? = nil, &block : Crest::Response ->)
      build_api_request_for_post_terminal_configurations(bbpos_wisepos_e: bbpos_wisepos_e, expand: expand, tipping: tipping, verifone_p400: verifone_p400).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_post_terminal_configurations(*, bbpos_wisepos_e : Stripe::BbposWisePose? = nil, expand : Array(String)? = nil, tipping : Stripe::PostTerminalConfigurationsRequestTipping? = nil, verifone_p400 : Stripe::VerifoneP400? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_terminal_configurations ..." }
      end

      if client_side_validation
        if _bbpos_wisepos_e = bbpos_wisepos_e
          _bbpos_wisepos_e.validate if _bbpos_wisepos_e.is_a?(OpenApi::Validatable)
        end

        if _tipping = tipping
          _tipping.validate if _tipping.is_a?(OpenApi::Validatable)
        end
        if _verifone_p400 = verifone_p400
          _verifone_p400.validate if _verifone_p400.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/terminal/configurations"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["bbpos_wisepos_e"] = bbpos_wisepos_e.to_s if !bbpos_wisepos_e.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["tipping"] = tipping.to_s if !tipping.nil?
      form_params["verifone_p400"] = verifone_p400.to_s if !verifone_p400.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_terminal_configurations",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates a new <code>Configuration</code> object.</p>
    # @param configuration [String?]
    # @optional @param bbpos_wisepos_e [Stripe::PostTerminalConfigurationsConfigurationRequestBbposWiseposE?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param tipping [Stripe::PostTerminalConfigurationsRequestTipping?]
    # @optional @param verifone_p400 [Stripe::PostTerminalConfigurationsConfigurationRequestVerifoneP400?]
    # @return [GetTerminalConfigurationsConfiguration200Response]
    def post_terminal_configurations_configuration(*, configuration : String? = nil, bbpos_wisepos_e : Stripe::PostTerminalConfigurationsConfigurationRequestBbposWiseposE? = nil, expand : Array(String)? = nil, tipping : Stripe::PostTerminalConfigurationsRequestTipping? = nil, verifone_p400 : Stripe::PostTerminalConfigurationsConfigurationRequestVerifoneP400? = nil)
      data, _status_code, _headers = post_terminal_configurations_configuration_with_http_info(configuration: configuration, bbpos_wisepos_e: bbpos_wisepos_e, expand: expand, tipping: tipping, verifone_p400: verifone_p400)
      data
    end

    # &lt;p&gt;Updates a new &lt;code&gt;Configuration&lt;/code&gt; object.&lt;/p&gt;
    # @param configuration [String?]
    # @optional @param bbpos_wisepos_e [Stripe::PostTerminalConfigurationsConfigurationRequestBbposWiseposE?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param tipping [Stripe::PostTerminalConfigurationsRequestTipping?]
    # @optional @param verifone_p400 [Stripe::PostTerminalConfigurationsConfigurationRequestVerifoneP400?]
    # @return [Array<(GetTerminalConfigurationsConfiguration200Response, Integer, Hash)>] GetTerminalConfigurationsConfiguration200Response data, response status code and response headers
    def post_terminal_configurations_configuration_with_http_info(*, configuration : String? = nil, bbpos_wisepos_e : Stripe::PostTerminalConfigurationsConfigurationRequestBbposWiseposE? = nil, expand : Array(String)? = nil, tipping : Stripe::PostTerminalConfigurationsRequestTipping? = nil, verifone_p400 : Stripe::PostTerminalConfigurationsConfigurationRequestVerifoneP400? = nil)
      request = build_api_request_for_post_terminal_configurations_configuration(configuration: configuration, bbpos_wisepos_e: bbpos_wisepos_e, expand: expand, tipping: tipping, verifone_p400: verifone_p400)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_terminal_configurations_configuration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return GetTerminalConfigurationsConfiguration200Response.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates a new &lt;code&gt;Configuration&lt;/code&gt; object.&lt;/p&gt;
    # @param configuration [String?]
    # @optional @param bbpos_wisepos_e [Stripe::PostTerminalConfigurationsConfigurationRequestBbposWiseposE?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param tipping [Stripe::PostTerminalConfigurationsRequestTipping?]
    # @optional @param verifone_p400 [Stripe::PostTerminalConfigurationsConfigurationRequestVerifoneP400?]
    # @return nil
    def post_terminal_configurations_configuration(*, configuration : String? = nil, bbpos_wisepos_e : Stripe::PostTerminalConfigurationsConfigurationRequestBbposWiseposE? = nil, expand : Array(String)? = nil, tipping : Stripe::PostTerminalConfigurationsRequestTipping? = nil, verifone_p400 : Stripe::PostTerminalConfigurationsConfigurationRequestVerifoneP400? = nil, &block : Crest::Response ->)
      build_api_request_for_post_terminal_configurations_configuration(configuration: configuration, bbpos_wisepos_e: bbpos_wisepos_e, expand: expand, tipping: tipping, verifone_p400: verifone_p400).execute(&block)
    end

    POST_TERMINAL_CONFIGURATIONS_CONFIGURATION_MAX_LENGTH_FOR_CONFIGURATION = 5000

    # @return Crest::Request
    def build_api_request_for_post_terminal_configurations_configuration(*, configuration : String? = nil, bbpos_wisepos_e : Stripe::PostTerminalConfigurationsConfigurationRequestBbposWiseposE? = nil, expand : Array(String)? = nil, tipping : Stripe::PostTerminalConfigurationsRequestTipping? = nil, verifone_p400 : Stripe::PostTerminalConfigurationsConfigurationRequestVerifoneP400? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_terminal_configurations_configuration ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"configuration\" is required and cannot be null") if configuration.nil?
        if _configuration = configuration
          OpenApi::PrimitiveValidator.validate_max_length("configuration", configuration.to_s.size, POST_TERMINAL_CONFIGURATIONS_CONFIGURATION_MAX_LENGTH_FOR_CONFIGURATION)
        end
        if _bbpos_wisepos_e = bbpos_wisepos_e
          _bbpos_wisepos_e.validate if _bbpos_wisepos_e.is_a?(OpenApi::Validatable)
        end

        if _tipping = tipping
          _tipping.validate if _tipping.is_a?(OpenApi::Validatable)
        end
        if _verifone_p400 = verifone_p400
          _verifone_p400.validate if _verifone_p400.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/terminal/configurations/{configuration}".sub("{" + "configuration" + "}", URI.encode_path(configuration.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["bbpos_wisepos_e"] = bbpos_wisepos_e.to_s if !bbpos_wisepos_e.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["tipping"] = tipping.to_s if !tipping.nil?
      form_params["verifone_p400"] = verifone_p400.to_s if !verifone_p400.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_terminal_configurations_configuration",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>To connect to a reader the Stripe Terminal SDK needs to retrieve a short-lived connection token from Stripe, proxied through your server. On your backend, add an endpoint that creates and returns a connection token.</p>
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param location [String?] The id of the location that this connection token is scoped to. If specified the connection token will only be usable with readers assigned to that location, otherwise the connection token will be usable with all readers. Note that location scoping only applies to internet-connected readers. For more details, see [the docs on scoping connection tokens](https://stripe.com/docs/terminal/fleet/locations#connection-tokens).
    # @return [TerminalConnectionToken]
    def post_terminal_connection_tokens(*, expand : Array(String)? = nil, location : String? = nil)
      data, _status_code, _headers = post_terminal_connection_tokens_with_http_info(expand: expand, location: location)
      data
    end

    # &lt;p&gt;To connect to a reader the Stripe Terminal SDK needs to retrieve a short-lived connection token from Stripe, proxied through your server. On your backend, add an endpoint that creates and returns a connection token.&lt;/p&gt;
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param location [String?] The id of the location that this connection token is scoped to. If specified the connection token will only be usable with readers assigned to that location, otherwise the connection token will be usable with all readers. Note that location scoping only applies to internet-connected readers. For more details, see [the docs on scoping connection tokens](https://stripe.com/docs/terminal/fleet/locations#connection-tokens).
    # @return [Array<(TerminalConnectionToken, Integer, Hash)>] TerminalConnectionToken data, response status code and response headers
    def post_terminal_connection_tokens_with_http_info(*, expand : Array(String)? = nil, location : String? = nil)
      request = build_api_request_for_post_terminal_connection_tokens(expand: expand, location: location)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_terminal_connection_tokens\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TerminalConnectionToken.from_json(data), status_code, headers
    end

    # &lt;p&gt;To connect to a reader the Stripe Terminal SDK needs to retrieve a short-lived connection token from Stripe, proxied through your server. On your backend, add an endpoint that creates and returns a connection token.&lt;/p&gt;
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param location [String?] The id of the location that this connection token is scoped to. If specified the connection token will only be usable with readers assigned to that location, otherwise the connection token will be usable with all readers. Note that location scoping only applies to internet-connected readers. For more details, see [the docs on scoping connection tokens](https://stripe.com/docs/terminal/fleet/locations#connection-tokens).
    # @return nil
    def post_terminal_connection_tokens(*, expand : Array(String)? = nil, location : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_terminal_connection_tokens(expand: expand, location: location).execute(&block)
    end

    POST_TERMINAL_CONNECTION_TOKENS_MAX_LENGTH_FOR_LOCATION = 5000

    # @return Crest::Request
    def build_api_request_for_post_terminal_connection_tokens(*, expand : Array(String)? = nil, location : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_terminal_connection_tokens ..." }
      end

      if client_side_validation
        if _location = location
          OpenApi::PrimitiveValidator.validate_max_length("location", location.to_s.size, POST_TERMINAL_CONNECTION_TOKENS_MAX_LENGTH_FOR_LOCATION)
        end
      end

      # resource path
      local_var_path = "/v1/terminal/connection_tokens"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["location"] = location.to_s if !location.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_terminal_connection_tokens",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new <code>Location</code> object. For further details, including which address fields are required in each country, see the <a href=\"/docs/terminal/fleet/locations\">Manage locations</a> guide.</p>
    # @param address [Stripe::CreateLocationAddressParam?]
    # @param display_name [String?] A name for the location.
    # @optional @param configuration_overrides [String?] The ID of a configuration that will be used to customize all readers in this location.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [TerminalLocation]
    def post_terminal_locations(*, address : Stripe::CreateLocationAddressParam? = nil, display_name : String? = nil, configuration_overrides : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_terminal_locations_with_http_info(address: address, display_name: display_name, configuration_overrides: configuration_overrides, expand: expand, metadata: metadata)
      data
    end

    # &lt;p&gt;Creates a new &lt;code&gt;Location&lt;/code&gt; object. For further details, including which address fields are required in each country, see the &lt;a href&#x3D;\&quot;/docs/terminal/fleet/locations\&quot;&gt;Manage locations&lt;/a&gt; guide.&lt;/p&gt;
    # @param address [Stripe::CreateLocationAddressParam?]
    # @param display_name [String?] A name for the location.
    # @optional @param configuration_overrides [String?] The ID of a configuration that will be used to customize all readers in this location.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(TerminalLocation, Integer, Hash)>] TerminalLocation data, response status code and response headers
    def post_terminal_locations_with_http_info(*, address : Stripe::CreateLocationAddressParam? = nil, display_name : String? = nil, configuration_overrides : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_terminal_locations(address: address, display_name: display_name, configuration_overrides: configuration_overrides, expand: expand, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_terminal_locations\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TerminalLocation.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new &lt;code&gt;Location&lt;/code&gt; object. For further details, including which address fields are required in each country, see the &lt;a href&#x3D;\&quot;/docs/terminal/fleet/locations\&quot;&gt;Manage locations&lt;/a&gt; guide.&lt;/p&gt;
    # @param address [Stripe::CreateLocationAddressParam?]
    # @param display_name [String?] A name for the location.
    # @optional @param configuration_overrides [String?] The ID of a configuration that will be used to customize all readers in this location.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_terminal_locations(*, address : Stripe::CreateLocationAddressParam? = nil, display_name : String? = nil, configuration_overrides : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_terminal_locations(address: address, display_name: display_name, configuration_overrides: configuration_overrides, expand: expand, metadata: metadata).execute(&block)
    end

    POST_TERMINAL_LOCATIONS_MAX_LENGTH_FOR_DISPLAY_NAME            = 1000
    POST_TERMINAL_LOCATIONS_MAX_LENGTH_FOR_CONFIGURATION_OVERRIDES = 1000

    # @return Crest::Request
    def build_api_request_for_post_terminal_locations(*, address : Stripe::CreateLocationAddressParam? = nil, display_name : String? = nil, configuration_overrides : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_terminal_locations ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"address\" is required and cannot be null") if address.nil?
        if _address = address
          _address.validate if _address.is_a?(OpenApi::Validatable)
        end
        raise ArgumentError.new("\"display_name\" is required and cannot be null") if display_name.nil?
        if _display_name = display_name
          OpenApi::PrimitiveValidator.validate_max_length("display_name", display_name.to_s.size, POST_TERMINAL_LOCATIONS_MAX_LENGTH_FOR_DISPLAY_NAME)
        end
        if _configuration_overrides = configuration_overrides
          OpenApi::PrimitiveValidator.validate_max_length("configuration_overrides", configuration_overrides.to_s.size, POST_TERMINAL_LOCATIONS_MAX_LENGTH_FOR_CONFIGURATION_OVERRIDES)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/terminal/locations"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["address"] = address.to_s if !address.nil?
      form_params["configuration_overrides"] = configuration_overrides.to_s if !configuration_overrides.nil?
      form_params["display_name"] = display_name.to_s if !display_name.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_terminal_locations",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates a <code>Location</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
    # @param location [String?]
    # @optional @param address [Stripe::OptionalFieldsAddress1?]
    # @optional @param configuration_overrides [String?] The ID of a configuration that will be used to customize all readers in this location.
    # @optional @param display_name [String?] A name for the location.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [GetTerminalLocationsLocation200Response]
    def post_terminal_locations_location(*, location : String? = nil, address : Stripe::OptionalFieldsAddress1? = nil, configuration_overrides : String? = nil, display_name : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_terminal_locations_location_with_http_info(location: location, address: address, configuration_overrides: configuration_overrides, display_name: display_name, expand: expand, metadata: metadata)
      data
    end

    # &lt;p&gt;Updates a &lt;code&gt;Location&lt;/code&gt; object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;
    # @param location [String?]
    # @optional @param address [Stripe::OptionalFieldsAddress1?]
    # @optional @param configuration_overrides [String?] The ID of a configuration that will be used to customize all readers in this location.
    # @optional @param display_name [String?] A name for the location.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(GetTerminalLocationsLocation200Response, Integer, Hash)>] GetTerminalLocationsLocation200Response data, response status code and response headers
    def post_terminal_locations_location_with_http_info(*, location : String? = nil, address : Stripe::OptionalFieldsAddress1? = nil, configuration_overrides : String? = nil, display_name : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_terminal_locations_location(location: location, address: address, configuration_overrides: configuration_overrides, display_name: display_name, expand: expand, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_terminal_locations_location\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return GetTerminalLocationsLocation200Response.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates a &lt;code&gt;Location&lt;/code&gt; object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;
    # @param location [String?]
    # @optional @param address [Stripe::OptionalFieldsAddress1?]
    # @optional @param configuration_overrides [String?] The ID of a configuration that will be used to customize all readers in this location.
    # @optional @param display_name [String?] A name for the location.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_terminal_locations_location(*, location : String? = nil, address : Stripe::OptionalFieldsAddress1? = nil, configuration_overrides : String? = nil, display_name : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_terminal_locations_location(location: location, address: address, configuration_overrides: configuration_overrides, display_name: display_name, expand: expand, metadata: metadata).execute(&block)
    end

    POST_TERMINAL_LOCATIONS_LOCATION_MAX_LENGTH_FOR_LOCATION                = 5000
    POST_TERMINAL_LOCATIONS_LOCATION_MAX_LENGTH_FOR_CONFIGURATION_OVERRIDES = 1000
    POST_TERMINAL_LOCATIONS_LOCATION_MAX_LENGTH_FOR_DISPLAY_NAME            = 1000

    # @return Crest::Request
    def build_api_request_for_post_terminal_locations_location(*, location : String? = nil, address : Stripe::OptionalFieldsAddress1? = nil, configuration_overrides : String? = nil, display_name : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_terminal_locations_location ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"location\" is required and cannot be null") if location.nil?
        if _location = location
          OpenApi::PrimitiveValidator.validate_max_length("location", location.to_s.size, POST_TERMINAL_LOCATIONS_LOCATION_MAX_LENGTH_FOR_LOCATION)
        end
        if _address = address
          _address.validate if _address.is_a?(OpenApi::Validatable)
        end
        if _configuration_overrides = configuration_overrides
          OpenApi::PrimitiveValidator.validate_max_length("configuration_overrides", configuration_overrides.to_s.size, POST_TERMINAL_LOCATIONS_LOCATION_MAX_LENGTH_FOR_CONFIGURATION_OVERRIDES)
        end
        if _display_name = display_name
          OpenApi::PrimitiveValidator.validate_max_length("display_name", display_name.to_s.size, POST_TERMINAL_LOCATIONS_LOCATION_MAX_LENGTH_FOR_DISPLAY_NAME)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/terminal/locations/{location}".sub("{" + "location" + "}", URI.encode_path(location.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["address"] = address.to_s if !address.nil?
      form_params["configuration_overrides"] = configuration_overrides.to_s if !configuration_overrides.nil?
      form_params["display_name"] = display_name.to_s if !display_name.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_terminal_locations_location",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new <code>Reader</code> object.</p>
    # @param registration_code [String?] A code generated by the reader used for registering to an account.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param label [String?] Custom label given to the reader for easier identification. If no label is specified, the registration code will be used.
    # @optional @param location [String?] The location to assign the reader to.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [TerminalReader]
    def post_terminal_readers(*, registration_code : String? = nil, expand : Array(String)? = nil, label : String? = nil, location : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_terminal_readers_with_http_info(registration_code: registration_code, expand: expand, label: label, location: location, metadata: metadata)
      data
    end

    # &lt;p&gt;Creates a new &lt;code&gt;Reader&lt;/code&gt; object.&lt;/p&gt;
    # @param registration_code [String?] A code generated by the reader used for registering to an account.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param label [String?] Custom label given to the reader for easier identification. If no label is specified, the registration code will be used.
    # @optional @param location [String?] The location to assign the reader to.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(TerminalReader, Integer, Hash)>] TerminalReader data, response status code and response headers
    def post_terminal_readers_with_http_info(*, registration_code : String? = nil, expand : Array(String)? = nil, label : String? = nil, location : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_terminal_readers(registration_code: registration_code, expand: expand, label: label, location: location, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_terminal_readers\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TerminalReader.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new &lt;code&gt;Reader&lt;/code&gt; object.&lt;/p&gt;
    # @param registration_code [String?] A code generated by the reader used for registering to an account.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param label [String?] Custom label given to the reader for easier identification. If no label is specified, the registration code will be used.
    # @optional @param location [String?] The location to assign the reader to.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_terminal_readers(*, registration_code : String? = nil, expand : Array(String)? = nil, label : String? = nil, location : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_terminal_readers(registration_code: registration_code, expand: expand, label: label, location: location, metadata: metadata).execute(&block)
    end

    POST_TERMINAL_READERS_MAX_LENGTH_FOR_REGISTRATION_CODE = 5000
    POST_TERMINAL_READERS_MAX_LENGTH_FOR_LABEL             = 5000
    POST_TERMINAL_READERS_MAX_LENGTH_FOR_LOCATION          = 5000

    # @return Crest::Request
    def build_api_request_for_post_terminal_readers(*, registration_code : String? = nil, expand : Array(String)? = nil, label : String? = nil, location : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_terminal_readers ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"registration_code\" is required and cannot be null") if registration_code.nil?
        if _registration_code = registration_code
          OpenApi::PrimitiveValidator.validate_max_length("registration_code", registration_code.to_s.size, POST_TERMINAL_READERS_MAX_LENGTH_FOR_REGISTRATION_CODE)
        end

        if _label = label
          OpenApi::PrimitiveValidator.validate_max_length("label", label.to_s.size, POST_TERMINAL_READERS_MAX_LENGTH_FOR_LABEL)
        end
        if _location = location
          OpenApi::PrimitiveValidator.validate_max_length("location", location.to_s.size, POST_TERMINAL_READERS_MAX_LENGTH_FOR_LOCATION)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/terminal/readers"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["label"] = label.to_s if !label.nil?
      form_params["location"] = location.to_s if !location.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["registration_code"] = registration_code.to_s if !registration_code.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_terminal_readers",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates a <code>Reader</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
    # @param reader [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param label [String?] The new label of the reader.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [GetTerminalReadersReader200Response]
    def post_terminal_readers_reader(*, reader : String? = nil, expand : Array(String)? = nil, label : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_terminal_readers_reader_with_http_info(reader: reader, expand: expand, label: label, metadata: metadata)
      data
    end

    # &lt;p&gt;Updates a &lt;code&gt;Reader&lt;/code&gt; object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;
    # @param reader [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param label [String?] The new label of the reader.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(GetTerminalReadersReader200Response, Integer, Hash)>] GetTerminalReadersReader200Response data, response status code and response headers
    def post_terminal_readers_reader_with_http_info(*, reader : String? = nil, expand : Array(String)? = nil, label : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_terminal_readers_reader(reader: reader, expand: expand, label: label, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_terminal_readers_reader\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return GetTerminalReadersReader200Response.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates a &lt;code&gt;Reader&lt;/code&gt; object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;
    # @param reader [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param label [String?] The new label of the reader.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_terminal_readers_reader(*, reader : String? = nil, expand : Array(String)? = nil, label : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_terminal_readers_reader(reader: reader, expand: expand, label: label, metadata: metadata).execute(&block)
    end

    POST_TERMINAL_READERS_READER_MAX_LENGTH_FOR_READER = 5000
    POST_TERMINAL_READERS_READER_MAX_LENGTH_FOR_LABEL  = 5000

    # @return Crest::Request
    def build_api_request_for_post_terminal_readers_reader(*, reader : String? = nil, expand : Array(String)? = nil, label : String? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_terminal_readers_reader ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"reader\" is required and cannot be null") if reader.nil?
        if _reader = reader
          OpenApi::PrimitiveValidator.validate_max_length("reader", reader.to_s.size, POST_TERMINAL_READERS_READER_MAX_LENGTH_FOR_READER)
        end

        if _label = label
          OpenApi::PrimitiveValidator.validate_max_length("label", label.to_s.size, POST_TERMINAL_READERS_READER_MAX_LENGTH_FOR_LABEL)
        end
        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/terminal/readers/{reader}".sub("{" + "reader" + "}", URI.encode_path(reader.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["label"] = label.to_s if !label.nil?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_terminal_readers_reader",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Cancels the current reader action.</p>
    # @param reader [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [TerminalReader]
    def post_terminal_readers_reader_cancel_action(*, reader : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_terminal_readers_reader_cancel_action_with_http_info(reader: reader, expand: expand)
      data
    end

    # &lt;p&gt;Cancels the current reader action.&lt;/p&gt;
    # @param reader [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(TerminalReader, Integer, Hash)>] TerminalReader data, response status code and response headers
    def post_terminal_readers_reader_cancel_action_with_http_info(*, reader : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_terminal_readers_reader_cancel_action(reader: reader, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_terminal_readers_reader_cancel_action\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TerminalReader.from_json(data), status_code, headers
    end

    # &lt;p&gt;Cancels the current reader action.&lt;/p&gt;
    # @param reader [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_terminal_readers_reader_cancel_action(*, reader : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_terminal_readers_reader_cancel_action(reader: reader, expand: expand).execute(&block)
    end

    POST_TERMINAL_READERS_READER_CANCEL_ACTION_MAX_LENGTH_FOR_READER = 5000

    # @return Crest::Request
    def build_api_request_for_post_terminal_readers_reader_cancel_action(*, reader : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_terminal_readers_reader_cancel_action ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"reader\" is required and cannot be null") if reader.nil?
        if _reader = reader
          OpenApi::PrimitiveValidator.validate_max_length("reader", reader.to_s.size, POST_TERMINAL_READERS_READER_CANCEL_ACTION_MAX_LENGTH_FOR_READER)
        end
      end

      # resource path
      local_var_path = "/v1/terminal/readers/{reader}/cancel_action".sub("{" + "reader" + "}", URI.encode_path(reader.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_terminal_readers_reader_cancel_action",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Initiates a payment flow on a Reader.</p>
    # @param reader [String?]
    # @param payment_intent [String?] PaymentIntent ID
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param process_config [Stripe::ProcessConfig?]
    # @return [TerminalReader]
    def post_terminal_readers_reader_process_payment_intent(*, reader : String? = nil, payment_intent : String? = nil, expand : Array(String)? = nil, process_config : Stripe::ProcessConfig? = nil)
      data, _status_code, _headers = post_terminal_readers_reader_process_payment_intent_with_http_info(reader: reader, payment_intent: payment_intent, expand: expand, process_config: process_config)
      data
    end

    # &lt;p&gt;Initiates a payment flow on a Reader.&lt;/p&gt;
    # @param reader [String?]
    # @param payment_intent [String?] PaymentIntent ID
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param process_config [Stripe::ProcessConfig?]
    # @return [Array<(TerminalReader, Integer, Hash)>] TerminalReader data, response status code and response headers
    def post_terminal_readers_reader_process_payment_intent_with_http_info(*, reader : String? = nil, payment_intent : String? = nil, expand : Array(String)? = nil, process_config : Stripe::ProcessConfig? = nil)
      request = build_api_request_for_post_terminal_readers_reader_process_payment_intent(reader: reader, payment_intent: payment_intent, expand: expand, process_config: process_config)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_terminal_readers_reader_process_payment_intent\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TerminalReader.from_json(data), status_code, headers
    end

    # &lt;p&gt;Initiates a payment flow on a Reader.&lt;/p&gt;
    # @param reader [String?]
    # @param payment_intent [String?] PaymentIntent ID
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param process_config [Stripe::ProcessConfig?]
    # @return nil
    def post_terminal_readers_reader_process_payment_intent(*, reader : String? = nil, payment_intent : String? = nil, expand : Array(String)? = nil, process_config : Stripe::ProcessConfig? = nil, &block : Crest::Response ->)
      build_api_request_for_post_terminal_readers_reader_process_payment_intent(reader: reader, payment_intent: payment_intent, expand: expand, process_config: process_config).execute(&block)
    end

    POST_TERMINAL_READERS_READER_PROCESS_PAYMENT_INTENT_MAX_LENGTH_FOR_READER         = 5000
    POST_TERMINAL_READERS_READER_PROCESS_PAYMENT_INTENT_MAX_LENGTH_FOR_PAYMENT_INTENT = 5000

    # @return Crest::Request
    def build_api_request_for_post_terminal_readers_reader_process_payment_intent(*, reader : String? = nil, payment_intent : String? = nil, expand : Array(String)? = nil, process_config : Stripe::ProcessConfig? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_terminal_readers_reader_process_payment_intent ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"reader\" is required and cannot be null") if reader.nil?
        if _reader = reader
          OpenApi::PrimitiveValidator.validate_max_length("reader", reader.to_s.size, POST_TERMINAL_READERS_READER_PROCESS_PAYMENT_INTENT_MAX_LENGTH_FOR_READER)
        end
        raise ArgumentError.new("\"payment_intent\" is required and cannot be null") if payment_intent.nil?
        if _payment_intent = payment_intent
          OpenApi::PrimitiveValidator.validate_max_length("payment_intent", payment_intent.to_s.size, POST_TERMINAL_READERS_READER_PROCESS_PAYMENT_INTENT_MAX_LENGTH_FOR_PAYMENT_INTENT)
        end

        if _process_config = process_config
          _process_config.validate if _process_config.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/terminal/readers/{reader}/process_payment_intent".sub("{" + "reader" + "}", URI.encode_path(reader.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["payment_intent"] = payment_intent.to_s if !payment_intent.nil?
      form_params["process_config"] = process_config.to_s if !process_config.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_terminal_readers_reader_process_payment_intent",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Initiates a setup intent flow on a Reader.</p>
    # @param reader [String?]
    # @param customer_consent_collected [Bool?] Customer Consent Collected
    # @param setup_intent [String?] SetupIntent ID
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [TerminalReader]
    def post_terminal_readers_reader_process_setup_intent(*, reader : String? = nil, customer_consent_collected : Bool? = nil, setup_intent : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_terminal_readers_reader_process_setup_intent_with_http_info(reader: reader, customer_consent_collected: customer_consent_collected, setup_intent: setup_intent, expand: expand)
      data
    end

    # &lt;p&gt;Initiates a setup intent flow on a Reader.&lt;/p&gt;
    # @param reader [String?]
    # @param customer_consent_collected [Bool?] Customer Consent Collected
    # @param setup_intent [String?] SetupIntent ID
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(TerminalReader, Integer, Hash)>] TerminalReader data, response status code and response headers
    def post_terminal_readers_reader_process_setup_intent_with_http_info(*, reader : String? = nil, customer_consent_collected : Bool? = nil, setup_intent : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_terminal_readers_reader_process_setup_intent(reader: reader, customer_consent_collected: customer_consent_collected, setup_intent: setup_intent, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_terminal_readers_reader_process_setup_intent\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TerminalReader.from_json(data), status_code, headers
    end

    # &lt;p&gt;Initiates a setup intent flow on a Reader.&lt;/p&gt;
    # @param reader [String?]
    # @param customer_consent_collected [Bool?] Customer Consent Collected
    # @param setup_intent [String?] SetupIntent ID
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_terminal_readers_reader_process_setup_intent(*, reader : String? = nil, customer_consent_collected : Bool? = nil, setup_intent : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_terminal_readers_reader_process_setup_intent(reader: reader, customer_consent_collected: customer_consent_collected, setup_intent: setup_intent, expand: expand).execute(&block)
    end

    POST_TERMINAL_READERS_READER_PROCESS_SETUP_INTENT_MAX_LENGTH_FOR_READER       = 5000
    POST_TERMINAL_READERS_READER_PROCESS_SETUP_INTENT_MAX_LENGTH_FOR_SETUP_INTENT = 5000

    # @return Crest::Request
    def build_api_request_for_post_terminal_readers_reader_process_setup_intent(*, reader : String? = nil, customer_consent_collected : Bool? = nil, setup_intent : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_terminal_readers_reader_process_setup_intent ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"reader\" is required and cannot be null") if reader.nil?
        if _reader = reader
          OpenApi::PrimitiveValidator.validate_max_length("reader", reader.to_s.size, POST_TERMINAL_READERS_READER_PROCESS_SETUP_INTENT_MAX_LENGTH_FOR_READER)
        end
        raise ArgumentError.new("\"customer_consent_collected\" is required and cannot be null") if customer_consent_collected.nil?

        raise ArgumentError.new("\"setup_intent\" is required and cannot be null") if setup_intent.nil?
        if _setup_intent = setup_intent
          OpenApi::PrimitiveValidator.validate_max_length("setup_intent", setup_intent.to_s.size, POST_TERMINAL_READERS_READER_PROCESS_SETUP_INTENT_MAX_LENGTH_FOR_SETUP_INTENT)
        end
      end

      # resource path
      local_var_path = "/v1/terminal/readers/{reader}/process_setup_intent".sub("{" + "reader" + "}", URI.encode_path(reader.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["customer_consent_collected"] = customer_consent_collected.to_s if !customer_consent_collected.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["setup_intent"] = setup_intent.to_s if !setup_intent.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_terminal_readers_reader_process_setup_intent",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Sets reader display to show cart details.</p>
    # @param reader [String?]
    # @param _type [String?] Type
    # @optional @param cart [Stripe::Cart?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [TerminalReader]
    def post_terminal_readers_reader_set_reader_display(*, reader : String? = nil, _type : String? = nil, cart : Stripe::Cart? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_terminal_readers_reader_set_reader_display_with_http_info(reader: reader, _type: _type, cart: cart, expand: expand)
      data
    end

    # &lt;p&gt;Sets reader display to show cart details.&lt;/p&gt;
    # @param reader [String?]
    # @param _type [String?] Type
    # @optional @param cart [Stripe::Cart?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(TerminalReader, Integer, Hash)>] TerminalReader data, response status code and response headers
    def post_terminal_readers_reader_set_reader_display_with_http_info(*, reader : String? = nil, _type : String? = nil, cart : Stripe::Cart? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_terminal_readers_reader_set_reader_display(reader: reader, _type: _type, cart: cart, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_terminal_readers_reader_set_reader_display\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TerminalReader.from_json(data), status_code, headers
    end

    # &lt;p&gt;Sets reader display to show cart details.&lt;/p&gt;
    # @param reader [String?]
    # @param _type [String?] Type
    # @optional @param cart [Stripe::Cart?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_terminal_readers_reader_set_reader_display(*, reader : String? = nil, _type : String? = nil, cart : Stripe::Cart? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_terminal_readers_reader_set_reader_display(reader: reader, _type: _type, cart: cart, expand: expand).execute(&block)
    end

    POST_TERMINAL_READERS_READER_SET_READER_DISPLAY_MAX_LENGTH_FOR_READER  = 5000
    POST_TERMINAL_READERS_READER_SET_READER_DISPLAY_VALID_VALUES_FOR__TYPE = StaticArray["cart"]

    # @return Crest::Request
    def build_api_request_for_post_terminal_readers_reader_set_reader_display(*, reader : String? = nil, _type : String? = nil, cart : Stripe::Cart? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_terminal_readers_reader_set_reader_display ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"reader\" is required and cannot be null") if reader.nil?
        if _reader = reader
          OpenApi::PrimitiveValidator.validate_max_length("reader", reader.to_s.size, POST_TERMINAL_READERS_READER_SET_READER_DISPLAY_MAX_LENGTH_FOR_READER)
        end
        raise ArgumentError.new("\"_type\" is required and cannot be null") if _type.nil?
        if __type = _type
          OpenApi::EnumValidator.validate("_type", __type, POST_TERMINAL_READERS_READER_SET_READER_DISPLAY_VALID_VALUES_FOR__TYPE)
        end
        if _cart = cart
          _cart.validate if _cart.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/terminal/readers/{reader}/set_reader_display".sub("{" + "reader" + "}", URI.encode_path(reader.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["cart"] = cart.to_s if !cart.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["type"] = _type.to_s if !_type.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_terminal_readers_reader_set_reader_display",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Create an incoming testmode bank transfer</p>
    # @param customer [String?]
    # @param amount [Int64?] Amount to be used for this test cash balance transaction. A positive integer representing how much to fund in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to fund $1.00 or 100 to fund ¥100, a zero-decimal currency).
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param reference [String?] A description of the test funding. This simulates free-text references supplied by customers when making bank transfers to their cash balance. You can use this to test how Stripe's [reconciliation algorithm](https://stripe.com/docs/payments/customer-balance/reconciliation) applies to different user inputs.
    # @return [CustomerCashBalanceTransaction]
    def post_test_helpers_customers_customer_fund_cash_balance(*, customer : String? = nil, amount : Int64? = nil, currency : String? = nil, expand : Array(String)? = nil, reference : String? = nil)
      data, _status_code, _headers = post_test_helpers_customers_customer_fund_cash_balance_with_http_info(customer: customer, amount: amount, currency: currency, expand: expand, reference: reference)
      data
    end

    # &lt;p&gt;Create an incoming testmode bank transfer&lt;/p&gt;
    # @param customer [String?]
    # @param amount [Int64?] Amount to be used for this test cash balance transaction. A positive integer representing how much to fund in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to fund $1.00 or 100 to fund ¥100, a zero-decimal currency).
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param reference [String?] A description of the test funding. This simulates free-text references supplied by customers when making bank transfers to their cash balance. You can use this to test how Stripe's [reconciliation algorithm](https://stripe.com/docs/payments/customer-balance/reconciliation) applies to different user inputs.
    # @return [Array<(CustomerCashBalanceTransaction, Integer, Hash)>] CustomerCashBalanceTransaction data, response status code and response headers
    def post_test_helpers_customers_customer_fund_cash_balance_with_http_info(*, customer : String? = nil, amount : Int64? = nil, currency : String? = nil, expand : Array(String)? = nil, reference : String? = nil)
      request = build_api_request_for_post_test_helpers_customers_customer_fund_cash_balance(customer: customer, amount: amount, currency: currency, expand: expand, reference: reference)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_test_helpers_customers_customer_fund_cash_balance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return CustomerCashBalanceTransaction.from_json(data), status_code, headers
    end

    # &lt;p&gt;Create an incoming testmode bank transfer&lt;/p&gt;
    # @param customer [String?]
    # @param amount [Int64?] Amount to be used for this test cash balance transaction. A positive integer representing how much to fund in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to fund $1.00 or 100 to fund ¥100, a zero-decimal currency).
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param reference [String?] A description of the test funding. This simulates free-text references supplied by customers when making bank transfers to their cash balance. You can use this to test how Stripe's [reconciliation algorithm](https://stripe.com/docs/payments/customer-balance/reconciliation) applies to different user inputs.
    # @return nil
    def post_test_helpers_customers_customer_fund_cash_balance(*, customer : String? = nil, amount : Int64? = nil, currency : String? = nil, expand : Array(String)? = nil, reference : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_test_helpers_customers_customer_fund_cash_balance(customer: customer, amount: amount, currency: currency, expand: expand, reference: reference).execute(&block)
    end

    POST_TEST_HELPERS_CUSTOMERS_CUSTOMER_FUND_CASH_BALANCE_MAX_LENGTH_FOR_CUSTOMER  = 5000
    POST_TEST_HELPERS_CUSTOMERS_CUSTOMER_FUND_CASH_BALANCE_MAX_LENGTH_FOR_REFERENCE = 5000

    # @return Crest::Request
    def build_api_request_for_post_test_helpers_customers_customer_fund_cash_balance(*, customer : String? = nil, amount : Int64? = nil, currency : String? = nil, expand : Array(String)? = nil, reference : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_test_helpers_customers_customer_fund_cash_balance ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"customer\" is required and cannot be null") if customer.nil?
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_TEST_HELPERS_CUSTOMERS_CUSTOMER_FUND_CASH_BALANCE_MAX_LENGTH_FOR_CUSTOMER)
        end
        raise ArgumentError.new("\"amount\" is required and cannot be null") if amount.nil?

        raise ArgumentError.new("\"currency\" is required and cannot be null") if currency.nil?

        if _reference = reference
          OpenApi::PrimitiveValidator.validate_max_length("reference", reference.to_s.size, POST_TEST_HELPERS_CUSTOMERS_CUSTOMER_FUND_CASH_BALANCE_MAX_LENGTH_FOR_REFERENCE)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/customers/{customer}/fund_cash_balance".sub("{" + "customer" + "}", URI.encode_path(customer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["reference"] = reference.to_s if !reference.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_test_helpers_customers_customer_fund_cash_balance",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the shipping status of the specified Issuing <code>Card</code> object to <code>delivered</code>.</p>
    # @param card [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [IssuingCard]
    def post_test_helpers_issuing_cards_card_shipping_deliver(*, card : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_test_helpers_issuing_cards_card_shipping_deliver_with_http_info(card: card, expand: expand)
      data
    end

    # &lt;p&gt;Updates the shipping status of the specified Issuing &lt;code&gt;Card&lt;/code&gt; object to &lt;code&gt;delivered&lt;/code&gt;.&lt;/p&gt;
    # @param card [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(IssuingCard, Integer, Hash)>] IssuingCard data, response status code and response headers
    def post_test_helpers_issuing_cards_card_shipping_deliver_with_http_info(*, card : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_test_helpers_issuing_cards_card_shipping_deliver(card: card, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_test_helpers_issuing_cards_card_shipping_deliver\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingCard.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the shipping status of the specified Issuing &lt;code&gt;Card&lt;/code&gt; object to &lt;code&gt;delivered&lt;/code&gt;.&lt;/p&gt;
    # @param card [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_test_helpers_issuing_cards_card_shipping_deliver(*, card : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_test_helpers_issuing_cards_card_shipping_deliver(card: card, expand: expand).execute(&block)
    end

    POST_TEST_HELPERS_ISSUING_CARDS_CARD_SHIPPING_DELIVER_MAX_LENGTH_FOR_CARD = 5000

    # @return Crest::Request
    def build_api_request_for_post_test_helpers_issuing_cards_card_shipping_deliver(*, card : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_test_helpers_issuing_cards_card_shipping_deliver ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"card\" is required and cannot be null") if card.nil?
        if _card = card
          OpenApi::PrimitiveValidator.validate_max_length("card", card.to_s.size, POST_TEST_HELPERS_ISSUING_CARDS_CARD_SHIPPING_DELIVER_MAX_LENGTH_FOR_CARD)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/issuing/cards/{card}/shipping/deliver".sub("{" + "card" + "}", URI.encode_path(card.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_test_helpers_issuing_cards_card_shipping_deliver",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the shipping status of the specified Issuing <code>Card</code> object to <code>failure</code>.</p>
    # @param card [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [IssuingCard]
    def post_test_helpers_issuing_cards_card_shipping_fail(*, card : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_test_helpers_issuing_cards_card_shipping_fail_with_http_info(card: card, expand: expand)
      data
    end

    # &lt;p&gt;Updates the shipping status of the specified Issuing &lt;code&gt;Card&lt;/code&gt; object to &lt;code&gt;failure&lt;/code&gt;.&lt;/p&gt;
    # @param card [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(IssuingCard, Integer, Hash)>] IssuingCard data, response status code and response headers
    def post_test_helpers_issuing_cards_card_shipping_fail_with_http_info(*, card : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_test_helpers_issuing_cards_card_shipping_fail(card: card, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_test_helpers_issuing_cards_card_shipping_fail\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingCard.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the shipping status of the specified Issuing &lt;code&gt;Card&lt;/code&gt; object to &lt;code&gt;failure&lt;/code&gt;.&lt;/p&gt;
    # @param card [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_test_helpers_issuing_cards_card_shipping_fail(*, card : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_test_helpers_issuing_cards_card_shipping_fail(card: card, expand: expand).execute(&block)
    end

    POST_TEST_HELPERS_ISSUING_CARDS_CARD_SHIPPING_FAIL_MAX_LENGTH_FOR_CARD = 5000

    # @return Crest::Request
    def build_api_request_for_post_test_helpers_issuing_cards_card_shipping_fail(*, card : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_test_helpers_issuing_cards_card_shipping_fail ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"card\" is required and cannot be null") if card.nil?
        if _card = card
          OpenApi::PrimitiveValidator.validate_max_length("card", card.to_s.size, POST_TEST_HELPERS_ISSUING_CARDS_CARD_SHIPPING_FAIL_MAX_LENGTH_FOR_CARD)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/issuing/cards/{card}/shipping/fail".sub("{" + "card" + "}", URI.encode_path(card.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_test_helpers_issuing_cards_card_shipping_fail",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the shipping status of the specified Issuing <code>Card</code> object to <code>returned</code>.</p>
    # @param card [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [IssuingCard]
    def post_test_helpers_issuing_cards_card_shipping_return(*, card : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_test_helpers_issuing_cards_card_shipping_return_with_http_info(card: card, expand: expand)
      data
    end

    # &lt;p&gt;Updates the shipping status of the specified Issuing &lt;code&gt;Card&lt;/code&gt; object to &lt;code&gt;returned&lt;/code&gt;.&lt;/p&gt;
    # @param card [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(IssuingCard, Integer, Hash)>] IssuingCard data, response status code and response headers
    def post_test_helpers_issuing_cards_card_shipping_return_with_http_info(*, card : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_test_helpers_issuing_cards_card_shipping_return(card: card, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_test_helpers_issuing_cards_card_shipping_return\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingCard.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the shipping status of the specified Issuing &lt;code&gt;Card&lt;/code&gt; object to &lt;code&gt;returned&lt;/code&gt;.&lt;/p&gt;
    # @param card [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_test_helpers_issuing_cards_card_shipping_return(*, card : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_test_helpers_issuing_cards_card_shipping_return(card: card, expand: expand).execute(&block)
    end

    POST_TEST_HELPERS_ISSUING_CARDS_CARD_SHIPPING_RETURN_MAX_LENGTH_FOR_CARD = 5000

    # @return Crest::Request
    def build_api_request_for_post_test_helpers_issuing_cards_card_shipping_return(*, card : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_test_helpers_issuing_cards_card_shipping_return ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"card\" is required and cannot be null") if card.nil?
        if _card = card
          OpenApi::PrimitiveValidator.validate_max_length("card", card.to_s.size, POST_TEST_HELPERS_ISSUING_CARDS_CARD_SHIPPING_RETURN_MAX_LENGTH_FOR_CARD)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/issuing/cards/{card}/shipping/return".sub("{" + "card" + "}", URI.encode_path(card.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_test_helpers_issuing_cards_card_shipping_return",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the shipping status of the specified Issuing <code>Card</code> object to <code>shipped</code>.</p>
    # @param card [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [IssuingCard]
    def post_test_helpers_issuing_cards_card_shipping_ship(*, card : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_test_helpers_issuing_cards_card_shipping_ship_with_http_info(card: card, expand: expand)
      data
    end

    # &lt;p&gt;Updates the shipping status of the specified Issuing &lt;code&gt;Card&lt;/code&gt; object to &lt;code&gt;shipped&lt;/code&gt;.&lt;/p&gt;
    # @param card [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(IssuingCard, Integer, Hash)>] IssuingCard data, response status code and response headers
    def post_test_helpers_issuing_cards_card_shipping_ship_with_http_info(*, card : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_test_helpers_issuing_cards_card_shipping_ship(card: card, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_test_helpers_issuing_cards_card_shipping_ship\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return IssuingCard.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the shipping status of the specified Issuing &lt;code&gt;Card&lt;/code&gt; object to &lt;code&gt;shipped&lt;/code&gt;.&lt;/p&gt;
    # @param card [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_test_helpers_issuing_cards_card_shipping_ship(*, card : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_test_helpers_issuing_cards_card_shipping_ship(card: card, expand: expand).execute(&block)
    end

    POST_TEST_HELPERS_ISSUING_CARDS_CARD_SHIPPING_SHIP_MAX_LENGTH_FOR_CARD = 5000

    # @return Crest::Request
    def build_api_request_for_post_test_helpers_issuing_cards_card_shipping_ship(*, card : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_test_helpers_issuing_cards_card_shipping_ship ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"card\" is required and cannot be null") if card.nil?
        if _card = card
          OpenApi::PrimitiveValidator.validate_max_length("card", card.to_s.size, POST_TEST_HELPERS_ISSUING_CARDS_CARD_SHIPPING_SHIP_MAX_LENGTH_FOR_CARD)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/issuing/cards/{card}/shipping/ship".sub("{" + "card" + "}", URI.encode_path(card.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_test_helpers_issuing_cards_card_shipping_ship",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Expire a refund with a status of <code>requires_action</code>.</p>
    # @param refund [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Refund]
    def post_test_helpers_refunds_refund_expire(*, refund : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_test_helpers_refunds_refund_expire_with_http_info(refund: refund, expand: expand)
      data
    end

    # &lt;p&gt;Expire a refund with a status of &lt;code&gt;requires_action&lt;/code&gt;.&lt;/p&gt;
    # @param refund [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(Refund, Integer, Hash)>] Refund data, response status code and response headers
    def post_test_helpers_refunds_refund_expire_with_http_info(*, refund : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_test_helpers_refunds_refund_expire(refund: refund, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_test_helpers_refunds_refund_expire\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Refund.from_json(data), status_code, headers
    end

    # &lt;p&gt;Expire a refund with a status of &lt;code&gt;requires_action&lt;/code&gt;.&lt;/p&gt;
    # @param refund [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_test_helpers_refunds_refund_expire(*, refund : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_test_helpers_refunds_refund_expire(refund: refund, expand: expand).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_post_test_helpers_refunds_refund_expire(*, refund : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_test_helpers_refunds_refund_expire ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"refund\" is required and cannot be null") if refund.nil?
      end

      # resource path
      local_var_path = "/v1/test_helpers/refunds/{refund}/expire".sub("{" + "refund" + "}", URI.encode_path(refund.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_test_helpers_refunds_refund_expire",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Presents a payment method on a simulated reader. Can be used to simulate accepting a payment, saving a card or refunding a transaction.</p>
    # @param reader [String?]
    # @optional @param card_present [Stripe::CardPresent?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param _type [String?] Simulated payment type
    # @return [TerminalReader]
    def post_test_helpers_terminal_readers_reader_present_payment_method(*, reader : String? = nil, card_present : Stripe::CardPresent? = nil, expand : Array(String)? = nil, _type : String? = nil)
      data, _status_code, _headers = post_test_helpers_terminal_readers_reader_present_payment_method_with_http_info(reader: reader, card_present: card_present, expand: expand, _type: _type)
      data
    end

    # &lt;p&gt;Presents a payment method on a simulated reader. Can be used to simulate accepting a payment, saving a card or refunding a transaction.&lt;/p&gt;
    # @param reader [String?]
    # @optional @param card_present [Stripe::CardPresent?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param _type [String?] Simulated payment type
    # @return [Array<(TerminalReader, Integer, Hash)>] TerminalReader data, response status code and response headers
    def post_test_helpers_terminal_readers_reader_present_payment_method_with_http_info(*, reader : String? = nil, card_present : Stripe::CardPresent? = nil, expand : Array(String)? = nil, _type : String? = nil)
      request = build_api_request_for_post_test_helpers_terminal_readers_reader_present_payment_method(reader: reader, card_present: card_present, expand: expand, _type: _type)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_test_helpers_terminal_readers_reader_present_payment_method\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TerminalReader.from_json(data), status_code, headers
    end

    # &lt;p&gt;Presents a payment method on a simulated reader. Can be used to simulate accepting a payment, saving a card or refunding a transaction.&lt;/p&gt;
    # @param reader [String?]
    # @optional @param card_present [Stripe::CardPresent?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param _type [String?] Simulated payment type
    # @return nil
    def post_test_helpers_terminal_readers_reader_present_payment_method(*, reader : String? = nil, card_present : Stripe::CardPresent? = nil, expand : Array(String)? = nil, _type : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_test_helpers_terminal_readers_reader_present_payment_method(reader: reader, card_present: card_present, expand: expand, _type: _type).execute(&block)
    end

    POST_TEST_HELPERS_TERMINAL_READERS_READER_PRESENT_PAYMENT_METHOD_MAX_LENGTH_FOR_READER  = 5000
    POST_TEST_HELPERS_TERMINAL_READERS_READER_PRESENT_PAYMENT_METHOD_VALID_VALUES_FOR__TYPE = StaticArray["card_present"]

    # @return Crest::Request
    def build_api_request_for_post_test_helpers_terminal_readers_reader_present_payment_method(*, reader : String? = nil, card_present : Stripe::CardPresent? = nil, expand : Array(String)? = nil, _type : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_test_helpers_terminal_readers_reader_present_payment_method ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"reader\" is required and cannot be null") if reader.nil?
        if _reader = reader
          OpenApi::PrimitiveValidator.validate_max_length("reader", reader.to_s.size, POST_TEST_HELPERS_TERMINAL_READERS_READER_PRESENT_PAYMENT_METHOD_MAX_LENGTH_FOR_READER)
        end
        if _card_present = card_present
          _card_present.validate if _card_present.is_a?(OpenApi::Validatable)
        end

        if __type = _type
          OpenApi::EnumValidator.validate("_type", __type, POST_TEST_HELPERS_TERMINAL_READERS_READER_PRESENT_PAYMENT_METHOD_VALID_VALUES_FOR__TYPE)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/terminal/readers/{reader}/present_payment_method".sub("{" + "reader" + "}", URI.encode_path(reader.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["card_present"] = card_present.to_s if !card_present.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["type"] = _type.to_s if !_type.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_test_helpers_terminal_readers_reader_present_payment_method",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new test clock that can be attached to new customers and quotes.</p>
    # @param frozen_time [Int64?] The initial frozen time for this test clock.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param name [String?] The name for this test clock.
    # @return [TestHelpersTestClock]
    def post_test_helpers_test_clocks(*, frozen_time : Int64? = nil, expand : Array(String)? = nil, name : String? = nil)
      data, _status_code, _headers = post_test_helpers_test_clocks_with_http_info(frozen_time: frozen_time, expand: expand, name: name)
      data
    end

    # &lt;p&gt;Creates a new test clock that can be attached to new customers and quotes.&lt;/p&gt;
    # @param frozen_time [Int64?] The initial frozen time for this test clock.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param name [String?] The name for this test clock.
    # @return [Array<(TestHelpersTestClock, Integer, Hash)>] TestHelpersTestClock data, response status code and response headers
    def post_test_helpers_test_clocks_with_http_info(*, frozen_time : Int64? = nil, expand : Array(String)? = nil, name : String? = nil)
      request = build_api_request_for_post_test_helpers_test_clocks(frozen_time: frozen_time, expand: expand, name: name)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_test_helpers_test_clocks\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TestHelpersTestClock.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new test clock that can be attached to new customers and quotes.&lt;/p&gt;
    # @param frozen_time [Int64?] The initial frozen time for this test clock.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param name [String?] The name for this test clock.
    # @return nil
    def post_test_helpers_test_clocks(*, frozen_time : Int64? = nil, expand : Array(String)? = nil, name : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_test_helpers_test_clocks(frozen_time: frozen_time, expand: expand, name: name).execute(&block)
    end

    POST_TEST_HELPERS_TEST_CLOCKS_MAX_LENGTH_FOR_NAME = 300

    # @return Crest::Request
    def build_api_request_for_post_test_helpers_test_clocks(*, frozen_time : Int64? = nil, expand : Array(String)? = nil, name : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_test_helpers_test_clocks ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"frozen_time\" is required and cannot be null") if frozen_time.nil?

        if _name = name
          OpenApi::PrimitiveValidator.validate_max_length("name", name.to_s.size, POST_TEST_HELPERS_TEST_CLOCKS_MAX_LENGTH_FOR_NAME)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/test_clocks"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["frozen_time"] = frozen_time.to_s if !frozen_time.nil?
      form_params["name"] = name.to_s if !name.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_test_helpers_test_clocks",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Starts advancing a test clock to a specified time in the future. Advancement is done when status changes to <code>Ready</code>.</p>
    # @param test_clock [String?]
    # @param frozen_time [Int64?] The time to advance the test clock. Must be after the test clock's current frozen time. Cannot be more than two intervals in the future from the shortest subscription in this test clock. If there are no subscriptions in this test clock, it cannot be more than two years in the future.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [TestHelpersTestClock]
    def post_test_helpers_test_clocks_test_clock_advance(*, test_clock : String? = nil, frozen_time : Int64? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_test_helpers_test_clocks_test_clock_advance_with_http_info(test_clock: test_clock, frozen_time: frozen_time, expand: expand)
      data
    end

    # &lt;p&gt;Starts advancing a test clock to a specified time in the future. Advancement is done when status changes to &lt;code&gt;Ready&lt;/code&gt;.&lt;/p&gt;
    # @param test_clock [String?]
    # @param frozen_time [Int64?] The time to advance the test clock. Must be after the test clock's current frozen time. Cannot be more than two intervals in the future from the shortest subscription in this test clock. If there are no subscriptions in this test clock, it cannot be more than two years in the future.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(TestHelpersTestClock, Integer, Hash)>] TestHelpersTestClock data, response status code and response headers
    def post_test_helpers_test_clocks_test_clock_advance_with_http_info(*, test_clock : String? = nil, frozen_time : Int64? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_test_helpers_test_clocks_test_clock_advance(test_clock: test_clock, frozen_time: frozen_time, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_test_helpers_test_clocks_test_clock_advance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TestHelpersTestClock.from_json(data), status_code, headers
    end

    # &lt;p&gt;Starts advancing a test clock to a specified time in the future. Advancement is done when status changes to &lt;code&gt;Ready&lt;/code&gt;.&lt;/p&gt;
    # @param test_clock [String?]
    # @param frozen_time [Int64?] The time to advance the test clock. Must be after the test clock's current frozen time. Cannot be more than two intervals in the future from the shortest subscription in this test clock. If there are no subscriptions in this test clock, it cannot be more than two years in the future.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_test_helpers_test_clocks_test_clock_advance(*, test_clock : String? = nil, frozen_time : Int64? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_test_helpers_test_clocks_test_clock_advance(test_clock: test_clock, frozen_time: frozen_time, expand: expand).execute(&block)
    end

    POST_TEST_HELPERS_TEST_CLOCKS_TEST_CLOCK_ADVANCE_MAX_LENGTH_FOR_TEST_CLOCK = 5000

    # @return Crest::Request
    def build_api_request_for_post_test_helpers_test_clocks_test_clock_advance(*, test_clock : String? = nil, frozen_time : Int64? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_test_helpers_test_clocks_test_clock_advance ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"test_clock\" is required and cannot be null") if test_clock.nil?
        if _test_clock = test_clock
          OpenApi::PrimitiveValidator.validate_max_length("test_clock", test_clock.to_s.size, POST_TEST_HELPERS_TEST_CLOCKS_TEST_CLOCK_ADVANCE_MAX_LENGTH_FOR_TEST_CLOCK)
        end
        raise ArgumentError.new("\"frozen_time\" is required and cannot be null") if frozen_time.nil?
      end

      # resource path
      local_var_path = "/v1/test_helpers/test_clocks/{test_clock}/advance".sub("{" + "test_clock" + "}", URI.encode_path(test_clock.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["frozen_time"] = frozen_time.to_s if !frozen_time.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_test_helpers_test_clocks_test_clock_advance",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Transitions a test mode created InboundTransfer to the <code>failed</code> status. The InboundTransfer must already be in the <code>processing</code> state.</p>
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param failure_details [Stripe::FailureDetailsParams?]
    # @return [TreasuryInboundTransfer]
    def post_test_helpers_treasury_inbound_transfers_id_fail(*, id : String? = nil, expand : Array(String)? = nil, failure_details : Stripe::FailureDetailsParams? = nil)
      data, _status_code, _headers = post_test_helpers_treasury_inbound_transfers_id_fail_with_http_info(id: id, expand: expand, failure_details: failure_details)
      data
    end

    # &lt;p&gt;Transitions a test mode created InboundTransfer to the &lt;code&gt;failed&lt;/code&gt; status. The InboundTransfer must already be in the &lt;code&gt;processing&lt;/code&gt; state.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param failure_details [Stripe::FailureDetailsParams?]
    # @return [Array<(TreasuryInboundTransfer, Integer, Hash)>] TreasuryInboundTransfer data, response status code and response headers
    def post_test_helpers_treasury_inbound_transfers_id_fail_with_http_info(*, id : String? = nil, expand : Array(String)? = nil, failure_details : Stripe::FailureDetailsParams? = nil)
      request = build_api_request_for_post_test_helpers_treasury_inbound_transfers_id_fail(id: id, expand: expand, failure_details: failure_details)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_test_helpers_treasury_inbound_transfers_id_fail\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryInboundTransfer.from_json(data), status_code, headers
    end

    # &lt;p&gt;Transitions a test mode created InboundTransfer to the &lt;code&gt;failed&lt;/code&gt; status. The InboundTransfer must already be in the &lt;code&gt;processing&lt;/code&gt; state.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param failure_details [Stripe::FailureDetailsParams?]
    # @return nil
    def post_test_helpers_treasury_inbound_transfers_id_fail(*, id : String? = nil, expand : Array(String)? = nil, failure_details : Stripe::FailureDetailsParams? = nil, &block : Crest::Response ->)
      build_api_request_for_post_test_helpers_treasury_inbound_transfers_id_fail(id: id, expand: expand, failure_details: failure_details).execute(&block)
    end

    POST_TEST_HELPERS_TREASURY_INBOUND_TRANSFERS_ID_FAIL_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_post_test_helpers_treasury_inbound_transfers_id_fail(*, id : String? = nil, expand : Array(String)? = nil, failure_details : Stripe::FailureDetailsParams? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_test_helpers_treasury_inbound_transfers_id_fail ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_TEST_HELPERS_TREASURY_INBOUND_TRANSFERS_ID_FAIL_MAX_LENGTH_FOR_ID)
        end

        if _failure_details = failure_details
          _failure_details.validate if _failure_details.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/treasury/inbound_transfers/{id}/fail".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["failure_details"] = failure_details.to_s if !failure_details.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_test_helpers_treasury_inbound_transfers_id_fail",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Marks the test mode InboundTransfer object as returned and links the InboundTransfer to a ReceivedDebit. The InboundTransfer must already be in the <code>succeeded</code> state.</p>
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [TreasuryInboundTransfer]
    def post_test_helpers_treasury_inbound_transfers_id_return(*, id : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_test_helpers_treasury_inbound_transfers_id_return_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Marks the test mode InboundTransfer object as returned and links the InboundTransfer to a ReceivedDebit. The InboundTransfer must already be in the &lt;code&gt;succeeded&lt;/code&gt; state.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryInboundTransfer, Integer, Hash)>] TreasuryInboundTransfer data, response status code and response headers
    def post_test_helpers_treasury_inbound_transfers_id_return_with_http_info(*, id : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_test_helpers_treasury_inbound_transfers_id_return(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_test_helpers_treasury_inbound_transfers_id_return\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryInboundTransfer.from_json(data), status_code, headers
    end

    # &lt;p&gt;Marks the test mode InboundTransfer object as returned and links the InboundTransfer to a ReceivedDebit. The InboundTransfer must already be in the &lt;code&gt;succeeded&lt;/code&gt; state.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_test_helpers_treasury_inbound_transfers_id_return(*, id : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_test_helpers_treasury_inbound_transfers_id_return(id: id, expand: expand).execute(&block)
    end

    POST_TEST_HELPERS_TREASURY_INBOUND_TRANSFERS_ID_RETURN_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_post_test_helpers_treasury_inbound_transfers_id_return(*, id : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_test_helpers_treasury_inbound_transfers_id_return ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_TEST_HELPERS_TREASURY_INBOUND_TRANSFERS_ID_RETURN_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/treasury/inbound_transfers/{id}/return".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_test_helpers_treasury_inbound_transfers_id_return",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Transitions a test mode created InboundTransfer to the <code>succeeded</code> status. The InboundTransfer must already be in the <code>processing</code> state.</p>
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [TreasuryInboundTransfer]
    def post_test_helpers_treasury_inbound_transfers_id_succeed(*, id : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_test_helpers_treasury_inbound_transfers_id_succeed_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Transitions a test mode created InboundTransfer to the &lt;code&gt;succeeded&lt;/code&gt; status. The InboundTransfer must already be in the &lt;code&gt;processing&lt;/code&gt; state.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryInboundTransfer, Integer, Hash)>] TreasuryInboundTransfer data, response status code and response headers
    def post_test_helpers_treasury_inbound_transfers_id_succeed_with_http_info(*, id : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_test_helpers_treasury_inbound_transfers_id_succeed(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_test_helpers_treasury_inbound_transfers_id_succeed\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryInboundTransfer.from_json(data), status_code, headers
    end

    # &lt;p&gt;Transitions a test mode created InboundTransfer to the &lt;code&gt;succeeded&lt;/code&gt; status. The InboundTransfer must already be in the &lt;code&gt;processing&lt;/code&gt; state.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_test_helpers_treasury_inbound_transfers_id_succeed(*, id : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_test_helpers_treasury_inbound_transfers_id_succeed(id: id, expand: expand).execute(&block)
    end

    POST_TEST_HELPERS_TREASURY_INBOUND_TRANSFERS_ID_SUCCEED_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_post_test_helpers_treasury_inbound_transfers_id_succeed(*, id : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_test_helpers_treasury_inbound_transfers_id_succeed ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_TEST_HELPERS_TREASURY_INBOUND_TRANSFERS_ID_SUCCEED_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/treasury/inbound_transfers/{id}/succeed".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_test_helpers_treasury_inbound_transfers_id_succeed",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Transitions a test mode created OutboundPayment to the <code>failed</code> status. The OutboundPayment must already be in the <code>processing</code> state.</p>
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [TreasuryOutboundPayment]
    def post_test_helpers_treasury_outbound_payments_id_fail(*, id : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_test_helpers_treasury_outbound_payments_id_fail_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Transitions a test mode created OutboundPayment to the &lt;code&gt;failed&lt;/code&gt; status. The OutboundPayment must already be in the &lt;code&gt;processing&lt;/code&gt; state.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryOutboundPayment, Integer, Hash)>] TreasuryOutboundPayment data, response status code and response headers
    def post_test_helpers_treasury_outbound_payments_id_fail_with_http_info(*, id : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_test_helpers_treasury_outbound_payments_id_fail(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_test_helpers_treasury_outbound_payments_id_fail\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryOutboundPayment.from_json(data), status_code, headers
    end

    # &lt;p&gt;Transitions a test mode created OutboundPayment to the &lt;code&gt;failed&lt;/code&gt; status. The OutboundPayment must already be in the &lt;code&gt;processing&lt;/code&gt; state.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_test_helpers_treasury_outbound_payments_id_fail(*, id : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_test_helpers_treasury_outbound_payments_id_fail(id: id, expand: expand).execute(&block)
    end

    POST_TEST_HELPERS_TREASURY_OUTBOUND_PAYMENTS_ID_FAIL_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_post_test_helpers_treasury_outbound_payments_id_fail(*, id : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_test_helpers_treasury_outbound_payments_id_fail ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_TEST_HELPERS_TREASURY_OUTBOUND_PAYMENTS_ID_FAIL_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/treasury/outbound_payments/{id}/fail".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_test_helpers_treasury_outbound_payments_id_fail",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Transitions a test mode created OutboundPayment to the <code>posted</code> status. The OutboundPayment must already be in the <code>processing</code> state.</p>
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [TreasuryOutboundPayment]
    def post_test_helpers_treasury_outbound_payments_id_post(*, id : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_test_helpers_treasury_outbound_payments_id_post_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Transitions a test mode created OutboundPayment to the &lt;code&gt;posted&lt;/code&gt; status. The OutboundPayment must already be in the &lt;code&gt;processing&lt;/code&gt; state.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryOutboundPayment, Integer, Hash)>] TreasuryOutboundPayment data, response status code and response headers
    def post_test_helpers_treasury_outbound_payments_id_post_with_http_info(*, id : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_test_helpers_treasury_outbound_payments_id_post(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_test_helpers_treasury_outbound_payments_id_post\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryOutboundPayment.from_json(data), status_code, headers
    end

    # &lt;p&gt;Transitions a test mode created OutboundPayment to the &lt;code&gt;posted&lt;/code&gt; status. The OutboundPayment must already be in the &lt;code&gt;processing&lt;/code&gt; state.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_test_helpers_treasury_outbound_payments_id_post(*, id : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_test_helpers_treasury_outbound_payments_id_post(id: id, expand: expand).execute(&block)
    end

    POST_TEST_HELPERS_TREASURY_OUTBOUND_PAYMENTS_ID_POST_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_post_test_helpers_treasury_outbound_payments_id_post(*, id : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_test_helpers_treasury_outbound_payments_id_post ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_TEST_HELPERS_TREASURY_OUTBOUND_PAYMENTS_ID_POST_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/treasury/outbound_payments/{id}/post".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_test_helpers_treasury_outbound_payments_id_post",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Transitions a test mode created OutboundPayment to the <code>returned</code> status. The OutboundPayment must already be in the <code>processing</code> state.</p>
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param returned_details [Stripe::ReturnedDetailsParams?]
    # @return [TreasuryOutboundPayment]
    def post_test_helpers_treasury_outbound_payments_id_return(*, id : String? = nil, expand : Array(String)? = nil, returned_details : Stripe::ReturnedDetailsParams? = nil)
      data, _status_code, _headers = post_test_helpers_treasury_outbound_payments_id_return_with_http_info(id: id, expand: expand, returned_details: returned_details)
      data
    end

    # &lt;p&gt;Transitions a test mode created OutboundPayment to the &lt;code&gt;returned&lt;/code&gt; status. The OutboundPayment must already be in the &lt;code&gt;processing&lt;/code&gt; state.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param returned_details [Stripe::ReturnedDetailsParams?]
    # @return [Array<(TreasuryOutboundPayment, Integer, Hash)>] TreasuryOutboundPayment data, response status code and response headers
    def post_test_helpers_treasury_outbound_payments_id_return_with_http_info(*, id : String? = nil, expand : Array(String)? = nil, returned_details : Stripe::ReturnedDetailsParams? = nil)
      request = build_api_request_for_post_test_helpers_treasury_outbound_payments_id_return(id: id, expand: expand, returned_details: returned_details)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_test_helpers_treasury_outbound_payments_id_return\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryOutboundPayment.from_json(data), status_code, headers
    end

    # &lt;p&gt;Transitions a test mode created OutboundPayment to the &lt;code&gt;returned&lt;/code&gt; status. The OutboundPayment must already be in the &lt;code&gt;processing&lt;/code&gt; state.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param returned_details [Stripe::ReturnedDetailsParams?]
    # @return nil
    def post_test_helpers_treasury_outbound_payments_id_return(*, id : String? = nil, expand : Array(String)? = nil, returned_details : Stripe::ReturnedDetailsParams? = nil, &block : Crest::Response ->)
      build_api_request_for_post_test_helpers_treasury_outbound_payments_id_return(id: id, expand: expand, returned_details: returned_details).execute(&block)
    end

    POST_TEST_HELPERS_TREASURY_OUTBOUND_PAYMENTS_ID_RETURN_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_post_test_helpers_treasury_outbound_payments_id_return(*, id : String? = nil, expand : Array(String)? = nil, returned_details : Stripe::ReturnedDetailsParams? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_test_helpers_treasury_outbound_payments_id_return ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_TEST_HELPERS_TREASURY_OUTBOUND_PAYMENTS_ID_RETURN_MAX_LENGTH_FOR_ID)
        end

        if _returned_details = returned_details
          _returned_details.validate if _returned_details.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/treasury/outbound_payments/{id}/return".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["returned_details"] = returned_details.to_s if !returned_details.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_test_helpers_treasury_outbound_payments_id_return",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Transitions a test mode created OutboundTransfer to the <code>failed</code> status. The OutboundTransfer must already be in the <code>processing</code> state.</p>
    # @param outbound_transfer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [TreasuryOutboundTransfer]
    def post_test_helpers_treasury_outbound_transfers_outbound_transfer_fail(*, outbound_transfer : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_test_helpers_treasury_outbound_transfers_outbound_transfer_fail_with_http_info(outbound_transfer: outbound_transfer, expand: expand)
      data
    end

    # &lt;p&gt;Transitions a test mode created OutboundTransfer to the &lt;code&gt;failed&lt;/code&gt; status. The OutboundTransfer must already be in the &lt;code&gt;processing&lt;/code&gt; state.&lt;/p&gt;
    # @param outbound_transfer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryOutboundTransfer, Integer, Hash)>] TreasuryOutboundTransfer data, response status code and response headers
    def post_test_helpers_treasury_outbound_transfers_outbound_transfer_fail_with_http_info(*, outbound_transfer : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_test_helpers_treasury_outbound_transfers_outbound_transfer_fail(outbound_transfer: outbound_transfer, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_test_helpers_treasury_outbound_transfers_outbound_transfer_fail\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryOutboundTransfer.from_json(data), status_code, headers
    end

    # &lt;p&gt;Transitions a test mode created OutboundTransfer to the &lt;code&gt;failed&lt;/code&gt; status. The OutboundTransfer must already be in the &lt;code&gt;processing&lt;/code&gt; state.&lt;/p&gt;
    # @param outbound_transfer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_test_helpers_treasury_outbound_transfers_outbound_transfer_fail(*, outbound_transfer : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_test_helpers_treasury_outbound_transfers_outbound_transfer_fail(outbound_transfer: outbound_transfer, expand: expand).execute(&block)
    end

    POST_TEST_HELPERS_TREASURY_OUTBOUND_TRANSFERS_OUTBOUND_TRANSFER_FAIL_MAX_LENGTH_FOR_OUTBOUND_TRANSFER = 5000

    # @return Crest::Request
    def build_api_request_for_post_test_helpers_treasury_outbound_transfers_outbound_transfer_fail(*, outbound_transfer : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_test_helpers_treasury_outbound_transfers_outbound_transfer_fail ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"outbound_transfer\" is required and cannot be null") if outbound_transfer.nil?
        if _outbound_transfer = outbound_transfer
          OpenApi::PrimitiveValidator.validate_max_length("outbound_transfer", outbound_transfer.to_s.size, POST_TEST_HELPERS_TREASURY_OUTBOUND_TRANSFERS_OUTBOUND_TRANSFER_FAIL_MAX_LENGTH_FOR_OUTBOUND_TRANSFER)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/fail".sub("{" + "outbound_transfer" + "}", URI.encode_path(outbound_transfer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_test_helpers_treasury_outbound_transfers_outbound_transfer_fail",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Transitions a test mode created OutboundTransfer to the <code>posted</code> status. The OutboundTransfer must already be in the <code>processing</code> state.</p>
    # @param outbound_transfer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [TreasuryOutboundTransfer]
    def post_test_helpers_treasury_outbound_transfers_outbound_transfer_post(*, outbound_transfer : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_test_helpers_treasury_outbound_transfers_outbound_transfer_post_with_http_info(outbound_transfer: outbound_transfer, expand: expand)
      data
    end

    # &lt;p&gt;Transitions a test mode created OutboundTransfer to the &lt;code&gt;posted&lt;/code&gt; status. The OutboundTransfer must already be in the &lt;code&gt;processing&lt;/code&gt; state.&lt;/p&gt;
    # @param outbound_transfer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryOutboundTransfer, Integer, Hash)>] TreasuryOutboundTransfer data, response status code and response headers
    def post_test_helpers_treasury_outbound_transfers_outbound_transfer_post_with_http_info(*, outbound_transfer : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_test_helpers_treasury_outbound_transfers_outbound_transfer_post(outbound_transfer: outbound_transfer, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_test_helpers_treasury_outbound_transfers_outbound_transfer_post\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryOutboundTransfer.from_json(data), status_code, headers
    end

    # &lt;p&gt;Transitions a test mode created OutboundTransfer to the &lt;code&gt;posted&lt;/code&gt; status. The OutboundTransfer must already be in the &lt;code&gt;processing&lt;/code&gt; state.&lt;/p&gt;
    # @param outbound_transfer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_test_helpers_treasury_outbound_transfers_outbound_transfer_post(*, outbound_transfer : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_test_helpers_treasury_outbound_transfers_outbound_transfer_post(outbound_transfer: outbound_transfer, expand: expand).execute(&block)
    end

    POST_TEST_HELPERS_TREASURY_OUTBOUND_TRANSFERS_OUTBOUND_TRANSFER_POST_MAX_LENGTH_FOR_OUTBOUND_TRANSFER = 5000

    # @return Crest::Request
    def build_api_request_for_post_test_helpers_treasury_outbound_transfers_outbound_transfer_post(*, outbound_transfer : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_test_helpers_treasury_outbound_transfers_outbound_transfer_post ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"outbound_transfer\" is required and cannot be null") if outbound_transfer.nil?
        if _outbound_transfer = outbound_transfer
          OpenApi::PrimitiveValidator.validate_max_length("outbound_transfer", outbound_transfer.to_s.size, POST_TEST_HELPERS_TREASURY_OUTBOUND_TRANSFERS_OUTBOUND_TRANSFER_POST_MAX_LENGTH_FOR_OUTBOUND_TRANSFER)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/post".sub("{" + "outbound_transfer" + "}", URI.encode_path(outbound_transfer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_test_helpers_treasury_outbound_transfers_outbound_transfer_post",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Transitions a test mode created OutboundTransfer to the <code>returned</code> status. The OutboundTransfer must already be in the <code>processing</code> state.</p>
    # @param outbound_transfer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param returned_details [Stripe::ReturnedDetailsParams1?]
    # @return [TreasuryOutboundTransfer]
    def post_test_helpers_treasury_outbound_transfers_outbound_transfer_return(*, outbound_transfer : String? = nil, expand : Array(String)? = nil, returned_details : Stripe::ReturnedDetailsParams1? = nil)
      data, _status_code, _headers = post_test_helpers_treasury_outbound_transfers_outbound_transfer_return_with_http_info(outbound_transfer: outbound_transfer, expand: expand, returned_details: returned_details)
      data
    end

    # &lt;p&gt;Transitions a test mode created OutboundTransfer to the &lt;code&gt;returned&lt;/code&gt; status. The OutboundTransfer must already be in the &lt;code&gt;processing&lt;/code&gt; state.&lt;/p&gt;
    # @param outbound_transfer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param returned_details [Stripe::ReturnedDetailsParams1?]
    # @return [Array<(TreasuryOutboundTransfer, Integer, Hash)>] TreasuryOutboundTransfer data, response status code and response headers
    def post_test_helpers_treasury_outbound_transfers_outbound_transfer_return_with_http_info(*, outbound_transfer : String? = nil, expand : Array(String)? = nil, returned_details : Stripe::ReturnedDetailsParams1? = nil)
      request = build_api_request_for_post_test_helpers_treasury_outbound_transfers_outbound_transfer_return(outbound_transfer: outbound_transfer, expand: expand, returned_details: returned_details)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_test_helpers_treasury_outbound_transfers_outbound_transfer_return\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryOutboundTransfer.from_json(data), status_code, headers
    end

    # &lt;p&gt;Transitions a test mode created OutboundTransfer to the &lt;code&gt;returned&lt;/code&gt; status. The OutboundTransfer must already be in the &lt;code&gt;processing&lt;/code&gt; state.&lt;/p&gt;
    # @param outbound_transfer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param returned_details [Stripe::ReturnedDetailsParams1?]
    # @return nil
    def post_test_helpers_treasury_outbound_transfers_outbound_transfer_return(*, outbound_transfer : String? = nil, expand : Array(String)? = nil, returned_details : Stripe::ReturnedDetailsParams1? = nil, &block : Crest::Response ->)
      build_api_request_for_post_test_helpers_treasury_outbound_transfers_outbound_transfer_return(outbound_transfer: outbound_transfer, expand: expand, returned_details: returned_details).execute(&block)
    end

    POST_TEST_HELPERS_TREASURY_OUTBOUND_TRANSFERS_OUTBOUND_TRANSFER_RETURN_MAX_LENGTH_FOR_OUTBOUND_TRANSFER = 5000

    # @return Crest::Request
    def build_api_request_for_post_test_helpers_treasury_outbound_transfers_outbound_transfer_return(*, outbound_transfer : String? = nil, expand : Array(String)? = nil, returned_details : Stripe::ReturnedDetailsParams1? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_test_helpers_treasury_outbound_transfers_outbound_transfer_return ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"outbound_transfer\" is required and cannot be null") if outbound_transfer.nil?
        if _outbound_transfer = outbound_transfer
          OpenApi::PrimitiveValidator.validate_max_length("outbound_transfer", outbound_transfer.to_s.size, POST_TEST_HELPERS_TREASURY_OUTBOUND_TRANSFERS_OUTBOUND_TRANSFER_RETURN_MAX_LENGTH_FOR_OUTBOUND_TRANSFER)
        end

        if _returned_details = returned_details
          _returned_details.validate if _returned_details.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/return".sub("{" + "outbound_transfer" + "}", URI.encode_path(outbound_transfer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["returned_details"] = returned_details.to_s if !returned_details.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_test_helpers_treasury_outbound_transfers_outbound_transfer_return",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Use this endpoint to simulate a test mode ReceivedCredit initiated by a third party. In live mode, you can’t directly create ReceivedCredits initiated by third parties.</p>
    # @param amount [Int64?] Amount (in cents) to be transferred.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param financial_account [String?] The FinancialAccount to send funds to.
    # @param network [String?] The rails used for the object.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param initiating_payment_method_details [Stripe::SourceParams?]
    # @return [TreasuryReceivedCredit]
    def post_test_helpers_treasury_received_credits(*, amount : Int64? = nil, currency : String? = nil, financial_account : String? = nil, network : String? = nil, description : String? = nil, expand : Array(String)? = nil, initiating_payment_method_details : Stripe::SourceParams? = nil)
      data, _status_code, _headers = post_test_helpers_treasury_received_credits_with_http_info(amount: amount, currency: currency, financial_account: financial_account, network: network, description: description, expand: expand, initiating_payment_method_details: initiating_payment_method_details)
      data
    end

    # &lt;p&gt;Use this endpoint to simulate a test mode ReceivedCredit initiated by a third party. In live mode, you can’t directly create ReceivedCredits initiated by third parties.&lt;/p&gt;
    # @param amount [Int64?] Amount (in cents) to be transferred.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param financial_account [String?] The FinancialAccount to send funds to.
    # @param network [String?] The rails used for the object.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param initiating_payment_method_details [Stripe::SourceParams?]
    # @return [Array<(TreasuryReceivedCredit, Integer, Hash)>] TreasuryReceivedCredit data, response status code and response headers
    def post_test_helpers_treasury_received_credits_with_http_info(*, amount : Int64? = nil, currency : String? = nil, financial_account : String? = nil, network : String? = nil, description : String? = nil, expand : Array(String)? = nil, initiating_payment_method_details : Stripe::SourceParams? = nil)
      request = build_api_request_for_post_test_helpers_treasury_received_credits(amount: amount, currency: currency, financial_account: financial_account, network: network, description: description, expand: expand, initiating_payment_method_details: initiating_payment_method_details)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_test_helpers_treasury_received_credits\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryReceivedCredit.from_json(data), status_code, headers
    end

    # &lt;p&gt;Use this endpoint to simulate a test mode ReceivedCredit initiated by a third party. In live mode, you can’t directly create ReceivedCredits initiated by third parties.&lt;/p&gt;
    # @param amount [Int64?] Amount (in cents) to be transferred.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param financial_account [String?] The FinancialAccount to send funds to.
    # @param network [String?] The rails used for the object.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param initiating_payment_method_details [Stripe::SourceParams?]
    # @return nil
    def post_test_helpers_treasury_received_credits(*, amount : Int64? = nil, currency : String? = nil, financial_account : String? = nil, network : String? = nil, description : String? = nil, expand : Array(String)? = nil, initiating_payment_method_details : Stripe::SourceParams? = nil, &block : Crest::Response ->)
      build_api_request_for_post_test_helpers_treasury_received_credits(amount: amount, currency: currency, financial_account: financial_account, network: network, description: description, expand: expand, initiating_payment_method_details: initiating_payment_method_details).execute(&block)
    end

    POST_TEST_HELPERS_TREASURY_RECEIVED_CREDITS_VALID_VALUES_FOR_NETWORK   = StaticArray["ach", "us_domestic_wire"]
    POST_TEST_HELPERS_TREASURY_RECEIVED_CREDITS_MAX_LENGTH_FOR_DESCRIPTION = 5000

    # @return Crest::Request
    def build_api_request_for_post_test_helpers_treasury_received_credits(*, amount : Int64? = nil, currency : String? = nil, financial_account : String? = nil, network : String? = nil, description : String? = nil, expand : Array(String)? = nil, initiating_payment_method_details : Stripe::SourceParams? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_test_helpers_treasury_received_credits ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"amount\" is required and cannot be null") if amount.nil?

        raise ArgumentError.new("\"currency\" is required and cannot be null") if currency.nil?

        raise ArgumentError.new("\"financial_account\" is required and cannot be null") if financial_account.nil?

        raise ArgumentError.new("\"network\" is required and cannot be null") if network.nil?
        if _network = network
          OpenApi::EnumValidator.validate("network", _network, POST_TEST_HELPERS_TREASURY_RECEIVED_CREDITS_VALID_VALUES_FOR_NETWORK)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_TEST_HELPERS_TREASURY_RECEIVED_CREDITS_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _initiating_payment_method_details = initiating_payment_method_details
          _initiating_payment_method_details.validate if _initiating_payment_method_details.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/treasury/received_credits"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["financial_account"] = financial_account.to_s if !financial_account.nil?
      form_params["initiating_payment_method_details"] = initiating_payment_method_details.to_s if !initiating_payment_method_details.nil?
      form_params["network"] = network.to_s if !network.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_test_helpers_treasury_received_credits",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Use this endpoint to simulate a test mode ReceivedDebit initiated by a third party. In live mode, you can’t directly create ReceivedDebits initiated by third parties.</p>
    # @param amount [Int64?] Amount (in cents) to be transferred.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param financial_account [String?] The FinancialAccount to pull funds from.
    # @param network [String?] The rails used for the object.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param initiating_payment_method_details [Stripe::SourceParams?]
    # @return [TreasuryReceivedDebit]
    def post_test_helpers_treasury_received_debits(*, amount : Int64? = nil, currency : String? = nil, financial_account : String? = nil, network : String? = nil, description : String? = nil, expand : Array(String)? = nil, initiating_payment_method_details : Stripe::SourceParams? = nil)
      data, _status_code, _headers = post_test_helpers_treasury_received_debits_with_http_info(amount: amount, currency: currency, financial_account: financial_account, network: network, description: description, expand: expand, initiating_payment_method_details: initiating_payment_method_details)
      data
    end

    # &lt;p&gt;Use this endpoint to simulate a test mode ReceivedDebit initiated by a third party. In live mode, you can’t directly create ReceivedDebits initiated by third parties.&lt;/p&gt;
    # @param amount [Int64?] Amount (in cents) to be transferred.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param financial_account [String?] The FinancialAccount to pull funds from.
    # @param network [String?] The rails used for the object.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param initiating_payment_method_details [Stripe::SourceParams?]
    # @return [Array<(TreasuryReceivedDebit, Integer, Hash)>] TreasuryReceivedDebit data, response status code and response headers
    def post_test_helpers_treasury_received_debits_with_http_info(*, amount : Int64? = nil, currency : String? = nil, financial_account : String? = nil, network : String? = nil, description : String? = nil, expand : Array(String)? = nil, initiating_payment_method_details : Stripe::SourceParams? = nil)
      request = build_api_request_for_post_test_helpers_treasury_received_debits(amount: amount, currency: currency, financial_account: financial_account, network: network, description: description, expand: expand, initiating_payment_method_details: initiating_payment_method_details)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_test_helpers_treasury_received_debits\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryReceivedDebit.from_json(data), status_code, headers
    end

    # &lt;p&gt;Use this endpoint to simulate a test mode ReceivedDebit initiated by a third party. In live mode, you can’t directly create ReceivedDebits initiated by third parties.&lt;/p&gt;
    # @param amount [Int64?] Amount (in cents) to be transferred.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param financial_account [String?] The FinancialAccount to pull funds from.
    # @param network [String?] The rails used for the object.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param initiating_payment_method_details [Stripe::SourceParams?]
    # @return nil
    def post_test_helpers_treasury_received_debits(*, amount : Int64? = nil, currency : String? = nil, financial_account : String? = nil, network : String? = nil, description : String? = nil, expand : Array(String)? = nil, initiating_payment_method_details : Stripe::SourceParams? = nil, &block : Crest::Response ->)
      build_api_request_for_post_test_helpers_treasury_received_debits(amount: amount, currency: currency, financial_account: financial_account, network: network, description: description, expand: expand, initiating_payment_method_details: initiating_payment_method_details).execute(&block)
    end

    POST_TEST_HELPERS_TREASURY_RECEIVED_DEBITS_VALID_VALUES_FOR_NETWORK   = StaticArray["ach"]
    POST_TEST_HELPERS_TREASURY_RECEIVED_DEBITS_MAX_LENGTH_FOR_DESCRIPTION = 5000

    # @return Crest::Request
    def build_api_request_for_post_test_helpers_treasury_received_debits(*, amount : Int64? = nil, currency : String? = nil, financial_account : String? = nil, network : String? = nil, description : String? = nil, expand : Array(String)? = nil, initiating_payment_method_details : Stripe::SourceParams? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_test_helpers_treasury_received_debits ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"amount\" is required and cannot be null") if amount.nil?

        raise ArgumentError.new("\"currency\" is required and cannot be null") if currency.nil?

        raise ArgumentError.new("\"financial_account\" is required and cannot be null") if financial_account.nil?

        raise ArgumentError.new("\"network\" is required and cannot be null") if network.nil?
        if _network = network
          OpenApi::EnumValidator.validate("network", _network, POST_TEST_HELPERS_TREASURY_RECEIVED_DEBITS_VALID_VALUES_FOR_NETWORK)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_TEST_HELPERS_TREASURY_RECEIVED_DEBITS_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _initiating_payment_method_details = initiating_payment_method_details
          _initiating_payment_method_details.validate if _initiating_payment_method_details.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/test_helpers/treasury/received_debits"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["financial_account"] = financial_account.to_s if !financial_account.nil?
      form_params["initiating_payment_method_details"] = initiating_payment_method_details.to_s if !initiating_payment_method_details.nil?
      form_params["network"] = network.to_s if !network.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_test_helpers_treasury_received_debits",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a single-use token that represents a bank account’s details. This token can be used with any API method in place of a bank account dictionary. This token can be used only once, by attaching it to a <a href=\"#accounts\">Custom account</a>.</p>
    # @optional @param account [Stripe::ConnectJsAccountTokenSpecs?]
    # @optional @param bank_account [Stripe::TokenCreateBankAccount?]
    # @optional @param card [Stripe::PostTokensRequestCard?]
    # @optional @param customer [String?] The customer (owned by the application's account) for which to create a token. This can be used only with an [OAuth access token](https://stripe.com/docs/connect/standard-accounts) or [Stripe-Account header](https://stripe.com/docs/connect/authentication). For more details, see [Cloning Saved Payment Methods](https://stripe.com/docs/connect/cloning-saved-payment-methods).
    # @optional @param cvc_update [Stripe::CvcParams?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param person [Stripe::PersonTokenSpecs?]
    # @optional @param pii [Stripe::PiiTokenSpecs?]
    # @return [Token]
    def post_tokens(*, account : Stripe::ConnectJsAccountTokenSpecs? = nil, bank_account : Stripe::TokenCreateBankAccount? = nil, card : Stripe::PostTokensRequestCard? = nil, customer : String? = nil, cvc_update : Stripe::CvcParams? = nil, expand : Array(String)? = nil, person : Stripe::PersonTokenSpecs? = nil, pii : Stripe::PiiTokenSpecs? = nil)
      data, _status_code, _headers = post_tokens_with_http_info(account: account, bank_account: bank_account, card: card, customer: customer, cvc_update: cvc_update, expand: expand, person: person, pii: pii)
      data
    end

    # &lt;p&gt;Creates a single-use token that represents a bank account’s details. This token can be used with any API method in place of a bank account dictionary. This token can be used only once, by attaching it to a &lt;a href&#x3D;\&quot;#accounts\&quot;&gt;Custom account&lt;/a&gt;.&lt;/p&gt;
    # @optional @param account [Stripe::ConnectJsAccountTokenSpecs?]
    # @optional @param bank_account [Stripe::TokenCreateBankAccount?]
    # @optional @param card [Stripe::PostTokensRequestCard?]
    # @optional @param customer [String?] The customer (owned by the application's account) for which to create a token. This can be used only with an [OAuth access token](https://stripe.com/docs/connect/standard-accounts) or [Stripe-Account header](https://stripe.com/docs/connect/authentication). For more details, see [Cloning Saved Payment Methods](https://stripe.com/docs/connect/cloning-saved-payment-methods).
    # @optional @param cvc_update [Stripe::CvcParams?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param person [Stripe::PersonTokenSpecs?]
    # @optional @param pii [Stripe::PiiTokenSpecs?]
    # @return [Array<(Token, Integer, Hash)>] Token data, response status code and response headers
    def post_tokens_with_http_info(*, account : Stripe::ConnectJsAccountTokenSpecs? = nil, bank_account : Stripe::TokenCreateBankAccount? = nil, card : Stripe::PostTokensRequestCard? = nil, customer : String? = nil, cvc_update : Stripe::CvcParams? = nil, expand : Array(String)? = nil, person : Stripe::PersonTokenSpecs? = nil, pii : Stripe::PiiTokenSpecs? = nil)
      request = build_api_request_for_post_tokens(account: account, bank_account: bank_account, card: card, customer: customer, cvc_update: cvc_update, expand: expand, person: person, pii: pii)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_tokens\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Token.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a single-use token that represents a bank account’s details. This token can be used with any API method in place of a bank account dictionary. This token can be used only once, by attaching it to a &lt;a href&#x3D;\&quot;#accounts\&quot;&gt;Custom account&lt;/a&gt;.&lt;/p&gt;
    # @optional @param account [Stripe::ConnectJsAccountTokenSpecs?]
    # @optional @param bank_account [Stripe::TokenCreateBankAccount?]
    # @optional @param card [Stripe::PostTokensRequestCard?]
    # @optional @param customer [String?] The customer (owned by the application's account) for which to create a token. This can be used only with an [OAuth access token](https://stripe.com/docs/connect/standard-accounts) or [Stripe-Account header](https://stripe.com/docs/connect/authentication). For more details, see [Cloning Saved Payment Methods](https://stripe.com/docs/connect/cloning-saved-payment-methods).
    # @optional @param cvc_update [Stripe::CvcParams?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param person [Stripe::PersonTokenSpecs?]
    # @optional @param pii [Stripe::PiiTokenSpecs?]
    # @return nil
    def post_tokens(*, account : Stripe::ConnectJsAccountTokenSpecs? = nil, bank_account : Stripe::TokenCreateBankAccount? = nil, card : Stripe::PostTokensRequestCard? = nil, customer : String? = nil, cvc_update : Stripe::CvcParams? = nil, expand : Array(String)? = nil, person : Stripe::PersonTokenSpecs? = nil, pii : Stripe::PiiTokenSpecs? = nil, &block : Crest::Response ->)
      build_api_request_for_post_tokens(account: account, bank_account: bank_account, card: card, customer: customer, cvc_update: cvc_update, expand: expand, person: person, pii: pii).execute(&block)
    end

    POST_TOKENS_MAX_LENGTH_FOR_CUSTOMER = 5000

    # @return Crest::Request
    def build_api_request_for_post_tokens(*, account : Stripe::ConnectJsAccountTokenSpecs? = nil, bank_account : Stripe::TokenCreateBankAccount? = nil, card : Stripe::PostTokensRequestCard? = nil, customer : String? = nil, cvc_update : Stripe::CvcParams? = nil, expand : Array(String)? = nil, person : Stripe::PersonTokenSpecs? = nil, pii : Stripe::PiiTokenSpecs? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_tokens ..." }
      end

      if client_side_validation
        if _account = account
          _account.validate if _account.is_a?(OpenApi::Validatable)
        end
        if _bank_account = bank_account
          _bank_account.validate if _bank_account.is_a?(OpenApi::Validatable)
        end
        if _card = card
          _card.validate if _card.is_a?(OpenApi::Validatable)
        end
        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_TOKENS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _cvc_update = cvc_update
          _cvc_update.validate if _cvc_update.is_a?(OpenApi::Validatable)
        end

        if _person = person
          _person.validate if _person.is_a?(OpenApi::Validatable)
        end
        if _pii = pii
          _pii.validate if _pii.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/tokens"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["account"] = account.to_s if !account.nil?
      form_params["bank_account"] = bank_account.to_s if !bank_account.nil?
      form_params["card"] = card.to_s if !card.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["cvc_update"] = cvc_update.to_s if !cvc_update.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["person"] = person.to_s if !person.nil?
      form_params["pii"] = pii.to_s if !pii.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_tokens",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Top up the balance of an account</p>
    # @param amount [Int64?] A positive integer representing how much to transfer.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param source [String?] The ID of a source to transfer funds from. For most users, this should be left unspecified which will use the bank account that was set up in the dashboard for the specified currency. In test mode, this can be a test bank token (see [Testing Top-ups](https://stripe.com/docs/connect/testing#testing-top-ups)).
    # @optional @param statement_descriptor [String?] Extra information about a top-up for the source's bank statement. Limited to 15 ASCII characters.
    # @optional @param transfer_group [String?] A string that identifies this top-up as part of a group.
    # @return [Topup]
    def post_topups(*, amount : Int64? = nil, currency : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, source : String? = nil, statement_descriptor : String? = nil, transfer_group : String? = nil)
      data, _status_code, _headers = post_topups_with_http_info(amount: amount, currency: currency, description: description, expand: expand, metadata: metadata, source: source, statement_descriptor: statement_descriptor, transfer_group: transfer_group)
      data
    end

    # &lt;p&gt;Top up the balance of an account&lt;/p&gt;
    # @param amount [Int64?] A positive integer representing how much to transfer.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param source [String?] The ID of a source to transfer funds from. For most users, this should be left unspecified which will use the bank account that was set up in the dashboard for the specified currency. In test mode, this can be a test bank token (see [Testing Top-ups](https://stripe.com/docs/connect/testing#testing-top-ups)).
    # @optional @param statement_descriptor [String?] Extra information about a top-up for the source's bank statement. Limited to 15 ASCII characters.
    # @optional @param transfer_group [String?] A string that identifies this top-up as part of a group.
    # @return [Array<(Topup, Integer, Hash)>] Topup data, response status code and response headers
    def post_topups_with_http_info(*, amount : Int64? = nil, currency : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, source : String? = nil, statement_descriptor : String? = nil, transfer_group : String? = nil)
      request = build_api_request_for_post_topups(amount: amount, currency: currency, description: description, expand: expand, metadata: metadata, source: source, statement_descriptor: statement_descriptor, transfer_group: transfer_group)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_topups\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Topup.from_json(data), status_code, headers
    end

    # &lt;p&gt;Top up the balance of an account&lt;/p&gt;
    # @param amount [Int64?] A positive integer representing how much to transfer.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param source [String?] The ID of a source to transfer funds from. For most users, this should be left unspecified which will use the bank account that was set up in the dashboard for the specified currency. In test mode, this can be a test bank token (see [Testing Top-ups](https://stripe.com/docs/connect/testing#testing-top-ups)).
    # @optional @param statement_descriptor [String?] Extra information about a top-up for the source's bank statement. Limited to 15 ASCII characters.
    # @optional @param transfer_group [String?] A string that identifies this top-up as part of a group.
    # @return nil
    def post_topups(*, amount : Int64? = nil, currency : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, source : String? = nil, statement_descriptor : String? = nil, transfer_group : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_topups(amount: amount, currency: currency, description: description, expand: expand, metadata: metadata, source: source, statement_descriptor: statement_descriptor, transfer_group: transfer_group).execute(&block)
    end

    POST_TOPUPS_MAX_LENGTH_FOR_DESCRIPTION          = 5000
    POST_TOPUPS_MAX_LENGTH_FOR_SOURCE               = 5000
    POST_TOPUPS_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR =   15

    # @return Crest::Request
    def build_api_request_for_post_topups(*, amount : Int64? = nil, currency : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, source : String? = nil, statement_descriptor : String? = nil, transfer_group : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_topups ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"amount\" is required and cannot be null") if amount.nil?

        raise ArgumentError.new("\"currency\" is required and cannot be null") if currency.nil?

        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_TOPUPS_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
        if _source = source
          OpenApi::PrimitiveValidator.validate_max_length("source", source.to_s.size, POST_TOPUPS_MAX_LENGTH_FOR_SOURCE)
        end
        if _statement_descriptor = statement_descriptor
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor", statement_descriptor.to_s.size, POST_TOPUPS_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR)
        end
      end

      # resource path
      local_var_path = "/v1/topups"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["source"] = source.to_s if !source.nil?
      form_params["statement_descriptor"] = statement_descriptor.to_s if !statement_descriptor.nil?
      form_params["transfer_group"] = transfer_group.to_s if !transfer_group.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_topups",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the metadata of a top-up. Other top-up details are not editable by design.</p>
    # @param topup [String?]
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Topup]
    def post_topups_topup(*, topup : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_topups_topup_with_http_info(topup: topup, description: description, expand: expand, metadata: metadata)
      data
    end

    # &lt;p&gt;Updates the metadata of a top-up. Other top-up details are not editable by design.&lt;/p&gt;
    # @param topup [String?]
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(Topup, Integer, Hash)>] Topup data, response status code and response headers
    def post_topups_topup_with_http_info(*, topup : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_topups_topup(topup: topup, description: description, expand: expand, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_topups_topup\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Topup.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the metadata of a top-up. Other top-up details are not editable by design.&lt;/p&gt;
    # @param topup [String?]
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_topups_topup(*, topup : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_topups_topup(topup: topup, description: description, expand: expand, metadata: metadata).execute(&block)
    end

    POST_TOPUPS_TOPUP_MAX_LENGTH_FOR_TOPUP       = 5000
    POST_TOPUPS_TOPUP_MAX_LENGTH_FOR_DESCRIPTION = 5000

    # @return Crest::Request
    def build_api_request_for_post_topups_topup(*, topup : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_topups_topup ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"topup\" is required and cannot be null") if topup.nil?
        if _topup = topup
          OpenApi::PrimitiveValidator.validate_max_length("topup", topup.to_s.size, POST_TOPUPS_TOPUP_MAX_LENGTH_FOR_TOPUP)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_TOPUPS_TOPUP_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/topups/{topup}".sub("{" + "topup" + "}", URI.encode_path(topup.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["description"] = description.to_s if !description.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_topups_topup",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Cancels a top-up. Only pending top-ups can be canceled.</p>
    # @param topup [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Topup]
    def post_topups_topup_cancel(*, topup : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_topups_topup_cancel_with_http_info(topup: topup, expand: expand)
      data
    end

    # &lt;p&gt;Cancels a top-up. Only pending top-ups can be canceled.&lt;/p&gt;
    # @param topup [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(Topup, Integer, Hash)>] Topup data, response status code and response headers
    def post_topups_topup_cancel_with_http_info(*, topup : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_topups_topup_cancel(topup: topup, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_topups_topup_cancel\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Topup.from_json(data), status_code, headers
    end

    # &lt;p&gt;Cancels a top-up. Only pending top-ups can be canceled.&lt;/p&gt;
    # @param topup [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_topups_topup_cancel(*, topup : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_topups_topup_cancel(topup: topup, expand: expand).execute(&block)
    end

    POST_TOPUPS_TOPUP_CANCEL_MAX_LENGTH_FOR_TOPUP = 5000

    # @return Crest::Request
    def build_api_request_for_post_topups_topup_cancel(*, topup : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_topups_topup_cancel ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"topup\" is required and cannot be null") if topup.nil?
        if _topup = topup
          OpenApi::PrimitiveValidator.validate_max_length("topup", topup.to_s.size, POST_TOPUPS_TOPUP_CANCEL_MAX_LENGTH_FOR_TOPUP)
        end
      end

      # resource path
      local_var_path = "/v1/topups/{topup}/cancel".sub("{" + "topup" + "}", URI.encode_path(topup.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_topups_topup_cancel",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>To send funds from your Stripe account to a connected account, you create a new transfer object. Your <a href=\"#balance\">Stripe balance</a> must be able to cover the transfer amount, or you’ll receive an “Insufficient Funds” error.</p>
    # @param currency [String?] 3-letter [ISO code for currency](https://stripe.com/docs/payouts).
    # @param destination [String?] The ID of a connected Stripe account. <a href=\\\"/docs/connect/charges-transfers\\\">See the Connect documentation</a> for details.
    # @optional @param amount [Int64?] A positive integer in cents (or local equivalent) representing how much to transfer.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param source_transaction [String?] You can use this parameter to transfer funds from a charge before they are added to your available balance. A pending balance will transfer immediately but the funds will not become available until the original charge becomes available. [See the Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-availability) for details.
    # @optional @param source_type [String?] The source balance to use for this transfer. One of `bank_account`, `card`, or `fpx`. For most users, this will default to `card`.
    # @optional @param transfer_group [String?] A string that identifies this transaction as part of a group. See the [Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-options) for details.
    # @return [Transfer]
    def post_transfers(*, currency : String? = nil, destination : String? = nil, amount : Int64? = nil, description : String? = nil, expand : Array(String)? = nil, source_transaction : String? = nil, source_type : String? = nil, transfer_group : String? = nil)
      data, _status_code, _headers = post_transfers_with_http_info(currency: currency, destination: destination, amount: amount, description: description, expand: expand, source_transaction: source_transaction, source_type: source_type, transfer_group: transfer_group)
      data
    end

    # &lt;p&gt;To send funds from your Stripe account to a connected account, you create a new transfer object. Your &lt;a href&#x3D;\&quot;#balance\&quot;&gt;Stripe balance&lt;/a&gt; must be able to cover the transfer amount, or you’ll receive an “Insufficient Funds” error.&lt;/p&gt;
    # @param currency [String?] 3-letter [ISO code for currency](https://stripe.com/docs/payouts).
    # @param destination [String?] The ID of a connected Stripe account. <a href=\\\"/docs/connect/charges-transfers\\\">See the Connect documentation</a> for details.
    # @optional @param amount [Int64?] A positive integer in cents (or local equivalent) representing how much to transfer.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param source_transaction [String?] You can use this parameter to transfer funds from a charge before they are added to your available balance. A pending balance will transfer immediately but the funds will not become available until the original charge becomes available. [See the Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-availability) for details.
    # @optional @param source_type [String?] The source balance to use for this transfer. One of `bank_account`, `card`, or `fpx`. For most users, this will default to `card`.
    # @optional @param transfer_group [String?] A string that identifies this transaction as part of a group. See the [Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-options) for details.
    # @return [Array<(Transfer, Integer, Hash)>] Transfer data, response status code and response headers
    def post_transfers_with_http_info(*, currency : String? = nil, destination : String? = nil, amount : Int64? = nil, description : String? = nil, expand : Array(String)? = nil, source_transaction : String? = nil, source_type : String? = nil, transfer_group : String? = nil)
      request = build_api_request_for_post_transfers(currency: currency, destination: destination, amount: amount, description: description, expand: expand, source_transaction: source_transaction, source_type: source_type, transfer_group: transfer_group)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_transfers\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Transfer.from_json(data), status_code, headers
    end

    # &lt;p&gt;To send funds from your Stripe account to a connected account, you create a new transfer object. Your &lt;a href&#x3D;\&quot;#balance\&quot;&gt;Stripe balance&lt;/a&gt; must be able to cover the transfer amount, or you’ll receive an “Insufficient Funds” error.&lt;/p&gt;
    # @param currency [String?] 3-letter [ISO code for currency](https://stripe.com/docs/payouts).
    # @param destination [String?] The ID of a connected Stripe account. <a href=\\\"/docs/connect/charges-transfers\\\">See the Connect documentation</a> for details.
    # @optional @param amount [Int64?] A positive integer in cents (or local equivalent) representing how much to transfer.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param source_transaction [String?] You can use this parameter to transfer funds from a charge before they are added to your available balance. A pending balance will transfer immediately but the funds will not become available until the original charge becomes available. [See the Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-availability) for details.
    # @optional @param source_type [String?] The source balance to use for this transfer. One of `bank_account`, `card`, or `fpx`. For most users, this will default to `card`.
    # @optional @param transfer_group [String?] A string that identifies this transaction as part of a group. See the [Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-options) for details.
    # @return nil
    def post_transfers(*, currency : String? = nil, destination : String? = nil, amount : Int64? = nil, description : String? = nil, expand : Array(String)? = nil, source_transaction : String? = nil, source_type : String? = nil, transfer_group : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_transfers(currency: currency, destination: destination, amount: amount, description: description, expand: expand, source_transaction: source_transaction, source_type: source_type, transfer_group: transfer_group).execute(&block)
    end

    POST_TRANSFERS_MAX_LENGTH_FOR_DESCRIPTION   = 5000
    POST_TRANSFERS_MAX_LENGTH_FOR_SOURCE_TYPE   = 5000
    POST_TRANSFERS_VALID_VALUES_FOR_SOURCE_TYPE = StaticArray["bank_account", "card", "fpx"]

    # @return Crest::Request
    def build_api_request_for_post_transfers(*, currency : String? = nil, destination : String? = nil, amount : Int64? = nil, description : String? = nil, expand : Array(String)? = nil, source_transaction : String? = nil, source_type : String? = nil, transfer_group : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_transfers ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"currency\" is required and cannot be null") if currency.nil?

        raise ArgumentError.new("\"destination\" is required and cannot be null") if destination.nil?

        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_TRANSFERS_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _source_type = source_type
          OpenApi::EnumValidator.validate("source_type", _source_type, POST_TRANSFERS_VALID_VALUES_FOR_SOURCE_TYPE)
        end
      end

      # resource path
      local_var_path = "/v1/transfers"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["destination"] = destination.to_s if !destination.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["source_transaction"] = source_transaction.to_s if !source_transaction.nil?
      form_params["source_type"] = source_type.to_s if !source_type.nil?
      form_params["transfer_group"] = transfer_group.to_s if !transfer_group.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_transfers",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>When you create a new reversal, you must specify a transfer to create it on.</p>  <p>When reversing transfers, you can optionally reverse part of the transfer. You can do so as many times as you wish until the entire transfer has been reversed.</p>  <p>Once entirely reversed, a transfer can’t be reversed again. This method will return an error when called on an already-reversed transfer, or when trying to reverse more money than is left on a transfer.</p>
    # @param id [String?]
    # @optional @param amount [Int64?] A positive integer in cents (or local equivalent) representing how much of this transfer to reverse. Can only reverse up to the unreversed amount remaining of the transfer. Partial transfer reversals are only allowed for transfers to Stripe Accounts. Defaults to the entire transfer amount.
    # @optional @param description [String?] An arbitrary string which you can attach to a reversal object. It is displayed alongside the reversal in the Dashboard. This will be unset if you POST an empty value.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param refund_application_fee [Bool?] Boolean indicating whether the application fee should be refunded when reversing this transfer. If a full transfer reversal is given, the full application fee will be refunded. Otherwise, the application fee will be refunded with an amount proportional to the amount of the transfer reversed.
    # @return [TransferReversal]
    def post_transfers_id_reversals(*, id : String? = nil, amount : Int64? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, refund_application_fee : Bool? = nil)
      data, _status_code, _headers = post_transfers_id_reversals_with_http_info(id: id, amount: amount, description: description, expand: expand, metadata: metadata, refund_application_fee: refund_application_fee)
      data
    end

    # &lt;p&gt;When you create a new reversal, you must specify a transfer to create it on.&lt;/p&gt;  &lt;p&gt;When reversing transfers, you can optionally reverse part of the transfer. You can do so as many times as you wish until the entire transfer has been reversed.&lt;/p&gt;  &lt;p&gt;Once entirely reversed, a transfer can’t be reversed again. This method will return an error when called on an already-reversed transfer, or when trying to reverse more money than is left on a transfer.&lt;/p&gt;
    # @param id [String?]
    # @optional @param amount [Int64?] A positive integer in cents (or local equivalent) representing how much of this transfer to reverse. Can only reverse up to the unreversed amount remaining of the transfer. Partial transfer reversals are only allowed for transfers to Stripe Accounts. Defaults to the entire transfer amount.
    # @optional @param description [String?] An arbitrary string which you can attach to a reversal object. It is displayed alongside the reversal in the Dashboard. This will be unset if you POST an empty value.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param refund_application_fee [Bool?] Boolean indicating whether the application fee should be refunded when reversing this transfer. If a full transfer reversal is given, the full application fee will be refunded. Otherwise, the application fee will be refunded with an amount proportional to the amount of the transfer reversed.
    # @return [Array<(TransferReversal, Integer, Hash)>] TransferReversal data, response status code and response headers
    def post_transfers_id_reversals_with_http_info(*, id : String? = nil, amount : Int64? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, refund_application_fee : Bool? = nil)
      request = build_api_request_for_post_transfers_id_reversals(id: id, amount: amount, description: description, expand: expand, metadata: metadata, refund_application_fee: refund_application_fee)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_transfers_id_reversals\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TransferReversal.from_json(data), status_code, headers
    end

    # &lt;p&gt;When you create a new reversal, you must specify a transfer to create it on.&lt;/p&gt;  &lt;p&gt;When reversing transfers, you can optionally reverse part of the transfer. You can do so as many times as you wish until the entire transfer has been reversed.&lt;/p&gt;  &lt;p&gt;Once entirely reversed, a transfer can’t be reversed again. This method will return an error when called on an already-reversed transfer, or when trying to reverse more money than is left on a transfer.&lt;/p&gt;
    # @param id [String?]
    # @optional @param amount [Int64?] A positive integer in cents (or local equivalent) representing how much of this transfer to reverse. Can only reverse up to the unreversed amount remaining of the transfer. Partial transfer reversals are only allowed for transfers to Stripe Accounts. Defaults to the entire transfer amount.
    # @optional @param description [String?] An arbitrary string which you can attach to a reversal object. It is displayed alongside the reversal in the Dashboard. This will be unset if you POST an empty value.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param refund_application_fee [Bool?] Boolean indicating whether the application fee should be refunded when reversing this transfer. If a full transfer reversal is given, the full application fee will be refunded. Otherwise, the application fee will be refunded with an amount proportional to the amount of the transfer reversed.
    # @return nil
    def post_transfers_id_reversals(*, id : String? = nil, amount : Int64? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, refund_application_fee : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_post_transfers_id_reversals(id: id, amount: amount, description: description, expand: expand, metadata: metadata, refund_application_fee: refund_application_fee).execute(&block)
    end

    POST_TRANSFERS_ID_REVERSALS_MAX_LENGTH_FOR_ID          = 5000
    POST_TRANSFERS_ID_REVERSALS_MAX_LENGTH_FOR_DESCRIPTION = 5000

    # @return Crest::Request
    def build_api_request_for_post_transfers_id_reversals(*, id : String? = nil, amount : Int64? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, refund_application_fee : Bool? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_transfers_id_reversals ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_TRANSFERS_ID_REVERSALS_MAX_LENGTH_FOR_ID)
        end

        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_TRANSFERS_ID_REVERSALS_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/transfers/{id}/reversals".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["refund_application_fee"] = refund_application_fee.to_s if !refund_application_fee.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_transfers_id_reversals",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the specified transfer by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>  <p>This request accepts only metadata as an argument.</p>
    # @param transfer [String?]
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Transfer]
    def post_transfers_transfer(*, transfer : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_transfers_transfer_with_http_info(transfer: transfer, description: description, expand: expand, metadata: metadata)
      data
    end

    # &lt;p&gt;Updates the specified transfer by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;  &lt;p&gt;This request accepts only metadata as an argument.&lt;/p&gt;
    # @param transfer [String?]
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(Transfer, Integer, Hash)>] Transfer data, response status code and response headers
    def post_transfers_transfer_with_http_info(*, transfer : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_transfers_transfer(transfer: transfer, description: description, expand: expand, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_transfers_transfer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Transfer.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the specified transfer by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;  &lt;p&gt;This request accepts only metadata as an argument.&lt;/p&gt;
    # @param transfer [String?]
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_transfers_transfer(*, transfer : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_transfers_transfer(transfer: transfer, description: description, expand: expand, metadata: metadata).execute(&block)
    end

    POST_TRANSFERS_TRANSFER_MAX_LENGTH_FOR_TRANSFER    = 5000
    POST_TRANSFERS_TRANSFER_MAX_LENGTH_FOR_DESCRIPTION = 5000

    # @return Crest::Request
    def build_api_request_for_post_transfers_transfer(*, transfer : String? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_transfers_transfer ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"transfer\" is required and cannot be null") if transfer.nil?
        if _transfer = transfer
          OpenApi::PrimitiveValidator.validate_max_length("transfer", transfer.to_s.size, POST_TRANSFERS_TRANSFER_MAX_LENGTH_FOR_TRANSFER)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_TRANSFERS_TRANSFER_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/transfers/{transfer}".sub("{" + "transfer" + "}", URI.encode_path(transfer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["description"] = description.to_s if !description.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_transfers_transfer",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the specified reversal by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>  <p>This request only accepts metadata and description as arguments.</p>
    # @param id [String?]
    # @param transfer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [TransferReversal]
    def post_transfers_transfer_reversals_id(*, id : String? = nil, transfer : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_transfers_transfer_reversals_id_with_http_info(id: id, transfer: transfer, expand: expand, metadata: metadata)
      data
    end

    # &lt;p&gt;Updates the specified reversal by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;  &lt;p&gt;This request only accepts metadata and description as arguments.&lt;/p&gt;
    # @param id [String?]
    # @param transfer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(TransferReversal, Integer, Hash)>] TransferReversal data, response status code and response headers
    def post_transfers_transfer_reversals_id_with_http_info(*, id : String? = nil, transfer : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_transfers_transfer_reversals_id(id: id, transfer: transfer, expand: expand, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_transfers_transfer_reversals_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TransferReversal.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the specified reversal by setting the values of the parameters passed. Any parameters not provided will be left unchanged.&lt;/p&gt;  &lt;p&gt;This request only accepts metadata and description as arguments.&lt;/p&gt;
    # @param id [String?]
    # @param transfer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_transfers_transfer_reversals_id(*, id : String? = nil, transfer : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_transfers_transfer_reversals_id(id: id, transfer: transfer, expand: expand, metadata: metadata).execute(&block)
    end

    POST_TRANSFERS_TRANSFER_REVERSALS_ID_MAX_LENGTH_FOR_ID       = 5000
    POST_TRANSFERS_TRANSFER_REVERSALS_ID_MAX_LENGTH_FOR_TRANSFER = 5000

    # @return Crest::Request
    def build_api_request_for_post_transfers_transfer_reversals_id(*, id : String? = nil, transfer : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_transfers_transfer_reversals_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_TRANSFERS_TRANSFER_REVERSALS_ID_MAX_LENGTH_FOR_ID)
        end
        raise ArgumentError.new("\"transfer\" is required and cannot be null") if transfer.nil?
        if _transfer = transfer
          OpenApi::PrimitiveValidator.validate_max_length("transfer", transfer.to_s.size, POST_TRANSFERS_TRANSFER_REVERSALS_ID_MAX_LENGTH_FOR_TRANSFER)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/transfers/{transfer}/reversals/{id}".sub("{" + "id" + "}", URI.encode_path(id.to_s)).sub("{" + "transfer" + "}", URI.encode_path(transfer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_transfers_transfer_reversals_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Reverses a ReceivedCredit and creates a CreditReversal object.</p>
    # @param received_credit [String?] The ReceivedCredit to reverse.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [TreasuryCreditReversal]
    def post_treasury_credit_reversals(*, received_credit : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_treasury_credit_reversals_with_http_info(received_credit: received_credit, expand: expand)
      data
    end

    # &lt;p&gt;Reverses a ReceivedCredit and creates a CreditReversal object.&lt;/p&gt;
    # @param received_credit [String?] The ReceivedCredit to reverse.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryCreditReversal, Integer, Hash)>] TreasuryCreditReversal data, response status code and response headers
    def post_treasury_credit_reversals_with_http_info(*, received_credit : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_treasury_credit_reversals(received_credit: received_credit, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_treasury_credit_reversals\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryCreditReversal.from_json(data), status_code, headers
    end

    # &lt;p&gt;Reverses a ReceivedCredit and creates a CreditReversal object.&lt;/p&gt;
    # @param received_credit [String?] The ReceivedCredit to reverse.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_treasury_credit_reversals(*, received_credit : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_treasury_credit_reversals(received_credit: received_credit, expand: expand).execute(&block)
    end

    POST_TREASURY_CREDIT_REVERSALS_MAX_LENGTH_FOR_RECEIVED_CREDIT = 5000

    # @return Crest::Request
    def build_api_request_for_post_treasury_credit_reversals(*, received_credit : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_treasury_credit_reversals ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"received_credit\" is required and cannot be null") if received_credit.nil?
        if _received_credit = received_credit
          OpenApi::PrimitiveValidator.validate_max_length("received_credit", received_credit.to_s.size, POST_TREASURY_CREDIT_REVERSALS_MAX_LENGTH_FOR_RECEIVED_CREDIT)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/credit_reversals"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["received_credit"] = received_credit.to_s if !received_credit.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_treasury_credit_reversals",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Reverses a ReceivedDebit and creates a DebitReversal object.</p>
    # @param received_debit [String?] The ReceivedDebit to reverse.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [TreasuryDebitReversal]
    def post_treasury_debit_reversals(*, received_debit : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_treasury_debit_reversals_with_http_info(received_debit: received_debit, expand: expand)
      data
    end

    # &lt;p&gt;Reverses a ReceivedDebit and creates a DebitReversal object.&lt;/p&gt;
    # @param received_debit [String?] The ReceivedDebit to reverse.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryDebitReversal, Integer, Hash)>] TreasuryDebitReversal data, response status code and response headers
    def post_treasury_debit_reversals_with_http_info(*, received_debit : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_treasury_debit_reversals(received_debit: received_debit, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_treasury_debit_reversals\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryDebitReversal.from_json(data), status_code, headers
    end

    # &lt;p&gt;Reverses a ReceivedDebit and creates a DebitReversal object.&lt;/p&gt;
    # @param received_debit [String?] The ReceivedDebit to reverse.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_treasury_debit_reversals(*, received_debit : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_treasury_debit_reversals(received_debit: received_debit, expand: expand).execute(&block)
    end

    POST_TREASURY_DEBIT_REVERSALS_MAX_LENGTH_FOR_RECEIVED_DEBIT = 5000

    # @return Crest::Request
    def build_api_request_for_post_treasury_debit_reversals(*, received_debit : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_treasury_debit_reversals ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"received_debit\" is required and cannot be null") if received_debit.nil?
        if _received_debit = received_debit
          OpenApi::PrimitiveValidator.validate_max_length("received_debit", received_debit.to_s.size, POST_TREASURY_DEBIT_REVERSALS_MAX_LENGTH_FOR_RECEIVED_DEBIT)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/debit_reversals"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["received_debit"] = received_debit.to_s if !received_debit.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_treasury_debit_reversals",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new FinancialAccount. For now, each connected account can only have one FinancialAccount.</p>
    # @param supported_currencies [Array(String)?] The currencies the FinancialAccount can hold a balance in.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param features [Stripe::FeatureAccess?]
    # @optional @param platform_restrictions [Stripe::PlatformRestrictions?]
    # @return [TreasuryFinancialAccount]
    def post_treasury_financial_accounts(*, supported_currencies : Array(String)? = nil, expand : Array(String)? = nil, features : Stripe::FeatureAccess? = nil, platform_restrictions : Stripe::PlatformRestrictions? = nil)
      data, _status_code, _headers = post_treasury_financial_accounts_with_http_info(supported_currencies: supported_currencies, expand: expand, features: features, platform_restrictions: platform_restrictions)
      data
    end

    # &lt;p&gt;Creates a new FinancialAccount. For now, each connected account can only have one FinancialAccount.&lt;/p&gt;
    # @param supported_currencies [Array(String)?] The currencies the FinancialAccount can hold a balance in.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param features [Stripe::FeatureAccess?]
    # @optional @param platform_restrictions [Stripe::PlatformRestrictions?]
    # @return [Array<(TreasuryFinancialAccount, Integer, Hash)>] TreasuryFinancialAccount data, response status code and response headers
    def post_treasury_financial_accounts_with_http_info(*, supported_currencies : Array(String)? = nil, expand : Array(String)? = nil, features : Stripe::FeatureAccess? = nil, platform_restrictions : Stripe::PlatformRestrictions? = nil)
      request = build_api_request_for_post_treasury_financial_accounts(supported_currencies: supported_currencies, expand: expand, features: features, platform_restrictions: platform_restrictions)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_treasury_financial_accounts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryFinancialAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates a new FinancialAccount. For now, each connected account can only have one FinancialAccount.&lt;/p&gt;
    # @param supported_currencies [Array(String)?] The currencies the FinancialAccount can hold a balance in.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param features [Stripe::FeatureAccess?]
    # @optional @param platform_restrictions [Stripe::PlatformRestrictions?]
    # @return nil
    def post_treasury_financial_accounts(*, supported_currencies : Array(String)? = nil, expand : Array(String)? = nil, features : Stripe::FeatureAccess? = nil, platform_restrictions : Stripe::PlatformRestrictions? = nil, &block : Crest::Response ->)
      build_api_request_for_post_treasury_financial_accounts(supported_currencies: supported_currencies, expand: expand, features: features, platform_restrictions: platform_restrictions).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_post_treasury_financial_accounts(*, supported_currencies : Array(String)? = nil, expand : Array(String)? = nil, features : Stripe::FeatureAccess? = nil, platform_restrictions : Stripe::PlatformRestrictions? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_treasury_financial_accounts ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"supported_currencies\" is required and cannot be null") if supported_currencies.nil?

        if _features = features
          _features.validate if _features.is_a?(OpenApi::Validatable)
        end
        if _platform_restrictions = platform_restrictions
          _platform_restrictions.validate if _platform_restrictions.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/financial_accounts"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["features"] = features.to_s if !features.nil?
      form_params["platform_restrictions"] = platform_restrictions.to_s if !platform_restrictions.nil?
      form_params["supported_currencies"] = @api_client.build_collection_param(supported_currencies, "csv") if !supported_currencies.nil? && !supported_currencies.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_treasury_financial_accounts",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the details of a FinancialAccount.</p>
    # @param financial_account [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param features [Stripe::FeatureAccess1?]
    # @optional @param platform_restrictions [Stripe::PlatformRestrictions?]
    # @return [TreasuryFinancialAccount]
    def post_treasury_financial_accounts_financial_account(*, financial_account : String? = nil, expand : Array(String)? = nil, features : Stripe::FeatureAccess1? = nil, platform_restrictions : Stripe::PlatformRestrictions? = nil)
      data, _status_code, _headers = post_treasury_financial_accounts_financial_account_with_http_info(financial_account: financial_account, expand: expand, features: features, platform_restrictions: platform_restrictions)
      data
    end

    # &lt;p&gt;Updates the details of a FinancialAccount.&lt;/p&gt;
    # @param financial_account [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param features [Stripe::FeatureAccess1?]
    # @optional @param platform_restrictions [Stripe::PlatformRestrictions?]
    # @return [Array<(TreasuryFinancialAccount, Integer, Hash)>] TreasuryFinancialAccount data, response status code and response headers
    def post_treasury_financial_accounts_financial_account_with_http_info(*, financial_account : String? = nil, expand : Array(String)? = nil, features : Stripe::FeatureAccess1? = nil, platform_restrictions : Stripe::PlatformRestrictions? = nil)
      request = build_api_request_for_post_treasury_financial_accounts_financial_account(financial_account: financial_account, expand: expand, features: features, platform_restrictions: platform_restrictions)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_treasury_financial_accounts_financial_account\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryFinancialAccount.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the details of a FinancialAccount.&lt;/p&gt;
    # @param financial_account [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param features [Stripe::FeatureAccess1?]
    # @optional @param platform_restrictions [Stripe::PlatformRestrictions?]
    # @return nil
    def post_treasury_financial_accounts_financial_account(*, financial_account : String? = nil, expand : Array(String)? = nil, features : Stripe::FeatureAccess1? = nil, platform_restrictions : Stripe::PlatformRestrictions? = nil, &block : Crest::Response ->)
      build_api_request_for_post_treasury_financial_accounts_financial_account(financial_account: financial_account, expand: expand, features: features, platform_restrictions: platform_restrictions).execute(&block)
    end

    POST_TREASURY_FINANCIAL_ACCOUNTS_FINANCIAL_ACCOUNT_MAX_LENGTH_FOR_FINANCIAL_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_post_treasury_financial_accounts_financial_account(*, financial_account : String? = nil, expand : Array(String)? = nil, features : Stripe::FeatureAccess1? = nil, platform_restrictions : Stripe::PlatformRestrictions? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_treasury_financial_accounts_financial_account ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"financial_account\" is required and cannot be null") if financial_account.nil?
        if _financial_account = financial_account
          OpenApi::PrimitiveValidator.validate_max_length("financial_account", financial_account.to_s.size, POST_TREASURY_FINANCIAL_ACCOUNTS_FINANCIAL_ACCOUNT_MAX_LENGTH_FOR_FINANCIAL_ACCOUNT)
        end

        if _features = features
          _features.validate if _features.is_a?(OpenApi::Validatable)
        end
        if _platform_restrictions = platform_restrictions
          _platform_restrictions.validate if _platform_restrictions.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/financial_accounts/{financial_account}".sub("{" + "financial_account" + "}", URI.encode_path(financial_account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["features"] = features.to_s if !features.nil?
      form_params["platform_restrictions"] = platform_restrictions.to_s if !platform_restrictions.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_treasury_financial_accounts_financial_account",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the Features associated with a FinancialAccount.</p>
    # @param financial_account [String?]
    # @optional @param card_issuing [Stripe::Access1?]
    # @optional @param deposit_insurance [Stripe::Access2?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param financial_addresses [Stripe::FinancialAddresses1?]
    # @optional @param inbound_transfers [Stripe::InboundTransfers2?]
    # @optional @param intra_stripe_flows [Stripe::Access3?]
    # @optional @param outbound_payments [Stripe::OutboundPayments1?]
    # @optional @param outbound_transfers [Stripe::OutboundTransfers1?]
    # @return [TreasuryFinancialAccountFeatures]
    def post_treasury_financial_accounts_financial_account_features(*, financial_account : String? = nil, card_issuing : Stripe::Access1? = nil, deposit_insurance : Stripe::Access2? = nil, expand : Array(String)? = nil, financial_addresses : Stripe::FinancialAddresses1? = nil, inbound_transfers : Stripe::InboundTransfers2? = nil, intra_stripe_flows : Stripe::Access3? = nil, outbound_payments : Stripe::OutboundPayments1? = nil, outbound_transfers : Stripe::OutboundTransfers1? = nil)
      data, _status_code, _headers = post_treasury_financial_accounts_financial_account_features_with_http_info(financial_account: financial_account, card_issuing: card_issuing, deposit_insurance: deposit_insurance, expand: expand, financial_addresses: financial_addresses, inbound_transfers: inbound_transfers, intra_stripe_flows: intra_stripe_flows, outbound_payments: outbound_payments, outbound_transfers: outbound_transfers)
      data
    end

    # &lt;p&gt;Updates the Features associated with a FinancialAccount.&lt;/p&gt;
    # @param financial_account [String?]
    # @optional @param card_issuing [Stripe::Access1?]
    # @optional @param deposit_insurance [Stripe::Access2?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param financial_addresses [Stripe::FinancialAddresses1?]
    # @optional @param inbound_transfers [Stripe::InboundTransfers2?]
    # @optional @param intra_stripe_flows [Stripe::Access3?]
    # @optional @param outbound_payments [Stripe::OutboundPayments1?]
    # @optional @param outbound_transfers [Stripe::OutboundTransfers1?]
    # @return [Array<(TreasuryFinancialAccountFeatures, Integer, Hash)>] TreasuryFinancialAccountFeatures data, response status code and response headers
    def post_treasury_financial_accounts_financial_account_features_with_http_info(*, financial_account : String? = nil, card_issuing : Stripe::Access1? = nil, deposit_insurance : Stripe::Access2? = nil, expand : Array(String)? = nil, financial_addresses : Stripe::FinancialAddresses1? = nil, inbound_transfers : Stripe::InboundTransfers2? = nil, intra_stripe_flows : Stripe::Access3? = nil, outbound_payments : Stripe::OutboundPayments1? = nil, outbound_transfers : Stripe::OutboundTransfers1? = nil)
      request = build_api_request_for_post_treasury_financial_accounts_financial_account_features(financial_account: financial_account, card_issuing: card_issuing, deposit_insurance: deposit_insurance, expand: expand, financial_addresses: financial_addresses, inbound_transfers: inbound_transfers, intra_stripe_flows: intra_stripe_flows, outbound_payments: outbound_payments, outbound_transfers: outbound_transfers)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_treasury_financial_accounts_financial_account_features\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryFinancialAccountFeatures.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the Features associated with a FinancialAccount.&lt;/p&gt;
    # @param financial_account [String?]
    # @optional @param card_issuing [Stripe::Access1?]
    # @optional @param deposit_insurance [Stripe::Access2?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param financial_addresses [Stripe::FinancialAddresses1?]
    # @optional @param inbound_transfers [Stripe::InboundTransfers2?]
    # @optional @param intra_stripe_flows [Stripe::Access3?]
    # @optional @param outbound_payments [Stripe::OutboundPayments1?]
    # @optional @param outbound_transfers [Stripe::OutboundTransfers1?]
    # @return nil
    def post_treasury_financial_accounts_financial_account_features(*, financial_account : String? = nil, card_issuing : Stripe::Access1? = nil, deposit_insurance : Stripe::Access2? = nil, expand : Array(String)? = nil, financial_addresses : Stripe::FinancialAddresses1? = nil, inbound_transfers : Stripe::InboundTransfers2? = nil, intra_stripe_flows : Stripe::Access3? = nil, outbound_payments : Stripe::OutboundPayments1? = nil, outbound_transfers : Stripe::OutboundTransfers1? = nil, &block : Crest::Response ->)
      build_api_request_for_post_treasury_financial_accounts_financial_account_features(financial_account: financial_account, card_issuing: card_issuing, deposit_insurance: deposit_insurance, expand: expand, financial_addresses: financial_addresses, inbound_transfers: inbound_transfers, intra_stripe_flows: intra_stripe_flows, outbound_payments: outbound_payments, outbound_transfers: outbound_transfers).execute(&block)
    end

    POST_TREASURY_FINANCIAL_ACCOUNTS_FINANCIAL_ACCOUNT_FEATURES_MAX_LENGTH_FOR_FINANCIAL_ACCOUNT = 5000

    # @return Crest::Request
    def build_api_request_for_post_treasury_financial_accounts_financial_account_features(*, financial_account : String? = nil, card_issuing : Stripe::Access1? = nil, deposit_insurance : Stripe::Access2? = nil, expand : Array(String)? = nil, financial_addresses : Stripe::FinancialAddresses1? = nil, inbound_transfers : Stripe::InboundTransfers2? = nil, intra_stripe_flows : Stripe::Access3? = nil, outbound_payments : Stripe::OutboundPayments1? = nil, outbound_transfers : Stripe::OutboundTransfers1? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_treasury_financial_accounts_financial_account_features ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"financial_account\" is required and cannot be null") if financial_account.nil?
        if _financial_account = financial_account
          OpenApi::PrimitiveValidator.validate_max_length("financial_account", financial_account.to_s.size, POST_TREASURY_FINANCIAL_ACCOUNTS_FINANCIAL_ACCOUNT_FEATURES_MAX_LENGTH_FOR_FINANCIAL_ACCOUNT)
        end
        if _card_issuing = card_issuing
          _card_issuing.validate if _card_issuing.is_a?(OpenApi::Validatable)
        end
        if _deposit_insurance = deposit_insurance
          _deposit_insurance.validate if _deposit_insurance.is_a?(OpenApi::Validatable)
        end

        if _financial_addresses = financial_addresses
          _financial_addresses.validate if _financial_addresses.is_a?(OpenApi::Validatable)
        end
        if _inbound_transfers = inbound_transfers
          _inbound_transfers.validate if _inbound_transfers.is_a?(OpenApi::Validatable)
        end
        if _intra_stripe_flows = intra_stripe_flows
          _intra_stripe_flows.validate if _intra_stripe_flows.is_a?(OpenApi::Validatable)
        end
        if _outbound_payments = outbound_payments
          _outbound_payments.validate if _outbound_payments.is_a?(OpenApi::Validatable)
        end
        if _outbound_transfers = outbound_transfers
          _outbound_transfers.validate if _outbound_transfers.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/financial_accounts/{financial_account}/features".sub("{" + "financial_account" + "}", URI.encode_path(financial_account.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["card_issuing"] = card_issuing.to_s if !card_issuing.nil?
      form_params["deposit_insurance"] = deposit_insurance.to_s if !deposit_insurance.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["financial_addresses"] = financial_addresses.to_s if !financial_addresses.nil?
      form_params["inbound_transfers"] = inbound_transfers.to_s if !inbound_transfers.nil?
      form_params["intra_stripe_flows"] = intra_stripe_flows.to_s if !intra_stripe_flows.nil?
      form_params["outbound_payments"] = outbound_payments.to_s if !outbound_payments.nil?
      form_params["outbound_transfers"] = outbound_transfers.to_s if !outbound_transfers.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_treasury_financial_accounts_financial_account_features",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates an InboundTransfer.</p>
    # @param amount [Int64?] Amount (in cents) to be transferred.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param financial_account [String?] The FinancialAccount to send funds to.
    # @param origin_payment_method [String?] The origin payment method to be debited for the InboundTransfer.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param statement_descriptor [String?] The complete description that appears on your customers' statements. Maximum 10 characters.
    # @return [TreasuryInboundTransfer]
    def post_treasury_inbound_transfers(*, amount : Int64? = nil, currency : String? = nil, financial_account : String? = nil, origin_payment_method : String? = nil, description : String? = nil, expand : Array(String)? = nil, statement_descriptor : String? = nil)
      data, _status_code, _headers = post_treasury_inbound_transfers_with_http_info(amount: amount, currency: currency, financial_account: financial_account, origin_payment_method: origin_payment_method, description: description, expand: expand, statement_descriptor: statement_descriptor)
      data
    end

    # &lt;p&gt;Creates an InboundTransfer.&lt;/p&gt;
    # @param amount [Int64?] Amount (in cents) to be transferred.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param financial_account [String?] The FinancialAccount to send funds to.
    # @param origin_payment_method [String?] The origin payment method to be debited for the InboundTransfer.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param statement_descriptor [String?] The complete description that appears on your customers' statements. Maximum 10 characters.
    # @return [Array<(TreasuryInboundTransfer, Integer, Hash)>] TreasuryInboundTransfer data, response status code and response headers
    def post_treasury_inbound_transfers_with_http_info(*, amount : Int64? = nil, currency : String? = nil, financial_account : String? = nil, origin_payment_method : String? = nil, description : String? = nil, expand : Array(String)? = nil, statement_descriptor : String? = nil)
      request = build_api_request_for_post_treasury_inbound_transfers(amount: amount, currency: currency, financial_account: financial_account, origin_payment_method: origin_payment_method, description: description, expand: expand, statement_descriptor: statement_descriptor)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_treasury_inbound_transfers\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryInboundTransfer.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates an InboundTransfer.&lt;/p&gt;
    # @param amount [Int64?] Amount (in cents) to be transferred.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param financial_account [String?] The FinancialAccount to send funds to.
    # @param origin_payment_method [String?] The origin payment method to be debited for the InboundTransfer.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param statement_descriptor [String?] The complete description that appears on your customers' statements. Maximum 10 characters.
    # @return nil
    def post_treasury_inbound_transfers(*, amount : Int64? = nil, currency : String? = nil, financial_account : String? = nil, origin_payment_method : String? = nil, description : String? = nil, expand : Array(String)? = nil, statement_descriptor : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_treasury_inbound_transfers(amount: amount, currency: currency, financial_account: financial_account, origin_payment_method: origin_payment_method, description: description, expand: expand, statement_descriptor: statement_descriptor).execute(&block)
    end

    POST_TREASURY_INBOUND_TRANSFERS_MAX_LENGTH_FOR_ORIGIN_PAYMENT_METHOD = 5000
    POST_TREASURY_INBOUND_TRANSFERS_MAX_LENGTH_FOR_DESCRIPTION           = 5000
    POST_TREASURY_INBOUND_TRANSFERS_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR  =   10

    # @return Crest::Request
    def build_api_request_for_post_treasury_inbound_transfers(*, amount : Int64? = nil, currency : String? = nil, financial_account : String? = nil, origin_payment_method : String? = nil, description : String? = nil, expand : Array(String)? = nil, statement_descriptor : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_treasury_inbound_transfers ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"amount\" is required and cannot be null") if amount.nil?

        raise ArgumentError.new("\"currency\" is required and cannot be null") if currency.nil?

        raise ArgumentError.new("\"financial_account\" is required and cannot be null") if financial_account.nil?

        raise ArgumentError.new("\"origin_payment_method\" is required and cannot be null") if origin_payment_method.nil?
        if _origin_payment_method = origin_payment_method
          OpenApi::PrimitiveValidator.validate_max_length("origin_payment_method", origin_payment_method.to_s.size, POST_TREASURY_INBOUND_TRANSFERS_MAX_LENGTH_FOR_ORIGIN_PAYMENT_METHOD)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_TREASURY_INBOUND_TRANSFERS_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _statement_descriptor = statement_descriptor
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor", statement_descriptor.to_s.size, POST_TREASURY_INBOUND_TRANSFERS_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/inbound_transfers"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["financial_account"] = financial_account.to_s if !financial_account.nil?
      form_params["origin_payment_method"] = origin_payment_method.to_s if !origin_payment_method.nil?
      form_params["statement_descriptor"] = statement_descriptor.to_s if !statement_descriptor.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_treasury_inbound_transfers",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Cancels an InboundTransfer.</p>
    # @param inbound_transfer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [TreasuryInboundTransfer]
    def post_treasury_inbound_transfers_inbound_transfer_cancel(*, inbound_transfer : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_treasury_inbound_transfers_inbound_transfer_cancel_with_http_info(inbound_transfer: inbound_transfer, expand: expand)
      data
    end

    # &lt;p&gt;Cancels an InboundTransfer.&lt;/p&gt;
    # @param inbound_transfer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryInboundTransfer, Integer, Hash)>] TreasuryInboundTransfer data, response status code and response headers
    def post_treasury_inbound_transfers_inbound_transfer_cancel_with_http_info(*, inbound_transfer : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_treasury_inbound_transfers_inbound_transfer_cancel(inbound_transfer: inbound_transfer, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_treasury_inbound_transfers_inbound_transfer_cancel\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryInboundTransfer.from_json(data), status_code, headers
    end

    # &lt;p&gt;Cancels an InboundTransfer.&lt;/p&gt;
    # @param inbound_transfer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_treasury_inbound_transfers_inbound_transfer_cancel(*, inbound_transfer : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_treasury_inbound_transfers_inbound_transfer_cancel(inbound_transfer: inbound_transfer, expand: expand).execute(&block)
    end

    POST_TREASURY_INBOUND_TRANSFERS_INBOUND_TRANSFER_CANCEL_MAX_LENGTH_FOR_INBOUND_TRANSFER = 5000

    # @return Crest::Request
    def build_api_request_for_post_treasury_inbound_transfers_inbound_transfer_cancel(*, inbound_transfer : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_treasury_inbound_transfers_inbound_transfer_cancel ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"inbound_transfer\" is required and cannot be null") if inbound_transfer.nil?
        if _inbound_transfer = inbound_transfer
          OpenApi::PrimitiveValidator.validate_max_length("inbound_transfer", inbound_transfer.to_s.size, POST_TREASURY_INBOUND_TRANSFERS_INBOUND_TRANSFER_CANCEL_MAX_LENGTH_FOR_INBOUND_TRANSFER)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/inbound_transfers/{inbound_transfer}/cancel".sub("{" + "inbound_transfer" + "}", URI.encode_path(inbound_transfer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_treasury_inbound_transfers_inbound_transfer_cancel",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates an OutboundPayment.</p>
    # @param amount [Int64?] Amount (in cents) to be transferred.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param financial_account [String?] The FinancialAccount to pull funds from.
    # @optional @param customer [String?] ID of the customer to whom the OutboundPayment is sent. Must match the Customer attached to the `destination_payment_method` passed in.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param destination_payment_method [String?] The PaymentMethod to use as the payment instrument for the OutboundPayment. Exclusive with `destination_payment_method_data`.
    # @optional @param destination_payment_method_data [Stripe::PaymentMethodData?]
    # @optional @param destination_payment_method_options [Stripe::PaymentMethodOptions2?]
    # @optional @param end_user_details [Stripe::EndUserDetailsParams?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param statement_descriptor [String?] The description that appears on the receiving end for this OutboundPayment (for example, bank statement for external bank transfer). Maximum 10 characters for `ach` payments, 140 characters for `wire` payments, or 500 characters for `stripe` network transfers. The default value is `payment`.
    # @return [TreasuryOutboundPayment]
    def post_treasury_outbound_payments(*, amount : Int64? = nil, currency : String? = nil, financial_account : String? = nil, customer : String? = nil, description : String? = nil, destination_payment_method : String? = nil, destination_payment_method_data : Stripe::PaymentMethodData? = nil, destination_payment_method_options : Stripe::PaymentMethodOptions2? = nil, end_user_details : Stripe::EndUserDetailsParams? = nil, expand : Array(String)? = nil, statement_descriptor : String? = nil)
      data, _status_code, _headers = post_treasury_outbound_payments_with_http_info(amount: amount, currency: currency, financial_account: financial_account, customer: customer, description: description, destination_payment_method: destination_payment_method, destination_payment_method_data: destination_payment_method_data, destination_payment_method_options: destination_payment_method_options, end_user_details: end_user_details, expand: expand, statement_descriptor: statement_descriptor)
      data
    end

    # &lt;p&gt;Creates an OutboundPayment.&lt;/p&gt;
    # @param amount [Int64?] Amount (in cents) to be transferred.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param financial_account [String?] The FinancialAccount to pull funds from.
    # @optional @param customer [String?] ID of the customer to whom the OutboundPayment is sent. Must match the Customer attached to the `destination_payment_method` passed in.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param destination_payment_method [String?] The PaymentMethod to use as the payment instrument for the OutboundPayment. Exclusive with `destination_payment_method_data`.
    # @optional @param destination_payment_method_data [Stripe::PaymentMethodData?]
    # @optional @param destination_payment_method_options [Stripe::PaymentMethodOptions2?]
    # @optional @param end_user_details [Stripe::EndUserDetailsParams?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param statement_descriptor [String?] The description that appears on the receiving end for this OutboundPayment (for example, bank statement for external bank transfer). Maximum 10 characters for `ach` payments, 140 characters for `wire` payments, or 500 characters for `stripe` network transfers. The default value is `payment`.
    # @return [Array<(TreasuryOutboundPayment, Integer, Hash)>] TreasuryOutboundPayment data, response status code and response headers
    def post_treasury_outbound_payments_with_http_info(*, amount : Int64? = nil, currency : String? = nil, financial_account : String? = nil, customer : String? = nil, description : String? = nil, destination_payment_method : String? = nil, destination_payment_method_data : Stripe::PaymentMethodData? = nil, destination_payment_method_options : Stripe::PaymentMethodOptions2? = nil, end_user_details : Stripe::EndUserDetailsParams? = nil, expand : Array(String)? = nil, statement_descriptor : String? = nil)
      request = build_api_request_for_post_treasury_outbound_payments(amount: amount, currency: currency, financial_account: financial_account, customer: customer, description: description, destination_payment_method: destination_payment_method, destination_payment_method_data: destination_payment_method_data, destination_payment_method_options: destination_payment_method_options, end_user_details: end_user_details, expand: expand, statement_descriptor: statement_descriptor)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_treasury_outbound_payments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryOutboundPayment.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates an OutboundPayment.&lt;/p&gt;
    # @param amount [Int64?] Amount (in cents) to be transferred.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param financial_account [String?] The FinancialAccount to pull funds from.
    # @optional @param customer [String?] ID of the customer to whom the OutboundPayment is sent. Must match the Customer attached to the `destination_payment_method` passed in.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param destination_payment_method [String?] The PaymentMethod to use as the payment instrument for the OutboundPayment. Exclusive with `destination_payment_method_data`.
    # @optional @param destination_payment_method_data [Stripe::PaymentMethodData?]
    # @optional @param destination_payment_method_options [Stripe::PaymentMethodOptions2?]
    # @optional @param end_user_details [Stripe::EndUserDetailsParams?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param statement_descriptor [String?] The description that appears on the receiving end for this OutboundPayment (for example, bank statement for external bank transfer). Maximum 10 characters for `ach` payments, 140 characters for `wire` payments, or 500 characters for `stripe` network transfers. The default value is `payment`.
    # @return nil
    def post_treasury_outbound_payments(*, amount : Int64? = nil, currency : String? = nil, financial_account : String? = nil, customer : String? = nil, description : String? = nil, destination_payment_method : String? = nil, destination_payment_method_data : Stripe::PaymentMethodData? = nil, destination_payment_method_options : Stripe::PaymentMethodOptions2? = nil, end_user_details : Stripe::EndUserDetailsParams? = nil, expand : Array(String)? = nil, statement_descriptor : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_treasury_outbound_payments(amount: amount, currency: currency, financial_account: financial_account, customer: customer, description: description, destination_payment_method: destination_payment_method, destination_payment_method_data: destination_payment_method_data, destination_payment_method_options: destination_payment_method_options, end_user_details: end_user_details, expand: expand, statement_descriptor: statement_descriptor).execute(&block)
    end

    POST_TREASURY_OUTBOUND_PAYMENTS_MAX_LENGTH_FOR_CUSTOMER                   = 5000
    POST_TREASURY_OUTBOUND_PAYMENTS_MAX_LENGTH_FOR_DESCRIPTION                = 5000
    POST_TREASURY_OUTBOUND_PAYMENTS_MAX_LENGTH_FOR_DESTINATION_PAYMENT_METHOD = 5000
    POST_TREASURY_OUTBOUND_PAYMENTS_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR       = 5000

    # @return Crest::Request
    def build_api_request_for_post_treasury_outbound_payments(*, amount : Int64? = nil, currency : String? = nil, financial_account : String? = nil, customer : String? = nil, description : String? = nil, destination_payment_method : String? = nil, destination_payment_method_data : Stripe::PaymentMethodData? = nil, destination_payment_method_options : Stripe::PaymentMethodOptions2? = nil, end_user_details : Stripe::EndUserDetailsParams? = nil, expand : Array(String)? = nil, statement_descriptor : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_treasury_outbound_payments ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"amount\" is required and cannot be null") if amount.nil?

        raise ArgumentError.new("\"currency\" is required and cannot be null") if currency.nil?

        raise ArgumentError.new("\"financial_account\" is required and cannot be null") if financial_account.nil?

        if _customer = customer
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, POST_TREASURY_OUTBOUND_PAYMENTS_MAX_LENGTH_FOR_CUSTOMER)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_TREASURY_OUTBOUND_PAYMENTS_MAX_LENGTH_FOR_DESCRIPTION)
        end
        if _destination_payment_method = destination_payment_method
          OpenApi::PrimitiveValidator.validate_max_length("destination_payment_method", destination_payment_method.to_s.size, POST_TREASURY_OUTBOUND_PAYMENTS_MAX_LENGTH_FOR_DESTINATION_PAYMENT_METHOD)
        end
        if _destination_payment_method_data = destination_payment_method_data
          _destination_payment_method_data.validate if _destination_payment_method_data.is_a?(OpenApi::Validatable)
        end
        if _destination_payment_method_options = destination_payment_method_options
          _destination_payment_method_options.validate if _destination_payment_method_options.is_a?(OpenApi::Validatable)
        end
        if _end_user_details = end_user_details
          _end_user_details.validate if _end_user_details.is_a?(OpenApi::Validatable)
        end

        if _statement_descriptor = statement_descriptor
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor", statement_descriptor.to_s.size, POST_TREASURY_OUTBOUND_PAYMENTS_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/outbound_payments"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["customer"] = customer.to_s if !customer.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["destination_payment_method"] = destination_payment_method.to_s if !destination_payment_method.nil?
      form_params["destination_payment_method_data"] = destination_payment_method_data.to_s if !destination_payment_method_data.nil?
      form_params["destination_payment_method_options"] = destination_payment_method_options.to_s if !destination_payment_method_options.nil?
      form_params["end_user_details"] = end_user_details.to_s if !end_user_details.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["financial_account"] = financial_account.to_s if !financial_account.nil?
      form_params["statement_descriptor"] = statement_descriptor.to_s if !statement_descriptor.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_treasury_outbound_payments",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Cancel an OutboundPayment.</p>
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [TreasuryOutboundPayment]
    def post_treasury_outbound_payments_id_cancel(*, id : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_treasury_outbound_payments_id_cancel_with_http_info(id: id, expand: expand)
      data
    end

    # &lt;p&gt;Cancel an OutboundPayment.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryOutboundPayment, Integer, Hash)>] TreasuryOutboundPayment data, response status code and response headers
    def post_treasury_outbound_payments_id_cancel_with_http_info(*, id : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_treasury_outbound_payments_id_cancel(id: id, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_treasury_outbound_payments_id_cancel\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryOutboundPayment.from_json(data), status_code, headers
    end

    # &lt;p&gt;Cancel an OutboundPayment.&lt;/p&gt;
    # @param id [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_treasury_outbound_payments_id_cancel(*, id : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_treasury_outbound_payments_id_cancel(id: id, expand: expand).execute(&block)
    end

    POST_TREASURY_OUTBOUND_PAYMENTS_ID_CANCEL_MAX_LENGTH_FOR_ID = 5000

    # @return Crest::Request
    def build_api_request_for_post_treasury_outbound_payments_id_cancel(*, id : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_treasury_outbound_payments_id_cancel ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"id\" is required and cannot be null") if id.nil?
        if _id = id
          OpenApi::PrimitiveValidator.validate_max_length("id", id.to_s.size, POST_TREASURY_OUTBOUND_PAYMENTS_ID_CANCEL_MAX_LENGTH_FOR_ID)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/outbound_payments/{id}/cancel".sub("{" + "id" + "}", URI.encode_path(id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_treasury_outbound_payments_id_cancel",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates an OutboundTransfer.</p>
    # @param amount [Int64?] Amount (in cents) to be transferred.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param financial_account [String?] The FinancialAccount to pull funds from.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param destination_payment_method [String?] The PaymentMethod to use as the payment instrument for the OutboundTransfer.
    # @optional @param destination_payment_method_options [Stripe::PaymentMethodOptions3?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param statement_descriptor [String?] Statement descriptor to be shown on the receiving end of an OutboundTransfer. Maximum 10 characters for `ach` transfers or 140 characters for `wire` transfers. The default value is `transfer`.
    # @return [TreasuryOutboundTransfer]
    def post_treasury_outbound_transfers(*, amount : Int64? = nil, currency : String? = nil, financial_account : String? = nil, description : String? = nil, destination_payment_method : String? = nil, destination_payment_method_options : Stripe::PaymentMethodOptions3? = nil, expand : Array(String)? = nil, statement_descriptor : String? = nil)
      data, _status_code, _headers = post_treasury_outbound_transfers_with_http_info(amount: amount, currency: currency, financial_account: financial_account, description: description, destination_payment_method: destination_payment_method, destination_payment_method_options: destination_payment_method_options, expand: expand, statement_descriptor: statement_descriptor)
      data
    end

    # &lt;p&gt;Creates an OutboundTransfer.&lt;/p&gt;
    # @param amount [Int64?] Amount (in cents) to be transferred.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param financial_account [String?] The FinancialAccount to pull funds from.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param destination_payment_method [String?] The PaymentMethod to use as the payment instrument for the OutboundTransfer.
    # @optional @param destination_payment_method_options [Stripe::PaymentMethodOptions3?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param statement_descriptor [String?] Statement descriptor to be shown on the receiving end of an OutboundTransfer. Maximum 10 characters for `ach` transfers or 140 characters for `wire` transfers. The default value is `transfer`.
    # @return [Array<(TreasuryOutboundTransfer, Integer, Hash)>] TreasuryOutboundTransfer data, response status code and response headers
    def post_treasury_outbound_transfers_with_http_info(*, amount : Int64? = nil, currency : String? = nil, financial_account : String? = nil, description : String? = nil, destination_payment_method : String? = nil, destination_payment_method_options : Stripe::PaymentMethodOptions3? = nil, expand : Array(String)? = nil, statement_descriptor : String? = nil)
      request = build_api_request_for_post_treasury_outbound_transfers(amount: amount, currency: currency, financial_account: financial_account, description: description, destination_payment_method: destination_payment_method, destination_payment_method_options: destination_payment_method_options, expand: expand, statement_descriptor: statement_descriptor)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_treasury_outbound_transfers\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryOutboundTransfer.from_json(data), status_code, headers
    end

    # &lt;p&gt;Creates an OutboundTransfer.&lt;/p&gt;
    # @param amount [Int64?] Amount (in cents) to be transferred.
    # @param currency [String?] Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
    # @param financial_account [String?] The FinancialAccount to pull funds from.
    # @optional @param description [String?] An arbitrary string attached to the object. Often useful for displaying to users.
    # @optional @param destination_payment_method [String?] The PaymentMethod to use as the payment instrument for the OutboundTransfer.
    # @optional @param destination_payment_method_options [Stripe::PaymentMethodOptions3?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param statement_descriptor [String?] Statement descriptor to be shown on the receiving end of an OutboundTransfer. Maximum 10 characters for `ach` transfers or 140 characters for `wire` transfers. The default value is `transfer`.
    # @return nil
    def post_treasury_outbound_transfers(*, amount : Int64? = nil, currency : String? = nil, financial_account : String? = nil, description : String? = nil, destination_payment_method : String? = nil, destination_payment_method_options : Stripe::PaymentMethodOptions3? = nil, expand : Array(String)? = nil, statement_descriptor : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_treasury_outbound_transfers(amount: amount, currency: currency, financial_account: financial_account, description: description, destination_payment_method: destination_payment_method, destination_payment_method_options: destination_payment_method_options, expand: expand, statement_descriptor: statement_descriptor).execute(&block)
    end

    POST_TREASURY_OUTBOUND_TRANSFERS_MAX_LENGTH_FOR_DESCRIPTION                = 5000
    POST_TREASURY_OUTBOUND_TRANSFERS_MAX_LENGTH_FOR_DESTINATION_PAYMENT_METHOD = 5000
    POST_TREASURY_OUTBOUND_TRANSFERS_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR       = 5000

    # @return Crest::Request
    def build_api_request_for_post_treasury_outbound_transfers(*, amount : Int64? = nil, currency : String? = nil, financial_account : String? = nil, description : String? = nil, destination_payment_method : String? = nil, destination_payment_method_options : Stripe::PaymentMethodOptions3? = nil, expand : Array(String)? = nil, statement_descriptor : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_treasury_outbound_transfers ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"amount\" is required and cannot be null") if amount.nil?

        raise ArgumentError.new("\"currency\" is required and cannot be null") if currency.nil?

        raise ArgumentError.new("\"financial_account\" is required and cannot be null") if financial_account.nil?

        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_TREASURY_OUTBOUND_TRANSFERS_MAX_LENGTH_FOR_DESCRIPTION)
        end
        if _destination_payment_method = destination_payment_method
          OpenApi::PrimitiveValidator.validate_max_length("destination_payment_method", destination_payment_method.to_s.size, POST_TREASURY_OUTBOUND_TRANSFERS_MAX_LENGTH_FOR_DESTINATION_PAYMENT_METHOD)
        end
        if _destination_payment_method_options = destination_payment_method_options
          _destination_payment_method_options.validate if _destination_payment_method_options.is_a?(OpenApi::Validatable)
        end

        if _statement_descriptor = statement_descriptor
          OpenApi::PrimitiveValidator.validate_max_length("statement_descriptor", statement_descriptor.to_s.size, POST_TREASURY_OUTBOUND_TRANSFERS_MAX_LENGTH_FOR_STATEMENT_DESCRIPTOR)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/outbound_transfers"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["amount"] = amount.to_s if !amount.nil?
      form_params["currency"] = currency.to_s if !currency.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["destination_payment_method"] = destination_payment_method.to_s if !destination_payment_method.nil?
      form_params["destination_payment_method_options"] = destination_payment_method_options.to_s if !destination_payment_method_options.nil?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["financial_account"] = financial_account.to_s if !financial_account.nil?
      form_params["statement_descriptor"] = statement_descriptor.to_s if !statement_descriptor.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_treasury_outbound_transfers",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>An OutboundTransfer can be canceled if the funds have not yet been paid out.</p>
    # @param outbound_transfer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [TreasuryOutboundTransfer]
    def post_treasury_outbound_transfers_outbound_transfer_cancel(*, outbound_transfer : String? = nil, expand : Array(String)? = nil)
      data, _status_code, _headers = post_treasury_outbound_transfers_outbound_transfer_cancel_with_http_info(outbound_transfer: outbound_transfer, expand: expand)
      data
    end

    # &lt;p&gt;An OutboundTransfer can be canceled if the funds have not yet been paid out.&lt;/p&gt;
    # @param outbound_transfer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return [Array<(TreasuryOutboundTransfer, Integer, Hash)>] TreasuryOutboundTransfer data, response status code and response headers
    def post_treasury_outbound_transfers_outbound_transfer_cancel_with_http_info(*, outbound_transfer : String? = nil, expand : Array(String)? = nil)
      request = build_api_request_for_post_treasury_outbound_transfers_outbound_transfer_cancel(outbound_transfer: outbound_transfer, expand: expand)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_treasury_outbound_transfers_outbound_transfer_cancel\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TreasuryOutboundTransfer.from_json(data), status_code, headers
    end

    # &lt;p&gt;An OutboundTransfer can be canceled if the funds have not yet been paid out.&lt;/p&gt;
    # @param outbound_transfer [String?]
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @return nil
    def post_treasury_outbound_transfers_outbound_transfer_cancel(*, outbound_transfer : String? = nil, expand : Array(String)? = nil, &block : Crest::Response ->)
      build_api_request_for_post_treasury_outbound_transfers_outbound_transfer_cancel(outbound_transfer: outbound_transfer, expand: expand).execute(&block)
    end

    POST_TREASURY_OUTBOUND_TRANSFERS_OUTBOUND_TRANSFER_CANCEL_MAX_LENGTH_FOR_OUTBOUND_TRANSFER = 5000

    # @return Crest::Request
    def build_api_request_for_post_treasury_outbound_transfers_outbound_transfer_cancel(*, outbound_transfer : String? = nil, expand : Array(String)? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_treasury_outbound_transfers_outbound_transfer_cancel ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"outbound_transfer\" is required and cannot be null") if outbound_transfer.nil?
        if _outbound_transfer = outbound_transfer
          OpenApi::PrimitiveValidator.validate_max_length("outbound_transfer", outbound_transfer.to_s.size, POST_TREASURY_OUTBOUND_TRANSFERS_OUTBOUND_TRANSFER_CANCEL_MAX_LENGTH_FOR_OUTBOUND_TRANSFER)
        end
      end

      # resource path
      local_var_path = "/v1/treasury/outbound_transfers/{outbound_transfer}/cancel".sub("{" + "outbound_transfer" + "}", URI.encode_path(outbound_transfer.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_treasury_outbound_transfers_outbound_transfer_cancel",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>A webhook endpoint must have a <code>url</code> and a list of <code>enabled_events</code>. You may optionally specify the Boolean <code>connect</code> parameter. If set to true, then a Connect webhook endpoint that notifies the specified <code>url</code> about events from all connected accounts is created; otherwise an account webhook endpoint that notifies the specified <code>url</code> only about events from your account is created. You can also create webhook endpoints in the <a href=\"https://dashboard.stripe.com/account/webhooks\">webhooks settings</a> section of the Dashboard.</p>
    # @param enabled_events [Array(String)?] The list of events to enable for this endpoint. You may specify `['*']` to enable all events, except those that require explicit selection.
    # @param url [String?] The URL of the webhook endpoint.
    # @optional @param api_version [String?] Events sent to this endpoint will be generated with this Stripe Version instead of your account's default Stripe Version.
    # @optional @param connect [Bool?] Whether this endpoint should receive events from connected accounts (`true`), or from your account (`false`). Defaults to `false`.
    # @optional @param description [String?] An optional description of what the webhook is used for.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [WebhookEndpoint]
    def post_webhook_endpoints(*, enabled_events : Array(String)? = nil, url : String? = nil, api_version : String? = nil, connect : Bool? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      data, _status_code, _headers = post_webhook_endpoints_with_http_info(enabled_events: enabled_events, url: url, api_version: api_version, connect: connect, description: description, expand: expand, metadata: metadata)
      data
    end

    # &lt;p&gt;A webhook endpoint must have a &lt;code&gt;url&lt;/code&gt; and a list of &lt;code&gt;enabled_events&lt;/code&gt;. You may optionally specify the Boolean &lt;code&gt;connect&lt;/code&gt; parameter. If set to true, then a Connect webhook endpoint that notifies the specified &lt;code&gt;url&lt;/code&gt; about events from all connected accounts is created; otherwise an account webhook endpoint that notifies the specified &lt;code&gt;url&lt;/code&gt; only about events from your account is created. You can also create webhook endpoints in the &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/account/webhooks\&quot;&gt;webhooks settings&lt;/a&gt; section of the Dashboard.&lt;/p&gt;
    # @param enabled_events [Array(String)?] The list of events to enable for this endpoint. You may specify `['*']` to enable all events, except those that require explicit selection.
    # @param url [String?] The URL of the webhook endpoint.
    # @optional @param api_version [String?] Events sent to this endpoint will be generated with this Stripe Version instead of your account's default Stripe Version.
    # @optional @param connect [Bool?] Whether this endpoint should receive events from connected accounts (`true`), or from your account (`false`). Defaults to `false`.
    # @optional @param description [String?] An optional description of what the webhook is used for.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return [Array<(WebhookEndpoint, Integer, Hash)>] WebhookEndpoint data, response status code and response headers
    def post_webhook_endpoints_with_http_info(*, enabled_events : Array(String)? = nil, url : String? = nil, api_version : String? = nil, connect : Bool? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil)
      request = build_api_request_for_post_webhook_endpoints(enabled_events: enabled_events, url: url, api_version: api_version, connect: connect, description: description, expand: expand, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_webhook_endpoints\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return WebhookEndpoint.from_json(data), status_code, headers
    end

    # &lt;p&gt;A webhook endpoint must have a &lt;code&gt;url&lt;/code&gt; and a list of &lt;code&gt;enabled_events&lt;/code&gt;. You may optionally specify the Boolean &lt;code&gt;connect&lt;/code&gt; parameter. If set to true, then a Connect webhook endpoint that notifies the specified &lt;code&gt;url&lt;/code&gt; about events from all connected accounts is created; otherwise an account webhook endpoint that notifies the specified &lt;code&gt;url&lt;/code&gt; only about events from your account is created. You can also create webhook endpoints in the &lt;a href&#x3D;\&quot;https://dashboard.stripe.com/account/webhooks\&quot;&gt;webhooks settings&lt;/a&gt; section of the Dashboard.&lt;/p&gt;
    # @param enabled_events [Array(String)?] The list of events to enable for this endpoint. You may specify `['*']` to enable all events, except those that require explicit selection.
    # @param url [String?] The URL of the webhook endpoint.
    # @optional @param api_version [String?] Events sent to this endpoint will be generated with this Stripe Version instead of your account's default Stripe Version.
    # @optional @param connect [Bool?] Whether this endpoint should receive events from connected accounts (`true`), or from your account (`false`). Defaults to `false`.
    # @optional @param description [String?] An optional description of what the webhook is used for.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @return nil
    def post_webhook_endpoints(*, enabled_events : Array(String)? = nil, url : String? = nil, api_version : String? = nil, connect : Bool? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, &block : Crest::Response ->)
      build_api_request_for_post_webhook_endpoints(enabled_events: enabled_events, url: url, api_version: api_version, connect: connect, description: description, expand: expand, metadata: metadata).execute(&block)
    end

    POST_WEBHOOK_ENDPOINTS_VALID_VALUES_FOR_ENABLED_EVENTS = StaticArray["*", "account.application.authorized", "account.application.deauthorized", "account.external_account.created", "account.external_account.deleted", "account.external_account.updated", "account.updated", "application_fee.created", "application_fee.refund.updated", "application_fee.refunded", "balance.available", "billing_portal.configuration.created", "billing_portal.configuration.updated", "billing_portal.session.created", "capability.updated", "cash_balance.funds_available", "charge.captured", "charge.dispute.closed", "charge.dispute.created", "charge.dispute.funds_reinstated", "charge.dispute.funds_withdrawn", "charge.dispute.updated", "charge.expired", "charge.failed", "charge.pending", "charge.refund.updated", "charge.refunded", "charge.succeeded", "charge.updated", "checkout.session.async_payment_failed", "checkout.session.async_payment_succeeded", "checkout.session.completed", "checkout.session.expired", "coupon.created", "coupon.deleted", "coupon.updated", "credit_note.created", "credit_note.updated", "credit_note.voided", "customer.created", "customer.deleted", "customer.discount.created", "customer.discount.deleted", "customer.discount.updated", "customer.source.created", "customer.source.deleted", "customer.source.expiring", "customer.source.updated", "customer.subscription.created", "customer.subscription.deleted", "customer.subscription.pending_update_applied", "customer.subscription.pending_update_expired", "customer.subscription.trial_will_end", "customer.subscription.updated", "customer.tax_id.created", "customer.tax_id.deleted", "customer.tax_id.updated", "customer.updated", "customer_cash_balance_transaction.created", "file.created", "financial_connections.account.created", "financial_connections.account.deactivated", "financial_connections.account.disconnected", "financial_connections.account.reactivated", "financial_connections.account.refreshed_balance", "identity.verification_session.canceled", "identity.verification_session.created", "identity.verification_session.processing", "identity.verification_session.redacted", "identity.verification_session.requires_input", "identity.verification_session.verified", "invoice.created", "invoice.deleted", "invoice.finalization_failed", "invoice.finalized", "invoice.marked_uncollectible", "invoice.paid", "invoice.payment_action_required", "invoice.payment_failed", "invoice.payment_succeeded", "invoice.sent", "invoice.upcoming", "invoice.updated", "invoice.voided", "invoiceitem.created", "invoiceitem.deleted", "invoiceitem.updated", "issuing_authorization.created", "issuing_authorization.request", "issuing_authorization.updated", "issuing_card.created", "issuing_card.updated", "issuing_cardholder.created", "issuing_cardholder.updated", "issuing_dispute.closed", "issuing_dispute.created", "issuing_dispute.funds_reinstated", "issuing_dispute.submitted", "issuing_dispute.updated", "issuing_transaction.created", "issuing_transaction.updated", "mandate.updated", "order.created", "payment_intent.amount_capturable_updated", "payment_intent.canceled", "payment_intent.created", "payment_intent.partially_funded", "payment_intent.payment_failed", "payment_intent.processing", "payment_intent.requires_action", "payment_intent.succeeded", "payment_link.created", "payment_link.updated", "payment_method.attached", "payment_method.automatically_updated", "payment_method.detached", "payment_method.updated", "payout.canceled", "payout.created", "payout.failed", "payout.paid", "payout.updated", "person.created", "person.deleted", "person.updated", "plan.created", "plan.deleted", "plan.updated", "price.created", "price.deleted", "price.updated", "product.created", "product.deleted", "product.updated", "promotion_code.created", "promotion_code.updated", "quote.accepted", "quote.canceled", "quote.created", "quote.finalized", "radar.early_fraud_warning.created", "radar.early_fraud_warning.updated", "recipient.created", "recipient.deleted", "recipient.updated", "reporting.report_run.failed", "reporting.report_run.succeeded", "reporting.report_type.updated", "review.closed", "review.opened", "setup_intent.canceled", "setup_intent.created", "setup_intent.requires_action", "setup_intent.setup_failed", "setup_intent.succeeded", "sigma.scheduled_query_run.created", "sku.created", "sku.deleted", "sku.updated", "source.canceled", "source.chargeable", "source.failed", "source.mandate_notification", "source.refund_attributes_required", "source.transaction.created", "source.transaction.updated", "subscription_schedule.aborted", "subscription_schedule.canceled", "subscription_schedule.completed", "subscription_schedule.created", "subscription_schedule.expiring", "subscription_schedule.released", "subscription_schedule.updated", "tax_rate.created", "tax_rate.updated", "terminal.reader.action_failed", "terminal.reader.action_succeeded", "test_helpers.test_clock.advancing", "test_helpers.test_clock.created", "test_helpers.test_clock.deleted", "test_helpers.test_clock.internal_failure", "test_helpers.test_clock.ready", "topup.canceled", "topup.created", "topup.failed", "topup.reversed", "topup.succeeded", "transfer.created", "transfer.reversed", "transfer.updated", "treasury.credit_reversal.created", "treasury.credit_reversal.posted", "treasury.debit_reversal.completed", "treasury.debit_reversal.created", "treasury.debit_reversal.initial_credit_granted", "treasury.financial_account.closed", "treasury.financial_account.created", "treasury.financial_account.features_status_updated", "treasury.inbound_transfer.canceled", "treasury.inbound_transfer.created", "treasury.inbound_transfer.failed", "treasury.inbound_transfer.succeeded", "treasury.outbound_payment.canceled", "treasury.outbound_payment.created", "treasury.outbound_payment.expected_arrival_date_updated", "treasury.outbound_payment.failed", "treasury.outbound_payment.posted", "treasury.outbound_payment.returned", "treasury.outbound_transfer.canceled", "treasury.outbound_transfer.created", "treasury.outbound_transfer.expected_arrival_date_updated", "treasury.outbound_transfer.failed", "treasury.outbound_transfer.posted", "treasury.outbound_transfer.returned", "treasury.received_credit.created", "treasury.received_credit.failed", "treasury.received_credit.succeeded", "treasury.received_debit.created"]
    POST_WEBHOOK_ENDPOINTS_MAX_LENGTH_FOR_API_VERSION      = 5000
    POST_WEBHOOK_ENDPOINTS_VALID_VALUES_FOR_API_VERSION    = StaticArray["2011-01-01", "2011-06-21", "2011-06-28", "2011-08-01", "2011-09-15", "2011-11-17", "2012-02-23", "2012-03-25", "2012-06-18", "2012-06-28", "2012-07-09", "2012-09-24", "2012-10-26", "2012-11-07", "2013-02-11", "2013-02-13", "2013-07-05", "2013-08-12", "2013-08-13", "2013-10-29", "2013-12-03", "2014-01-31", "2014-03-13", "2014-03-28", "2014-05-19", "2014-06-13", "2014-06-17", "2014-07-22", "2014-07-26", "2014-08-04", "2014-08-20", "2014-09-08", "2014-10-07", "2014-11-05", "2014-11-20", "2014-12-08", "2014-12-17", "2014-12-22", "2015-01-11", "2015-01-26", "2015-02-10", "2015-02-16", "2015-02-18", "2015-03-24", "2015-04-07", "2015-06-15", "2015-07-07", "2015-07-13", "2015-07-28", "2015-08-07", "2015-08-19", "2015-09-03", "2015-09-08", "2015-09-23", "2015-10-01", "2015-10-12", "2015-10-16", "2016-02-03", "2016-02-19", "2016-02-22", "2016-02-23", "2016-02-29", "2016-03-07", "2016-06-15", "2016-07-06", "2016-10-19", "2017-01-27", "2017-02-14", "2017-04-06", "2017-05-25", "2017-06-05", "2017-08-15", "2017-12-14", "2018-01-23", "2018-02-05", "2018-02-06", "2018-02-28", "2018-05-21", "2018-07-27", "2018-08-23", "2018-09-06", "2018-09-24", "2018-10-31", "2018-11-08", "2019-02-11", "2019-02-19", "2019-03-14", "2019-05-16", "2019-08-14", "2019-09-09", "2019-10-08", "2019-10-17", "2019-11-05", "2019-12-03", "2020-03-02", "2020-08-27", "2022-08-01"]
    POST_WEBHOOK_ENDPOINTS_MAX_LENGTH_FOR_DESCRIPTION      = 5000

    # @return Crest::Request
    def build_api_request_for_post_webhook_endpoints(*, enabled_events : Array(String)? = nil, url : String? = nil, api_version : String? = nil, connect : Bool? = nil, description : String? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_webhook_endpoints ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"enabled_events\" is required and cannot be null") if enabled_events.nil?
        if _enabled_events = enabled_events
          OpenApi::EnumValidator.validate("enabled_events", _enabled_events, POST_WEBHOOK_ENDPOINTS_VALID_VALUES_FOR_ENABLED_EVENTS)
        end
        raise ArgumentError.new("\"url\" is required and cannot be null") if url.nil?

        if _api_version = api_version
          OpenApi::EnumValidator.validate("api_version", _api_version, POST_WEBHOOK_ENDPOINTS_VALID_VALUES_FOR_API_VERSION)
        end

        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_WEBHOOK_ENDPOINTS_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/webhook_endpoints"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["api_version"] = api_version.to_s if !api_version.nil?
      form_params["connect"] = connect.to_s if !connect.nil?
      form_params["description"] = description.to_s if !description.nil?
      form_params["enabled_events"] = @api_client.build_collection_param(enabled_events, "csv") if !enabled_events.nil? && !enabled_events.empty?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["url"] = url.to_s if !url.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_webhook_endpoints",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the webhook endpoint. You may edit the <code>url</code>, the list of <code>enabled_events</code>, and the status of your endpoint.</p>
    # @param webhook_endpoint [String?]
    # @optional @param description [String?] An optional description of what the webhook is used for.
    # @optional @param disabled [Bool?] Disable the webhook endpoint if set to true.
    # @optional @param enabled_events [Array(String)?] The list of events to enable for this endpoint. You may specify `['*']` to enable all events, except those that require explicit selection.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param url [String?] The URL of the webhook endpoint.
    # @return [WebhookEndpoint]
    def post_webhook_endpoints_webhook_endpoint(*, webhook_endpoint : String? = nil, description : String? = nil, disabled : Bool? = nil, enabled_events : Array(String)? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, url : String? = nil)
      data, _status_code, _headers = post_webhook_endpoints_webhook_endpoint_with_http_info(webhook_endpoint: webhook_endpoint, description: description, disabled: disabled, enabled_events: enabled_events, expand: expand, metadata: metadata, url: url)
      data
    end

    # &lt;p&gt;Updates the webhook endpoint. You may edit the &lt;code&gt;url&lt;/code&gt;, the list of &lt;code&gt;enabled_events&lt;/code&gt;, and the status of your endpoint.&lt;/p&gt;
    # @param webhook_endpoint [String?]
    # @optional @param description [String?] An optional description of what the webhook is used for.
    # @optional @param disabled [Bool?] Disable the webhook endpoint if set to true.
    # @optional @param enabled_events [Array(String)?] The list of events to enable for this endpoint. You may specify `['*']` to enable all events, except those that require explicit selection.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param url [String?] The URL of the webhook endpoint.
    # @return [Array<(WebhookEndpoint, Integer, Hash)>] WebhookEndpoint data, response status code and response headers
    def post_webhook_endpoints_webhook_endpoint_with_http_info(*, webhook_endpoint : String? = nil, description : String? = nil, disabled : Bool? = nil, enabled_events : Array(String)? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, url : String? = nil)
      request = build_api_request_for_post_webhook_endpoints_webhook_endpoint(webhook_endpoint: webhook_endpoint, description: description, disabled: disabled, enabled_events: enabled_events, expand: expand, metadata: metadata, url: url)

      data, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: DefaultApi#post_webhook_endpoints_webhook_endpoint\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return WebhookEndpoint.from_json(data), status_code, headers
    end

    # &lt;p&gt;Updates the webhook endpoint. You may edit the &lt;code&gt;url&lt;/code&gt;, the list of &lt;code&gt;enabled_events&lt;/code&gt;, and the status of your endpoint.&lt;/p&gt;
    # @param webhook_endpoint [String?]
    # @optional @param description [String?] An optional description of what the webhook is used for.
    # @optional @param disabled [Bool?] Disable the webhook endpoint if set to true.
    # @optional @param enabled_events [Array(String)?] The list of events to enable for this endpoint. You may specify `['*']` to enable all events, except those that require explicit selection.
    # @optional @param expand [Array(String)?] Specifies which fields in the response should be expanded.
    # @optional @param metadata [Stripe::PostAccountRequestMetadata?]
    # @optional @param url [String?] The URL of the webhook endpoint.
    # @return nil
    def post_webhook_endpoints_webhook_endpoint(*, webhook_endpoint : String? = nil, description : String? = nil, disabled : Bool? = nil, enabled_events : Array(String)? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, url : String? = nil, &block : Crest::Response ->)
      build_api_request_for_post_webhook_endpoints_webhook_endpoint(webhook_endpoint: webhook_endpoint, description: description, disabled: disabled, enabled_events: enabled_events, expand: expand, metadata: metadata, url: url).execute(&block)
    end

    POST_WEBHOOK_ENDPOINTS_WEBHOOK_ENDPOINT_MAX_LENGTH_FOR_WEBHOOK_ENDPOINT = 5000
    POST_WEBHOOK_ENDPOINTS_WEBHOOK_ENDPOINT_MAX_LENGTH_FOR_DESCRIPTION      = 5000
    POST_WEBHOOK_ENDPOINTS_WEBHOOK_ENDPOINT_VALID_VALUES_FOR_ENABLED_EVENTS = StaticArray["*", "account.application.authorized", "account.application.deauthorized", "account.external_account.created", "account.external_account.deleted", "account.external_account.updated", "account.updated", "application_fee.created", "application_fee.refund.updated", "application_fee.refunded", "balance.available", "billing_portal.configuration.created", "billing_portal.configuration.updated", "billing_portal.session.created", "capability.updated", "cash_balance.funds_available", "charge.captured", "charge.dispute.closed", "charge.dispute.created", "charge.dispute.funds_reinstated", "charge.dispute.funds_withdrawn", "charge.dispute.updated", "charge.expired", "charge.failed", "charge.pending", "charge.refund.updated", "charge.refunded", "charge.succeeded", "charge.updated", "checkout.session.async_payment_failed", "checkout.session.async_payment_succeeded", "checkout.session.completed", "checkout.session.expired", "coupon.created", "coupon.deleted", "coupon.updated", "credit_note.created", "credit_note.updated", "credit_note.voided", "customer.created", "customer.deleted", "customer.discount.created", "customer.discount.deleted", "customer.discount.updated", "customer.source.created", "customer.source.deleted", "customer.source.expiring", "customer.source.updated", "customer.subscription.created", "customer.subscription.deleted", "customer.subscription.pending_update_applied", "customer.subscription.pending_update_expired", "customer.subscription.trial_will_end", "customer.subscription.updated", "customer.tax_id.created", "customer.tax_id.deleted", "customer.tax_id.updated", "customer.updated", "customer_cash_balance_transaction.created", "file.created", "financial_connections.account.created", "financial_connections.account.deactivated", "financial_connections.account.disconnected", "financial_connections.account.reactivated", "financial_connections.account.refreshed_balance", "identity.verification_session.canceled", "identity.verification_session.created", "identity.verification_session.processing", "identity.verification_session.redacted", "identity.verification_session.requires_input", "identity.verification_session.verified", "invoice.created", "invoice.deleted", "invoice.finalization_failed", "invoice.finalized", "invoice.marked_uncollectible", "invoice.paid", "invoice.payment_action_required", "invoice.payment_failed", "invoice.payment_succeeded", "invoice.sent", "invoice.upcoming", "invoice.updated", "invoice.voided", "invoiceitem.created", "invoiceitem.deleted", "invoiceitem.updated", "issuing_authorization.created", "issuing_authorization.request", "issuing_authorization.updated", "issuing_card.created", "issuing_card.updated", "issuing_cardholder.created", "issuing_cardholder.updated", "issuing_dispute.closed", "issuing_dispute.created", "issuing_dispute.funds_reinstated", "issuing_dispute.submitted", "issuing_dispute.updated", "issuing_transaction.created", "issuing_transaction.updated", "mandate.updated", "order.created", "payment_intent.amount_capturable_updated", "payment_intent.canceled", "payment_intent.created", "payment_intent.partially_funded", "payment_intent.payment_failed", "payment_intent.processing", "payment_intent.requires_action", "payment_intent.succeeded", "payment_link.created", "payment_link.updated", "payment_method.attached", "payment_method.automatically_updated", "payment_method.detached", "payment_method.updated", "payout.canceled", "payout.created", "payout.failed", "payout.paid", "payout.updated", "person.created", "person.deleted", "person.updated", "plan.created", "plan.deleted", "plan.updated", "price.created", "price.deleted", "price.updated", "product.created", "product.deleted", "product.updated", "promotion_code.created", "promotion_code.updated", "quote.accepted", "quote.canceled", "quote.created", "quote.finalized", "radar.early_fraud_warning.created", "radar.early_fraud_warning.updated", "recipient.created", "recipient.deleted", "recipient.updated", "reporting.report_run.failed", "reporting.report_run.succeeded", "reporting.report_type.updated", "review.closed", "review.opened", "setup_intent.canceled", "setup_intent.created", "setup_intent.requires_action", "setup_intent.setup_failed", "setup_intent.succeeded", "sigma.scheduled_query_run.created", "sku.created", "sku.deleted", "sku.updated", "source.canceled", "source.chargeable", "source.failed", "source.mandate_notification", "source.refund_attributes_required", "source.transaction.created", "source.transaction.updated", "subscription_schedule.aborted", "subscription_schedule.canceled", "subscription_schedule.completed", "subscription_schedule.created", "subscription_schedule.expiring", "subscription_schedule.released", "subscription_schedule.updated", "tax_rate.created", "tax_rate.updated", "terminal.reader.action_failed", "terminal.reader.action_succeeded", "test_helpers.test_clock.advancing", "test_helpers.test_clock.created", "test_helpers.test_clock.deleted", "test_helpers.test_clock.internal_failure", "test_helpers.test_clock.ready", "topup.canceled", "topup.created", "topup.failed", "topup.reversed", "topup.succeeded", "transfer.created", "transfer.reversed", "transfer.updated", "treasury.credit_reversal.created", "treasury.credit_reversal.posted", "treasury.debit_reversal.completed", "treasury.debit_reversal.created", "treasury.debit_reversal.initial_credit_granted", "treasury.financial_account.closed", "treasury.financial_account.created", "treasury.financial_account.features_status_updated", "treasury.inbound_transfer.canceled", "treasury.inbound_transfer.created", "treasury.inbound_transfer.failed", "treasury.inbound_transfer.succeeded", "treasury.outbound_payment.canceled", "treasury.outbound_payment.created", "treasury.outbound_payment.expected_arrival_date_updated", "treasury.outbound_payment.failed", "treasury.outbound_payment.posted", "treasury.outbound_payment.returned", "treasury.outbound_transfer.canceled", "treasury.outbound_transfer.created", "treasury.outbound_transfer.expected_arrival_date_updated", "treasury.outbound_transfer.failed", "treasury.outbound_transfer.posted", "treasury.outbound_transfer.returned", "treasury.received_credit.created", "treasury.received_credit.failed", "treasury.received_credit.succeeded", "treasury.received_debit.created"]

    # @return Crest::Request
    def build_api_request_for_post_webhook_endpoints_webhook_endpoint(*, webhook_endpoint : String? = nil, description : String? = nil, disabled : Bool? = nil, enabled_events : Array(String)? = nil, expand : Array(String)? = nil, metadata : Stripe::PostAccountRequestMetadata? = nil, url : String? = nil) : Crest::Request
      if debugging
        Log.debug { "Calling API: DefaultApi.post_webhook_endpoints_webhook_endpoint ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"webhook_endpoint\" is required and cannot be null") if webhook_endpoint.nil?
        if _webhook_endpoint = webhook_endpoint
          OpenApi::PrimitiveValidator.validate_max_length("webhook_endpoint", webhook_endpoint.to_s.size, POST_WEBHOOK_ENDPOINTS_WEBHOOK_ENDPOINT_MAX_LENGTH_FOR_WEBHOOK_ENDPOINT)
        end
        if _description = description
          OpenApi::PrimitiveValidator.validate_max_length("description", description.to_s.size, POST_WEBHOOK_ENDPOINTS_WEBHOOK_ENDPOINT_MAX_LENGTH_FOR_DESCRIPTION)
        end

        if _enabled_events = enabled_events
          OpenApi::EnumValidator.validate("enabled_events", _enabled_events, POST_WEBHOOK_ENDPOINTS_WEBHOOK_ENDPOINT_VALID_VALUES_FOR_ENABLED_EVENTS)
        end

        if _metadata = metadata
          _metadata.validate if _metadata.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/webhook_endpoints/{webhook_endpoint}".sub("{" + "webhook_endpoint" + "}", URI.encode_path(webhook_endpoint.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | IO)).new
      form_params["description"] = description.to_s if !description.nil?
      form_params["disabled"] = disabled.to_s if !disabled.nil?
      form_params["enabled_events"] = @api_client.build_collection_param(enabled_events, "csv") if !enabled_events.nil? && !enabled_events.empty?
      form_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      form_params["metadata"] = metadata.to_s if !metadata.nil?
      form_params["url"] = url.to_s if !url.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "DefaultApi.post_webhook_endpoints_webhook_endpoint",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end
  end
end
