#  Stripe API
#
# The Stripe REST API. Please see https://stripe.com/docs/api for more details.
#
# The version of the OpenAPI document: 2022-11-15
# Contact: dev-platform@stripe.com
# Generated by: https://openapi-generator.tech
#

require "uri"
require "../api_client"

module Stripe
  class SubscriptionsApi
    property api_client : ApiClient

    delegate client_side_validation, debugging, to: @api_client.config

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end

    # <p>Cancels a customer’s subscription immediately. The customer will not be charged again for the subscription.</p>  <p>Note, however, that any pending invoice items that you’ve created will still be charged for at the end of the period, unless manually <a href=\"#delete_invoiceitem\">deleted</a>. If you’ve set the subscription to cancel at the end of the period, any pending prorations will also be left in place and collected at the end of the period. But if the subscription is set to cancel immediately, pending prorations will be removed.</p>  <p>By default, upon subscription cancellation, Stripe will stop automatic collection of all finalized invoices for the customer. This is intended to prevent unexpected payment attempts after the customer has canceled a subscription. However, you can resume automatic collection of the invoices manually after subscription cancellation to have us proceed. Or, you could check for unpaid invoices before allowing the customer to cancel the subscription at all.</p>
    # @required @param subscription_exposed_id [String?]
    # @optional @param delete_subscriptions_subscription_exposed_id_request [Stripe::DeleteSubscriptionsSubscriptionExposedIdRequest?]
    # @return [Stripe::Subscription]
    def delete_subscriptions_subscription_exposed_id(
      *,
      subscription_exposed_id : String? = nil,
      delete_subscriptions_subscription_exposed_id_request : Stripe::DeleteSubscriptionsSubscriptionExposedIdRequest? = nil
    ) : Stripe::Subscription
      data, _status_code, _headers = delete_subscriptions_subscription_exposed_id_with_http_info(subscription_exposed_id: subscription_exposed_id, delete_subscriptions_subscription_exposed_id_request: delete_subscriptions_subscription_exposed_id_request)
      data
    end

    # &lt;p&gt;Cancels a customer’s subscription immediately. The customer will not be charged again for the subscription.&lt;/p&gt;  &lt;p&gt;Note, however, that any pending invoice items that you’ve created will still be charged for at the end of the period, unless manually &lt;a href&#x3D;\&quot;#delete_invoiceitem\&quot;&gt;deleted&lt;/a&gt;. If you’ve set the subscription to cancel at the end of the period, any pending prorations will also be left in place and collected at the end of the period. But if the subscription is set to cancel immediately, pending prorations will be removed.&lt;/p&gt;  &lt;p&gt;By default, upon subscription cancellation, Stripe will stop automatic collection of all finalized invoices for the customer. This is intended to prevent unexpected payment attempts after the customer has canceled a subscription. However, you can resume automatic collection of the invoices manually after subscription cancellation to have us proceed. Or, you could check for unpaid invoices before allowing the customer to cancel the subscription at all.&lt;/p&gt;
    # @required @param subscription_exposed_id [String?]
    # @optional @param delete_subscriptions_subscription_exposed_id_request [Stripe::DeleteSubscriptionsSubscriptionExposedIdRequest?]
    # @return [Tuple(Stripe::Subscription, Integer, Hash)] Stripe::Subscription, response status code and response headers
    def delete_subscriptions_subscription_exposed_id_with_http_info(
      *,
      subscription_exposed_id : String? = nil,
      delete_subscriptions_subscription_exposed_id_request : Stripe::DeleteSubscriptionsSubscriptionExposedIdRequest? = nil
    ) : Tuple(Stripe::Subscription, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_delete_subscriptions_subscription_exposed_id(subscription_exposed_id: subscription_exposed_id, delete_subscriptions_subscription_exposed_id_request: delete_subscriptions_subscription_exposed_id_request)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: SubscriptionsApi#delete_subscriptions_subscription_exposed_id\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(Stripe::Subscription.from_json(body), status_code, headers)
    end

    # &lt;p&gt;Cancels a customer’s subscription immediately. The customer will not be charged again for the subscription.&lt;/p&gt;  &lt;p&gt;Note, however, that any pending invoice items that you’ve created will still be charged for at the end of the period, unless manually &lt;a href&#x3D;\&quot;#delete_invoiceitem\&quot;&gt;deleted&lt;/a&gt;. If you’ve set the subscription to cancel at the end of the period, any pending prorations will also be left in place and collected at the end of the period. But if the subscription is set to cancel immediately, pending prorations will be removed.&lt;/p&gt;  &lt;p&gt;By default, upon subscription cancellation, Stripe will stop automatic collection of all finalized invoices for the customer. This is intended to prevent unexpected payment attempts after the customer has canceled a subscription. However, you can resume automatic collection of the invoices manually after subscription cancellation to have us proceed. Or, you could check for unpaid invoices before allowing the customer to cancel the subscription at all.&lt;/p&gt;
    # @required @param subscription_exposed_id [String?]
    # @optional @param delete_subscriptions_subscription_exposed_id_request [Stripe::DeleteSubscriptionsSubscriptionExposedIdRequest?]
    # @return nil
    def delete_subscriptions_subscription_exposed_id(
      *,
      subscription_exposed_id : String? = nil,
      delete_subscriptions_subscription_exposed_id_request : Stripe::DeleteSubscriptionsSubscriptionExposedIdRequest? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_delete_subscriptions_subscription_exposed_id(subscription_exposed_id: subscription_exposed_id, delete_subscriptions_subscription_exposed_id_request: delete_subscriptions_subscription_exposed_id_request).execute(&block)
    end

    DELETE_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID = 5000

    # @return Crest::Request
    def build_api_request_for_delete_subscriptions_subscription_exposed_id(
      *,
      subscription_exposed_id : String? = nil,
      delete_subscriptions_subscription_exposed_id_request : Stripe::DeleteSubscriptionsSubscriptionExposedIdRequest? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: SubscriptionsApi.delete_subscriptions_subscription_exposed_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"subscription_exposed_id\" is required and cannot be null") if subscription_exposed_id.nil?
        unless (_subscription_exposed_id = subscription_exposed_id).nil?
          OpenApi::PrimitiveValidator.validate_max_length("subscription_exposed_id", subscription_exposed_id.to_s.size, DELETE_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID)
        end
        unless (_delete_subscriptions_subscription_exposed_id_request = delete_subscriptions_subscription_exposed_id_request).nil?
          _delete_subscriptions_subscription_exposed_id_request.validate if _delete_subscriptions_subscription_exposed_id_request.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/subscriptions/{subscription_exposed_id}".sub("{" + "subscription_exposed_id" + "}", URI.encode_path(subscription_exposed_id.to_s))

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = nil

      # http body (model)
      post_body : IO | String | Nil = @api_client.encode(body: delete_subscriptions_subscription_exposed_id_request, content_type: header_params["Content-Type"]?) if !delete_subscriptions_subscription_exposed_id_request.nil?

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "SubscriptionsApi.delete_subscriptions_subscription_exposed_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Removes the currently applied discount on a subscription.</p>
    # @required @param subscription_exposed_id [String?]
    # @return [Stripe::DeletedDiscount]
    def delete_subscriptions_subscription_exposed_id_discount(
      *,
      subscription_exposed_id : String? = nil
    ) : Stripe::DeletedDiscount
      data, _status_code, _headers = delete_subscriptions_subscription_exposed_id_discount_with_http_info(subscription_exposed_id: subscription_exposed_id)
      data
    end

    # &lt;p&gt;Removes the currently applied discount on a subscription.&lt;/p&gt;
    # @required @param subscription_exposed_id [String?]
    # @return [Tuple(Stripe::DeletedDiscount, Integer, Hash)] Stripe::DeletedDiscount, response status code and response headers
    def delete_subscriptions_subscription_exposed_id_discount_with_http_info(
      *,
      subscription_exposed_id : String? = nil
    ) : Tuple(Stripe::DeletedDiscount, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_delete_subscriptions_subscription_exposed_id_discount(subscription_exposed_id: subscription_exposed_id)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: SubscriptionsApi#delete_subscriptions_subscription_exposed_id_discount\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(Stripe::DeletedDiscount.from_json(body), status_code, headers)
    end

    # &lt;p&gt;Removes the currently applied discount on a subscription.&lt;/p&gt;
    # @required @param subscription_exposed_id [String?]
    # @return nil
    def delete_subscriptions_subscription_exposed_id_discount(
      *,
      subscription_exposed_id : String? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_delete_subscriptions_subscription_exposed_id_discount(subscription_exposed_id: subscription_exposed_id).execute(&block)
    end

    DELETE_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_DISCOUNT_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID = 5000

    # @return Crest::Request
    def build_api_request_for_delete_subscriptions_subscription_exposed_id_discount(
      *,
      subscription_exposed_id : String? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: SubscriptionsApi.delete_subscriptions_subscription_exposed_id_discount ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"subscription_exposed_id\" is required and cannot be null") if subscription_exposed_id.nil?
        unless (_subscription_exposed_id = subscription_exposed_id).nil?
          OpenApi::PrimitiveValidator.validate_max_length("subscription_exposed_id", subscription_exposed_id.to_s.size, DELETE_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_DISCOUNT_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID)
        end
      end

      # resource path
      local_var_path = "/v1/subscriptions/{subscription_exposed_id}/discount".sub("{" + "subscription_exposed_id" + "}", URI.encode_path(subscription_exposed_id.to_s))

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = nil

      # http body (model)
      post_body : IO | String | Nil = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "SubscriptionsApi.delete_subscriptions_subscription_exposed_id_discount",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>By default, returns a list of subscriptions that have not been canceled. In order to list canceled subscriptions, specify <code>status=canceled</code>.</p>
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param limit [Int32?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param test_clock [String?] Filter for subscriptions that are associated with the specified test clock. The response will not include subscriptions with test clocks if this and the customer parameter is not set.
    # @optional @param price [String?] Filter for subscriptions that contain this recurring price ID.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param customer [String?] The ID of the customer whose subscriptions will be retrieved.
    # @optional @param collection_method [String?] The collection method of the subscriptions to retrieve. Either `charge_automatically` or `send_invoice`.
    # @optional @param status [String?] The status of the subscriptions to retrieve. Passing in a value of `canceled` will return all canceled subscriptions, including those belonging to deleted customers. Pass `ended` to find subscriptions that are canceled and subscriptions that are expired due to [incomplete payment](https://stripe.com/docs/billing/subscriptions/overview#subscription-statuses). Passing in a value of `all` will return subscriptions of all statuses. If no value is supplied, all subscriptions that have not been canceled are returned.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param current_period_end [Stripe::GetAccountsCreatedParameter?]
    # @optional @param current_period_start [Stripe::GetAccountsCreatedParameter?]
    # @return [Stripe::SubscriptionsSubscriptionList]
    def get_subscriptions(
      *,
      ending_before : String? = nil,
      starting_after : String? = nil,
      limit : Int64? = nil,
      test_clock : String? = nil,
      price : String? = nil,
      expand : Array(Array(String))? = nil,
      customer : String? = nil,
      collection_method : String? = nil,
      status : String? = nil,
      created : Stripe::GetAccountsCreatedParameter? = nil,
      current_period_end : Stripe::GetAccountsCreatedParameter? = nil,
      current_period_start : Stripe::GetAccountsCreatedParameter? = nil
    ) : Stripe::SubscriptionsSubscriptionList
      data, _status_code, _headers = get_subscriptions_with_http_info(ending_before: ending_before, starting_after: starting_after, limit: limit, test_clock: test_clock, price: price, expand: expand, customer: customer, collection_method: collection_method, status: status, created: created, current_period_end: current_period_end, current_period_start: current_period_start)
      data
    end

    # &lt;p&gt;By default, returns a list of subscriptions that have not been canceled. In order to list canceled subscriptions, specify &lt;code&gt;status&#x3D;canceled&lt;/code&gt;.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param limit [Int32?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param test_clock [String?] Filter for subscriptions that are associated with the specified test clock. The response will not include subscriptions with test clocks if this and the customer parameter is not set.
    # @optional @param price [String?] Filter for subscriptions that contain this recurring price ID.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param customer [String?] The ID of the customer whose subscriptions will be retrieved.
    # @optional @param collection_method [String?] The collection method of the subscriptions to retrieve. Either `charge_automatically` or `send_invoice`.
    # @optional @param status [String?] The status of the subscriptions to retrieve. Passing in a value of `canceled` will return all canceled subscriptions, including those belonging to deleted customers. Pass `ended` to find subscriptions that are canceled and subscriptions that are expired due to [incomplete payment](https://stripe.com/docs/billing/subscriptions/overview#subscription-statuses). Passing in a value of `all` will return subscriptions of all statuses. If no value is supplied, all subscriptions that have not been canceled are returned.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param current_period_end [Stripe::GetAccountsCreatedParameter?]
    # @optional @param current_period_start [Stripe::GetAccountsCreatedParameter?]
    # @return [Tuple(Stripe::SubscriptionsSubscriptionList, Integer, Hash)] Stripe::SubscriptionsSubscriptionList, response status code and response headers
    def get_subscriptions_with_http_info(
      *,
      ending_before : String? = nil,
      starting_after : String? = nil,
      limit : Int64? = nil,
      test_clock : String? = nil,
      price : String? = nil,
      expand : Array(Array(String))? = nil,
      customer : String? = nil,
      collection_method : String? = nil,
      status : String? = nil,
      created : Stripe::GetAccountsCreatedParameter? = nil,
      current_period_end : Stripe::GetAccountsCreatedParameter? = nil,
      current_period_start : Stripe::GetAccountsCreatedParameter? = nil
    ) : Tuple(Stripe::SubscriptionsSubscriptionList, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_get_subscriptions(ending_before: ending_before, starting_after: starting_after, limit: limit, test_clock: test_clock, price: price, expand: expand, customer: customer, collection_method: collection_method, status: status, created: created, current_period_end: current_period_end, current_period_start: current_period_start)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: SubscriptionsApi#get_subscriptions\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(Stripe::SubscriptionsSubscriptionList.from_json(body), status_code, headers)
    end

    # &lt;p&gt;By default, returns a list of subscriptions that have not been canceled. In order to list canceled subscriptions, specify &lt;code&gt;status&#x3D;canceled&lt;/code&gt;.&lt;/p&gt;
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param limit [Int32?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param test_clock [String?] Filter for subscriptions that are associated with the specified test clock. The response will not include subscriptions with test clocks if this and the customer parameter is not set.
    # @optional @param price [String?] Filter for subscriptions that contain this recurring price ID.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @optional @param customer [String?] The ID of the customer whose subscriptions will be retrieved.
    # @optional @param collection_method [String?] The collection method of the subscriptions to retrieve. Either `charge_automatically` or `send_invoice`.
    # @optional @param status [String?] The status of the subscriptions to retrieve. Passing in a value of `canceled` will return all canceled subscriptions, including those belonging to deleted customers. Pass `ended` to find subscriptions that are canceled and subscriptions that are expired due to [incomplete payment](https://stripe.com/docs/billing/subscriptions/overview#subscription-statuses). Passing in a value of `all` will return subscriptions of all statuses. If no value is supplied, all subscriptions that have not been canceled are returned.
    # @optional @param created [Stripe::GetAccountsCreatedParameter?]
    # @optional @param current_period_end [Stripe::GetAccountsCreatedParameter?]
    # @optional @param current_period_start [Stripe::GetAccountsCreatedParameter?]
    # @return nil
    def get_subscriptions(
      *,
      ending_before : String? = nil,
      starting_after : String? = nil,
      limit : Int64? = nil,
      test_clock : String? = nil,
      price : String? = nil,
      expand : Array(Array(String))? = nil,
      customer : String? = nil,
      collection_method : String? = nil,
      status : String? = nil,
      created : Stripe::GetAccountsCreatedParameter? = nil,
      current_period_end : Stripe::GetAccountsCreatedParameter? = nil,
      current_period_start : Stripe::GetAccountsCreatedParameter? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_get_subscriptions(ending_before: ending_before, starting_after: starting_after, limit: limit, test_clock: test_clock, price: price, expand: expand, customer: customer, collection_method: collection_method, status: status, created: created, current_period_end: current_period_end, current_period_start: current_period_start).execute(&block)
    end

    GET_SUBSCRIPTIONS_MAX_LENGTH_FOR_ENDING_BEFORE       = 5000
    GET_SUBSCRIPTIONS_MAX_LENGTH_FOR_STARTING_AFTER      = 5000
    GET_SUBSCRIPTIONS_MAX_LENGTH_FOR_TEST_CLOCK          = 5000
    GET_SUBSCRIPTIONS_MAX_LENGTH_FOR_PRICE               = 5000
    GET_SUBSCRIPTIONS_MAX_LENGTH_FOR_CUSTOMER            = 5000
    GET_SUBSCRIPTIONS_VALID_VALUES_FOR_COLLECTION_METHOD = String.static_array("charge_automatically", "send_invoice")
    GET_SUBSCRIPTIONS_VALID_VALUES_FOR_STATUS            = String.static_array("active", "all", "canceled", "ended", "incomplete", "incomplete_expired", "past_due", "trialing", "unpaid")

    # @return Crest::Request
    def build_api_request_for_get_subscriptions(
      *,
      ending_before : String? = nil,
      starting_after : String? = nil,
      limit : Int64? = nil,
      test_clock : String? = nil,
      price : String? = nil,
      expand : Array(Array(String))? = nil,
      customer : String? = nil,
      collection_method : String? = nil,
      status : String? = nil,
      created : Stripe::GetAccountsCreatedParameter? = nil,
      current_period_end : Stripe::GetAccountsCreatedParameter? = nil,
      current_period_start : Stripe::GetAccountsCreatedParameter? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: SubscriptionsApi.get_subscriptions ..." }
      end

      if client_side_validation
        unless (_ending_before = ending_before).nil?
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_SUBSCRIPTIONS_MAX_LENGTH_FOR_ENDING_BEFORE)
        end
        unless (_starting_after = starting_after).nil?
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_SUBSCRIPTIONS_MAX_LENGTH_FOR_STARTING_AFTER)
        end

        unless (_test_clock = test_clock).nil?
          OpenApi::PrimitiveValidator.validate_max_length("test_clock", test_clock.to_s.size, GET_SUBSCRIPTIONS_MAX_LENGTH_FOR_TEST_CLOCK)
        end
        unless (_price = price).nil?
          OpenApi::PrimitiveValidator.validate_max_length("price", price.to_s.size, GET_SUBSCRIPTIONS_MAX_LENGTH_FOR_PRICE)
        end

        unless (_customer = customer).nil?
          OpenApi::PrimitiveValidator.validate_max_length("customer", customer.to_s.size, GET_SUBSCRIPTIONS_MAX_LENGTH_FOR_CUSTOMER)
        end
        unless (_collection_method = collection_method).nil?
          OpenApi::EnumValidator.validate("collection_method", _collection_method, GET_SUBSCRIPTIONS_VALID_VALUES_FOR_COLLECTION_METHOD)
        end
        unless (_status = status).nil?
          OpenApi::EnumValidator.validate("status", _status, GET_SUBSCRIPTIONS_VALID_VALUES_FOR_STATUS)
        end
        unless (_created = created).nil?
          _created.validate if _created.is_a?(OpenApi::Validatable)
        end
        unless (_current_period_end = current_period_end).nil?
          _current_period_end.validate if _current_period_end.is_a?(OpenApi::Validatable)
        end
        unless (_current_period_start = current_period_start).nil?
          _current_period_start.validate if _current_period_start.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/subscriptions"

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["test_clock"] = test_clock.to_s if !test_clock.nil?
      query_params["price"] = price.to_s if !price.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["customer"] = customer.to_s if !customer.nil?
      query_params["collection_method"] = collection_method.to_s if !collection_method.nil?
      query_params["status"] = status.to_s if !status.nil?
      query_params["created"] = created.to_s if !created.nil?
      query_params["current_period_end"] = current_period_end.to_s if !current_period_end.nil?
      query_params["current_period_start"] = current_period_start.to_s if !current_period_start.nil?

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = nil

      # http body (model)
      post_body : IO | String | Nil = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "SubscriptionsApi.get_subscriptions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Search for subscriptions you’ve previously created using Stripe’s <a href=\"/docs/search#search-query-language\">Search Query Language</a>. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.</p>
    # @required @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for subscriptions](https://stripe.com/docs/search#query-fields-for-subscriptions).
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @optional @param limit [Int32?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Stripe::SearchResult]
    def get_subscriptions_search(
      *,
      query : String? = nil,
      page : String? = nil,
      limit : Int64? = nil,
      expand : Array(Array(String))? = nil
    ) : Stripe::SearchResult
      data, _status_code, _headers = get_subscriptions_search_with_http_info(query: query, page: page, limit: limit, expand: expand)
      data
    end

    # &lt;p&gt;Search for subscriptions you’ve previously created using Stripe’s &lt;a href&#x3D;\&quot;/docs/search#search-query-language\&quot;&gt;Search Query Language&lt;/a&gt;. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.&lt;/p&gt;
    # @required @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for subscriptions](https://stripe.com/docs/search#query-fields-for-subscriptions).
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @optional @param limit [Int32?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Tuple(Stripe::SearchResult, Integer, Hash)] Stripe::SearchResult, response status code and response headers
    def get_subscriptions_search_with_http_info(
      *,
      query : String? = nil,
      page : String? = nil,
      limit : Int64? = nil,
      expand : Array(Array(String))? = nil
    ) : Tuple(Stripe::SearchResult, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_get_subscriptions_search(query: query, page: page, limit: limit, expand: expand)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: SubscriptionsApi#get_subscriptions_search\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(Stripe::SearchResult.from_json(body), status_code, headers)
    end

    # &lt;p&gt;Search for subscriptions you’ve previously created using Stripe’s &lt;a href&#x3D;\&quot;/docs/search#search-query-language\&quot;&gt;Search Query Language&lt;/a&gt;. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.&lt;/p&gt;
    # @required @param query [String?] The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for subscriptions](https://stripe.com/docs/search#query-fields-for-subscriptions).
    # @optional @param page [String?] A cursor for pagination across multiple pages of results. Don't include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
    # @optional @param limit [Int32?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_subscriptions_search(
      *,
      query : String? = nil,
      page : String? = nil,
      limit : Int64? = nil,
      expand : Array(Array(String))? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_get_subscriptions_search(query: query, page: page, limit: limit, expand: expand).execute(&block)
    end

    GET_SUBSCRIPTIONS_SEARCH_MAX_LENGTH_FOR_QUERY = 5000
    GET_SUBSCRIPTIONS_SEARCH_MAX_LENGTH_FOR_PAGE  = 5000

    # @return Crest::Request
    def build_api_request_for_get_subscriptions_search(
      *,
      query : String? = nil,
      page : String? = nil,
      limit : Int64? = nil,
      expand : Array(Array(String))? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: SubscriptionsApi.get_subscriptions_search ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"query\" is required and cannot be null") if query.nil?
        unless (_query = query).nil?
          OpenApi::PrimitiveValidator.validate_max_length("query", query.to_s.size, GET_SUBSCRIPTIONS_SEARCH_MAX_LENGTH_FOR_QUERY)
        end
        unless (_page = page).nil?
          OpenApi::PrimitiveValidator.validate_max_length("page", page.to_s.size, GET_SUBSCRIPTIONS_SEARCH_MAX_LENGTH_FOR_PAGE)
        end
      end

      # resource path
      local_var_path = "/v1/subscriptions/search"

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new
      query_params["page"] = page.to_s if !page.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["query"] = query.to_s if !query.nil?

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = nil

      # http body (model)
      post_body : IO | String | Nil = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "SubscriptionsApi.get_subscriptions_search",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the subscription with the given ID.</p>
    # @required @param subscription_exposed_id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Stripe::Subscription]
    def get_subscriptions_subscription_exposed_id(
      *,
      subscription_exposed_id : String? = nil,
      expand : Array(Array(String))? = nil
    ) : Stripe::Subscription
      data, _status_code, _headers = get_subscriptions_subscription_exposed_id_with_http_info(subscription_exposed_id: subscription_exposed_id, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the subscription with the given ID.&lt;/p&gt;
    # @required @param subscription_exposed_id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Tuple(Stripe::Subscription, Integer, Hash)] Stripe::Subscription, response status code and response headers
    def get_subscriptions_subscription_exposed_id_with_http_info(
      *,
      subscription_exposed_id : String? = nil,
      expand : Array(Array(String))? = nil
    ) : Tuple(Stripe::Subscription, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_get_subscriptions_subscription_exposed_id(subscription_exposed_id: subscription_exposed_id, expand: expand)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: SubscriptionsApi#get_subscriptions_subscription_exposed_id\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(Stripe::Subscription.from_json(body), status_code, headers)
    end

    # &lt;p&gt;Retrieves the subscription with the given ID.&lt;/p&gt;
    # @required @param subscription_exposed_id [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_subscriptions_subscription_exposed_id(
      *,
      subscription_exposed_id : String? = nil,
      expand : Array(Array(String))? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_get_subscriptions_subscription_exposed_id(subscription_exposed_id: subscription_exposed_id, expand: expand).execute(&block)
    end

    GET_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID = 5000

    # @return Crest::Request
    def build_api_request_for_get_subscriptions_subscription_exposed_id(
      *,
      subscription_exposed_id : String? = nil,
      expand : Array(Array(String))? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: SubscriptionsApi.get_subscriptions_subscription_exposed_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"subscription_exposed_id\" is required and cannot be null") if subscription_exposed_id.nil?
        unless (_subscription_exposed_id = subscription_exposed_id).nil?
          OpenApi::PrimitiveValidator.validate_max_length("subscription_exposed_id", subscription_exposed_id.to_s.size, GET_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID)
        end
      end

      # resource path
      local_var_path = "/v1/subscriptions/{subscription_exposed_id}".sub("{" + "subscription_exposed_id" + "}", URI.encode_path(subscription_exposed_id.to_s))

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = nil

      # http body (model)
      post_body : IO | String | Nil = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "SubscriptionsApi.get_subscriptions_subscription_exposed_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a new subscription on an existing customer. Each customer can have up to 500 active or scheduled subscriptions.</p>  <p>When you create a subscription with <code>collection_method=charge_automatically</code>, the first invoice is finalized as part of the request. The <code>payment_behavior</code> parameter determines the exact behavior of the initial payment.</p>  <p>To start subscriptions where the first invoice always begins in a <code>draft</code> status, use <a href=\"/docs/billing/subscriptions/subscription-schedules#managing\">subscription schedules</a> instead. Schedules provide the flexibility to model more complex billing configurations that change over time.</p>
    # @required @param post_subscriptions_request [Stripe::PostSubscriptionsRequest?]
    # @return [Stripe::Subscription]
    def post_subscriptions(
      *,
      post_subscriptions_request : Stripe::PostSubscriptionsRequest? = nil
    ) : Stripe::Subscription
      data, _status_code, _headers = post_subscriptions_with_http_info(post_subscriptions_request: post_subscriptions_request)
      data
    end

    # &lt;p&gt;Creates a new subscription on an existing customer. Each customer can have up to 500 active or scheduled subscriptions.&lt;/p&gt;  &lt;p&gt;When you create a subscription with &lt;code&gt;collection_method&#x3D;charge_automatically&lt;/code&gt;, the first invoice is finalized as part of the request. The &lt;code&gt;payment_behavior&lt;/code&gt; parameter determines the exact behavior of the initial payment.&lt;/p&gt;  &lt;p&gt;To start subscriptions where the first invoice always begins in a &lt;code&gt;draft&lt;/code&gt; status, use &lt;a href&#x3D;\&quot;/docs/billing/subscriptions/subscription-schedules#managing\&quot;&gt;subscription schedules&lt;/a&gt; instead. Schedules provide the flexibility to model more complex billing configurations that change over time.&lt;/p&gt;
    # @required @param post_subscriptions_request [Stripe::PostSubscriptionsRequest?]
    # @return [Tuple(Stripe::Subscription, Integer, Hash)] Stripe::Subscription, response status code and response headers
    def post_subscriptions_with_http_info(
      *,
      post_subscriptions_request : Stripe::PostSubscriptionsRequest? = nil
    ) : Tuple(Stripe::Subscription, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_post_subscriptions(post_subscriptions_request: post_subscriptions_request)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: SubscriptionsApi#post_subscriptions\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(Stripe::Subscription.from_json(body), status_code, headers)
    end

    # &lt;p&gt;Creates a new subscription on an existing customer. Each customer can have up to 500 active or scheduled subscriptions.&lt;/p&gt;  &lt;p&gt;When you create a subscription with &lt;code&gt;collection_method&#x3D;charge_automatically&lt;/code&gt;, the first invoice is finalized as part of the request. The &lt;code&gt;payment_behavior&lt;/code&gt; parameter determines the exact behavior of the initial payment.&lt;/p&gt;  &lt;p&gt;To start subscriptions where the first invoice always begins in a &lt;code&gt;draft&lt;/code&gt; status, use &lt;a href&#x3D;\&quot;/docs/billing/subscriptions/subscription-schedules#managing\&quot;&gt;subscription schedules&lt;/a&gt; instead. Schedules provide the flexibility to model more complex billing configurations that change over time.&lt;/p&gt;
    # @required @param post_subscriptions_request [Stripe::PostSubscriptionsRequest?]
    # @return nil
    def post_subscriptions(
      *,
      post_subscriptions_request : Stripe::PostSubscriptionsRequest? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_post_subscriptions(post_subscriptions_request: post_subscriptions_request).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_post_subscriptions(
      *,
      post_subscriptions_request : Stripe::PostSubscriptionsRequest? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: SubscriptionsApi.post_subscriptions ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"post_subscriptions_request\" is required and cannot be null") if post_subscriptions_request.nil?
        unless (_post_subscriptions_request = post_subscriptions_request).nil?
          _post_subscriptions_request.validate if _post_subscriptions_request.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/subscriptions"

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = nil

      # http body (model)
      post_body : IO | String | Nil = @api_client.encode(body: post_subscriptions_request, content_type: header_params["Content-Type"]?) if !post_subscriptions_request.nil?

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "SubscriptionsApi.post_subscriptions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates an existing subscription on a customer to match the specified parameters. When changing plans or quantities, we will optionally prorate the price we charge next month to make up for any price changes. To preview how the proration will be calculated, use the <a href=\"#upcoming_invoice\">upcoming invoice</a> endpoint.</p>
    # @required @param subscription_exposed_id [String?]
    # @optional @param post_subscriptions_subscription_exposed_id_request [Stripe::PostSubscriptionsSubscriptionExposedIdRequest?]
    # @return [Stripe::Subscription]
    def post_subscriptions_subscription_exposed_id(
      *,
      subscription_exposed_id : String? = nil,
      post_subscriptions_subscription_exposed_id_request : Stripe::PostSubscriptionsSubscriptionExposedIdRequest? = nil
    ) : Stripe::Subscription
      data, _status_code, _headers = post_subscriptions_subscription_exposed_id_with_http_info(subscription_exposed_id: subscription_exposed_id, post_subscriptions_subscription_exposed_id_request: post_subscriptions_subscription_exposed_id_request)
      data
    end

    # &lt;p&gt;Updates an existing subscription on a customer to match the specified parameters. When changing plans or quantities, we will optionally prorate the price we charge next month to make up for any price changes. To preview how the proration will be calculated, use the &lt;a href&#x3D;\&quot;#upcoming_invoice\&quot;&gt;upcoming invoice&lt;/a&gt; endpoint.&lt;/p&gt;
    # @required @param subscription_exposed_id [String?]
    # @optional @param post_subscriptions_subscription_exposed_id_request [Stripe::PostSubscriptionsSubscriptionExposedIdRequest?]
    # @return [Tuple(Stripe::Subscription, Integer, Hash)] Stripe::Subscription, response status code and response headers
    def post_subscriptions_subscription_exposed_id_with_http_info(
      *,
      subscription_exposed_id : String? = nil,
      post_subscriptions_subscription_exposed_id_request : Stripe::PostSubscriptionsSubscriptionExposedIdRequest? = nil
    ) : Tuple(Stripe::Subscription, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_post_subscriptions_subscription_exposed_id(subscription_exposed_id: subscription_exposed_id, post_subscriptions_subscription_exposed_id_request: post_subscriptions_subscription_exposed_id_request)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: SubscriptionsApi#post_subscriptions_subscription_exposed_id\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(Stripe::Subscription.from_json(body), status_code, headers)
    end

    # &lt;p&gt;Updates an existing subscription on a customer to match the specified parameters. When changing plans or quantities, we will optionally prorate the price we charge next month to make up for any price changes. To preview how the proration will be calculated, use the &lt;a href&#x3D;\&quot;#upcoming_invoice\&quot;&gt;upcoming invoice&lt;/a&gt; endpoint.&lt;/p&gt;
    # @required @param subscription_exposed_id [String?]
    # @optional @param post_subscriptions_subscription_exposed_id_request [Stripe::PostSubscriptionsSubscriptionExposedIdRequest?]
    # @return nil
    def post_subscriptions_subscription_exposed_id(
      *,
      subscription_exposed_id : String? = nil,
      post_subscriptions_subscription_exposed_id_request : Stripe::PostSubscriptionsSubscriptionExposedIdRequest? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_post_subscriptions_subscription_exposed_id(subscription_exposed_id: subscription_exposed_id, post_subscriptions_subscription_exposed_id_request: post_subscriptions_subscription_exposed_id_request).execute(&block)
    end

    POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID = 5000

    # @return Crest::Request
    def build_api_request_for_post_subscriptions_subscription_exposed_id(
      *,
      subscription_exposed_id : String? = nil,
      post_subscriptions_subscription_exposed_id_request : Stripe::PostSubscriptionsSubscriptionExposedIdRequest? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: SubscriptionsApi.post_subscriptions_subscription_exposed_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"subscription_exposed_id\" is required and cannot be null") if subscription_exposed_id.nil?
        unless (_subscription_exposed_id = subscription_exposed_id).nil?
          OpenApi::PrimitiveValidator.validate_max_length("subscription_exposed_id", subscription_exposed_id.to_s.size, POST_SUBSCRIPTIONS_SUBSCRIPTION_EXPOSED_ID_MAX_LENGTH_FOR_SUBSCRIPTION_EXPOSED_ID)
        end
        unless (_post_subscriptions_subscription_exposed_id_request = post_subscriptions_subscription_exposed_id_request).nil?
          _post_subscriptions_subscription_exposed_id_request.validate if _post_subscriptions_subscription_exposed_id_request.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/subscriptions/{subscription_exposed_id}".sub("{" + "subscription_exposed_id" + "}", URI.encode_path(subscription_exposed_id.to_s))

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = nil

      # http body (model)
      post_body : IO | String | Nil = @api_client.encode(body: post_subscriptions_subscription_exposed_id_request, content_type: header_params["Content-Type"]?) if !post_subscriptions_subscription_exposed_id_request.nil?

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "SubscriptionsApi.post_subscriptions_subscription_exposed_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end
  end
end
