#  Stripe API
#
# The Stripe REST API. Please see https://stripe.com/docs/api for more details.
#
# The version of the OpenAPI document: 2022-08-01
# Contact: dev-platform@stripe.com
# Generated by: https://openapi-generator.tech
#

require "uri"
require "../api_client"

module Stripe
  class SubscriptionItemsApi
    property api_client : ApiClient

    delegate client_side_validation, debugging, to: @api_client.config

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end

    # <p>Deletes an item from the subscription. Removing a subscription item from a subscription will not cancel the subscription.</p>
    # @required @param item [String?]
    # @optional @param delete_subscription_items_item_request [Stripe::DeleteSubscriptionItemsItemRequest?]
    # @return [Stripe::DeletedSubscriptionItem]
    def delete_subscription_items_item(
      *,
      item : String? = nil,
      delete_subscription_items_item_request : Stripe::DeleteSubscriptionItemsItemRequest? = nil
    ) : Stripe::DeletedSubscriptionItem
      data, _status_code, _headers = delete_subscription_items_item_with_http_info(item: item, delete_subscription_items_item_request: delete_subscription_items_item_request)
      data
    end

    # &lt;p&gt;Deletes an item from the subscription. Removing a subscription item from a subscription will not cancel the subscription.&lt;/p&gt;
    # @required @param item [String?]
    # @optional @param delete_subscription_items_item_request [Stripe::DeleteSubscriptionItemsItemRequest?]
    # @return [Tuple(Stripe::DeletedSubscriptionItem, Integer, Hash)] Stripe::DeletedSubscriptionItem, response status code and response headers
    def delete_subscription_items_item_with_http_info(
      *,
      item : String? = nil,
      delete_subscription_items_item_request : Stripe::DeleteSubscriptionItemsItemRequest? = nil
    ) : Tuple(Stripe::DeletedSubscriptionItem, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_delete_subscription_items_item(item: item, delete_subscription_items_item_request: delete_subscription_items_item_request)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: SubscriptionItemsApi#delete_subscription_items_item\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(Stripe::DeletedSubscriptionItem.from_json(body), status_code, headers)
    end

    # &lt;p&gt;Deletes an item from the subscription. Removing a subscription item from a subscription will not cancel the subscription.&lt;/p&gt;
    # @required @param item [String?]
    # @optional @param delete_subscription_items_item_request [Stripe::DeleteSubscriptionItemsItemRequest?]
    # @return nil
    def delete_subscription_items_item(
      *,
      item : String? = nil,
      delete_subscription_items_item_request : Stripe::DeleteSubscriptionItemsItemRequest? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_delete_subscription_items_item(item: item, delete_subscription_items_item_request: delete_subscription_items_item_request).execute(&block)
    end

    DELETE_SUBSCRIPTION_ITEMS_ITEM_MAX_LENGTH_FOR_ITEM = 5000

    # @return Crest::Request
    def build_api_request_for_delete_subscription_items_item(
      *,
      item : String? = nil,
      delete_subscription_items_item_request : Stripe::DeleteSubscriptionItemsItemRequest? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: SubscriptionItemsApi.delete_subscription_items_item ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"item\" is required and cannot be null") if item.nil?
        unless (_item = item).nil?
          OpenApi::PrimitiveValidator.validate_max_length("item", item.to_s.size, DELETE_SUBSCRIPTION_ITEMS_ITEM_MAX_LENGTH_FOR_ITEM)
        end
        unless (_delete_subscription_items_item_request = delete_subscription_items_item_request).nil?
          _delete_subscription_items_item_request.validate if _delete_subscription_items_item_request.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/subscription_items/{item}".sub("{" + "item" + "}", URI.encode_path(item.to_s))

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = nil

      # http body (model)
      post_body : IO | String | Nil = @api_client.encode(body: delete_subscription_items_item_request, content_type: header_params["Content-Type"]?) if !delete_subscription_items_item_request.nil?

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "SubscriptionItemsApi.delete_subscription_items_item",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Returns a list of your subscription items for a given subscription.</p>
    # @required @param subscription [String?] The ID of the subscription whose items will be retrieved.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param limit [Int32?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Stripe::SubscriptionsItemsSubscriptionItemList]
    def get_subscription_items(
      *,
      subscription : String? = nil,
      ending_before : String? = nil,
      starting_after : String? = nil,
      limit : Int64? = nil,
      expand : Array(Array(String))? = nil
    ) : Stripe::SubscriptionsItemsSubscriptionItemList
      data, _status_code, _headers = get_subscription_items_with_http_info(subscription: subscription, ending_before: ending_before, starting_after: starting_after, limit: limit, expand: expand)
      data
    end

    # &lt;p&gt;Returns a list of your subscription items for a given subscription.&lt;/p&gt;
    # @required @param subscription [String?] The ID of the subscription whose items will be retrieved.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param limit [Int32?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Tuple(Stripe::SubscriptionsItemsSubscriptionItemList, Integer, Hash)] Stripe::SubscriptionsItemsSubscriptionItemList, response status code and response headers
    def get_subscription_items_with_http_info(
      *,
      subscription : String? = nil,
      ending_before : String? = nil,
      starting_after : String? = nil,
      limit : Int64? = nil,
      expand : Array(Array(String))? = nil
    ) : Tuple(Stripe::SubscriptionsItemsSubscriptionItemList, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_get_subscription_items(subscription: subscription, ending_before: ending_before, starting_after: starting_after, limit: limit, expand: expand)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: SubscriptionItemsApi#get_subscription_items\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(Stripe::SubscriptionsItemsSubscriptionItemList.from_json(body), status_code, headers)
    end

    # &lt;p&gt;Returns a list of your subscription items for a given subscription.&lt;/p&gt;
    # @required @param subscription [String?] The ID of the subscription whose items will be retrieved.
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param limit [Int32?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_subscription_items(
      *,
      subscription : String? = nil,
      ending_before : String? = nil,
      starting_after : String? = nil,
      limit : Int64? = nil,
      expand : Array(Array(String))? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_get_subscription_items(subscription: subscription, ending_before: ending_before, starting_after: starting_after, limit: limit, expand: expand).execute(&block)
    end

    GET_SUBSCRIPTION_ITEMS_MAX_LENGTH_FOR_SUBSCRIPTION = 5000

    # @return Crest::Request
    def build_api_request_for_get_subscription_items(
      *,
      subscription : String? = nil,
      ending_before : String? = nil,
      starting_after : String? = nil,
      limit : Int64? = nil,
      expand : Array(Array(String))? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: SubscriptionItemsApi.get_subscription_items ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"subscription\" is required and cannot be null") if subscription.nil?
        unless (_subscription = subscription).nil?
          OpenApi::PrimitiveValidator.validate_max_length("subscription", subscription.to_s.size, GET_SUBSCRIPTION_ITEMS_MAX_LENGTH_FOR_SUBSCRIPTION)
        end
      end

      # resource path
      local_var_path = "/v1/subscription_items"

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?
      query_params["subscription"] = subscription.to_s if !subscription.nil?

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = nil

      # http body (model)
      post_body : IO | String | Nil = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "SubscriptionItemsApi.get_subscription_items",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Retrieves the subscription item with the given ID.</p>
    # @required @param item [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Stripe::SubscriptionItem]
    def get_subscription_items_item(
      *,
      item : String? = nil,
      expand : Array(Array(String))? = nil
    ) : Stripe::SubscriptionItem
      data, _status_code, _headers = get_subscription_items_item_with_http_info(item: item, expand: expand)
      data
    end

    # &lt;p&gt;Retrieves the subscription item with the given ID.&lt;/p&gt;
    # @required @param item [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Tuple(Stripe::SubscriptionItem, Integer, Hash)] Stripe::SubscriptionItem, response status code and response headers
    def get_subscription_items_item_with_http_info(
      *,
      item : String? = nil,
      expand : Array(Array(String))? = nil
    ) : Tuple(Stripe::SubscriptionItem, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_get_subscription_items_item(item: item, expand: expand)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: SubscriptionItemsApi#get_subscription_items_item\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(Stripe::SubscriptionItem.from_json(body), status_code, headers)
    end

    # &lt;p&gt;Retrieves the subscription item with the given ID.&lt;/p&gt;
    # @required @param item [String?]
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_subscription_items_item(
      *,
      item : String? = nil,
      expand : Array(Array(String))? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_get_subscription_items_item(item: item, expand: expand).execute(&block)
    end

    GET_SUBSCRIPTION_ITEMS_ITEM_MAX_LENGTH_FOR_ITEM = 5000

    # @return Crest::Request
    def build_api_request_for_get_subscription_items_item(
      *,
      item : String? = nil,
      expand : Array(Array(String))? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: SubscriptionItemsApi.get_subscription_items_item ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"item\" is required and cannot be null") if item.nil?
        unless (_item = item).nil?
          OpenApi::PrimitiveValidator.validate_max_length("item", item.to_s.size, GET_SUBSCRIPTION_ITEMS_ITEM_MAX_LENGTH_FOR_ITEM)
        end
      end

      # resource path
      local_var_path = "/v1/subscription_items/{item}".sub("{" + "item" + "}", URI.encode_path(item.to_s))

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = nil

      # http body (model)
      post_body : IO | String | Nil = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "SubscriptionItemsApi.get_subscription_items_item",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>For the specified subscription item, returns a list of summary objects. Each object in the list provides usage information that’s been summarized from multiple usage records and over a subscription billing period (e.g., 15 usage records in the month of September).</p>  <p>The list is sorted in reverse-chronological order (newest first). The first list item represents the most current usage period that hasn’t ended yet. Since new usage records can still be added, the returned summary information for the subscription item’s ID should be seen as unstable until the subscription billing period ends.</p>
    # @required @param subscription_item [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param limit [Int32?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Stripe::UsageEventsResourceUsageRecordSummaryList]
    def get_subscription_items_subscription_item_usage_record_summaries(
      *,
      subscription_item : String? = nil,
      ending_before : String? = nil,
      starting_after : String? = nil,
      limit : Int64? = nil,
      expand : Array(Array(String))? = nil
    ) : Stripe::UsageEventsResourceUsageRecordSummaryList
      data, _status_code, _headers = get_subscription_items_subscription_item_usage_record_summaries_with_http_info(subscription_item: subscription_item, ending_before: ending_before, starting_after: starting_after, limit: limit, expand: expand)
      data
    end

    # &lt;p&gt;For the specified subscription item, returns a list of summary objects. Each object in the list provides usage information that’s been summarized from multiple usage records and over a subscription billing period (e.g., 15 usage records in the month of September).&lt;/p&gt;  &lt;p&gt;The list is sorted in reverse-chronological order (newest first). The first list item represents the most current usage period that hasn’t ended yet. Since new usage records can still be added, the returned summary information for the subscription item’s ID should be seen as unstable until the subscription billing period ends.&lt;/p&gt;
    # @required @param subscription_item [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param limit [Int32?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return [Tuple(Stripe::UsageEventsResourceUsageRecordSummaryList, Integer, Hash)] Stripe::UsageEventsResourceUsageRecordSummaryList, response status code and response headers
    def get_subscription_items_subscription_item_usage_record_summaries_with_http_info(
      *,
      subscription_item : String? = nil,
      ending_before : String? = nil,
      starting_after : String? = nil,
      limit : Int64? = nil,
      expand : Array(Array(String))? = nil
    ) : Tuple(Stripe::UsageEventsResourceUsageRecordSummaryList, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_get_subscription_items_subscription_item_usage_record_summaries(subscription_item: subscription_item, ending_before: ending_before, starting_after: starting_after, limit: limit, expand: expand)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: SubscriptionItemsApi#get_subscription_items_subscription_item_usage_record_summaries\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(Stripe::UsageEventsResourceUsageRecordSummaryList.from_json(body), status_code, headers)
    end

    # &lt;p&gt;For the specified subscription item, returns a list of summary objects. Each object in the list provides usage information that’s been summarized from multiple usage records and over a subscription billing period (e.g., 15 usage records in the month of September).&lt;/p&gt;  &lt;p&gt;The list is sorted in reverse-chronological order (newest first). The first list item represents the most current usage period that hasn’t ended yet. Since new usage records can still be added, the returned summary information for the subscription item’s ID should be seen as unstable until the subscription billing period ends.&lt;/p&gt;
    # @required @param subscription_item [String?]
    # @optional @param ending_before [String?] A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
    # @optional @param starting_after [String?] A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    # @optional @param limit [Int32?] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
    # @optional @param expand [Array(Array(String))?] Specifies which fields in the response should be expanded.
    # @return nil
    def get_subscription_items_subscription_item_usage_record_summaries(
      *,
      subscription_item : String? = nil,
      ending_before : String? = nil,
      starting_after : String? = nil,
      limit : Int64? = nil,
      expand : Array(Array(String))? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_get_subscription_items_subscription_item_usage_record_summaries(subscription_item: subscription_item, ending_before: ending_before, starting_after: starting_after, limit: limit, expand: expand).execute(&block)
    end

    GET_SUBSCRIPTION_ITEMS_SUBSCRIPTION_ITEM_USAGE_RECORD_SUMMARIES_MAX_LENGTH_FOR_ENDING_BEFORE  = 5000
    GET_SUBSCRIPTION_ITEMS_SUBSCRIPTION_ITEM_USAGE_RECORD_SUMMARIES_MAX_LENGTH_FOR_STARTING_AFTER = 5000

    # @return Crest::Request
    def build_api_request_for_get_subscription_items_subscription_item_usage_record_summaries(
      *,
      subscription_item : String? = nil,
      ending_before : String? = nil,
      starting_after : String? = nil,
      limit : Int64? = nil,
      expand : Array(Array(String))? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: SubscriptionItemsApi.get_subscription_items_subscription_item_usage_record_summaries ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"subscription_item\" is required and cannot be null") if subscription_item.nil?

        unless (_ending_before = ending_before).nil?
          OpenApi::PrimitiveValidator.validate_max_length("ending_before", ending_before.to_s.size, GET_SUBSCRIPTION_ITEMS_SUBSCRIPTION_ITEM_USAGE_RECORD_SUMMARIES_MAX_LENGTH_FOR_ENDING_BEFORE)
        end
        unless (_starting_after = starting_after).nil?
          OpenApi::PrimitiveValidator.validate_max_length("starting_after", starting_after.to_s.size, GET_SUBSCRIPTION_ITEMS_SUBSCRIPTION_ITEM_USAGE_RECORD_SUMMARIES_MAX_LENGTH_FOR_STARTING_AFTER)
        end
      end

      # resource path
      local_var_path = "/v1/subscription_items/{subscription_item}/usage_record_summaries".sub("{" + "subscription_item" + "}", URI.encode_path(subscription_item.to_s))

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new
      query_params["ending_before"] = ending_before.to_s if !ending_before.nil?
      query_params["starting_after"] = starting_after.to_s if !starting_after.nil?
      query_params["limit"] = limit.to_s if !limit.nil?
      query_params["expand"] = @api_client.build_collection_param(expand, "csv") if !expand.nil? && !expand.empty?

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = nil

      # http body (model)
      post_body : IO | String | Nil = nil

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "SubscriptionItemsApi.get_subscription_items_subscription_item_usage_record_summaries",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Adds a new item to an existing subscription. No existing items will be changed or replaced.</p>
    # @required @param post_subscription_items_request [Stripe::PostSubscriptionItemsRequest?]
    # @return [Stripe::SubscriptionItem]
    def post_subscription_items(
      *,
      post_subscription_items_request : Stripe::PostSubscriptionItemsRequest? = nil
    ) : Stripe::SubscriptionItem
      data, _status_code, _headers = post_subscription_items_with_http_info(post_subscription_items_request: post_subscription_items_request)
      data
    end

    # &lt;p&gt;Adds a new item to an existing subscription. No existing items will be changed or replaced.&lt;/p&gt;
    # @required @param post_subscription_items_request [Stripe::PostSubscriptionItemsRequest?]
    # @return [Tuple(Stripe::SubscriptionItem, Integer, Hash)] Stripe::SubscriptionItem, response status code and response headers
    def post_subscription_items_with_http_info(
      *,
      post_subscription_items_request : Stripe::PostSubscriptionItemsRequest? = nil
    ) : Tuple(Stripe::SubscriptionItem, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_post_subscription_items(post_subscription_items_request: post_subscription_items_request)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: SubscriptionItemsApi#post_subscription_items\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(Stripe::SubscriptionItem.from_json(body), status_code, headers)
    end

    # &lt;p&gt;Adds a new item to an existing subscription. No existing items will be changed or replaced.&lt;/p&gt;
    # @required @param post_subscription_items_request [Stripe::PostSubscriptionItemsRequest?]
    # @return nil
    def post_subscription_items(
      *,
      post_subscription_items_request : Stripe::PostSubscriptionItemsRequest? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_post_subscription_items(post_subscription_items_request: post_subscription_items_request).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_post_subscription_items(
      *,
      post_subscription_items_request : Stripe::PostSubscriptionItemsRequest? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: SubscriptionItemsApi.post_subscription_items ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"post_subscription_items_request\" is required and cannot be null") if post_subscription_items_request.nil?
        unless (_post_subscription_items_request = post_subscription_items_request).nil?
          _post_subscription_items_request.validate if _post_subscription_items_request.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/subscription_items"

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = nil

      # http body (model)
      post_body : IO | String | Nil = @api_client.encode(body: post_subscription_items_request, content_type: header_params["Content-Type"]?) if !post_subscription_items_request.nil?

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "SubscriptionItemsApi.post_subscription_items",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Updates the plan or quantity of an item on a current subscription.</p>
    # @required @param item [String?]
    # @optional @param post_subscription_items_item_request [Stripe::PostSubscriptionItemsItemRequest?]
    # @return [Stripe::SubscriptionItem]
    def post_subscription_items_item(
      *,
      item : String? = nil,
      post_subscription_items_item_request : Stripe::PostSubscriptionItemsItemRequest? = nil
    ) : Stripe::SubscriptionItem
      data, _status_code, _headers = post_subscription_items_item_with_http_info(item: item, post_subscription_items_item_request: post_subscription_items_item_request)
      data
    end

    # &lt;p&gt;Updates the plan or quantity of an item on a current subscription.&lt;/p&gt;
    # @required @param item [String?]
    # @optional @param post_subscription_items_item_request [Stripe::PostSubscriptionItemsItemRequest?]
    # @return [Tuple(Stripe::SubscriptionItem, Integer, Hash)] Stripe::SubscriptionItem, response status code and response headers
    def post_subscription_items_item_with_http_info(
      *,
      item : String? = nil,
      post_subscription_items_item_request : Stripe::PostSubscriptionItemsItemRequest? = nil
    ) : Tuple(Stripe::SubscriptionItem, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_post_subscription_items_item(item: item, post_subscription_items_item_request: post_subscription_items_item_request)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: SubscriptionItemsApi#post_subscription_items_item\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(Stripe::SubscriptionItem.from_json(body), status_code, headers)
    end

    # &lt;p&gt;Updates the plan or quantity of an item on a current subscription.&lt;/p&gt;
    # @required @param item [String?]
    # @optional @param post_subscription_items_item_request [Stripe::PostSubscriptionItemsItemRequest?]
    # @return nil
    def post_subscription_items_item(
      *,
      item : String? = nil,
      post_subscription_items_item_request : Stripe::PostSubscriptionItemsItemRequest? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_post_subscription_items_item(item: item, post_subscription_items_item_request: post_subscription_items_item_request).execute(&block)
    end

    POST_SUBSCRIPTION_ITEMS_ITEM_MAX_LENGTH_FOR_ITEM = 5000

    # @return Crest::Request
    def build_api_request_for_post_subscription_items_item(
      *,
      item : String? = nil,
      post_subscription_items_item_request : Stripe::PostSubscriptionItemsItemRequest? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: SubscriptionItemsApi.post_subscription_items_item ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"item\" is required and cannot be null") if item.nil?
        unless (_item = item).nil?
          OpenApi::PrimitiveValidator.validate_max_length("item", item.to_s.size, POST_SUBSCRIPTION_ITEMS_ITEM_MAX_LENGTH_FOR_ITEM)
        end
        unless (_post_subscription_items_item_request = post_subscription_items_item_request).nil?
          _post_subscription_items_item_request.validate if _post_subscription_items_item_request.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/subscription_items/{item}".sub("{" + "item" + "}", URI.encode_path(item.to_s))

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = nil

      # http body (model)
      post_body : IO | String | Nil = @api_client.encode(body: post_subscription_items_item_request, content_type: header_params["Content-Type"]?) if !post_subscription_items_item_request.nil?

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "SubscriptionItemsApi.post_subscription_items_item",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # <p>Creates a usage record for a specified subscription item and date, and fills it with a quantity.</p>  <p>Usage records provide <code>quantity</code> information that Stripe uses to track how much a customer is using your service. With usage information and the pricing model set up by the <a href=\"https://stripe.com/docs/billing/subscriptions/metered-billing\">metered billing</a> plan, Stripe helps you send accurate invoices to your customers.</p>  <p>The default calculation for usage is to add up all the <code>quantity</code> values of the usage records within a billing period. You can change this default behavior with the billing plan’s <code>aggregate_usage</code> <a href=\"/docs/api/plans/create#create_plan-aggregate_usage\">parameter</a>. When there is more than one usage record with the same timestamp, Stripe adds the <code>quantity</code> values together. In most cases, this is the desired resolution, however, you can change this behavior with the <code>action</code> parameter.</p>  <p>The default pricing model for metered billing is <a href=\"/docs/api/plans/object#plan_object-billing_scheme\">per-unit pricing</a>. For finer granularity, you can configure metered billing to have a <a href=\"https://stripe.com/docs/billing/subscriptions/tiers\">tiered pricing</a> model.</p>
    # @required @param subscription_item [String?]
    # @required @param post_subscription_items_subscription_item_usage_records_request [Stripe::PostSubscriptionItemsSubscriptionItemUsageRecordsRequest?]
    # @return [Stripe::UsageRecord]
    def post_subscription_items_subscription_item_usage_records(
      *,
      subscription_item : String? = nil,
      post_subscription_items_subscription_item_usage_records_request : Stripe::PostSubscriptionItemsSubscriptionItemUsageRecordsRequest? = nil
    ) : Stripe::UsageRecord
      data, _status_code, _headers = post_subscription_items_subscription_item_usage_records_with_http_info(subscription_item: subscription_item, post_subscription_items_subscription_item_usage_records_request: post_subscription_items_subscription_item_usage_records_request)
      data
    end

    # &lt;p&gt;Creates a usage record for a specified subscription item and date, and fills it with a quantity.&lt;/p&gt;  &lt;p&gt;Usage records provide &lt;code&gt;quantity&lt;/code&gt; information that Stripe uses to track how much a customer is using your service. With usage information and the pricing model set up by the &lt;a href&#x3D;\&quot;https://stripe.com/docs/billing/subscriptions/metered-billing\&quot;&gt;metered billing&lt;/a&gt; plan, Stripe helps you send accurate invoices to your customers.&lt;/p&gt;  &lt;p&gt;The default calculation for usage is to add up all the &lt;code&gt;quantity&lt;/code&gt; values of the usage records within a billing period. You can change this default behavior with the billing plan’s &lt;code&gt;aggregate_usage&lt;/code&gt; &lt;a href&#x3D;\&quot;/docs/api/plans/create#create_plan-aggregate_usage\&quot;&gt;parameter&lt;/a&gt;. When there is more than one usage record with the same timestamp, Stripe adds the &lt;code&gt;quantity&lt;/code&gt; values together. In most cases, this is the desired resolution, however, you can change this behavior with the &lt;code&gt;action&lt;/code&gt; parameter.&lt;/p&gt;  &lt;p&gt;The default pricing model for metered billing is &lt;a href&#x3D;\&quot;/docs/api/plans/object#plan_object-billing_scheme\&quot;&gt;per-unit pricing&lt;/a&gt;. For finer granularity, you can configure metered billing to have a &lt;a href&#x3D;\&quot;https://stripe.com/docs/billing/subscriptions/tiers\&quot;&gt;tiered pricing&lt;/a&gt; model.&lt;/p&gt;
    # @required @param subscription_item [String?]
    # @required @param post_subscription_items_subscription_item_usage_records_request [Stripe::PostSubscriptionItemsSubscriptionItemUsageRecordsRequest?]
    # @return [Tuple(Stripe::UsageRecord, Integer, Hash)] Stripe::UsageRecord, response status code and response headers
    def post_subscription_items_subscription_item_usage_records_with_http_info(
      *,
      subscription_item : String? = nil,
      post_subscription_items_subscription_item_usage_records_request : Stripe::PostSubscriptionItemsSubscriptionItemUsageRecordsRequest? = nil
    ) : Tuple(Stripe::UsageRecord, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_post_subscription_items_subscription_item_usage_records(subscription_item: subscription_item, post_subscription_items_subscription_item_usage_records_request: post_subscription_items_subscription_item_usage_records_request)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: SubscriptionItemsApi#post_subscription_items_subscription_item_usage_records\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(Stripe::UsageRecord.from_json(body), status_code, headers)
    end

    # &lt;p&gt;Creates a usage record for a specified subscription item and date, and fills it with a quantity.&lt;/p&gt;  &lt;p&gt;Usage records provide &lt;code&gt;quantity&lt;/code&gt; information that Stripe uses to track how much a customer is using your service. With usage information and the pricing model set up by the &lt;a href&#x3D;\&quot;https://stripe.com/docs/billing/subscriptions/metered-billing\&quot;&gt;metered billing&lt;/a&gt; plan, Stripe helps you send accurate invoices to your customers.&lt;/p&gt;  &lt;p&gt;The default calculation for usage is to add up all the &lt;code&gt;quantity&lt;/code&gt; values of the usage records within a billing period. You can change this default behavior with the billing plan’s &lt;code&gt;aggregate_usage&lt;/code&gt; &lt;a href&#x3D;\&quot;/docs/api/plans/create#create_plan-aggregate_usage\&quot;&gt;parameter&lt;/a&gt;. When there is more than one usage record with the same timestamp, Stripe adds the &lt;code&gt;quantity&lt;/code&gt; values together. In most cases, this is the desired resolution, however, you can change this behavior with the &lt;code&gt;action&lt;/code&gt; parameter.&lt;/p&gt;  &lt;p&gt;The default pricing model for metered billing is &lt;a href&#x3D;\&quot;/docs/api/plans/object#plan_object-billing_scheme\&quot;&gt;per-unit pricing&lt;/a&gt;. For finer granularity, you can configure metered billing to have a &lt;a href&#x3D;\&quot;https://stripe.com/docs/billing/subscriptions/tiers\&quot;&gt;tiered pricing&lt;/a&gt; model.&lt;/p&gt;
    # @required @param subscription_item [String?]
    # @required @param post_subscription_items_subscription_item_usage_records_request [Stripe::PostSubscriptionItemsSubscriptionItemUsageRecordsRequest?]
    # @return nil
    def post_subscription_items_subscription_item_usage_records(
      *,
      subscription_item : String? = nil,
      post_subscription_items_subscription_item_usage_records_request : Stripe::PostSubscriptionItemsSubscriptionItemUsageRecordsRequest? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_post_subscription_items_subscription_item_usage_records(subscription_item: subscription_item, post_subscription_items_subscription_item_usage_records_request: post_subscription_items_subscription_item_usage_records_request).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_post_subscription_items_subscription_item_usage_records(
      *,
      subscription_item : String? = nil,
      post_subscription_items_subscription_item_usage_records_request : Stripe::PostSubscriptionItemsSubscriptionItemUsageRecordsRequest? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: SubscriptionItemsApi.post_subscription_items_subscription_item_usage_records ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"subscription_item\" is required and cannot be null") if subscription_item.nil?

        raise ArgumentError.new("\"post_subscription_items_subscription_item_usage_records_request\" is required and cannot be null") if post_subscription_items_subscription_item_usage_records_request.nil?
        unless (_post_subscription_items_subscription_item_usage_records_request = post_subscription_items_subscription_item_usage_records_request).nil?
          _post_subscription_items_subscription_item_usage_records_request.validate if _post_subscription_items_subscription_item_usage_records_request.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/v1/subscription_items/{subscription_item}/usage_records".sub("{" + "subscription_item" + "}", URI.encode_path(subscription_item.to_s))

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = nil

      # http body (model)
      post_body : IO | String | Nil = @api_client.encode(body: post_subscription_items_subscription_item_usage_records_request, content_type: header_params["Content-Type"]?) if !post_subscription_items_subscription_item_usage_records_request.nil?

      # auth_names
      auth_names = ["basicAuth", "bearerAuth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "SubscriptionItemsApi.post_subscription_items_subscription_item_usage_records",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end
  end
end
